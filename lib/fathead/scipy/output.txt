scipy.cluster.hierarchy.average	A										<section class="prog__container"><p>Performs average/UPGMA linkage on a condensed distance matrix</p><pre><code>scipy.cluster.hierarchy.average(y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    The upper triangular of the distance matrix. The result of pdist is returned in this form.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray\n    A linkage matrix containing the hierarchical clustering. See the linkage function documentation for more information on its structure.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.average.html
scipy cluster hierarchy average	R	scipy.cluster.hierarchy.average										
scipy cluster.hierarchy.average	R	scipy.cluster.hierarchy.average										
scipy.cluster.hierarchy.centroid	A										<section class="prog__container"><p>Performs centroid/UPGMC linkage.</p><pre><code>scipy.cluster.hierarchy.centroid(y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    A condensed or redundant distance matrix. A condensed distance matrix is a flat array containing the upper triangular of the distance matrix. This is the form that pdist returns. Alternatively, a collection of m observation vectors in n dimensions may be passed as a m by n array.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray\n    A linkage matrix containing the hierarchical clustering. See the linkage function documentation for more information on its structure.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.centroid.html
scipy cluster hierarchy centroid	R	scipy.cluster.hierarchy.centroid										
scipy cluster.hierarchy.centroid	R	scipy.cluster.hierarchy.centroid										
scipy.cluster.hierarchy.ClusterNode	A										<section class="prog__container"><p>A tree node class for representing a cluster.</p><pre><code>class scipy.cluster.hierarchy.ClusterNode(id, left=None, right=None, dist=0, count=1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.ClusterNode.html
scipy.cluster.hierarchy.ClusterNode.get_count	A										<section class="prog__container"><p>The number of leaf nodes (original observations) belonging to\nthe cluster node nd. If the target node is a leaf, 1 is\nreturned.</p><pre><code>ClusterNode.get_count()</code></pre><span class="prog__sub">Parameters:</span><pre><code>get_count : int\n    The number of leaf nodes below the target node.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.ClusterNode.get_count.html
scipy cluster hierarchy ClusterNode get_count	R	scipy.cluster.hierarchy.ClusterNode.get_count										
scipy cluster.hierarchy.ClusterNode.get_count	R	scipy.cluster.hierarchy.ClusterNode.get_count										
scipy.cluster.hierarchy.ClusterNode.get_id	A										<section class="prog__container"><p>The identifier of the target node.</p><pre><code>ClusterNode.get_id()</code></pre><span class="prog__sub">Parameters:</span><pre><code>id : int\n    The identifier of the target node.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.ClusterNode.get_id.html
scipy cluster hierarchy ClusterNode get_id	R	scipy.cluster.hierarchy.ClusterNode.get_id										
scipy cluster.hierarchy.ClusterNode.get_id	R	scipy.cluster.hierarchy.ClusterNode.get_id										
scipy.cluster.hierarchy.ClusterNode.get_left	A										<section class="prog__container"><p>Return a reference to the left child tree object.</p><pre><code>ClusterNode.get_left()</code></pre><span class="prog__sub">Parameters:</span><pre><code>left : ClusterNode\n    The left child of the target node.  If the node is a leaf, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.ClusterNode.get_left.html
scipy cluster hierarchy ClusterNode get_left	R	scipy.cluster.hierarchy.ClusterNode.get_left										
scipy cluster.hierarchy.ClusterNode.get_left	R	scipy.cluster.hierarchy.ClusterNode.get_left										
scipy.cluster.hierarchy.ClusterNode.get_right	A										<section class="prog__container"><p>Returns a reference to the right child tree object.</p><pre><code>ClusterNode.get_right()</code></pre><span class="prog__sub">Parameters:</span><pre><code>right : ClusterNode\n    The left child of the target node.  If the node is a leaf, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.ClusterNode.get_right.html
scipy cluster hierarchy ClusterNode get_right	R	scipy.cluster.hierarchy.ClusterNode.get_right										
scipy cluster.hierarchy.ClusterNode.get_right	R	scipy.cluster.hierarchy.ClusterNode.get_right										
scipy.cluster.hierarchy.ClusterNode.is_leaf	A										<section class="prog__container"><p>Returns True if the target node is a leaf.</p><pre><code>ClusterNode.is_leaf()</code></pre><span class="prog__sub">Parameters:</span><pre><code>leafness : bool\n    True if the target node is a leaf node.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.ClusterNode.is_leaf.html
scipy cluster hierarchy ClusterNode is_leaf	R	scipy.cluster.hierarchy.ClusterNode.is_leaf										
scipy cluster.hierarchy.ClusterNode.is_leaf	R	scipy.cluster.hierarchy.ClusterNode.is_leaf										
scipy.cluster.hierarchy.ClusterNode.pre_order	A										<section class="prog__container"><p>Performs pre-order traversal without recursive function calls.</p><pre><code>ClusterNode.pre_order(func=<function <lambda> at 0x2aba95730758>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    Applied to each leaf ClusterNode object in the pre-order traversal. Given the i’th leaf node in the pre-ordeR traversal n[i], the result of func(n[i]) is stored in L[i]. If not provided, the index of the original observation to which the node corresponds is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>L : list\n    The pre-order traversal.</code></pre><span class="prog__sub">Examples:</span><pre><code>ids = root.pre_order(lambda x: x.id)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.ClusterNode.pre_order.html
scipy cluster hierarchy ClusterNode pre_order	R	scipy.cluster.hierarchy.ClusterNode.pre_order										
scipy cluster.hierarchy.ClusterNode.pre_order	R	scipy.cluster.hierarchy.ClusterNode.pre_order										
scipy cluster hierarchy ClusterNode	R	scipy.cluster.hierarchy.ClusterNode										
scipy cluster.hierarchy.ClusterNode	R	scipy.cluster.hierarchy.ClusterNode										
scipy.cluster.hierarchy.complete	A					[[scipy.cluster.hierarchy.linkage]]					<section class="prog__container"><p>Performs complete/max/farthest point linkage on a condensed distance matrix</p><pre><code>scipy.cluster.hierarchy.complete(y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    The upper triangular of the distance matrix. The result of pdist is returned in this form.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray\n    A linkage matrix containing the hierarchical clustering. See the linkage function documentation for more information on its structure.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.complete.html
scipy cluster hierarchy complete	R	scipy.cluster.hierarchy.complete										
scipy cluster.hierarchy.complete	R	scipy.cluster.hierarchy.complete										
scipy.cluster.hierarchy.cophenet	A										<section class="prog__container"><p>Calculates the cophenetic distances between each observation in\nthe hierarchical clustering defined by the linkage Z.</p><pre><code>scipy.cluster.hierarchy.cophenet(Z, Y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded as an array (see linkage function). \nY : ndarray (optional)\n    Calculates the cophenetic correlation coefficient c of a hierarchical clustering defined by the linkage matrix Z of a set of \(n\) observations in \(m\) dimensions. Y is the condensed distance matrix from which Z was generated.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    The cophentic correlation distance (if y is passed). \nd : ndarray\n    The cophenetic distance matrix in condensed form. The \(ij\) th entry is the cophenetic distance between original observations \(i\) and \(j\).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.cophenet.html
scipy cluster hierarchy cophenet	R	scipy.cluster.hierarchy.cophenet										
scipy cluster.hierarchy.cophenet	R	scipy.cluster.hierarchy.cophenet										
scipy.cluster.hierarchy.correspond	A										<section class="prog__container"><p>Checks for correspondence between linkage and condensed distance matrices</p><pre><code>scipy.cluster.hierarchy.correspond(Z, Y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : array_like\n    The linkage matrix to check for correspondence. \nY : array_like\n    The condensed distance matrix to check for correspondence.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : bool\n    A boolean indicating whether the linkage matrix and distance matrix could possibly correspond to one another.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.correspond.html
scipy cluster hierarchy correspond	R	scipy.cluster.hierarchy.correspond										
scipy cluster.hierarchy.correspond	R	scipy.cluster.hierarchy.correspond										
scipy.cluster.hierarchy.cut_tree	A										<section class="prog__container"><p>Given a linkage matrix Z, return the cut tree.</p><pre><code>scipy.cluster.hierarchy.cut_tree(Z, n_clusters=None, height=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : scipy.cluster.linkage array\n    The linkage matrix. \nn_clusters : array_like, optional\n    Number of clusters in the tree at the cut point. \nheight : array_like, optional\n    The height at which to cut the tree.  Only possible for ultrametric trees.</code></pre><span class="prog__sub">Returns:</span><pre><code>cutree : array\n    An array indicating group membership at each agglomeration step.  I.e., for a full cut tree, in the first column each data point is in its own cluster.  At the next step, two nodes are merged.  Finally all singleton and non-singleton clusters are in one group.  If n_clusters or height is given, the columns correspond to the columns of n_clusters or height.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import cluster\n>>> np.random.seed(23)\n>>> X = np.random.randn(50, 4)\n>>> Z = cluster.hierarchy.ward(X)\n>>> cutree = cluster.hierarchy.cut_tree(Z, n_clusters=[5, 10])\n>>> cutree[:10]\narray([[0, 0],\n       [1, 1],\n       [2, 2],\n       [3, 3],\n       [3, 4],\n       [2, 2],\n       [0, 0],\n       [1, 5],\n       [3, 6],\n       [4, 7]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.cut_tree.html
scipy cluster hierarchy cut_tree	R	scipy.cluster.hierarchy.cut_tree										
scipy cluster.hierarchy.cut_tree	R	scipy.cluster.hierarchy.cut_tree										
scipy.cluster.hierarchy.dendrogram	A					[[scipy.cluster.hierarchy.linkage]]\\n[[scipy.cluster.hierarchy.set_link_color_palette]]					<section class="prog__container"><p>Plots the hierarchical clustering as a dendrogram.</p><pre><code>scipy.cluster.hierarchy.dendrogram(Z, p=30, truncate_mode=None, color_threshold=None, get_leaves=True, orientation='top', labels=None, count_sort=False, distance_sort=False, show_leaf_counts=True, no_plot=False, no_labels=False, leaf_font_size=None, leaf_rotation=None, leaf_label_func=None, show_contracted=False, link_color_func=None, ax=None, above_threshold_color='b')</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The linkage matrix encoding the hierarchical clustering to render as a dendrogram. See the linkage function for more information on the format of Z. \np : int, optional\n    The p parameter for truncate_mode. \ntruncate_mode : str, optional\n    The dendrogram can be hard to read when the original observation matrix from which the linkage is derived is large. Truncation is used to condense the dendrogram. There are several modes:  None/'none' No truncation is performed (Default).  'lastp' The last p non-singleton formed in the linkage are the only non-leaf nodes in the linkage; they correspond to rows Z[n-p-2:end] in Z. All other non-singleton clusters are contracted into leaf nodes.  'mlab' This corresponds to MATLAB(TM) behavior. (not implemented yet)  'level'/'mtica' No more than p levels of the dendrogram tree are displayed. This corresponds to Mathematica(TM) behavior.   \ncolor_threshold : double, optional\n    For brevity, let \(t\) be the color_threshold. Colors all the descendent links below a cluster node \(k\) the same color if \(k\) is the first node below the cut threshold \(t\). All links connecting nodes with distances greater than or equal to the threshold are colored blue. If \(t\) is less than or equal to zero, all nodes are colored blue. If color_threshold is None or ‘default’, corresponding with MATLAB(TM) behavior, the threshold is set to 0.7*max(Z[:,2]). \nget_leaves : bool, optional\n    Includes a list R['leaves']=H in the result dictionary. For each \(i\), H[i] == j, cluster node j appears in position i in the left-to-right traversal of the leaves, where \(j < 2n-1\) and \(i < n\). \norientation : str, optional\n    The direction to plot the dendrogram, which can be any of the following strings:  'top' Plots the root at the top, and plot descendent links going downwards. (default).  'bottom' Plots the root at the bottom, and plot descendent links going upwards.  'left' Plots the root at the left, and plot descendent links going right.  'right' Plots the root at the right, and plot descendent links going left.   \nlabels : ndarray, optional\n    By default labels is None so the index of the original observation is used to label the leaf nodes.  Otherwise, this is an \(n\) -sized list (or tuple). The labels[i] value is the text to put under the \(i\) th leaf node only if it corresponds to an original observation and not a non-singleton cluster. \ncount_sort : str or bool, optional\n    For each node n, the order (visually, from left-to-right) n’s two descendent links are plotted is determined by this parameter, which can be any of the following values:  False Nothing is done.  'ascending' or True The child with the minimum number of original objects in its cluster is plotted first.  'descendent' The child with the maximum number of original objects in its cluster is plotted first.   Note distance_sort and count_sort cannot both be True. \ndistance_sort : str or bool, optional\n    For each node n, the order (visually, from left-to-right) n’s two descendent links are plotted is determined by this parameter, which can be any of the following values:  False Nothing is done.  'ascending' or True The child with the minimum distance between its direct descendents is plotted first.  'descending' The child with the maximum distance between its direct descendents is plotted first.   Note distance_sort and count_sort cannot both be True. \nshow_leaf_counts : bool, optional\n    When True, leaf nodes representing \(k>1\) original observation are labeled with the number of observations they contain in parentheses. \nno_plot : bool, optional\n    When True, the final rendering is not performed. This is useful if only the data structures computed for the rendering are needed or if matplotlib is not available. \nno_labels : bool, optional\n    When True, no labels appear next to the leaf nodes in the rendering of the dendrogram. \nleaf_rotation : double, optional\n    Specifies the angle (in degrees) to rotate the leaf labels. When unspecified, the rotation is based on the number of nodes in the dendrogram (default is 0). \nleaf_font_size : int, optional\n    Specifies the font size (in points) of the leaf labels. When unspecified, the size based on the number of nodes in the dendrogram. \nleaf_label_func : lambda or function, optional\n    When leaf_label_func is a callable function, for each leaf with cluster index \(k < 2n-1\). The function is expected to return a string with the label for the leaf. Indices \(k < n\) correspond to original observations while indices \(k \geq n\) correspond to non-singleton clusters. For example, to label singletons with their node id and non-singletons with their id, count, and inconsistency coefficient, simply do: # First define the leaf label function. def llf(id):     if id < n:         return str(id)     else:         return '[%d %d %1.2f]' % (id, count, R[n-id,3]) # The text for the leaf nodes is going to be big so force # a rotation of 90 degrees. dendrogram(Z, leaf_label_func=llf, leaf_rotation=90)   \nshow_contracted : bool, optional\n    When True the heights of non-singleton nodes contracted into a leaf node are plotted as crosses along the link connecting that leaf node.  This really is only useful when truncation is used (see truncate_mode parameter). \nlink_color_func : callable, optional\n    If given, link_color_function is called with each non-singleton id corresponding to each U-shaped link it will paint. The function is expected to return the color to paint the link, encoded as a matplotlib color string code. For example: dendrogram(Z, link_color_func=lambda k: colors[k])   colors the direct links below each untruncated non-singleton node k using colors[k]. \nax : matplotlib Axes instance, optional\n    If None and no_plot is not True, the dendrogram will be plotted on the current axes.  Otherwise if no_plot is not True the dendrogram will be plotted on the given Axes instance. This can be useful if the dendrogram is part of a more complex figure. \nabove_threshold_color : str, optional\n    This matplotlib color string sets the color of the links above the color_threshold. The default is ‘b’.</code></pre><span class="prog__sub">Returns:</span><pre><code>R : dict\n    A dictionary of data structures computed to render the dendrogram. Its has the following keys:  'color_list' A list of color names. The k’th element represents the color of the k’th link.  'icoord' and 'dcoord' Each of them is a list of lists. Let icoord = [I1, I2, ..., Ip] where Ik = [xk1, xk2, xk3, xk4] and dcoord = [D1, D2, ..., Dp] where Dk = [yk1, yk2, yk3, yk4], then the k’th link painted is (xk1, yk1) - (xk2, yk2) - (xk3, yk3) - (xk4, yk4).  'ivl' A list of labels corresponding to the leaf nodes.  'leaves' For each i, H[i] == j, cluster node j appears in position i in the left-to-right traversal of the leaves, where \(j < 2n-1\) and \(i < n\). If j is less than n, the i-th leaf node corresponds to an original observation. Otherwise, it corresponds to a non-singleton cluster.</code></pre><span class="prog__sub">Examples:</span><pre><code># First define the leaf label function.\ndef llf(id):\n    if id < n:\n        return str(id)\n    else:\n        return '[%d %d %1.2f]' % (id, count, R[n-id,3])\n# The text for the leaf nodes is going to be big so force\n# a rotation of 90 degrees.\ndendrogram(Z, leaf_label_func=llf, leaf_rotation=90)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.dendrogram.html
scipy cluster hierarchy dendrogram	R	scipy.cluster.hierarchy.dendrogram										
scipy cluster.hierarchy.dendrogram	R	scipy.cluster.hierarchy.dendrogram										
scipy.cluster.hierarchy.fcluster	A										<section class="prog__container"><p>Forms flat clusters from the hierarchical clustering defined by\nthe linkage matrix Z.</p><pre><code>scipy.cluster.hierarchy.fcluster(Z, t, criterion='inconsistent', depth=2, R=None, monocrit=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded with the matrix returned by the linkage function. \nt : float\n    The threshold to apply when forming flat clusters. \ncriterion : str, optional\n    The criterion to use in forming flat clusters. This can be any of the following values:   inconsistent : If a cluster node and all its descendants have an inconsistent value less than or equal to t then all its leaf descendants belong to the same flat cluster. When no non-singleton cluster meets this criterion, every node is assigned to its own cluster. (Default)  distance : Forms flat clusters so that the original observations in each flat cluster have no greater a cophenetic distance than t.  maxclust : Finds a minimum threshold r so that the cophenetic distance between any two original observations in the same flat cluster is no more than r and no more than t flat clusters are formed.  monocrit : Forms a flat cluster from a cluster node c with index i when monocrit[j] <= t. For example, to threshold on the maximum mean distance as computed in the inconsistency matrix R with a threshold of 0.8 do: MR = maxRstat(Z, R, 3) cluster(Z, t=0.8, criterion='monocrit', monocrit=MR)    maxclust_monocrit : Forms a flat cluster from a non-singleton cluster node c when monocrit[i] <= r for all cluster indices i below and including c. r is minimized such that no more than t flat clusters are formed. monocrit must be monotonic. For example, to minimize the threshold t on maximum inconsistency values so that no more than 3 flat clusters are formed, do: MI = maxinconsts(Z, R) cluster(Z, t=3, criterion='maxclust_monocrit', monocrit=MI)      \ndepth : int, optional\n    The maximum depth to perform the inconsistency calculation. It has no meaning for the other criteria. Default is 2. \nR : ndarray, optional\n    The inconsistency matrix to use for the ‘inconsistent’ criterion. This matrix is computed if not provided. \nmonocrit : ndarray, optional\n    An array of length n-1. monocrit[i] is the statistics upon which non-singleton i is thresholded. The monocrit vector must be monotonic, i.e. given a node c with index i, for all node indices j corresponding to nodes below c, monocrit[i] >= monocrit[j].</code></pre><span class="prog__sub">Returns:</span><pre><code>fcluster : ndarray\n    An array of length n. T[i] is the flat cluster number to which original observation i belongs.</code></pre><span class="prog__sub">Examples:</span><pre><code>MR = maxRstat(Z, R, 3)\ncluster(Z, t=0.8, criterion='monocrit', monocrit=MR)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.fcluster.html
scipy.cluster.hierarchy.fclusterdata	A										<section class="prog__container"><p>Cluster observation data using a given metric.</p><pre><code>scipy.cluster.hierarchy.fclusterdata(X, t, criterion='inconsistent', metric='euclidean', depth=2, method='single', R=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>X : (N, M) ndarray\n    N by M data matrix with N observations in M dimensions. \nt : float\n    The threshold to apply when forming flat clusters. \ncriterion : str, optional\n    Specifies the criterion for forming flat clusters.  Valid values are ‘inconsistent’ (default), ‘distance’, or ‘maxclust’ cluster formation algorithms. See fcluster for descriptions. \nmetric : str, optional\n    The distance metric for calculating pairwise distances. See distance.pdist for descriptions and linkage to verify compatibility with the linkage method. \ndepth : int, optional\n    The maximum depth for the inconsistency calculation. See inconsistent for more information. \nmethod : str, optional\n    The linkage method to use (single, complete, average, weighted, median centroid, ward). See linkage for more information. Default is “single”. \nR : ndarray, optional\n    The inconsistency matrix. It will be computed if necessary if it is not passed.</code></pre><span class="prog__sub">Returns:</span><pre><code>fclusterdata : ndarray\n    A vector of length n. T[i] is the flat cluster number to which original observation i belongs.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.fclusterdata.html
scipy cluster hierarchy fclusterdata	R	scipy.cluster.hierarchy.fclusterdata										
scipy cluster.hierarchy.fclusterdata	R	scipy.cluster.hierarchy.fclusterdata										
scipy cluster hierarchy fcluster	R	scipy.cluster.hierarchy.fcluster										
scipy cluster.hierarchy.fcluster	R	scipy.cluster.hierarchy.fcluster										
scipy.cluster.hierarchy.from_mlab_linkage	A										<section class="prog__container"><p>Converts a linkage matrix generated by MATLAB(TM) to a new\nlinkage matrix compatible with this module.</p><pre><code>scipy.cluster.hierarchy.from_mlab_linkage(Z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    A linkage matrix generated by MATLAB(TM).</code></pre><span class="prog__sub">Returns:</span><pre><code>ZS : ndarray\n    A linkage matrix compatible with this library.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.from_mlab_linkage.html
scipy cluster hierarchy from_mlab_linkage	R	scipy.cluster.hierarchy.from_mlab_linkage										
scipy cluster.hierarchy.from_mlab_linkage	R	scipy.cluster.hierarchy.from_mlab_linkage										
scipy.cluster.hierarchy.inconsistent	A										<section class="prog__container"><p>Calculates inconsistency statistics on a linkage.</p><pre><code>scipy.cluster.hierarchy.inconsistent(Z, d=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The \((n-1)\) by 4 matrix encoding the linkage (hierarchical clustering).  See linkage documentation for more information on its form. \nd : int, optional\n    The number of links up to d levels below each non-singleton cluster.</code></pre><span class="prog__sub">Returns:</span><pre><code>R : ndarray\n    A \((n-1)\) by 5 matrix where the i‘th row contains the link statistics for the non-singleton cluster i. The link statistics are computed over the link heights for links \(d\) levels below the cluster i. R[i,0] and R[i,1] are the mean and standard deviation of the link heights, respectively; R[i,2] is the number of links included in the calculation; and R[i,3] is the inconsistency coefficient,  \[\frac{\mathtt{Z[i,2]} - \mathtt{R[i,0]}} {R[i,1]}\]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.inconsistent.html
scipy cluster hierarchy inconsistent	R	scipy.cluster.hierarchy.inconsistent										
scipy cluster.hierarchy.inconsistent	R	scipy.cluster.hierarchy.inconsistent										
scipy.cluster.hierarchy.is_isomorphic	A										<section class="prog__container"><p>Determines if two different cluster assignments are equivalent.</p><pre><code>scipy.cluster.hierarchy.is_isomorphic(T1, T2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>T1 : array_like\n    An assignment of singleton cluster ids to flat cluster ids. \nT2 : array_like\n    An assignment of singleton cluster ids to flat cluster ids.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : bool\n    Whether the flat cluster assignments T1 and T2 are equivalent.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.is_isomorphic.html
scipy cluster hierarchy is_isomorphic	R	scipy.cluster.hierarchy.is_isomorphic										
scipy cluster.hierarchy.is_isomorphic	R	scipy.cluster.hierarchy.is_isomorphic										
scipy.cluster.hierarchy.is_monotonic	A										<section class="prog__container"><p>Returns True if the linkage passed is monotonic.</p><pre><code>scipy.cluster.hierarchy.is_monotonic(Z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The linkage matrix to check for monotonicity.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : bool\n    A boolean indicating whether the linkage is monotonic.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.is_monotonic.html
scipy cluster hierarchy is_monotonic	R	scipy.cluster.hierarchy.is_monotonic										
scipy cluster.hierarchy.is_monotonic	R	scipy.cluster.hierarchy.is_monotonic										
scipy.cluster.hierarchy.is_valid_im	A										<section class="prog__container"><p>Returns True if the inconsistency matrix passed is valid.</p><pre><code>scipy.cluster.hierarchy.is_valid_im(R, warning=False, throw=False, name=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>R : ndarray\n    The inconsistency matrix to check for validity. \nwarning : bool, optional\n    When True, issues a Python warning if the linkage matrix passed is invalid. \nthrow : bool, optional\n    When True, throws a Python exception if the linkage matrix passed is invalid. \nname : str, optional\n    This string refers to the variable name of the invalid linkage matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : bool\n    True if the inconsistency matrix is valid.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.is_valid_im.html
scipy cluster hierarchy is_valid_im	R	scipy.cluster.hierarchy.is_valid_im										
scipy cluster.hierarchy.is_valid_im	R	scipy.cluster.hierarchy.is_valid_im										
scipy.cluster.hierarchy.is_valid_linkage	A										<section class="prog__container"><p>Checks the validity of a linkage matrix.</p><pre><code>scipy.cluster.hierarchy.is_valid_linkage(Z, warning=False, throw=False, name=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : array_like\n    Linkage matrix. \nwarning : bool, optional\n    When True, issues a Python warning if the linkage matrix passed is invalid. \nthrow : bool, optional\n    When True, throws a Python exception if the linkage matrix passed is invalid. \nname : str, optional\n    This string refers to the variable name of the invalid linkage matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : bool\n    True if the inconsistency matrix is valid.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.is_valid_linkage.html
scipy cluster hierarchy is_valid_linkage	R	scipy.cluster.hierarchy.is_valid_linkage										
scipy cluster.hierarchy.is_valid_linkage	R	scipy.cluster.hierarchy.is_valid_linkage										
scipy.cluster.hierarchy.leaders	A										<section class="prog__container"><p>Returns the root nodes in a hierarchical clustering.</p><pre><code>scipy.cluster.hierarchy.leaders(Z, T)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded as a matrix. See linkage for more information. \nT : ndarray\n    The flat cluster assignment vector.</code></pre><span class="prog__sub">Returns:</span><pre><code>L : ndarray\n    The leader linkage node id’s stored as a k-element 1-D array where k is the number of flat clusters found in T. L[j]=i is the linkage cluster node id that is the leader of flat cluster with id M[j].  If i < n, i corresponds to an original observation, otherwise it corresponds to a non-singleton cluster. For example: if L[3]=2 and M[3]=8, the flat cluster with id 8’s leader is linkage node 2. \nM : ndarray\n    The leader linkage node id’s stored as a k-element 1-D array where k is the number of flat clusters found in T. This allows the set of flat cluster ids to be any arbitrary set of k integers.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.leaders.html
scipy cluster hierarchy leaders	R	scipy.cluster.hierarchy.leaders										
scipy cluster.hierarchy.leaders	R	scipy.cluster.hierarchy.leaders										
scipy.cluster.hierarchy.leaves_list	A										<section class="prog__container"><p>Returns a list of leaf node ids</p><pre><code>scipy.cluster.hierarchy.leaves_list(Z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded as a matrix.  Z is a linkage matrix.  See linkage for more information.</code></pre><span class="prog__sub">Returns:</span><pre><code>leaves_list : ndarray\n    The list of leaf node ids.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.leaves_list.html
scipy cluster hierarchy leaves_list	R	scipy.cluster.hierarchy.leaves_list										
scipy cluster.hierarchy.leaves_list	R	scipy.cluster.hierarchy.leaves_list										
scipy.cluster.hierarchy.linkage	A										<section class="prog__container"><p>Performs hierarchical/agglomerative clustering on the condensed\ndistance matrix y.</p><pre><code>scipy.cluster.hierarchy.linkage(y, method='single', metric='euclidean')</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    A condensed or redundant distance matrix. A condensed distance matrix is a flat array containing the upper triangular of the distance matrix. This is the form that pdist returns. Alternatively, a collection of \(m\) observation vectors in n dimensions may be passed as an \(m\) by \(n\) array. \nmethod : str, optional\n    The linkage algorithm to use. See the Linkage Methods section below for full descriptions. \nmetric : str or function, optional\n    The distance metric to use in the case that y is a collection of observation vectors; ignored otherwise. See the distance.pdist function for a list of valid distance metrics. A custom distance function can also be used. See the distance.pdist function for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded as a linkage matrix.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html
scipy cluster hierarchy linkage	R	scipy.cluster.hierarchy.linkage										
scipy cluster.hierarchy.linkage	R	scipy.cluster.hierarchy.linkage										
scipy.cluster.hierarchy.maxdists	A										<section class="prog__container"><p>Returns the maximum distance between any non-singleton cluster.</p><pre><code>scipy.cluster.hierarchy.maxdists(Z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded as a matrix. See linkage for more information.</code></pre><span class="prog__sub">Returns:</span><pre><code>maxdists : ndarray\n    A (n-1) sized numpy array of doubles; MD[i] represents the maximum distance between any cluster (including singletons) below and including the node with index i. More specifically, MD[i] = Z[Q(i)-n, 2].max() where Q(i) is the set of all node indices below and including node i.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.maxdists.html
scipy cluster hierarchy maxdists	R	scipy.cluster.hierarchy.maxdists										
scipy cluster.hierarchy.maxdists	R	scipy.cluster.hierarchy.maxdists										
scipy.cluster.hierarchy.maxinconsts	A										<section class="prog__container"><p>Returns the maximum inconsistency coefficient for each\nnon-singleton cluster and its descendents.</p><pre><code>scipy.cluster.hierarchy.maxinconsts(Z, R)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded as a matrix. See linkage for more information. \nR : ndarray\n    The inconsistency matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>MI : ndarray\n    A monotonic (n-1)-sized numpy array of doubles.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.maxinconsts.html
scipy cluster hierarchy maxinconsts	R	scipy.cluster.hierarchy.maxinconsts										
scipy cluster.hierarchy.maxinconsts	R	scipy.cluster.hierarchy.maxinconsts										
scipy.cluster.hierarchy.maxRstat	A										<section class="prog__container"><p>Returns the maximum statistic for each non-singleton cluster and\nits descendents.</p><pre><code>scipy.cluster.hierarchy.maxRstat(Z, R, i)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : array_like\n    The hierarchical clustering encoded as a matrix. See linkage for more information. \nR : array_like\n    The inconsistency matrix. \ni : int\n    The column of R to use as the statistic.</code></pre><span class="prog__sub">Returns:</span><pre><code>MR : ndarray\n    Calculates the maximum statistic for the i’th column of the inconsistency matrix R for each non-singleton cluster node. MR[j] is the maximum over R[Q(j)-n, i] where Q(j) the set of all node ids corresponding to nodes below and including j.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.maxRstat.html
scipy cluster hierarchy maxRstat	R	scipy.cluster.hierarchy.maxRstat										
scipy cluster.hierarchy.maxRstat	R	scipy.cluster.hierarchy.maxRstat										
scipy.cluster.hierarchy.median	A										<section class="prog__container"><p>Performs median/WPGMC linkage.</p><pre><code>scipy.cluster.hierarchy.median(y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    A condensed or redundant distance matrix. A condensed distance matrix is a flat array containing the upper triangular of the distance matrix. This is the form that pdist returns. Alternatively, a collection of m observation vectors in n dimensions may be passed as a m by n array.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded as a linkage matrix.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.median.html
scipy cluster hierarchy median	R	scipy.cluster.hierarchy.median										
scipy cluster.hierarchy.median	R	scipy.cluster.hierarchy.median										
scipy.cluster.hierarchy.num_obs_linkage	A										<section class="prog__container"><p>Returns the number of original observations of the linkage matrix\npassed.</p><pre><code>scipy.cluster.hierarchy.num_obs_linkage(Z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The linkage matrix on which to perform the operation.</code></pre><span class="prog__sub">Returns:</span><pre><code>n : int\n    The number of original observations in the linkage.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.num_obs_linkage.html
scipy cluster hierarchy num_obs_linkage	R	scipy.cluster.hierarchy.num_obs_linkage										
scipy cluster.hierarchy.num_obs_linkage	R	scipy.cluster.hierarchy.num_obs_linkage										
scipy.cluster.hierarchy.set_link_color_palette	A					[[scipy.cluster.hierarchy.dendrogram]]					<section class="prog__container"><p>Set list of matplotlib color codes for use by dendrogram.</p><pre><code>scipy.cluster.hierarchy.set_link_color_palette(palette)</code></pre><span class="prog__sub">Parameters:</span><pre><code>palette : list of str or None\n    A list of matplotlib color codes.  The order of the color codes is the order in which the colors are cycled through when color thresholding in the dendrogram. If None, resets the palette to its default (which is ['g', 'r', 'c', 'm', 'y', 'k']).</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.cluster import hierarchy\n>>> ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268., 400.,\n...                    754., 564., 138., 219., 869., 669.])\n>>> Z = hierarchy.linkage(ytdist, 'single')\n>>> dn = hierarchy.dendrogram(Z, no_plot=True)\n>>> dn['color_list']\n['g', 'b', 'b', 'b', 'b']\n>>> hierarchy.set_link_color_palette(['c', 'm', 'y', 'k'])\n>>> dn = hierarchy.dendrogram(Z, no_plot=True)\n>>> dn['color_list']\n['c', 'b', 'b', 'b', 'b']\n>>> dn = hierarchy.dendrogram(Z, no_plot=True, color_threshold=267,\n...                           above_threshold_color='k')\n>>> dn['color_list']\n['c', 'm', 'm', 'k', 'k']</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.set_link_color_palette.html
scipy cluster hierarchy set_link_color_palette	R	scipy.cluster.hierarchy.set_link_color_palette										
scipy cluster.hierarchy.set_link_color_palette	R	scipy.cluster.hierarchy.set_link_color_palette										
scipy.cluster.hierarchy.single	A										<section class="prog__container"><p>Performs single/min/nearest linkage on the condensed distance matrix y</p><pre><code>scipy.cluster.hierarchy.single(y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    The upper triangular of the distance matrix. The result of pdist is returned in this form.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray\n    The linkage matrix.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.single.html
scipy cluster hierarchy single	R	scipy.cluster.hierarchy.single										
scipy cluster.hierarchy.single	R	scipy.cluster.hierarchy.single										
scipy.cluster.hierarchy.to_mlab_linkage	A										<section class="prog__container"><p>Converts a linkage matrix to a MATLAB(TM) compatible one.</p><pre><code>scipy.cluster.hierarchy.to_mlab_linkage(Z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    A linkage matrix generated by this library.</code></pre><span class="prog__sub">Returns:</span><pre><code>to_mlab_linkage : ndarray\n    A linkage matrix compatible with MATLAB(TM)’s hierarchical clustering functions. The return linkage matrix has the last column removed and the cluster indices are converted to 1..N indexing.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.to_mlab_linkage.html
scipy cluster hierarchy to_mlab_linkage	R	scipy.cluster.hierarchy.to_mlab_linkage										
scipy cluster.hierarchy.to_mlab_linkage	R	scipy.cluster.hierarchy.to_mlab_linkage										
scipy.cluster.hierarchy.to_tree	A										<section class="prog__container"><p>Converts a hierarchical clustering encoded in the matrix Z (by\nlinkage) into an easy-to-use tree object.</p><pre><code>scipy.cluster.hierarchy.to_tree(Z, rd=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Z : ndarray\n    The linkage matrix in proper form (see the linkage function documentation). \nrd : bool, optional\n    When False, a reference to the root ClusterNode object is returned.  Otherwise, a tuple (r,d) is returned. r is a reference to the root node while d is a dictionary mapping cluster ids to ClusterNode references. If a cluster id is less than n, then it corresponds to a singleton cluster (leaf node). See linkage for more information on the assignment of cluster ids to clusters.</code></pre><span class="prog__sub">Returns:</span><pre><code>L : list\n    The pre-order traversal.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.to_tree.html
scipy cluster hierarchy to_tree	R	scipy.cluster.hierarchy.to_tree										
scipy cluster.hierarchy.to_tree	R	scipy.cluster.hierarchy.to_tree										
scipy.cluster.hierarchy.ward	A										<section class="prog__container"><p>Performs Ward’s linkage on a condensed or redundant distance matrix.</p><pre><code>scipy.cluster.hierarchy.ward(y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    A condensed or redundant distance matrix. A condensed distance matrix is a flat array containing the upper triangular of the distance matrix. This is the form that pdist returns. Alternatively, a collection of m observation vectors in n dimensions may be passed as a m by n array.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray\n    The hierarchical clustering encoded as a linkage matrix.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.ward.html
scipy cluster hierarchy ward	R	scipy.cluster.hierarchy.ward										
scipy cluster.hierarchy.ward	R	scipy.cluster.hierarchy.ward										
scipy.cluster.hierarchy.weighted	A										<section class="prog__container"><p>Performs weighted/WPGMA linkage on the condensed distance matrix.</p><pre><code>scipy.cluster.hierarchy.weighted(y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    The upper triangular of the distance matrix. The result of pdist is returned in this form.</code></pre><span class="prog__sub">Returns:</span><pre><code>Z : ndarray\n    A linkage matrix containing the hierarchical clustering. See the linkage function documentation for more information on its structure.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.weighted.html
scipy cluster hierarchy weighted	R	scipy.cluster.hierarchy.weighted										
scipy cluster.hierarchy.weighted	R	scipy.cluster.hierarchy.weighted										
scipy.cluster.vq.kmeans2	A										<section class="prog__container"><p>Classify a set of observations into k clusters using the k-means algorithm.</p><pre><code>scipy.cluster.vq.kmeans2(data, k, iter=10, thresh=1e-05, minit='random', missing='warn', check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    A ‘M’ by ‘N’ array of ‘M’ observations in ‘N’ dimensions or a length ‘M’ array of ‘M’ one-dimensional observations. \nk : int or ndarray\n    The number of clusters to form as well as the number of centroids to generate. If minit initialization string is ‘matrix’, or if a ndarray is given instead, it is interpreted as initial cluster to use instead. \niter : int, optional\n    Number of iterations of the k-means algrithm to run. Note that this differs in meaning from the iters parameter to the kmeans function. \nthresh : float, optional\n    (not used yet) \nminit : str, optional\n    Method for initialization. Available methods are ‘random’, ‘points’, and ‘matrix’: ‘random’: generate k centroids from a Gaussian with mean and variance estimated from the data. ‘points’: choose k observations (rows) at random from data for the initial centroids. ‘matrix’: interpret the k parameter as a k by M (or length k array for one-dimensional data) array of initial centroids. \nmissing : str, optional\n    Method to deal with empty clusters. Available methods are ‘warn’ and ‘raise’: ‘warn’: give a warning and continue. ‘raise’: raise an ClusterError and terminate the algorithm. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. Default: True</code></pre><span class="prog__sub">Returns:</span><pre><code>centroid : ndarray\n    A ‘k’ by ‘N’ array of centroids found at the last iteration of k-means. \nlabel : ndarray\n    label[i] is the code or index of the centroid the i’th observation is closest to.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.vq.kmeans2.html
scipy cluster vq kmeans2	R	scipy.cluster.vq.kmeans2										
scipy cluster.vq.kmeans2	R	scipy.cluster.vq.kmeans2										
scipy.cluster.vq.kmeans	A										<section class="prog__container"><p>Performs k-means on a set of observation vectors forming k clusters.</p><pre><code>scipy.cluster.vq.kmeans(obs, k_or_guess, iter=20, thresh=1e-05, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obs : ndarray\n    Each row of the M by N array is an observation vector. The columns are the features seen during each observation. The features must be whitened first with the whiten function. \nk_or_guess : int or ndarray\n    The number of centroids to generate. A code is assigned to each centroid, which is also the row index of the centroid in the code_book matrix generated. The initial k centroids are chosen by randomly selecting observations from the observation matrix. Alternatively, passing a k by N array specifies the initial k centroids. \niter : int, optional\n    The number of times to run k-means, returning the codebook with the lowest distortion. This argument is ignored if initial centroids are specified with an array for the k_or_guess parameter. This parameter does not represent the number of iterations of the k-means algorithm. \nthresh : float, optional\n    Terminates the k-means algorithm if the change in distortion since the last k-means iteration is less than or equal to thresh. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. Default: True</code></pre><span class="prog__sub">Returns:</span><pre><code>codebook : ndarray\n    A k by N array of k centroids. The i’th centroid codebook[i] is represented with the code i. The centroids and codes generated represent the lowest distortion seen, not necessarily the globally minimal distortion. \ndistortion : float\n    The distortion between the observations passed and the centroids generated.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import array\n>>> from scipy.cluster.vq import vq, kmeans, whiten\n>>> features  = array([[ 1.9,2.3],\n...                    [ 1.5,2.5],\n...                    [ 0.8,0.6],\n...                    [ 0.4,1.8],\n...                    [ 0.1,0.1],\n...                    [ 0.2,1.8],\n...                    [ 2.0,0.5],\n...                    [ 0.3,1.5],\n...                    [ 1.0,1.0]])\n>>> whitened = whiten(features)\n>>> book = array((whitened[0],whitened[2]))\n>>> kmeans(whitened,book)\n(array([[ 2.3110306 ,  2.86287398],    # random\n       [ 0.93218041,  1.24398691]]), 0.85684700941625547)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.vq.kmeans.html
scipy cluster vq kmeans	R	scipy.cluster.vq.kmeans										
scipy cluster.vq.kmeans	R	scipy.cluster.vq.kmeans										
scipy.cluster.vq.vq	A										<section class="prog__container"><p>Assign codes from a code book to observations.</p><pre><code>scipy.cluster.vq.vq(obs, code_book, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obs : ndarray\n    Each row of the ‘M’ x ‘N’ array is an observation.  The columns are the “features” seen during each observation. The features must be whitened first using the whiten function or something equivalent. \ncode_book : ndarray\n    The code book is usually generated using the k-means algorithm. Each row of the array holds a different code, and the columns are the features of the code. >>> #              f0    f1    f2   f3 >>> code_book = [ ...             [  1.,   2.,   3.,   4.],  #c0 ...             [  1.,   2.,   3.,   4.],  #c1 ...             [  1.,   2.,   3.,   4.]]  #c2   \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. Default: True</code></pre><span class="prog__sub">Returns:</span><pre><code>code : ndarray\n    A length M array holding the code book index for each observation. \ndist : ndarray\n    The distortion (distance) between the observation and its nearest code.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> #              f0    f1    f2   f3\n>>> code_book = [\n...             [  1.,   2.,   3.,   4.],  #c0\n...             [  1.,   2.,   3.,   4.],  #c1\n...             [  1.,   2.,   3.,   4.]]  #c2</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.vq.vq.html
scipy cluster vq vq	R	scipy.cluster.vq.vq										
scipy cluster.vq.vq	R	scipy.cluster.vq.vq										
scipy.cluster.vq.whiten	A										<section class="prog__container"><p>Normalize a group of observations on a per feature basis.</p><pre><code>scipy.cluster.vq.whiten(obs, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>obs : ndarray\n    Each row of the array is an observation.  The columns are the features seen during each observation. >>> #         f0    f1    f2 >>> obs = [[  1.,   1.,   1.],  #o0 ...        [  2.,   2.,   2.],  #o1 ...        [  3.,   3.,   3.],  #o2 ...        [  4.,   4.,   4.]]  #o3   \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. Default: True</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    Contains the values in obs scaled by the standard deviation of each column.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> #         f0    f1    f2\n>>> obs = [[  1.,   1.,   1.],  #o0\n...        [  2.,   2.,   2.],  #o1\n...        [  3.,   3.,   3.],  #o2\n...        [  4.,   4.,   4.]]  #o3</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.vq.whiten.html
scipy cluster vq whiten	R	scipy.cluster.vq.whiten										
scipy cluster.vq.whiten	R	scipy.cluster.vq.whiten										
scipy.constants.C2F	A										<section class="prog__container"><p>C2F is deprecated!\nscipy.constants.C2F is deprecated in scipy 0.18.0. Use scipy.constants.convert_teperature instead. Note that the new function has a different signature.</p><pre><code>scipy.constants.C2F(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>C : array_like\n    Celsius temperature(s) to be converted.</code></pre><span class="prog__sub">Returns:</span><pre><code>F : float or array of floats\n    Equivalent Fahrenheit temperature(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import C2F\n>>> C2F(np.array([-40, 40.0]))\narray([ -40.,  104.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.C2F.html
scipy constants C2F	R	scipy.constants.C2F										
scipy constants.C2F	R	scipy.constants.C2F										
scipy.constants.C2K	A										<section class="prog__container"><p>C2K is deprecated!\nscipy.constants.C2K is deprecated in scipy 0.18.0. Use scipy.constants.convert_teperature instead. Note that the new function has a different signature.</p><pre><code>scipy.constants.C2K(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>C : array_like\n    Celsius temperature(s) to be converted.</code></pre><span class="prog__sub">Returns:</span><pre><code>K : float or array of floats\n    Equivalent Kelvin temperature(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import C2K\n>>> C2K(np.array([-40, 40.0]))\narray([ 233.15,  313.15])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.C2K.html
scipy constants C2K	R	scipy.constants.C2K										
scipy constants.C2K	R	scipy.constants.C2K										
scipy.constants.ConstantWarning	A										<section class="prog__container"><p>Accessing a constant no longer in current CODATA data set</p><pre><code>exception scipy.constants.ConstantWarning</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.ConstantWarning.html
scipy constants ConstantWarning	R	scipy.constants.ConstantWarning										
scipy constants.ConstantWarning	R	scipy.constants.ConstantWarning										
scipy.constants.convert_temperature	A										<section class="prog__container"><p>Convert from a temperature scale to another one among Celsius, Kelvin,\nFahrenheit and Rankine scales.</p><pre><code>scipy.constants.convert_temperature(val, old_scale, new_scale)</code></pre><span class="prog__sub">Parameters:</span><pre><code>val : array_like\n    Value(s) of the temperature(s) to be converted expressed in the original scale. \nold_scale: str\n    Specifies as a string the original scale from which the temperature value(s) will be converted. Supported scales are Celsius (‘Celsius’, ‘celsius’, ‘C’ or ‘c’), Kelvin (‘Kelvin’, ‘kelvin’, ‘K’, ‘k’), Fahrenheit (‘Fahrenheit’, ‘fahrenheit’, ‘F’ or ‘f’) and Rankine (‘Rankine’, ‘rankine’, ‘R’, ‘r’). \nnew_scale: str\n    Specifies as a string the new scale to which the temperature value(s) will be converted. Supported scales are Celsius (‘Celsius’, ‘celsius’, ‘C’ or ‘c’), Kelvin (‘Kelvin’, ‘kelvin’, ‘K’, ‘k’), Fahrenheit (‘Fahrenheit’, ‘fahrenheit’, ‘F’ or ‘f’) and Rankine (‘Rankine’, ‘rankine’, ‘R’, ‘r’).</code></pre><span class="prog__sub">Returns:</span><pre><code>res : float or array of floats\n    Value(s) of the converted temperature(s) expressed in the new scale.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import convert_temperature\n>>> convert_temperature(np.array([-40, 40.0]), 'Celsius', 'Kelvin')\narray([ 233.15,  313.15])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.convert_temperature.html
scipy constants convert_temperature	R	scipy.constants.convert_temperature										
scipy constants.convert_temperature	R	scipy.constants.convert_temperature										
scipy.constants.F2C	A										<section class="prog__container"><p>F2C is deprecated!\nscipy.constants.F2C is deprecated in scipy 0.18.0. Use scipy.constants.convert_teperature instead. Note that the new function has a different signature.</p><pre><code>scipy.constants.F2C(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : array_like\n    Fahrenheit temperature(s) to be converted.</code></pre><span class="prog__sub">Returns:</span><pre><code>C : float or array of floats\n    Equivalent Celsius temperature(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import F2C\n>>> F2C(np.array([-40, 40.0]))\narray([-40.        ,   4.44444444])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.F2C.html
scipy constants F2C	R	scipy.constants.F2C										
scipy constants.F2C	R	scipy.constants.F2C										
scipy.constants.F2K	A										<section class="prog__container"><p>F2K is deprecated!\nscipy.constants.F2K is deprecated in scipy 0.18.0. Use scipy.constants.convert_teperature instead. Note that the new function has a different signature.</p><pre><code>scipy.constants.F2K(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : array_like\n    Fahrenheit temperature(s) to be converted.</code></pre><span class="prog__sub">Returns:</span><pre><code>K : float or array of floats\n    Equivalent Kelvin temperature(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import F2K\n>>> F2K(np.array([-40, 104]))\narray([ 233.15,  313.15])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.F2K.html
scipy constants F2K	R	scipy.constants.F2K										
scipy constants.F2K	R	scipy.constants.F2K										
scipy.constants.find	A										<section class="prog__container"><p>Return list of physical_constant keys containing a given string.</p><pre><code>scipy.constants.find(sub=None, disp=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sub : str, unicode\n    Sub-string to search keys for.  By default, return all keys. \ndisp : bool\n    If True, print the keys that are found, and return None. Otherwise, return the list of keys without printing anything.</code></pre><span class="prog__sub">Returns:</span><pre><code>keys : list or None\n    If disp is False, the list of keys is returned. Otherwise, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.find.html
scipy constants find	R	scipy.constants.find										
scipy constants.find	R	scipy.constants.find										
scipy.constants.K2C	A										<section class="prog__container"><p>K2C is deprecated!\nscipy.constants.K2C is deprecated in scipy 0.18.0. Use scipy.constants.convert_teperature instead. Note that the new function has a different signature.</p><pre><code>scipy.constants.K2C(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>K : array_like\n    Kelvin temperature(s) to be converted.</code></pre><span class="prog__sub">Returns:</span><pre><code>C : float or array of floats\n    Equivalent Celsius temperature(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import K2C\n>>> K2C(np.array([233.15, 313.15]))\narray([-40.,  40.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.K2C.html
scipy constants K2C	R	scipy.constants.K2C										
scipy constants.K2C	R	scipy.constants.K2C										
scipy.constants.K2F	A										<section class="prog__container"><p>K2F is deprecated!\nscipy.constants.K2F is deprecated in scipy 0.18.0. Use scipy.constants.convert_teperature instead. Note that the new function has a different signature.</p><pre><code>scipy.constants.K2F(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>K : array_like\n    Kelvin temperature(s) to be converted.</code></pre><span class="prog__sub">Returns:</span><pre><code>F : float or array of floats\n    Equivalent Fahrenheit temperature(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import K2F\n>>> K2F(np.array([233.15,  313.15]))\narray([ -40.,  104.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.K2F.html
scipy constants K2F	R	scipy.constants.K2F										
scipy constants.K2F	R	scipy.constants.K2F										
scipy.constants.lambda2nu	A										<section class="prog__container"><p>Convert wavelength to optical frequency</p><pre><code>scipy.constants.lambda2nu(lambda_)</code></pre><span class="prog__sub">Parameters:</span><pre><code>lambda_ : array_like\n    Wavelength(s) to be converted.</code></pre><span class="prog__sub">Returns:</span><pre><code>nu : float or array of floats\n    Equivalent optical frequency.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import lambda2nu, speed_of_light\n>>> lambda2nu(np.array((1, speed_of_light)))\narray([  2.99792458e+08,   1.00000000e+00])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.lambda2nu.html
scipy constants lambda2nu	R	scipy.constants.lambda2nu										
scipy constants.lambda2nu	R	scipy.constants.lambda2nu										
scipy.constants.nu2lambda	A										<section class="prog__container"><p>Convert optical frequency to wavelength.</p><pre><code>scipy.constants.nu2lambda(nu)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : array_like\n    Optical frequency to be converted.</code></pre><span class="prog__sub">Returns:</span><pre><code>lambda : float or array of floats\n    Equivalent wavelength(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.constants import nu2lambda, speed_of_light\n>>> nu2lambda(np.array((1, speed_of_light)))\narray([  2.99792458e+08,   1.00000000e+00])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.nu2lambda.html
scipy constants nu2lambda	R	scipy.constants.nu2lambda										
scipy constants.nu2lambda	R	scipy.constants.nu2lambda										
scipy.constants.precision	A										<section class="prog__container"><p>Relative precision in physical_constants indexed by key</p><pre><code>scipy.constants.precision(key)</code></pre><span class="prog__sub">Parameters:</span><pre><code>key : Python string or unicode\n    Key in dictionary physical_constants</code></pre><span class="prog__sub">Returns:</span><pre><code>prec : float\n    Relative precision in physical_constants corresponding to key</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import constants\n>>> constants.precision(u'proton mass')\n1.2555138746605121e-08</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.precision.html
scipy constants precision	R	scipy.constants.precision										
scipy constants.precision	R	scipy.constants.precision										
scipy.constants.unit	A										<section class="prog__container"><p>Unit in physical_constants indexed by key</p><pre><code>scipy.constants.unit(key)</code></pre><span class="prog__sub">Parameters:</span><pre><code>key : Python string or unicode\n    Key in dictionary physical_constants</code></pre><span class="prog__sub">Returns:</span><pre><code>unit : Python string\n    Unit in physical_constants corresponding to key</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import constants\n>>> constants.unit(u'proton mass')\n'kg'</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.unit.html
scipy constants unit	R	scipy.constants.unit										
scipy constants.unit	R	scipy.constants.unit										
scipy.constants.value	A										<section class="prog__container"><p>Value in physical_constants indexed by key</p><pre><code>scipy.constants.value(key)</code></pre><span class="prog__sub">Parameters:</span><pre><code>key : Python string or unicode\n    Key in dictionary physical_constants</code></pre><span class="prog__sub">Returns:</span><pre><code>value : float\n    Value in physical_constants corresponding to key</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import constants\n>>> constants.value(u'elementary charge')\n    1.6021766208e-19</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.constants.value.html
scipy constants value	R	scipy.constants.value										
scipy constants.value	R	scipy.constants.value										
scipy.fftpack.cc_diff	A										<section class="prog__container"><p>Return (a,b)-cosh/cosh pseudo-derivative of a periodic sequence.</p><pre><code>scipy.fftpack.cc_diff(x, a, b, period=None, _cache={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array to take the pseudo-derivative from. \na,b : float\n    Defines the parameters of the sinh/sinh pseudo-differential operator. \nperiod : float, optional\n    The period of the sequence x. Default is 2*pi.</code></pre><span class="prog__sub">Returns:</span><pre><code>cc_diff : ndarray\n    Pseudo-derivative of periodic sequence x.</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = cosh(j*a*2*pi/period)/cosh(j*b*2*pi/period) * x_j</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.cc_diff.html
scipy fftpack cc_diff	R	scipy.fftpack.cc_diff										
scipy fftpack.cc_diff	R	scipy.fftpack.cc_diff										
scipy.fftpack.convolve.convolve	A										<section class="prog__container"><p>Wrapper for convolve.</p><pre><code>scipy.fftpack.convolve.convolve(x, omega[, swap_real_imag, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (n)\nomega : input rank-1 array(‘d’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘d’) with bounds (n) and x storage</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.convolve.convolve.html
scipy fftpack convolve convolve	R	scipy.fftpack.convolve.convolve										
scipy fftpack.convolve.convolve	R	scipy.fftpack.convolve.convolve										
scipy.fftpack.convolve.convolve_z	A										<section class="prog__container"><p>Wrapper for convolve_z.</p><pre><code>scipy.fftpack.convolve.convolve_z(x, omega_real, omega_imag[, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (n)\nomega_real : input rank-1 array(‘d’) with bounds (n)\nomega_imag : input rank-1 array(‘d’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘d’) with bounds (n) and x storage</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.convolve.convolve_z.html
scipy fftpack convolve convolve_z	R	scipy.fftpack.convolve.convolve_z										
scipy fftpack.convolve.convolve_z	R	scipy.fftpack.convolve.convolve_z										
scipy.fftpack.convolve.destroy_convolve_cache	A										<section class="prog__container"><p>Wrapper for destroy_convolve_cache.</p><pre><code>scipy.fftpack.convolve.destroy_convolve_cache = <fortran object></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.convolve.destroy_convolve_cache.html
scipy fftpack convolve destroy_convolve_cache	R	scipy.fftpack.convolve.destroy_convolve_cache										
scipy fftpack.convolve.destroy_convolve_cache	R	scipy.fftpack.convolve.destroy_convolve_cache										
scipy.fftpack.convolve.init_convolution_kernel	A										<section class="prog__container"><p>Wrapper for init_convolution_kernel.</p><pre><code>scipy.fftpack.convolve.init_convolution_kernel(n, kernel_func[, d, zero_nyquist, kernel_func_extra_args]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int\nkernel_func : call-back function</code></pre><span class="prog__sub">Returns:</span><pre><code>omega : rank-1 array(‘d’) with bounds (n)</code></pre><span class="prog__sub">Examples:</span><pre><code>def kernel_func(k): return kernel_func\nRequired arguments:\n  k : input int\nReturn objects:\n  kernel_func : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.convolve.init_convolution_kernel.html
scipy fftpack convolve init_convolution_kernel	R	scipy.fftpack.convolve.init_convolution_kernel										
scipy fftpack.convolve.init_convolution_kernel	R	scipy.fftpack.convolve.init_convolution_kernel										
scipy.fftpack.cs_diff	A										<section class="prog__container"><p>Return (a,b)-cosh/sinh pseudo-derivative of a periodic sequence.</p><pre><code>scipy.fftpack.cs_diff(x, a, b, period=None, _cache={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array to take the pseudo-derivative from. \na, b : float\n    Defines the parameters of the cosh/sinh pseudo-differential operator. \nperiod : float, optional\n    The period of the sequence. Default period is 2*pi.</code></pre><span class="prog__sub">Returns:</span><pre><code>cs_diff : ndarray\n    Pseudo-derivative of periodic sequence x.</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = -sqrt(-1)*cosh(j*a*2*pi/period)/sinh(j*b*2*pi/period) * x_j\ny_0 = 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.cs_diff.html
scipy fftpack cs_diff	R	scipy.fftpack.cs_diff										
scipy fftpack.cs_diff	R	scipy.fftpack.cs_diff										
scipy.fftpack.dct	A										<section class="prog__container"><p>Return the Discrete Cosine Transform of arbitrary type sequence x.</p><pre><code>scipy.fftpack.dct(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array. \ntype : {1, 2, 3}, optional\n    Type of the DCT (see Notes). Default type is 2. \nn : int, optional\n    Length of the transform.  If n < x.shape[axis], x is truncated.  If n > x.shape[axis], x is zero-padded. The default results in n = x.shape[axis]. \naxis : int, optional\n    Axis along which the dct is computed; the default is over the last axis (i.e., axis=-1). \nnorm : {None, ‘ortho’}, optional\n    Normalization mode (see Notes). Default is None. \noverwrite_x : bool, optional\n    If True, the contents of x can be destroyed; the default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray of real\n    The transformed input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>N-2\ny[k] = x[0] + (-1)**k x[N-1] + 2 * sum x[n]*cos(pi*k*n/(N-1))\n                                   n=1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.dct.html
scipy fftpack dct	R	scipy.fftpack.dct										
scipy fftpack.dct	R	scipy.fftpack.dct										
scipy.fftpack.diff	A										<section class="prog__container"><p>Return k-th derivative (or integral) of a periodic sequence x.</p><pre><code>scipy.fftpack.diff(x, order=1, period=None, _cache={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \norder : int, optional\n    The order of differentiation. Default order is 1. If order is negative, then integration is carried out under the assumption that x_0 == 0. \nperiod : float, optional\n    The assumed period of the sequence. Default is 2*pi.</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = pow(sqrt(-1)*j*2*pi/period, order) * x_j\ny_0 = 0 if order is not 0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.diff.html
scipy fftpack diff	R	scipy.fftpack.diff										
scipy fftpack.diff	R	scipy.fftpack.diff										
scipy.fftpack.dst	A										<section class="prog__container"><p>Return the Discrete Sine Transform of arbitrary type sequence x.</p><pre><code>scipy.fftpack.dst(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array. \ntype : {1, 2, 3}, optional\n    Type of the DST (see Notes). Default type is 2. \nn : int, optional\n    Length of the transform.  If n < x.shape[axis], x is truncated.  If n > x.shape[axis], x is zero-padded. The default results in n = x.shape[axis]. \naxis : int, optional\n    Axis along which the dst is computed; the default is over the last axis (i.e., axis=-1). \nnorm : {None, ‘ortho’}, optional\n    Normalization mode (see Notes). Default is None. \noverwrite_x : bool, optional\n    If True, the contents of x can be destroyed; the default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>dst : ndarray of reals\n    The transformed input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>N-1\ny[k] = 2 * sum x[n]*sin(pi*(k+1)*(n+1)/(N+1))\n           n=0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.dst.html
scipy fftpack dst	R	scipy.fftpack.dst										
scipy fftpack.dst	R	scipy.fftpack.dst										
scipy.fftpack.fft2	A										<section class="prog__container"><p>2-D discrete Fourier transform.</p><pre><code>scipy.fftpack.fft2(x, shape=None, axes=(-2, -1), overwrite_x=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.fft2.html
scipy fftpack fft2	R	scipy.fftpack.fft2										
scipy fftpack.fft2	R	scipy.fftpack.fft2										
scipy.fftpack.fft	A										<section class="prog__container"><p>Return discrete Fourier transform of real or complex sequence.</p><pre><code>scipy.fftpack.fft(x, n=None, axis=-1, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array to Fourier transform. \nn : int, optional\n    Length of the Fourier transform.  If n < x.shape[axis], x is truncated.  If n > x.shape[axis], x is zero-padded. The default results in n = x.shape[axis]. \naxis : int, optional\n    Axis along which the fft’s are computed; the default is over the last axis (i.e., axis=-1). \noverwrite_x : bool, optional\n    If True, the contents of x can be destroyed; the default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : complex ndarray\n    with the elements: [y(0),y(1),..,y(n/2),y(1-n/2),...,y(-1)]        if n is even [y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is odd   where: y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k* 2*pi/n), j = 0..n-1   Note that y(-j) = y(n-j).conjugate().</code></pre><span class="prog__sub">Examples:</span><pre><code>[y(0),y(1),..,y(n/2),y(1-n/2),...,y(-1)]        if n is even\n[y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is odd</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.fft.html
scipy.fftpack.fftfreq	A										<section class="prog__container"><p>Return the Discrete Fourier Transform sample frequencies.</p><pre><code>scipy.fftpack.fftfreq(n, d=1.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Window length. \nd : scalar, optional\n    Sample spacing (inverse of the sampling rate). Defaults to 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of length n containing the sample frequencies.</code></pre><span class="prog__sub">Examples:</span><pre><code>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even\nf = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.fftfreq.html
scipy fftpack fftfreq	R	scipy.fftpack.fftfreq										
scipy fftpack.fftfreq	R	scipy.fftpack.fftfreq										
scipy.fftpack.fftn	A					[[scipy.fftpack.ifftn]]					<section class="prog__container"><p>Return multidimensional discrete Fourier transform.</p><pre><code>scipy.fftpack.fftn(x, shape=None, axes=None, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The (n-dimensional) array to transform. \nshape : tuple of ints, optional\n    The shape of the result.  If both shape and axes (see below) are None, shape is x.shape; if shape is None but axes is not None, then shape is scipy.take(x.shape, axes, axis=0). If shape[i] > x.shape[i], the i-th dimension is padded with zeros. If shape[i] < x.shape[i], the i-th dimension is truncated to length shape[i]. \naxes : array_like of ints, optional\n    The axes of x (y if shape is not None) along which the transform is applied. \noverwrite_x : bool, optional\n    If True, the contents of x can be destroyed.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : complex-valued n-dimensional numpy array\n    The (n-dimensional) DFT of the input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>y[j_1,..,j_d] = sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]\n   x[k_1,..,k_d] * prod[i=1..d] exp(-sqrt(-1)*2*pi/n_i * j_i * k_i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.fftn.html
scipy fftpack fftn	R	scipy.fftpack.fftn										
scipy fftpack.fftn	R	scipy.fftpack.fftn										
scipy fftpack fft	R	scipy.fftpack.fft										
scipy fftpack.fft	R	scipy.fftpack.fft										
scipy.fftpack.fftshift	A										<section class="prog__container"><p>Shift the zero-frequency component to the center of the spectrum.</p><pre><code>scipy.fftpack.fftshift(x, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \naxes : int or shape tuple, optional\n    Axes over which to shift.  Default is None, which shifts all axes.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The shifted array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> freqs = np.fft.fftfreq(10, 0.1)\n>>> freqs\narray([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])\n>>> np.fft.fftshift(freqs)\narray([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.fftshift.html
scipy fftpack fftshift	R	scipy.fftpack.fftshift										
scipy fftpack.fftshift	R	scipy.fftpack.fftshift										
scipy.fftpack.hilbert	A										<section class="prog__container"><p>Return Hilbert transform of a periodic sequence x.</p><pre><code>scipy.fftpack.hilbert(x, _cache={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array, should be periodic. \n_cache : dict, optional\n    Dictionary that contains the kernel used to do a convolution with.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The transformed input.</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = sqrt(-1)*sign(j) * x_j\ny_0 = 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.hilbert.html
scipy fftpack hilbert	R	scipy.fftpack.hilbert										
scipy fftpack.hilbert	R	scipy.fftpack.hilbert										
scipy.fftpack.idct	A										<section class="prog__container"><p>Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.</p><pre><code>scipy.fftpack.idct(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array. \ntype : {1, 2, 3}, optional\n    Type of the DCT (see Notes). Default type is 2. \nn : int, optional\n    Length of the transform.  If n < x.shape[axis], x is truncated.  If n > x.shape[axis], x is zero-padded. The default results in n = x.shape[axis]. \naxis : int, optional\n    Axis along which the idct is computed; the default is over the last axis (i.e., axis=-1). \nnorm : {None, ‘ortho’}, optional\n    Normalization mode (see Notes). Default is None. \noverwrite_x : bool, optional\n    If True, the contents of x can be destroyed; the default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>idct : ndarray of real\n    The transformed input array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.fftpack import ifft, idct\n>>> ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real\narray([  4.,   3.,   5.,  10.,   5.,   3.])\n>>> idct(np.array([ 30.,  -8.,   6.,  -2.]), 1) / 6\narray([  4.,   3.,   5.,  10.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.idct.html
scipy fftpack idct	R	scipy.fftpack.idct										
scipy fftpack.idct	R	scipy.fftpack.idct										
scipy.fftpack.idst	A										<section class="prog__container"><p>Return the Inverse Discrete Sine Transform of an arbitrary type sequence.</p><pre><code>scipy.fftpack.idst(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array. \ntype : {1, 2, 3}, optional\n    Type of the DST (see Notes). Default type is 2. \nn : int, optional\n    Length of the transform.  If n < x.shape[axis], x is truncated.  If n > x.shape[axis], x is zero-padded. The default results in n = x.shape[axis]. \naxis : int, optional\n    Axis along which the idst is computed; the default is over the last axis (i.e., axis=-1). \nnorm : {None, ‘ortho’}, optional\n    Normalization mode (see Notes). Default is None. \noverwrite_x : bool, optional\n    If True, the contents of x can be destroyed; the default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>idst : ndarray of real\n    The transformed input array.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.idst.html
scipy fftpack idst	R	scipy.fftpack.idst										
scipy fftpack.idst	R	scipy.fftpack.idst										
scipy.fftpack.ifft2	A					[[scipy.fftpack.fft2]]\\n[[scipy.fftpack.ifft]]					<section class="prog__container"><p>2-D discrete inverse Fourier transform of real or complex sequence.</p><pre><code>scipy.fftpack.ifft2(x, shape=None, axes=(-2, -1), overwrite_x=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.ifft2.html
scipy fftpack ifft2	R	scipy.fftpack.ifft2										
scipy fftpack.ifft2	R	scipy.fftpack.ifft2										
scipy.fftpack.ifft	A										<section class="prog__container"><p>Return discrete inverse Fourier transform of real or complex sequence.</p><pre><code>scipy.fftpack.ifft(x, n=None, axis=-1, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Transformed data to invert. \nn : int, optional\n    Length of the inverse Fourier transform.  If n < x.shape[axis], x is truncated.  If n > x.shape[axis], x is zero-padded. The default results in n = x.shape[axis]. \naxis : int, optional\n    Axis along which the ifft’s are computed; the default is over the last axis (i.e., axis=-1). \noverwrite_x : bool, optional\n    If True, the contents of x can be destroyed; the default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>ifft : ndarray of floats\n    The inverse discrete Fourier transform.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.ifft.html
scipy.fftpack.ifftn	A										<section class="prog__container"><p>Return inverse multi-dimensional discrete Fourier transform of\narbitrary type sequence x.</p><pre><code>scipy.fftpack.ifftn(x, shape=None, axes=None, overwrite_x=False)</code></pre><span class="prog__sub">Examples:</span><pre><code>y[j_1,..,j_d] = 1/p * sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]\n   x[k_1,..,k_d] * prod[i=1..d] exp(sqrt(-1)*2*pi/n_i * j_i * k_i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.ifftn.html
scipy fftpack ifftn	R	scipy.fftpack.ifftn										
scipy fftpack.ifftn	R	scipy.fftpack.ifftn										
scipy fftpack ifft	R	scipy.fftpack.ifft										
scipy fftpack.ifft	R	scipy.fftpack.ifft										
scipy.fftpack.ifftshift	A										<section class="prog__container"><p>The inverse of fftshift. Although identical for even-length x, the\nfunctions differ by one sample for odd-length x.</p><pre><code>scipy.fftpack.ifftshift(x, axes=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \naxes : int or shape tuple, optional\n    Axes over which to calculate.  Defaults to None, which shifts all axes.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The shifted array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n>>> freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n>>> np.fft.ifftshift(np.fft.fftshift(freqs))\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.ifftshift.html
scipy fftpack ifftshift	R	scipy.fftpack.ifftshift										
scipy fftpack.ifftshift	R	scipy.fftpack.ifftshift										
scipy.fftpack.ihilbert	A										<section class="prog__container"><p>Return inverse Hilbert transform of a periodic sequence x.</p><pre><code>scipy.fftpack.ihilbert(x)</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = -sqrt(-1)*sign(j) * x_j\ny_0 = 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.ihilbert.html
scipy fftpack ihilbert	R	scipy.fftpack.ihilbert										
scipy fftpack.ihilbert	R	scipy.fftpack.ihilbert										
scipy.fftpack.irfft	A					[[scipy.fftpack.rfft]]\\n[[scipy.fftpack.ifft]]					<section class="prog__container"><p>Return inverse discrete Fourier transform of real sequence x.</p><pre><code>scipy.fftpack.irfft(x, n=None, axis=-1, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Transformed data to invert. \nn : int, optional\n    Length of the inverse Fourier transform. If n < x.shape[axis], x is truncated. If n > x.shape[axis], x is zero-padded. The default results in n = x.shape[axis]. \naxis : int, optional\n    Axis along which the ifft’s are computed; the default is over the last axis (i.e., axis=-1). \noverwrite_x : bool, optional\n    If True, the contents of x can be destroyed; the default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>irfft : ndarray of floats\n    The inverse discrete Fourier transform.</code></pre><span class="prog__sub">Examples:</span><pre><code>[y(0),y(1),...,y(n-1)]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.irfft.html
scipy fftpack irfft	R	scipy.fftpack.irfft										
scipy fftpack.irfft	R	scipy.fftpack.irfft										
scipy.fftpack.itilbert	A										<section class="prog__container"><p>Return inverse h-Tilbert transform of a periodic sequence x.</p><pre><code>scipy.fftpack.itilbert(x, h, period=None, _cache={})</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = -sqrt(-1)*tanh(j*h*2*pi/period) * x_j\ny_0 = 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.itilbert.html
scipy fftpack itilbert	R	scipy.fftpack.itilbert										
scipy fftpack.itilbert	R	scipy.fftpack.itilbert										
scipy.fftpack.rfft	A					[[scipy.fftpack.fft]]\\n[[scipy.fftpack.irfft]]					<section class="prog__container"><p>Discrete Fourier transform of a real sequence.</p><pre><code>scipy.fftpack.rfft(x, n=None, axis=-1, overwrite_x=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, real-valued\n    The data to transform. \nn : int, optional\n    Defines the length of the Fourier transform.  If n is not specified (the default) then n = x.shape[axis].  If n < x.shape[axis], x is truncated, if n > x.shape[axis], x is zero-padded. \naxis : int, optional\n    The axis along which the transform is applied.  The default is the last axis. \noverwrite_x : bool, optional\n    If set to true, the contents of x can be overwritten. Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : real ndarray\n    The returned real array contains: [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2))]              if n is even [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2)),Im(y(n/2))]   if n is odd   where: y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k*2*pi/n) j = 0..n-1   Note that y(-j) == y(n-j).conjugate().</code></pre><span class="prog__sub">Examples:</span><pre><code>[y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2))]              if n is even\n[y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2)),Im(y(n/2))]   if n is odd</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfft.html
scipy.fftpack.rfftfreq	A										<section class="prog__container"><p>DFT sample frequencies (for usage with rfft, irfft).</p><pre><code>scipy.fftpack.rfftfreq(n, d=1.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Window length. \nd : scalar, optional\n    Sample spacing. Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The array of length n, containing the sample frequencies.</code></pre><span class="prog__sub">Examples:</span><pre><code>f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2]/(d*n)   if n is even\nf = [0,1,1,2,2,...,n/2-1,n/2-1,n/2,n/2]/(d*n)   if n is odd</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html
scipy fftpack rfftfreq	R	scipy.fftpack.rfftfreq										
scipy fftpack.rfftfreq	R	scipy.fftpack.rfftfreq										
scipy fftpack rfft	R	scipy.fftpack.rfft										
scipy fftpack.rfft	R	scipy.fftpack.rfft										
scipy.fftpack.sc_diff	A										<section class="prog__container"><p>Return (a,b)-sinh/cosh pseudo-derivative of a periodic sequence x.</p><pre><code>scipy.fftpack.sc_diff(x, a, b, period=None, _cache={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \na,b : float\n    Defines the parameters of the sinh/cosh pseudo-differential operator. \nperiod : float, optional\n    The period of the sequence x. Default is 2*pi.</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = sqrt(-1)*sinh(j*a*2*pi/period)/cosh(j*b*2*pi/period) * x_j\ny_0 = 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.sc_diff.html
scipy fftpack sc_diff	R	scipy.fftpack.sc_diff										
scipy fftpack.sc_diff	R	scipy.fftpack.sc_diff										
scipy.fftpack.shift	A										<section class="prog__container"><p>Shift periodic sequence x by a: y(u) = x(u+a).</p><pre><code>scipy.fftpack.shift(x, a, period=None, _cache={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array to take the pseudo-derivative from. \na : float\n    Defines the parameters of the sinh/sinh pseudo-differential \nperiod : float, optional\n    The period of the sequences x and y. Default period is 2*pi.</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = exp(j*a*2*pi/period*sqrt(-1)) * x_f</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.shift.html
scipy fftpack shift	R	scipy.fftpack.shift										
scipy fftpack.shift	R	scipy.fftpack.shift										
scipy.fftpack.ss_diff	A										<section class="prog__container"><p>Return (a,b)-sinh/sinh pseudo-derivative of a periodic sequence x.</p><pre><code>scipy.fftpack.ss_diff(x, a, b, period=None, _cache={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The array to take the pseudo-derivative from. \na,b\n    Defines the parameters of the sinh/sinh pseudo-differential operator. \nperiod : float, optional\n    The period of the sequence x. Default is 2*pi.</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = sinh(j*a*2*pi/period)/sinh(j*b*2*pi/period) * x_j\ny_0 = a/b * x_0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.ss_diff.html
scipy fftpack ss_diff	R	scipy.fftpack.ss_diff										
scipy fftpack.ss_diff	R	scipy.fftpack.ss_diff										
scipy.fftpack.tilbert	A										<section class="prog__container"><p>Return h-Tilbert transform of a periodic sequence x.</p><pre><code>scipy.fftpack.tilbert(x, h, period=None, _cache={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The input array to transform. \nh : float\n    Defines the parameter of the Tilbert transform. \nperiod : float, optional\n    The assumed period of the sequence.  Default period is 2*pi.</code></pre><span class="prog__sub">Returns:</span><pre><code>tilbert : ndarray\n    The result of the transform.</code></pre><span class="prog__sub">Examples:</span><pre><code>y_j = sqrt(-1)*coth(j*h*2*pi/period) * x_j\ny_0 = 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.tilbert.html
scipy fftpack tilbert	R	scipy.fftpack.tilbert										
scipy fftpack.tilbert	R	scipy.fftpack.tilbert										
scipy.integrate.complex_ode	A										<section class="prog__container"><p>A wrapper of ode for complex systems.</p><pre><code>class scipy.integrate.complex_ode(f, jac=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : callable f(t, y, *f_args)\n    Rhs of the equation. t is a scalar, y.shape == (n,). f_args is set by calling set_f_params(*args). \njac : callable jac(t, y, *jac_args)\n    Jacobian of the rhs, jac[i,j] = d f[i] / d y[j]. jac_args is set by calling set_f_params(*args).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.complex_ode.html
scipy.integrate.complex_ode.integrate	A										<section class="prog__container"><p>Find y=y(t), set y as an initial condition, and return y.</p><pre><code>complex_ode.integrate(t, step=0, relax=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.complex_ode.integrate.html
scipy integrate complex_ode integrate	R	scipy.integrate.complex_ode.integrate										
scipy integrate.complex_ode.integrate	R	scipy.integrate.complex_ode.integrate										
scipy integrate complex_ode	R	scipy.integrate.complex_ode										
scipy integrate.complex_ode	R	scipy.integrate.complex_ode										
scipy.integrate.complex_ode.set_f_params	A										<section class="prog__container"><p>Set extra parameters for user-supplied function f.</p><pre><code>complex_ode.set_f_params(*args)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.complex_ode.set_f_params.html
scipy integrate complex_ode set_f_params	R	scipy.integrate.complex_ode.set_f_params										
scipy integrate.complex_ode.set_f_params	R	scipy.integrate.complex_ode.set_f_params										
scipy.integrate.complex_ode.set_initial_value	A										<section class="prog__container"><p>Set initial conditions y(t) = y.</p><pre><code>complex_ode.set_initial_value(y, t=0.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.complex_ode.set_initial_value.html
scipy integrate complex_ode set_initial_value	R	scipy.integrate.complex_ode.set_initial_value										
scipy integrate.complex_ode.set_initial_value	R	scipy.integrate.complex_ode.set_initial_value										
scipy.integrate.complex_ode.set_integrator	A										<section class="prog__container"><p>Set integrator by name.</p><pre><code>complex_ode.set_integrator(name, **integrator_params)</code></pre><span class="prog__sub">Parameters:</span><pre><code>name : str\n    Name of the integrator \nintegrator_params\n    Additional parameters for the integrator.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.complex_ode.set_integrator.html
scipy integrate complex_ode set_integrator	R	scipy.integrate.complex_ode.set_integrator										
scipy integrate.complex_ode.set_integrator	R	scipy.integrate.complex_ode.set_integrator										
scipy.integrate.complex_ode.set_jac_params	A										<section class="prog__container"><p>Set extra parameters for user-supplied function jac.</p><pre><code>complex_ode.set_jac_params(*args)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.complex_ode.set_jac_params.html
scipy integrate complex_ode set_jac_params	R	scipy.integrate.complex_ode.set_jac_params										
scipy integrate.complex_ode.set_jac_params	R	scipy.integrate.complex_ode.set_jac_params										
scipy.integrate.complex_ode.set_solout	A										<section class="prog__container"><p>Set callable to be called at every successful integration step.</p><pre><code>complex_ode.set_solout(solout)</code></pre><span class="prog__sub">Parameters:</span><pre><code>solout : callable\n    solout(t, y) is called at each internal integrator step, t is a scalar providing the current independent position y is the current soloution y.shape == (n,) solout should return -1 to stop integration otherwise it should return None or 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.complex_ode.set_solout.html
scipy integrate complex_ode set_solout	R	scipy.integrate.complex_ode.set_solout										
scipy integrate.complex_ode.set_solout	R	scipy.integrate.complex_ode.set_solout										
scipy.integrate.complex_ode.successful	A										<section class="prog__container"><p>Check if integration was successful.</p><pre><code>complex_ode.successful()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.complex_ode.successful.html
scipy integrate complex_ode successful	R	scipy.integrate.complex_ode.successful										
scipy integrate.complex_ode.successful	R	scipy.integrate.complex_ode.successful										
scipy.integrate.cumtrapz	A										<section class="prog__container"><p>Cumulatively integrate y(x) using the composite trapezoidal rule.</p><pre><code>scipy.integrate.cumtrapz(y, x=None, dx=1.0, axis=-1, initial=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Values to integrate. \nx : array_like, optional\n    The coordinate to integrate along.  If None (default), use spacing dx between consecutive elements in y. \ndx : int, optional\n    Spacing between elements of y.  Only used if x is None. \naxis : int, optional\n    Specifies the axis to cumulate.  Default is -1 (last axis). \ninitial : scalar, optional\n    If given, uses this value as the first value in the returned result. Typically this value should be 0.  Default is None, which means no value at x[0] is returned and res has one element less than y along the axis of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    The result of cumulative integration of y along axis. If initial is None, the shape is such that the axis of integration has one less value than y.  If initial is given, the shape is equal to that of y.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import integrate\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.cumtrapz.html
scipy integrate cumtrapz	R	scipy.integrate.cumtrapz										
scipy integrate.cumtrapz	R	scipy.integrate.cumtrapz										
scipy.integrate.dblquad	A										<section class="prog__container"><p>Compute a double integral.</p><pre><code>scipy.integrate.dblquad(func, a, b, gfun, hfun, args=(), epsabs=1.49e-08, epsrel=1.49e-08)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable\n    A Python function or method of at least two variables: y must be the first argument and x the second argument. \na, b : float\n    The limits of integration in x: a < b \ngfun : callable\n    The lower boundary curve in y which is a function taking a single floating point argument (x) and returning a floating point result: a lambda function can be useful here. \nhfun : callable\n    The upper boundary curve in y (same requirements as gfun). \nargs : sequence, optional\n    Extra arguments to pass to func. \nepsabs : float, optional\n    Absolute tolerance passed directly to the inner 1-D quadrature integration. Default is 1.49e-8. \nepsrel : float, optional\n    Relative tolerance of the inner 1-D integrals. Default is 1.49e-8.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : float\n    The resultant integral. \nabserr : float\n    An estimate of the error.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.dblquad.html
scipy integrate dblquad	R	scipy.integrate.dblquad										
scipy integrate.dblquad	R	scipy.integrate.dblquad										
scipy.integrate.fixed_quad	A										<section class="prog__container"><p>Compute a definite integral using fixed-order Gaussian quadrature.</p><pre><code>scipy.integrate.fixed_quad(func, a, b, args=(), n=5)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable\n    A Python function or method to integrate (must accept vector inputs). \na : float\n    Lower limit of integration. \nb : float\n    Upper limit of integration. \nargs : tuple, optional\n    Extra arguments to pass to function, if any. \nn : int, optional\n    Order of quadrature integration. Default is 5.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : float\n    Gaussian quadrature approximation to the integral \nnone : None\n    Statically returned value of None</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.fixed_quad.html
scipy integrate fixed_quad	R	scipy.integrate.fixed_quad										
scipy integrate.fixed_quad	R	scipy.integrate.fixed_quad										
scipy.integrate.IntegrationWarning	A										<section class="prog__container"><p>Warning on issues during integration.</p><pre><code>exception scipy.integrate.IntegrationWarning</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.IntegrationWarning.html
scipy integrate IntegrationWarning	R	scipy.integrate.IntegrationWarning										
scipy integrate.IntegrationWarning	R	scipy.integrate.IntegrationWarning										
scipy.integrate.newton_cotes	A										<section class="prog__container"><p>Return weights and error coefficient for Newton-Cotes integration.</p><pre><code>scipy.integrate.newton_cotes(rn, equal=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rn : int\n    The integer order for equally-spaced data or the relative positions of the samples with the first sample at 0 and the last at N, where N+1 is the length of rn.  N is the order of the Newton-Cotes integration. \nequal : int, optional\n    Set to 1 to enforce equally spaced data.</code></pre><span class="prog__sub">Returns:</span><pre><code>an : ndarray\n    1-D array of weights to apply to the function at the provided sample positions. \nB : float\n    Error coefficient.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.newton_cotes.html
scipy integrate newton_cotes	R	scipy.integrate.newton_cotes										
scipy integrate.newton_cotes	R	scipy.integrate.newton_cotes										
scipy.integrate.nquad	A										<section class="prog__container"><p>Integration over multiple variables.</p><pre><code>scipy.integrate.nquad(func, ranges, args=None, opts=None, full_output=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable\n    The function to be integrated. Has arguments of x0, ... xn, t0, tm, where integration is carried out over x0, ... xn, which must be floats.  Function signature should be func(x0, x1, ..., xn, t0, t1, ..., tm).  Integration is carried out in order.  That is, integration over x0 is the innermost integral, and xn is the outermost. If performance is a concern, this function may be a ctypes function of the form: f(int n, double args[n])   where n is the number of extra parameters and args is an array of doubles of the additional parameters.  This function may then be compiled to a dynamic/shared library then imported through ctypes, setting the function’s argtypes to (c_int, c_double), and the function’s restype to (c_double).  Its pointer may then be passed into nquad normally. This allows the underlying Fortran library to evaluate the function in the innermost integration calls without callbacks to Python, and also speeds up the evaluation of the function itself. \nranges : iterable object\n    Each element of ranges may be either a sequence  of 2 numbers, or else a callable that returns such a sequence.  ranges[0] corresponds to integration over x0, and so on.  If an element of ranges is a callable, then it will be called with all of the integration arguments available, as well as any parametric arguments. e.g. if  func = f(x0, x1, x2, t0, t1), then ranges[0] may be defined as either (a, b) or else as (a, b) = range0(x1, x2, t0, t1). \nargs : iterable object, optional\n    Additional arguments t0, ..., tn, required by func, ranges, and opts. \nopts : iterable object or dict, optional\n    Options to be passed to quad.  May be empty, a dict, or a sequence of dicts or functions that return a dict.  If empty, the default options from scipy.integrate.quad are used.  If a dict, the same options are used for all levels of integraion.  If a sequence, then each element of the sequence corresponds to a particular integration. e.g. opts[0] corresponds to integration over x0, and so on. If a callable,  the signature must be the same as for ranges. The available options together with their default values are:   epsabs = 1.49e-08 epsrel = 1.49e-08 limit  = 50 points = None weight = None wvar   = None wopts  = None   For more information on these options, see quad and quad_explain. \nfull_output : bool, optional\n    Partial implementation of full_output from scipy.integrate.quad.  The number of integrand function evaluations neval can be obtained  by setting full_output=True when calling nquad.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : float\n    The result of the integration. \nabserr : float\n    The maximum of the estimates of the absolute error in the various integration results. \nout_dict : dict, optional\n    A dict containing additional information on the integration.</code></pre><span class="prog__sub">Examples:</span><pre><code>f(int n, double args[n])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.nquad.html
scipy integrate nquad	R	scipy.integrate.nquad										
scipy integrate.nquad	R	scipy.integrate.nquad										
scipy.integrate.ode	A										<section class="prog__container"><p>A generic interface class to numeric integrators.</p><pre><code>class scipy.integrate.ode(f, jac=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : callable f(t, y, *f_args)\n    Right-hand side of the differential equation. t is a scalar, y.shape == (n,). f_args is set by calling set_f_params(*args). f should return a scalar, array or list (not a tuple). \njac : callable jac(t, y, *jac_args), optional\n    Jacobian of the right-hand side, jac[i,j] = d f[i] / d y[j]. jac_args is set by calling set_jac_params(*args).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.integrate import ode\n>>>\n>>> y0, t0 = [1.0j, 2.0], 0\n>>>\n>>> def f(t, y, arg1):\n...     return [1j*arg1*y[0] + y[1], -arg1*y[1]**2]\n>>> def jac(t, y, arg1):\n...     return [[1j*arg1, 1], [0, -arg1*2*y[1]]]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html
scipy.integrate.odeint	A										<section class="prog__container"><p>Integrate a system of ordinary differential equations.</p><pre><code>scipy.integrate.odeint(func, y0, t, args=(), Dfun=None, col_deriv=0, full_output=0, ml=None, mu=None, rtol=None, atol=None, tcrit=None, h0=0.0, hmax=0.0, hmin=0.0, ixpr=0, mxstep=0, mxhnil=0, mxordn=12, mxords=5, printmessg=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable(y, t0, ...)\n    Computes the derivative of y at t0. \ny0 : array\n    Initial condition on y (can be a vector). \nt : array\n    A sequence of time points for which to solve for y.  The initial value point should be the first element of this sequence. \nargs : tuple, optional\n    Extra arguments to pass to function. \nDfun : callable(y, t0, ...)\n    Gradient (Jacobian) of func. \ncol_deriv : bool, optional\n    True if Dfun defines derivatives down columns (faster), otherwise Dfun should define derivatives across rows. \nfull_output : bool, optional\n    True if to return a dictionary of optional outputs as the second output \nprintmessg : bool, optional\n    Whether to print the convergence message</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array, shape (len(t), len(y0))\n    Array containing the value of y for each desired time in t, with the initial value y0 in the first row. \ninfodict : dict, only returned if full_output == True\n    Dictionary containing additional output information       key meaning    ‘hu’ vector of step sizes successfully used for each time step.  ‘tcur’ vector with the value of t reached for each time step. (will always be at least as large as the input times).  ‘tolsf’ vector of tolerance scale factors, greater than 1.0, computed when a request for too much accuracy was detected.  ‘tsw’ value of t at the time of the last method switch (given for each time step)  ‘nst’ cumulative number of time steps  ‘nfe’ cumulative number of function evaluations for each time step  ‘nje’ cumulative number of jacobian evaluations for each time step  ‘nqu’ a vector of method orders for each successful step.  ‘imxer’ index of the component of largest magnitude in the weighted local error vector (e / ewt) on an error return, -1 otherwise.  ‘lenrw’ the length of the double work array required.  ‘leniw’ the length of integer work array required.  ‘mused’ a vector of method indicators for each successful time step: 1: adams (nonstiff), 2: bdf (stiff)</code></pre><span class="prog__sub">Examples:</span><pre><code>dy/dt = func(y, t0, ...)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html
scipy.integrate.ode.integrate	A										<section class="prog__container"><p>Find y=y(t), set y as an initial condition, and return y.</p><pre><code>ode.integrate(t, step=0, relax=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.integrate.html
scipy integrate ode integrate	R	scipy.integrate.ode.integrate										
scipy integrate.ode.integrate	R	scipy.integrate.ode.integrate										
scipy integrate odeint	R	scipy.integrate.odeint										
scipy integrate.odeint	R	scipy.integrate.odeint										
scipy integrate ode	R	scipy.integrate.ode										
scipy integrate.ode	R	scipy.integrate.ode										
scipy.integrate.ode.set_f_params	A										<section class="prog__container"><p>Set extra parameters for user-supplied function f.</p><pre><code>ode.set_f_params(*args)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.set_f_params.html
scipy integrate ode set_f_params	R	scipy.integrate.ode.set_f_params										
scipy integrate.ode.set_f_params	R	scipy.integrate.ode.set_f_params										
scipy.integrate.ode.set_initial_value	A										<section class="prog__container"><p>Set initial conditions y(t) = y.</p><pre><code>ode.set_initial_value(y, t=0.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.set_initial_value.html
scipy integrate ode set_initial_value	R	scipy.integrate.ode.set_initial_value										
scipy integrate.ode.set_initial_value	R	scipy.integrate.ode.set_initial_value										
scipy.integrate.ode.set_integrator	A										<section class="prog__container"><p>Set integrator by name.</p><pre><code>ode.set_integrator(name, **integrator_params)</code></pre><span class="prog__sub">Parameters:</span><pre><code>name : str\n    Name of the integrator. \nintegrator_params\n    Additional parameters for the integrator.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.set_integrator.html
scipy integrate ode set_integrator	R	scipy.integrate.ode.set_integrator										
scipy integrate.ode.set_integrator	R	scipy.integrate.ode.set_integrator										
scipy.integrate.ode.set_jac_params	A										<section class="prog__container"><p>Set extra parameters for user-supplied function jac.</p><pre><code>ode.set_jac_params(*args)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.set_jac_params.html
scipy integrate ode set_jac_params	R	scipy.integrate.ode.set_jac_params										
scipy integrate.ode.set_jac_params	R	scipy.integrate.ode.set_jac_params										
scipy.integrate.ode.set_solout	A										<section class="prog__container"><p>Set callable to be called at every successful integration step.</p><pre><code>ode.set_solout(solout)</code></pre><span class="prog__sub">Parameters:</span><pre><code>solout : callable\n    solout(t, y) is called at each internal integrator step, t is a scalar providing the current independent position y is the current soloution y.shape == (n,) solout should return -1 to stop integration otherwise it should return None or 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.set_solout.html
scipy integrate ode set_solout	R	scipy.integrate.ode.set_solout										
scipy integrate.ode.set_solout	R	scipy.integrate.ode.set_solout										
scipy.integrate.ode.successful	A										<section class="prog__container"><p>Check if integration was successful.</p><pre><code>ode.successful()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.successful.html
scipy integrate ode successful	R	scipy.integrate.ode.successful										
scipy integrate.ode.successful	R	scipy.integrate.ode.successful										
scipy.integrate.quad	A										<section class="prog__container"><p>Compute a definite integral.</p><pre><code>scipy.integrate.quad(func, a, b, args=(), full_output=0, epsabs=1.49e-08, epsrel=1.49e-08, limit=50, points=None, weight=None, wvar=None, wopts=None, maxp1=50, limlst=50)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    A Python function or method to integrate.  If func takes many arguments, it is integrated along the axis corresponding to the first argument. If the user desires improved integration performance, then f may instead be a ctypes function of the form:  f(int n, double args[n]),  where args is an array of function arguments and n is the length of args. f.argtypes should be set to (c_int, c_double), and f.restype should be (c_double,). \na : float\n    Lower limit of integration (use -numpy.inf for -infinity). \nb : float\n    Upper limit of integration (use numpy.inf for +infinity). \nargs : tuple, optional\n    Extra arguments to pass to func. \nfull_output : int, optional\n    Non-zero to return a dictionary of integration information. If non-zero, warning messages are also suppressed and the message is appended to the output tuple.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : float\n    The integral of func from a to b. \nabserr : float\n    An estimate of the absolute error in the result. \ninfodict : dict\n    A dictionary containing additional information. Run scipy.integrate.quad_explain() for more information. \nmessage\n    A convergence message. \nexplain\n    Appended only with ‘cos’ or ‘sin’ weighting and infinite integration limits, it contains an explanation of the codes in infodict[‘ierlst’]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import integrate\n>>> x2 = lambda x: x**2\n>>> integrate.quad(x2, 0, 4)\n(21.333333333333332, 2.3684757858670003e-13)\n>>> print(4**3 / 3.)  # analytical result\n21.3333333333</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html
scipy.integrate.quad_explain	A										<section class="prog__container"><p>Print extra information about integrate.quad() parameters and returns.</p><pre><code>scipy.integrate.quad_explain(output=<open file '<stdout>', mode 'w' at 0x2aba830f0150>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>output : instance with “write” method, optional\n    Information about quad is passed to output.write(). Default is sys.stdout.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad_explain.html
scipy integrate quad_explain	R	scipy.integrate.quad_explain										
scipy integrate.quad_explain	R	scipy.integrate.quad_explain										
scipy.integrate.quadrature	A										<section class="prog__container"><p>Compute a definite integral using fixed-tolerance Gaussian quadrature.</p><pre><code>scipy.integrate.quadrature(func, a, b, args=(), tol=1.49e-08, rtol=1.49e-08, maxiter=50, vec_func=True, miniter=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    A Python function or method to integrate. \na : float\n    Lower limit of integration. \nb : float\n    Upper limit of integration. \nargs : tuple, optional\n    Extra arguments to pass to function. \ntol, rtol : float, optional\n    Iteration stops when error between last two iterates is less than tol OR the relative change is less than rtol. \nmaxiter : int, optional\n    Maximum order of Gaussian quadrature. \nvec_func : bool, optional\n    True or False if func handles arrays as arguments (is a “vector” function). Default is True. \nminiter : int, optional\n    Minimum order of Gaussian quadrature.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : float\n    Gaussian quadrature approximation (within tolerance) to integral. \nerr : float\n    Difference between last two estimates of the integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quadrature.html
scipy integrate quadrature	R	scipy.integrate.quadrature										
scipy integrate.quadrature	R	scipy.integrate.quadrature										
scipy integrate quad	R	scipy.integrate.quad										
scipy integrate.quad	R	scipy.integrate.quad										
scipy.integrate.romb	A										<section class="prog__container"><p>Romberg integration using samples of a function.</p><pre><code>scipy.integrate.romb(y, dx=1.0, axis=-1, show=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    A vector of 2**k + 1 equally-spaced samples of a function. \ndx : float, optional\n    The sample spacing. Default is 1. \naxis : int, optional\n    The axis along which to integrate. Default is -1 (last axis). \nshow : bool, optional\n    When y is a single 1-D array, then if this argument is True print the table showing Richardson extrapolation from the samples. Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>romb : ndarray\n    The integrated result for axis.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.romb.html
scipy.integrate.romberg	A										<section class="prog__container"><p>Romberg integration of a callable function or method.</p><pre><code>scipy.integrate.romberg(function, a, b, args=(), tol=1.48e-08, rtol=1.48e-08, show=False, divmax=10, vec_func=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>function : callable\n    Function to be integrated. \na : float\n    Lower limit of integration. \nb : float\n    Upper limit of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>results : float\n    Result of the integration.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import integrate\n>>> from scipy.special import erf\n>>> gaussian = lambda x: 1/np.sqrt(np.pi) * np.exp(-x**2)\n>>> result = integrate.romberg(gaussian, 0, 1, show=True)\nRomberg integration of <function vfunc at ...> from [0, 1]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.romberg.html
scipy integrate romberg	R	scipy.integrate.romberg										
scipy integrate.romberg	R	scipy.integrate.romberg										
scipy integrate romb	R	scipy.integrate.romb										
scipy integrate.romb	R	scipy.integrate.romb										
scipy.integrate.simps	A										<section class="prog__container"><p>Integrate y(x) using samples along the given axis and the composite\nSimpson’s rule.  If x is None, spacing of dx is assumed.</p><pre><code>scipy.integrate.simps(y, x=None, dx=1, axis=-1, even='avg')</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Array to be integrated. \nx : array_like, optional\n    If given, the points at which y is sampled. \ndx : int, optional\n    Spacing of integration points along axis of y. Only used when x is None. Default is 1. \naxis : int, optional\n    Axis along which to integrate. Default is the last axis. \neven : {‘avg’, ‘first’, ‘str’}, optional\n    ‘avg’ : Average two results:1) use the first N-2 intervals with a trapezoidal rule on the last interval and 2) use the last N-2 intervals with a trapezoidal rule on the first interval.  ‘first’ : Use Simpson’s rule for the first N-2 intervals with a trapezoidal rule on the last interval.  ‘last’ : Use Simpson’s rule for the last N-2 intervals with a trapezoidal rule on the first interval.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.simps.html
scipy integrate simps	R	scipy.integrate.simps										
scipy integrate.simps	R	scipy.integrate.simps										
scipy.integrate.solve_bvp	A										<section class="prog__container"><p>Solve a boundary-value problem for a system of ODEs.</p><pre><code>scipy.integrate.solve_bvp(fun, bc, x, y, p=None, S=None, fun_jac=None, bc_jac=None, tol=0.001, max_nodes=1000, verbose=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fun : callable\n    Right-hand side of the system. The calling signature is fun(x, y), or fun(x, y, p) if parameters are present. All arguments are ndarray: x with shape (m,), y with shape (n, m), meaning that y[:, i] corresponds to x[i], and p with shape (k,). The return value must be an array with shape (n, m) and with the same layout as y. \nbc : callable\n    Function evaluating residuals of the boundary conditions. The calling signature is bc(ya, yb), or bc(ya, yb, p) if parameters are present. All arguments are ndarray: ya and yb with shape (n,), and p with shape (k,). The return value must be an array with shape (n + k,). \nx : array_like, shape (m,)\n    Initial mesh. Must be a strictly increasing sequence of real numbers with x[0]=a and x[-1]=b. \ny : array_like, shape (n, m)\n    Initial guess for the function values at the mesh nodes, i-th column corresponds to x[i]. For problems in a complex domain pass y with a complex data type (even if the initial guess is purely real). \np : array_like with shape (k,) or None, optional\n    Initial guess for the unknown parameters. If None (default), it is assumed that the problem doesn’t depend on any parameters. \nS : array_like with shape (n, n) or None\n    Matrix defining the singular term. If None (default), the problem is solved without the singular term. \nfun_jac : callable or None, optional\n    Function computing derivatives of f with respect to y and p. The calling signature is fun_jac(x, y), or fun_jac(x, y, p) if parameters are present. The return must contain 1 or 2 elements in the following order:   df_dy : array_like with shape (n, n, m) where an element (i, j, q) equals to d f_i(x_q, y_q, p) / d (y_q)_j. df_dp : array_like with shape (n, k, m) where an element (i, j, q) equals to d f_i(x_q, y_q, p) / d p_j.   Here q numbers nodes at which x and y are defined, whereas i and j number vector components. If the problem is solved without unknown parameters df_dp should not be returned. If fun_jac is None (default), the derivatives will be estimated by the forward finite differences. \nbc_jac : callable or None, optional\n    Function computing derivatives of bc with respect to ya, yb and p. The calling signature is bc_jac(ya, yb), or bc_jac(ya, yb, p) if parameters are present. The return must contain 2 or 3 elements in the following order:   dbc_dya : array_like with shape (n, n) where an element (i, j) equals to d bc_i(ya, yb, p) / d ya_j. dbc_dyb : array_like with shape (n, n) where an element (i, j) equals to d bc_i(ya, yb, p) / d yb_j. dbc_dp : array_like with shape (n, k) where an element (i, j) equals to d bc_i(ya, yb, p) / d p_j.   If the problem is solved without unknown parameters dbc_dp should not be returned. If bc_jac is None (default), the derivatives will be estimated by the forward finite differences. \ntol : float, optional\n    Desired tolerance of the solution. If we define r = y' - f(x, y) where y is the found solution, then the solver tries to achieve on each mesh interval norm(r / (1 + abs(f)) < tol, where norm is estimated in a root mean squared sense (using a numerical quadrature formula). Default is 1e-3. \nmax_nodes : int, optional\n    Maximum allowed number of the mesh nodes. If exceeded, the algorithm terminates. Default is 1000. \nverbose : {0, 1, 2}, optional\n    Level of algorithm’s verbosity:   0 (default) : work silently. 1 : display a termination report. 2 : display progress during iterations.</code></pre><span class="prog__sub">Returns:</span><pre><code>Bunch object with the following fields defined:\nsol : PPoly\n    Found solution for y as scipy.interpolate.PPoly instance, a C1 continuous cubic spline. \np : ndarray or None, shape (k,)\n    Found parameters. None, if the parameters were not present in the problem. \nx : ndarray, shape (m,)\n    Nodes of the final mesh. \ny : ndarray, shape (n, m)\n    Solution values at the mesh nodes. \nyp : ndarray, shape (n, m)\n    Solution derivatives at the mesh nodes. \nrms_residuals : ndarray, shape (m - 1,)\n    RMS values of the relative residuals over each mesh interval (see the description of tol parameter). \nniter : int\n    Number of completed iterations. \nstatus : int\n    Reason for algorithm termination:   0: The algorithm converged to the desired accuracy. 1: The maximum number of mesh nodes is exceeded. 2: A singular Jacobian encountered when solving the collocation system.   \nmessage : string\n    Verbal description of the termination reason. \nsuccess : bool\n    True if the algorithm converged to the desired accuracy (status=0).</code></pre><span class="prog__sub">Examples:</span><pre><code>dy / dx = f(x, y, p) + S * y / (x - a), a <= x <= b\nbc(y(a), y(b), p) = 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_bvp.html
scipy integrate solve_bvp	R	scipy.integrate.solve_bvp										
scipy integrate.solve_bvp	R	scipy.integrate.solve_bvp										
scipy.integrate.tplquad	A										<section class="prog__container"><p>Compute a triple (definite) integral.</p><pre><code>scipy.integrate.tplquad(func, a, b, gfun, hfun, qfun, rfun, args=(), epsabs=1.49e-08, epsrel=1.49e-08)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    A Python function or method of at least three variables in the order (z, y, x). \na, b : float\n    The limits of integration in x: a < b \ngfun : function\n    The lower boundary curve in y which is a function taking a single floating point argument (x) and returning a floating point result: a lambda function can be useful here. \nhfun : function\n    The upper boundary curve in y (same requirements as gfun). \nqfun : function\n    The lower boundary surface in z.  It must be a function that takes two floats in the order (x, y) and returns a float. \nrfun : function\n    The upper boundary surface in z. (Same requirements as qfun.) \nargs : tuple, optional\n    Extra arguments to pass to func. \nepsabs : float, optional\n    Absolute tolerance passed directly to the innermost 1-D quadrature integration. Default is 1.49e-8. \nepsrel : float, optional\n    Relative tolerance of the innermost 1-D integrals. Default is 1.49e-8.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : float\n    The resultant integral. \nabserr : float\n    An estimate of the error.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.tplquad.html
scipy integrate tplquad	R	scipy.integrate.tplquad										
scipy integrate.tplquad	R	scipy.integrate.tplquad										
scipy.integrate.trapz	A					[[(in Python v3.7)]]					<section class="prog__container"><p>Integrate along the given axis using the composite trapezoidal rule.</p><pre><code>scipy.integrate.trapz(y, x=None, dx=1.0, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Input array to integrate. \nx : array_like, optional\n    If x is None, then spacing between all y elements is dx. \ndx : scalar, optional\n    If x is None, spacing given by dx is assumed. Default is 1. \naxis : int, optional\n    Specify the axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>trapz : float\n    Definite integral as approximated by trapezoidal rule.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.trapz([1,2,3])\n4.0\n>>> np.trapz([1,2,3], x=[4,6,8])\n8.0\n>>> np.trapz([1,2,3], dx=2)\n8.0\n>>> a = np.arange(6).reshape(2, 3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>> np.trapz(a, axis=0)\narray([ 1.5,  2.5,  3.5])\n>>> np.trapz(a, axis=1)\narray([ 2.,  8.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.trapz.html
scipy integrate trapz	R	scipy.integrate.trapz										
scipy integrate.trapz	R	scipy.integrate.trapz										
scipy.interpolate.Akima1DInterpolator.antiderivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the antiderivative.</p><pre><code>Akima1DInterpolator.antiderivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of antiderivative to evaluate. Default is 1, i.e. compute the first integral. If negative, the derivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>pp : PPoly\n    Piecewise polynomial of order k2 = k + n representing the antiderivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Akima1DInterpolator.antiderivative.html
scipy interpolate Akima1DInterpolator antiderivative	R	scipy.interpolate.Akima1DInterpolator.antiderivative										
scipy interpolate.Akima1DInterpolator.antiderivative	R	scipy.interpolate.Akima1DInterpolator.antiderivative										
scipy.interpolate.Akima1DInterpolator	A					[[scipy.interpolate.PchipInterpolator]]\\n[[scipy.interpolate.CubicSpline]]\\n[[scipy.interpolate.PPoly]]					<section class="prog__container"><p>Akima interpolator</p><pre><code>class scipy.interpolate.Akima1DInterpolator(x, y, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray, shape (m, )\n    1-D array of monotonically increasing real values. \ny : ndarray, shape (m, ...)\n    N-D array of real values. The length of y along the first axis must be equal to the length of x. \naxis : int, optional\n    Specifies the axis of y along which to interpolate. Interpolation defaults to the first axis of y.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Akima1DInterpolator.html
scipy.interpolate.Akima1DInterpolator.__call__	A										<section class="prog__container"><p>Evaluate the piecewise polynomial or its derivative.</p><pre><code>Akima1DInterpolator.__call__(x, nu=0, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at. \nnu : int, optional\n    Order of derivative to evaluate. Must be non-negative. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Akima1DInterpolator.__call__.html
scipy interpolate Akima1DInterpolator __call__	R	scipy.interpolate.Akima1DInterpolator.__call__										
scipy interpolate.Akima1DInterpolator.__call__	R	scipy.interpolate.Akima1DInterpolator.__call__										
scipy.interpolate.Akima1DInterpolator.construct_fast	A										<section class="prog__container"><p>Construct the piecewise polynomial without making checks.</p><pre><code>classmethod Akima1DInterpolator.construct_fast(c, x, extrapolate=None, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Akima1DInterpolator.construct_fast.html
scipy interpolate Akima1DInterpolator construct_fast	R	scipy.interpolate.Akima1DInterpolator.construct_fast										
scipy interpolate.Akima1DInterpolator.construct_fast	R	scipy.interpolate.Akima1DInterpolator.construct_fast										
scipy.interpolate.Akima1DInterpolator.derivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the derivative.</p><pre><code>Akima1DInterpolator.derivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of derivative to evaluate. Default is 1, i.e. compute the first derivative. If negative, the antiderivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>pp : PPoly\n    Piecewise polynomial of order k2 = k - n representing the derivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Akima1DInterpolator.derivative.html
scipy interpolate Akima1DInterpolator derivative	R	scipy.interpolate.Akima1DInterpolator.derivative										
scipy interpolate.Akima1DInterpolator.derivative	R	scipy.interpolate.Akima1DInterpolator.derivative										
scipy.interpolate.Akima1DInterpolator.integrate	A										<section class="prog__container"><p>Compute a definite integral over a piecewise polynomial.</p><pre><code>Akima1DInterpolator.integrate(a, b, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower integration bound \nb : float\n    Upper integration bound \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>ig : array_like\n    Definite integral of the piecewise polynomial over [a, b]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Akima1DInterpolator.integrate.html
scipy interpolate Akima1DInterpolator integrate	R	scipy.interpolate.Akima1DInterpolator.integrate										
scipy interpolate.Akima1DInterpolator.integrate	R	scipy.interpolate.Akima1DInterpolator.integrate										
scipy.interpolate.Akima1DInterpolator.roots	A					[[scipy.interpolate.PPoly.solve]]					<section class="prog__container"><p>Find real roots of the the piecewise polynomial.</p><pre><code>Akima1DInterpolator.roots(discontinuity=True, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>discontinuity : bool, optional\n    Whether to report sign changes across discontinuities at breakpoints as roots. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to return roots from the polynomial extrapolated based on first and last intervals, ‘periodic’ works the same as False. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>roots : ndarray\n    Roots of the polynomial(s). If the PPoly object describes multiple polynomials, the return value is an object array whose each element is an ndarray containing the roots.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Akima1DInterpolator.roots.html
scipy interpolate Akima1DInterpolator roots	R	scipy.interpolate.Akima1DInterpolator.roots										
scipy interpolate.Akima1DInterpolator.roots	R	scipy.interpolate.Akima1DInterpolator.roots										
scipy interpolate Akima1DInterpolator	R	scipy.interpolate.Akima1DInterpolator										
scipy interpolate.Akima1DInterpolator	R	scipy.interpolate.Akima1DInterpolator										
scipy.interpolate.Akima1DInterpolator.solve	A										<section class="prog__container"><p>Find real solutions of the the equation pp(x) == y.</p><pre><code>Akima1DInterpolator.solve(y=0.0, discontinuity=True, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : float, optional\n    Right-hand side. Default is zero. \ndiscontinuity : bool, optional\n    Whether to report sign changes across discontinuities at breakpoints as roots. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to return roots from the polynomial extrapolated based on first and last intervals, ‘periodic’ works the same as False. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>roots : ndarray\n    Roots of the polynomial(s). If the PPoly object describes multiple polynomials, the return value is an object array whose each element is an ndarray containing the roots.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import PPoly\n>>> pp = PPoly(np.array([[1, -4, 3], [1, 0, 0]]).T, [-2, 1, 2])\n>>> pp.roots()\narray([-1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Akima1DInterpolator.solve.html
scipy interpolate Akima1DInterpolator solve	R	scipy.interpolate.Akima1DInterpolator.solve										
scipy interpolate.Akima1DInterpolator.solve	R	scipy.interpolate.Akima1DInterpolator.solve										
scipy.interpolate.approximate_taylor_polynomial	A										<section class="prog__container"><p>Estimate the Taylor polynomial of f at x by polynomial fitting.</p><pre><code>scipy.interpolate.approximate_taylor_polynomial(f, x, degree, scale, order=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : callable\n    The function whose Taylor polynomial is sought. Should accept a vector of x values. \nx : scalar\n    The point at which the polynomial is to be evaluated. \ndegree : int\n    The degree of the Taylor polynomial \nscale : scalar\n    The width of the interval to use to evaluate the Taylor polynomial. Function values spread over a range this wide are used to fit the polynomial. Must be chosen carefully. \norder : int or None, optional\n    The order of the polynomial to be used in the fitting; f will be evaluated order+1 times. If None, use degree.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : poly1d instance\n    The Taylor polynomial (translated to the origin, so that for example p(0)=f(x)).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.approximate_taylor_polynomial.html
scipy interpolate approximate_taylor_polynomial	R	scipy.interpolate.approximate_taylor_polynomial										
scipy interpolate.approximate_taylor_polynomial	R	scipy.interpolate.approximate_taylor_polynomial										
scipy.interpolate.barycentric_interpolate	A					[[scipy.interpolate.BarycentricInterpolator]]					<section class="prog__container"><p>Convenience function for polynomial interpolation.</p><pre><code>scipy.interpolate.barycentric_interpolate(xi, yi, x, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like\n    1-d array of x coordinates of the points the polynomial should pass through \nyi : array_like\n    The y coordinates of the points the polynomial should pass through. \nx : scalar or array_like\n    Points to evaluate the interpolator at. \naxis : int, optional\n    Axis in the yi array corresponding to the x-coordinate values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : scalar or array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.barycentric_interpolate.html
scipy interpolate barycentric_interpolate	R	scipy.interpolate.barycentric_interpolate										
scipy interpolate.barycentric_interpolate	R	scipy.interpolate.barycentric_interpolate										
scipy.interpolate.BarycentricInterpolator.add_xi	A										<section class="prog__container"><p>Add more x values to the set to be interpolated</p><pre><code>BarycentricInterpolator.add_xi(xi, yi=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like\n    The x coordinates of the points that the polynomial should pass through. \nyi : array_like, optional\n    The y coordinates of the points the polynomial should pass through. Should have shape (xi.size, R); if R > 1 then the polynomial is vector-valued. If yi is not given, the y values will be supplied later. yi should be given if and only if the interpolator has y values specified.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BarycentricInterpolator.add_xi.html
scipy interpolate BarycentricInterpolator add_xi	R	scipy.interpolate.BarycentricInterpolator.add_xi										
scipy interpolate.BarycentricInterpolator.add_xi	R	scipy.interpolate.BarycentricInterpolator.add_xi										
scipy.interpolate.BarycentricInterpolator	A										<section class="prog__container"><p>The interpolating polynomial for a set of points</p><pre><code>class scipy.interpolate.BarycentricInterpolator(xi, yi=None, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like\n    1-d array of x coordinates of the points the polynomial should pass through \nyi : array_like, optional\n    The y coordinates of the points the polynomial should pass through. If None, the y values will be supplied later via the set_y method. \naxis : int, optional\n    Axis in the yi array corresponding to the x-coordinate values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BarycentricInterpolator.html
scipy.interpolate.BarycentricInterpolator.__call__	A										<section class="prog__container"><p>Evaluate the interpolating polynomial at the points x</p><pre><code>BarycentricInterpolator.__call__(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BarycentricInterpolator.__call__.html
scipy interpolate BarycentricInterpolator __call__	R	scipy.interpolate.BarycentricInterpolator.__call__										
scipy interpolate.BarycentricInterpolator.__call__	R	scipy.interpolate.BarycentricInterpolator.__call__										
scipy interpolate BarycentricInterpolator	R	scipy.interpolate.BarycentricInterpolator										
scipy interpolate.BarycentricInterpolator	R	scipy.interpolate.BarycentricInterpolator										
scipy.interpolate.BarycentricInterpolator.set_yi	A										<section class="prog__container"><p>Update the y values to be interpolated</p><pre><code>BarycentricInterpolator.set_yi(yi, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>yi : array_like\n    The y coordinates of the points the polynomial should pass through. If None, the y values will be supplied later. \naxis : int, optional\n    Axis in the yi array corresponding to the x-coordinate values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BarycentricInterpolator.set_yi.html
scipy interpolate BarycentricInterpolator set_yi	R	scipy.interpolate.BarycentricInterpolator.set_yi										
scipy interpolate.BarycentricInterpolator.set_yi	R	scipy.interpolate.BarycentricInterpolator.set_yi										
scipy.interpolate.bisplev	A					[[scipy.interpolate.splprep]]\\n[[scipy.interpolate.splrep]]\\n[[scipy.interpolate.splint]]\\n[[scipy.interpolate.sproot]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.UnivariateSpline]]\\n[[scipy.interpolate.BivariateSpline]]					<section class="prog__container"><p>Evaluate a bivariate B-spline and its derivatives.</p><pre><code>scipy.interpolate.bisplev(x, y, tck, dx=0, dy=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : ndarray\n    Rank-1 arrays specifying the domain over which to evaluate the spline or its derivative. \ntck : tuple\n    A sequence of length 5 returned by bisplrep containing the knot locations, the coefficients, and the degree of the spline: [tx, ty, c, kx, ky]. \ndx, dy : int, optional\n    The orders of the partial derivatives in x and y respectively.</code></pre><span class="prog__sub">Returns:</span><pre><code>vals : ndarray\n    The B-spline or its derivative evaluated over the set formed by the cross-product of x and y.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.bisplev.html
scipy interpolate bisplev	R	scipy.interpolate.bisplev										
scipy interpolate.bisplev	R	scipy.interpolate.bisplev										
scipy.interpolate.bisplrep	A					[[scipy.interpolate.splprep]]\\n[[scipy.interpolate.splrep]]\\n[[scipy.interpolate.splint]]\\n[[scipy.interpolate.sproot]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.UnivariateSpline]]\\n[[scipy.interpolate.BivariateSpline]]					<section class="prog__container"><p>Find a bivariate B-spline representation of a surface.</p><pre><code>scipy.interpolate.bisplrep(x, y, z, w=None, xb=None, xe=None, yb=None, ye=None, kx=3, ky=3, task=0, s=None, eps=1e-16, tx=None, ty=None, full_output=0, nxest=None, nyest=None, quiet=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : ndarray\n    Rank-1 arrays of data points. \nw : ndarray, optional\n    Rank-1 array of weights. By default w=np.ones(len(x)). \nxb, xe : float, optional\n    End points of approximation interval in x. By default xb = x.min(), xe=x.max(). \nyb, ye : float, optional\n    End points of approximation interval in y. By default yb=y.min(), ye = y.max(). \nkx, ky : int, optional\n    The degrees of the spline (1 <= kx, ky <= 5). Third order (kx=ky=3) is recommended. \ntask : int, optional\n    If task=0, find knots in x and y and coefficients for a given smoothing factor, s. If task=1, find knots and coefficients for another value of the smoothing factor, s.  bisplrep must have been previously called with task=0 or task=1. If task=-1, find coefficients for a given set of knots tx, ty. \ns : float, optional\n    A non-negative smoothing factor.  If weights correspond to the inverse of the standard-deviation of the errors in z, then a good s-value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) where m=len(x). \neps : float, optional\n    A threshold for determining the effective rank of an over-determined linear system of equations (0 < eps < 1). eps is not likely to need changing. \ntx, ty : ndarray, optional\n    Rank-1 arrays of the knots of the spline for task=-1 \nfull_output : int, optional\n    Non-zero to return optional outputs. \nnxest, nyest : int, optional\n    Over-estimates of the total number of knots. If None then nxest = max(kx+sqrt(m/2),2*kx+3), nyest = max(ky+sqrt(m/2),2*ky+3). \nquiet : int, optional\n    Non-zero to suppress printing of messages. This parameter is deprecated; use standard Python warning filters instead.</code></pre><span class="prog__sub">Returns:</span><pre><code>tck : array_like\n    A list [tx, ty, c, kx, ky] containing the knots (tx, ty) and coefficients (c) of the bivariate B-spline representation of the surface along with the degree of the spline. \nfp : ndarray\n    The weighted sum of squared residuals of the spline approximation. \nier : int\n    An integer flag about splrep success.  Success is indicated if ier<=0. If ier in [1,2,3] an error occurred but was not raised. Otherwise an error is raised. \nmsg : str\n    A message corresponding to the integer flag, ier.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.bisplrep.html
scipy interpolate bisplrep	R	scipy.interpolate.bisplrep										
scipy interpolate.bisplrep	R	scipy.interpolate.bisplrep										
scipy.interpolate.BivariateSpline	A										<section class="prog__container"><p>Base class for bivariate splines.</p><pre><code>class scipy.interpolate.BivariateSpline</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BivariateSpline.html
scipy.interpolate.BivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate the spline or its derivatives at given positions.</p><pre><code>BivariateSpline.__call__(x, y, mth=None, dx=0, dy=0, grid=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Input coordinates. If grid is False, evaluate the spline at points (x[i], y[i]), i=0, ..., len(x)-1.  Standard Numpy broadcasting is obeyed. If grid is True: evaluate spline at the grid points defined by the coordinate arrays x, y. The arrays must be sorted to increasing order. \ndx : int\n    Order of x-derivative  New in version 0.14.0.  \ndy : int\n    Order of y-derivative  New in version 0.14.0.  \ngrid : bool\n    Whether to evaluate the results on a grid spanned by the input arrays, or at points specified by the input arrays.  New in version 0.14.0.  \nmth : str\n    Deprecated argument. Has no effect.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BivariateSpline.__call__.html
scipy interpolate BivariateSpline __call__	R	scipy.interpolate.BivariateSpline.__call__										
scipy interpolate.BivariateSpline.__call__	R	scipy.interpolate.BivariateSpline.__call__										
scipy.interpolate.BivariateSpline.ev	A										<section class="prog__container"><p>Evaluate the spline at points</p><pre><code>BivariateSpline.ev(xi, yi, dx=0, dy=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi, yi : array_like\n    Input coordinates. Standard Numpy broadcasting is obeyed. \ndx : int, optional\n    Order of x-derivative  New in version 0.14.0.  \ndy : int, optional\n    Order of y-derivative  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BivariateSpline.ev.html
scipy interpolate BivariateSpline ev	R	scipy.interpolate.BivariateSpline.ev										
scipy interpolate.BivariateSpline.ev	R	scipy.interpolate.BivariateSpline.ev										
scipy.interpolate.BivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>BivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BivariateSpline.get_coeffs.html
scipy interpolate BivariateSpline get_coeffs	R	scipy.interpolate.BivariateSpline.get_coeffs										
scipy interpolate.BivariateSpline.get_coeffs	R	scipy.interpolate.BivariateSpline.get_coeffs										
scipy.interpolate.BivariateSpline.get_knots	A										<section class="prog__container"><p>Return a tuple (tx,ty) where tx,ty contain knots positions\nof the spline with respect to x-, y-variable, respectively.\nThe position of interior and additional knots are given as\nt[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively.</p><pre><code>BivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BivariateSpline.get_knots.html
scipy interpolate BivariateSpline get_knots	R	scipy.interpolate.BivariateSpline.get_knots										
scipy interpolate.BivariateSpline.get_knots	R	scipy.interpolate.BivariateSpline.get_knots										
scipy.interpolate.BivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline\napproximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0)</p><pre><code>BivariateSpline.get_residual()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BivariateSpline.get_residual.html
scipy interpolate BivariateSpline get_residual	R	scipy.interpolate.BivariateSpline.get_residual										
scipy interpolate.BivariateSpline.get_residual	R	scipy.interpolate.BivariateSpline.get_residual										
scipy.interpolate.BivariateSpline.integral	A										<section class="prog__container"><p>Evaluate the integral of the spline over area [xa,xb] x [ya,yb].</p><pre><code>BivariateSpline.integral(xa, xb, ya, yb)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xa, xb : float\n    The end-points of the x integration interval. \nya, yb : float\n    The end-points of the y integration interval.</code></pre><span class="prog__sub">Returns:</span><pre><code>integ : float\n    The value of the resulting integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BivariateSpline.integral.html
scipy interpolate BivariateSpline integral	R	scipy.interpolate.BivariateSpline.integral										
scipy interpolate.BivariateSpline.integral	R	scipy.interpolate.BivariateSpline.integral										
scipy interpolate BivariateSpline	R	scipy.interpolate.BivariateSpline										
scipy interpolate.BivariateSpline	R	scipy.interpolate.BivariateSpline										
scipy.interpolate.BPoly.antiderivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the antiderivative.</p><pre><code>BPoly.antiderivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of antiderivative to evaluate. Default is 1, i.e. compute the first integral. If negative, the derivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>bp : BPoly\n    Piecewise polynomial of order k + nu representing the antiderivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.antiderivative.html
scipy interpolate BPoly antiderivative	R	scipy.interpolate.BPoly.antiderivative										
scipy interpolate.BPoly.antiderivative	R	scipy.interpolate.BPoly.antiderivative										
scipy.interpolate.BPoly	A										<section class="prog__container"><p>Piecewise polynomial in terms of coefficients and breakpoints.</p><pre><code>class scipy.interpolate.BPoly(c, x, extrapolate=None, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : ndarray, shape (k, m, ...)\n    Polynomial coefficients, order k and m intervals \nx : ndarray, shape (m+1,)\n    Polynomial breakpoints. These must be sorted in increasing order. \nextrapolate : bool, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True. \naxis : int, optional\n    Interpolation axis. Default is zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>S = sum(c[a, i] * b(a, k; x) for a in range(k+1)),</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.html
scipy.interpolate.BPoly.__call__	A										<section class="prog__container"><p>Evaluate the piecewise polynomial or its derivative.</p><pre><code>BPoly.__call__(x, nu=0, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at. \nnu : int, optional\n    Order of derivative to evaluate. Must be non-negative. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.__call__.html
scipy interpolate BPoly __call__	R	scipy.interpolate.BPoly.__call__										
scipy interpolate.BPoly.__call__	R	scipy.interpolate.BPoly.__call__										
scipy.interpolate.BPoly.construct_fast	A										<section class="prog__container"><p>Construct the piecewise polynomial without making checks.</p><pre><code>classmethod BPoly.construct_fast(c, x, extrapolate=None, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.construct_fast.html
scipy interpolate BPoly construct_fast	R	scipy.interpolate.BPoly.construct_fast										
scipy interpolate.BPoly.construct_fast	R	scipy.interpolate.BPoly.construct_fast										
scipy.interpolate.BPoly.derivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the derivative.</p><pre><code>BPoly.derivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of derivative to evaluate. Default is 1, i.e. compute the first derivative. If negative, the antiderivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>bp : BPoly\n    Piecewise polynomial of order k - nu representing the derivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.derivative.html
scipy interpolate BPoly derivative	R	scipy.interpolate.BPoly.derivative										
scipy interpolate.BPoly.derivative	R	scipy.interpolate.BPoly.derivative										
scipy.interpolate.BPoly.extend	A										<section class="prog__container"><p>Add additional breakpoints and coefficients to the polynomial.</p><pre><code>BPoly.extend(c, x, right=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : ndarray, size (k, m, ...)\n    Additional coefficients for polynomials in intervals self.x[-1] <= x < x_right[0], x_right[0] <= x < x_right[1], ..., x_right[m-2] <= x < x_right[m-1] \nx : ndarray, size (m,)\n    Additional breakpoints. Must be sorted and either to the right or to the left of the current breakpoints. \nright : bool, optional\n    Whether the new intervals are to the right or to the left of the current intervals.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.extend.html
scipy interpolate BPoly extend	R	scipy.interpolate.BPoly.extend										
scipy interpolate.BPoly.extend	R	scipy.interpolate.BPoly.extend										
scipy.interpolate.BPoly.from_derivatives	A										<section class="prog__container"><p>Construct a piecewise polynomial in the Bernstein basis,\ncompatible with the specified values and derivatives at breakpoints.</p><pre><code>classmethod BPoly.from_derivatives(xi, yi, orders=None, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like\n    sorted 1D array of x-coordinates \nyi : array_like or list of array_likes\n    yi[i][j] is the j-th derivative known at xi[i] \norders : None or int or array_like of ints. Default: None.\n    Specifies the degree of local polynomials. If not None, some derivatives are ignored. \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import BPoly\n>>> BPoly.from_derivatives([0, 1], [[1, 2], [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.from_derivatives.html
scipy interpolate BPoly from_derivatives	R	scipy.interpolate.BPoly.from_derivatives										
scipy interpolate.BPoly.from_derivatives	R	scipy.interpolate.BPoly.from_derivatives										
scipy.interpolate.BPoly.from_power_basis	A										<section class="prog__container"><p>Construct a piecewise polynomial in Bernstein basis\nfrom a power basis polynomial.</p><pre><code>classmethod BPoly.from_power_basis(pp, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pp : PPoly\n    A piecewise polynomial in the power basis \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.from_power_basis.html
scipy interpolate BPoly from_power_basis	R	scipy.interpolate.BPoly.from_power_basis										
scipy interpolate.BPoly.from_power_basis	R	scipy.interpolate.BPoly.from_power_basis										
scipy.interpolate.BPoly.integrate	A										<section class="prog__container"><p>Compute a definite integral over a piecewise polynomial.</p><pre><code>BPoly.integrate(a, b, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower integration bound \nb : float\n    Upper integration bound \nextrapolate : {bool, ‘periodic’, None}, optional\n    Whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>array_like\n    Definite integral of the piecewise polynomial over [a, b]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BPoly.integrate.html
scipy interpolate BPoly integrate	R	scipy.interpolate.BPoly.integrate										
scipy interpolate.BPoly.integrate	R	scipy.interpolate.BPoly.integrate										
scipy interpolate BPoly	R	scipy.interpolate.BPoly										
scipy interpolate.BPoly	R	scipy.interpolate.BPoly										
scipy.interpolate.CloughTocher2DInterpolator	A										<section class="prog__container"><p>Piecewise cubic, C1 smooth, curvature-minimizing interpolant in 2D.</p><pre><code>class scipy.interpolate.CloughTocher2DInterpolator(points, values, tol=1e-6)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray of floats, shape (npoints, ndims); or Delaunay\n    Data point coordinates, or a precomputed Delaunay triangulation. \nvalues : ndarray of float or complex, shape (npoints, ...)\n    Data values. \nfill_value : float, optional\n    Value used to fill in for requested points outside of the convex hull of the input points.  If not provided, then the default is nan. \ntol : float, optional\n    Absolute/relative tolerance for gradient estimation. \nmaxiter : int, optional\n    Maximum number of iterations in gradient estimation. \nrescale : bool, optional\n    Rescale points to unit cube before performing interpolation. This is useful if some of the input dimensions have incommensurable units and differ by many orders of magnitude.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CloughTocher2DInterpolator.html
scipy.interpolate.CloughTocher2DInterpolator.__call__	A										<section class="prog__container"><p>Evaluate interpolator at given points.</p><pre><code>CloughTocher2DInterpolator.__call__(xi)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : ndarray of float, shape (..., ndim)\n    Points where to interpolate data at.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CloughTocher2DInterpolator.__call__.html
scipy interpolate CloughTocher2DInterpolator __call__	R	scipy.interpolate.CloughTocher2DInterpolator.__call__										
scipy interpolate.CloughTocher2DInterpolator.__call__	R	scipy.interpolate.CloughTocher2DInterpolator.__call__										
scipy interpolate CloughTocher2DInterpolator	R	scipy.interpolate.CloughTocher2DInterpolator										
scipy interpolate.CloughTocher2DInterpolator	R	scipy.interpolate.CloughTocher2DInterpolator										
scipy.interpolate.CubicSpline.antiderivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the antiderivative.</p><pre><code>CubicSpline.antiderivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of antiderivative to evaluate. Default is 1, i.e. compute the first integral. If negative, the derivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>pp : PPoly\n    Piecewise polynomial of order k2 = k + n representing the antiderivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.antiderivative.html
scipy interpolate CubicSpline antiderivative	R	scipy.interpolate.CubicSpline.antiderivative										
scipy interpolate.CubicSpline.antiderivative	R	scipy.interpolate.CubicSpline.antiderivative										
scipy.interpolate.CubicSpline	A					[[scipy.interpolate.Akima1DInterpolator]]\\n[[scipy.interpolate.PchipInterpolator]]\\n[[scipy.interpolate.PPoly]]					<section class="prog__container"><p>Cubic spline data interpolator.</p><pre><code>class scipy.interpolate.CubicSpline(x, y, axis=0, bc_type='not-a-knot', extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape (n,)\n    1-d array containing values of the independent variable. Values must be real, finite and in strictly increasing order. \ny : array_like\n    Array containing values of the dependent variable. It can have arbitrary number of dimensions, but the length along axis (see below) must match the length of x. Values must be finite. \naxis : int, optional\n    Axis along which y is assumed to be varying. Meaning that for x[i] the corresponding values are np.take(y, i, axis=axis). Default is 0. \nbc_type : string or 2-tuple, optional\n    Boundary condition type. Two additional equations, given by the boundary conditions, are required to determine all coefficients of polynomials on each segment [R54]. If bc_type is a string, then the specified condition will be applied at both ends of a spline. Available conditions are:  ‘not-a-knot’ (default): The first and second segment at a curve end are the same polynomial. It is a good default when there is no information on boundary conditions. ‘periodic’: The interpolated functions is assumed to be periodic of period x[-1] - x[0]. The first and last value of y must be identical: y[0] == y[-1]. This boundary condition will result in y'[0] == y'[-1] and y''[0] == y''[-1]. ‘clamped’: The first derivative at curves ends are zero. Assuming a 1D y, bc_type=((1, 0.0), (1, 0.0)) is the same condition. ‘natural’: The second derivative at curve ends are zero. Assuming a 1D y, bc_type=((2, 0.0), (2, 0.0)) is the same condition.  If bc_type is a 2-tuple, the first and the second value will be applied at the curve start and end respectively. The tuple values can be one of the previously mentioned strings (except ‘periodic’) or a tuple (order, deriv_values) allowing to specify arbitrary derivatives at curve ends:  order: the derivative order, 1 or 2. deriv_value: array_like containing derivative values, shape must be the same as y, excluding axis dimension. For example, if y is 1D, then deriv_value must be a scalar. If y is 3D with the shape (n0, n1, n2) and axis=2, then deriv_value must be 2D and have the shape (n0, n1).  \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), extrapolate is set to ‘periodic’ for bc_type='periodic' and to True otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import CubicSpline\n>>> import matplotlib.pyplot as plt\n>>> x = np.arange(10)\n>>> y = np.sin(x)\n>>> cs = CubicSpline(x, y)\n>>> xs = np.arange(-0.5, 9.6, 0.1)\n>>> plt.figure(figsize=(6.5, 4))\n>>> plt.plot(x, y, 'o', label='data')\n>>> plt.plot(xs, np.sin(xs), label='true')\n>>> plt.plot(xs, cs(xs), label="S")\n>>> plt.plot(xs, cs(xs, 1), label="S'")\n>>> plt.plot(xs, cs(xs, 2), label="S''")\n>>> plt.plot(xs, cs(xs, 3), label="S'''")\n>>> plt.xlim(-0.5, 9.5)\n>>> plt.legend(loc='lower left', ncol=2)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.html
scipy.interpolate.CubicSpline.__call__	A										<section class="prog__container"><p>Evaluate the piecewise polynomial or its derivative.</p><pre><code>CubicSpline.__call__(x, nu=0, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at. \nnu : int, optional\n    Order of derivative to evaluate. Must be non-negative. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.__call__.html
scipy interpolate CubicSpline __call__	R	scipy.interpolate.CubicSpline.__call__										
scipy interpolate.CubicSpline.__call__	R	scipy.interpolate.CubicSpline.__call__										
scipy.interpolate.CubicSpline.construct_fast	A										<section class="prog__container"><p>Construct the piecewise polynomial without making checks.</p><pre><code>classmethod CubicSpline.construct_fast(c, x, extrapolate=None, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.construct_fast.html
scipy interpolate CubicSpline construct_fast	R	scipy.interpolate.CubicSpline.construct_fast										
scipy interpolate.CubicSpline.construct_fast	R	scipy.interpolate.CubicSpline.construct_fast										
scipy.interpolate.CubicSpline.derivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the derivative.</p><pre><code>CubicSpline.derivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of derivative to evaluate. Default is 1, i.e. compute the first derivative. If negative, the antiderivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>pp : PPoly\n    Piecewise polynomial of order k2 = k - n representing the derivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.derivative.html
scipy interpolate CubicSpline derivative	R	scipy.interpolate.CubicSpline.derivative										
scipy interpolate.CubicSpline.derivative	R	scipy.interpolate.CubicSpline.derivative										
scipy.interpolate.CubicSpline.extend	A										<section class="prog__container"><p>Add additional breakpoints and coefficients to the polynomial.</p><pre><code>CubicSpline.extend(c, x, right=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : ndarray, size (k, m, ...)\n    Additional coefficients for polynomials in intervals self.x[-1] <= x < x_right[0], x_right[0] <= x < x_right[1], ..., x_right[m-2] <= x < x_right[m-1] \nx : ndarray, size (m,)\n    Additional breakpoints. Must be sorted and either to the right or to the left of the current breakpoints. \nright : bool, optional\n    Whether the new intervals are to the right or to the left of the current intervals.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.extend.html
scipy interpolate CubicSpline extend	R	scipy.interpolate.CubicSpline.extend										
scipy interpolate.CubicSpline.extend	R	scipy.interpolate.CubicSpline.extend										
scipy.interpolate.CubicSpline.from_bernstein_basis	A										<section class="prog__container"><p>Construct a piecewise polynomial in the power basis\nfrom a polynomial in Bernstein basis.</p><pre><code>classmethod CubicSpline.from_bernstein_basis(bp, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>bp : BPoly\n    A Bernstein basis polynomial, as created by BPoly \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.from_bernstein_basis.html
scipy interpolate CubicSpline from_bernstein_basis	R	scipy.interpolate.CubicSpline.from_bernstein_basis										
scipy interpolate.CubicSpline.from_bernstein_basis	R	scipy.interpolate.CubicSpline.from_bernstein_basis										
scipy.interpolate.CubicSpline.from_spline	A										<section class="prog__container"><p>Construct a piecewise polynomial from a spline</p><pre><code>classmethod CubicSpline.from_spline(tck, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tck\n    A spline, as returned by splrep \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.from_spline.html
scipy interpolate CubicSpline from_spline	R	scipy.interpolate.CubicSpline.from_spline										
scipy interpolate.CubicSpline.from_spline	R	scipy.interpolate.CubicSpline.from_spline										
scipy.interpolate.CubicSpline.integrate	A										<section class="prog__container"><p>Compute a definite integral over a piecewise polynomial.</p><pre><code>CubicSpline.integrate(a, b, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower integration bound \nb : float\n    Upper integration bound \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>ig : array_like\n    Definite integral of the piecewise polynomial over [a, b]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.integrate.html
scipy interpolate CubicSpline integrate	R	scipy.interpolate.CubicSpline.integrate										
scipy interpolate.CubicSpline.integrate	R	scipy.interpolate.CubicSpline.integrate										
scipy.interpolate.CubicSpline.roots	A					[[scipy.interpolate.PPoly.solve]]					<section class="prog__container"><p>Find real roots of the the piecewise polynomial.</p><pre><code>CubicSpline.roots(discontinuity=True, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>discontinuity : bool, optional\n    Whether to report sign changes across discontinuities at breakpoints as roots. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to return roots from the polynomial extrapolated based on first and last intervals, ‘periodic’ works the same as False. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>roots : ndarray\n    Roots of the polynomial(s). If the PPoly object describes multiple polynomials, the return value is an object array whose each element is an ndarray containing the roots.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.roots.html
scipy interpolate CubicSpline roots	R	scipy.interpolate.CubicSpline.roots										
scipy interpolate.CubicSpline.roots	R	scipy.interpolate.CubicSpline.roots										
scipy interpolate CubicSpline	R	scipy.interpolate.CubicSpline										
scipy interpolate.CubicSpline	R	scipy.interpolate.CubicSpline										
scipy.interpolate.CubicSpline.solve	A										<section class="prog__container"><p>Find real solutions of the the equation pp(x) == y.</p><pre><code>CubicSpline.solve(y=0.0, discontinuity=True, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : float, optional\n    Right-hand side. Default is zero. \ndiscontinuity : bool, optional\n    Whether to report sign changes across discontinuities at breakpoints as roots. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to return roots from the polynomial extrapolated based on first and last intervals, ‘periodic’ works the same as False. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>roots : ndarray\n    Roots of the polynomial(s). If the PPoly object describes multiple polynomials, the return value is an object array whose each element is an ndarray containing the roots.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import PPoly\n>>> pp = PPoly(np.array([[1, -4, 3], [1, 0, 0]]).T, [-2, 1, 2])\n>>> pp.roots()\narray([-1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.solve.html
scipy interpolate CubicSpline solve	R	scipy.interpolate.CubicSpline.solve										
scipy interpolate.CubicSpline.solve	R	scipy.interpolate.CubicSpline.solve										
scipy.interpolate.griddata	A										<section class="prog__container"><p>Interpolate unstructured D-dimensional data.</p><pre><code>scipy.interpolate.griddata(points, values, xi, method='linear', fill_value=nan, rescale=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray of floats, shape (n, D)\n    Data point coordinates. Can either be an array of shape (n, D), or a tuple of ndim arrays. \nvalues : ndarray of float or complex, shape (n,)\n    Data values. \nxi : ndarray of float, shape (M, D)\n    Points at which to interpolate data. \nmethod : {‘linear’, ‘nearest’, ‘cubic’}, optional\n    Method of interpolation. One of  nearest return the value at the data point closest to the point of interpolation.  See NearestNDInterpolator for more details.  linear tesselate the input point set to n-dimensional simplices, and interpolate linearly on each simplex.  See LinearNDInterpolator for more details.  cubic (1-D) return the value determined from a cubic spline.  cubic (2-D) return the value determined from a piecewise cubic, continuously differentiable (C1), and approximately curvature-minimizing polynomial surface. See CloughTocher2DInterpolator for more details.   \nfill_value : float, optional\n    Value used to fill in for requested points outside of the convex hull of the input points.  If not provided, then the default is nan. This option has no effect for the ‘nearest’ method. \nrescale : bool, optional\n    Rescale points to unit cube before performing interpolation. This is useful if some of the input dimensions have incommensurable units and differ by many orders of magnitude.  New in version 0.14.0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def func(x, y):\n...     return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.griddata.html
scipy interpolate griddata	R	scipy.interpolate.griddata										
scipy interpolate.griddata	R	scipy.interpolate.griddata										
scipy.interpolate.insert	A										<section class="prog__container"><p>Insert knots into a B-spline.</p><pre><code>scipy.interpolate.insert(x, tck, m=1, per=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x (u) : array_like\n    A 1-D point at which to insert a new knot(s).  If tck was returned from splprep, then the parameter values, u should be given. \ntck : tuple\n    A tuple (t,c,k) returned by splrep or splprep containing the vector of knots, the B-spline coefficients, and the degree of the spline. \nm : int, optional\n    The number of times to insert the given knot (its multiplicity). Default is 1. \nper : int, optional\n    If non-zero, the input spline is considered periodic.</code></pre><span class="prog__sub">Returns:</span><pre><code>tck : tuple\n    A tuple (t,c,k) containing the vector of knots, the B-spline coefficients, and the degree of the new spline. t(k+1) <= x <= t(n-k), where k is the degree of the spline. In case of a periodic spline (per != 0) there must be either at least k interior knots t(j) satisfying t(k+1)<t(j)<=x or at least k interior knots t(j) satisfying x<=t(j)<t(n-k).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.insert.html
scipy interpolate insert	R	scipy.interpolate.insert										
scipy interpolate.insert	R	scipy.interpolate.insert										
scipy.interpolate.interp1d	A										<section class="prog__container"><p>Interpolate a 1-D function.</p><pre><code>class scipy.interpolate.interp1d(x, y, kind='linear', axis=-1, copy=True, bounds_error=None, fill_value=nan, assume_sorted=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (N,) array_like\n    A 1-D array of real values. \ny : (...,N,...) array_like\n    A N-D array of real values. The length of y along the interpolation axis must be equal to the length of x. \nkind : str or int, optional\n    Specifies the kind of interpolation as a string (‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic, ‘cubic’ where ‘slinear’, ‘quadratic’ and ‘cubic’ refer to a spline interpolation of first, second or third order) or as an integer specifying the order of the spline interpolator to use. Default is ‘linear’. \naxis : int, optional\n    Specifies the axis of y along which to interpolate. Interpolation defaults to the last axis of y. \ncopy : bool, optional\n    If True, the class makes internal copies of x and y. If False, references to x and y are used. The default is to copy. \nbounds_error : bool, optional\n    If True, a ValueError is raised any time interpolation is attempted on a value outside of the range of x (where extrapolation is necessary). If False, out of bounds values are assigned fill_value. By default, an error is raised unless fill_value=”extrapolate”. \nfill_value : array-like or (array-like, array_like) or “extrapolate”, optional\n    if a ndarray (or float), this value will be used to fill in for requested points outside of the data range. If not provided, then the default is NaN. The array-like must broadcast properly to the dimensions of the non-interpolation axes.  If a two-element tuple, then the first element is used as a fill value for x_new < x[0] and the second element is used for x_new > x[-1]. Anything that is not a 2-element tuple (e.g., list or ndarray, regardless of shape) is taken to be a single array-like argument meant to be used for both bounds as below, above = fill_value, fill_value.  New in version 0.17.0.   If “extrapolate”, then points outside the data range will be extrapolated. (“nearest” and “linear” kinds only.)  New in version 0.17.0.    \nassume_sorted : bool, optional\n    If False, values of x can be in any order and they are sorted first. If True, x has to be an array of monotonically increasing values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy import interpolate\n>>> x = np.arange(0, 10)\n>>> y = np.exp(-x/3.0)\n>>> f = interpolate.interp1d(x, y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html
scipy.interpolate.interp1d.__call__	A										<section class="prog__container"><p>Evaluate the interpolant</p><pre><code>interp1d.__call__(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.__call__.html
scipy interpolate interp1d __call__	R	scipy.interpolate.interp1d.__call__										
scipy interpolate.interp1d.__call__	R	scipy.interpolate.interp1d.__call__										
scipy interpolate interp1d	R	scipy.interpolate.interp1d										
scipy interpolate.interp1d	R	scipy.interpolate.interp1d										
scipy.interpolate.interp2d	A										<section class="prog__container"><p>Interpolate over a 2-D grid.</p><pre><code>class scipy.interpolate.interp2d(x, y, z, kind='linear', copy=True, bounds_error=False, fill_value=nan)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays defining the data point coordinates. If the points lie on a regular grid, x can specify the column coordinates and y the row coordinates, for example: >>> x = [0,1,2];  y = [0,3]; z = [[1,2,3], [4,5,6]]   Otherwise, x and y must specify the full coordinates for each point, for example: >>> x = [0,1,2,0,1,2];  y = [0,0,0,3,3,3]; z = [1,2,3,4,5,6]   If x and y are multi-dimensional, they are flattened before use. \nz : array_like\n    The values of the function to interpolate at the data points. If z is a multi-dimensional array, it is flattened before use.  The length of a flattened z array is either len(x)*len(y) if x and y specify the column and row coordinates or len(z) == len(x) == len(y) if x and y specify coordinates for each point. \nkind : {‘linear’, ‘cubic’, ‘quintic’}, optional\n    The kind of spline interpolation to use. Default is ‘linear’. \ncopy : bool, optional\n    If True, the class makes internal copies of x, y and z. If False, references may be used. The default is to copy. \nbounds_error : bool, optional\n    If True, when interpolated values are requested outside of the domain of the input data (x,y), a ValueError is raised. If False, then fill_value is used. \nfill_value : number, optional\n    If provided, the value to use for points outside of the interpolation domain. If omitted (None), values outside the domain are extrapolated.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = [0,1,2];  y = [0,3]; z = [[1,2,3], [4,5,6]]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp2d.html
scipy.interpolate.interp2d.__call__	A										<section class="prog__container"><p>Interpolate the function.</p><pre><code>interp2d.__call__(x, y, dx=0, dy=0, assume_sorted=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : 1D array\n    x-coordinates of the mesh on which to interpolate. \ny : 1D array\n    y-coordinates of the mesh on which to interpolate. \ndx : int >= 0, < kx\n    Order of partial derivatives in x. \ndy : int >= 0, < ky\n    Order of partial derivatives in y. \nassume_sorted : bool, optional\n    If False, values of x and y can be in any order and they are sorted first. If True, x and y have to be arrays of monotonically increasing values.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : 2D array with shape (len(y), len(x))\n    The interpolated values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp2d.__call__.html
scipy interpolate interp2d __call__	R	scipy.interpolate.interp2d.__call__										
scipy interpolate.interp2d.__call__	R	scipy.interpolate.interp2d.__call__										
scipy interpolate interp2d	R	scipy.interpolate.interp2d										
scipy interpolate.interp2d	R	scipy.interpolate.interp2d										
scipy.interpolate.interpn	A										<section class="prog__container"><p>Multidimensional interpolation on regular grids.</p><pre><code>scipy.interpolate.interpn(points, values, xi, method='linear', bounds_error=True, fill_value=nan)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )\n    The points defining the regular grid in n dimensions. \nvalues : array_like, shape (m1, ..., mn, ...)\n    The data on the regular grid in n dimensions. \nxi : ndarray of shape (..., ndim)\n    The coordinates to sample the gridded data at \nmethod : str, optional\n    The method of interpolation to perform. Supported are “linear” and “nearest”, and “splinef2d”. “splinef2d” is only supported for 2-dimensional data. \nbounds_error : bool, optional\n    If True, when interpolated values are requested outside of the domain of the input data, a ValueError is raised. If False, then fill_value is used. \nfill_value : number, optional\n    If provided, the value to use for points outside of the interpolation domain. If None, values outside the domain are extrapolated.  Extrapolation is not supported by method “splinef2d”.</code></pre><span class="prog__sub">Returns:</span><pre><code>values_x : ndarray, shape xi.shape[:-1] + values.shape[ndim:]\n    Interpolated values at input coordinates.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interpn.html
scipy interpolate interpn	R	scipy.interpolate.interpn										
scipy interpolate.interpn	R	scipy.interpolate.interpn										
scipy.interpolate.InterpolatedUnivariateSpline.antiderivative	A					[[scipy.interpolate.splantider]]\\n[[scipy.interpolate.InterpolatedUnivariateSpline.derivative]]					<section class="prog__container"><p>Construct a new spline representing the antiderivative of this spline.</p><pre><code>InterpolatedUnivariateSpline.antiderivative(n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Order of antiderivative to evaluate. Default: 1</code></pre><span class="prog__sub">Returns:</span><pre><code>spline : UnivariateSpline\n    Spline of order k2=k+n representing the antiderivative of this spline.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, np.pi/2, 70)\n>>> y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2)\n>>> spl = UnivariateSpline(x, y, s=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.antiderivative.html
scipy interpolate InterpolatedUnivariateSpline antiderivative	R	scipy.interpolate.InterpolatedUnivariateSpline.antiderivative										
scipy interpolate.InterpolatedUnivariateSpline.antiderivative	R	scipy.interpolate.InterpolatedUnivariateSpline.antiderivative										
scipy.interpolate.InterpolatedUnivariateSpline	A										<section class="prog__container"><p>One-dimensional interpolating spline for a given set of data points.</p><pre><code>class scipy.interpolate.InterpolatedUnivariateSpline(x, y, w=None, bbox=[None, None], k=3, ext=0, check_finite=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (N,) array_like\n    Input dimension of data points – must be increasing \ny : (N,) array_like\n    input dimension of data points \nw : (N,) array_like, optional\n    Weights for spline fitting.  Must be positive.  If None (default), weights are all equal. \nbbox : (2,) array_like, optional\n    2-sequence specifying the boundary of the approximation interval. If None (default), bbox=[x[0], x[-1]]. \nk : int, optional\n    Degree of the smoothing spline.  Must be 1 <= k <= 5. \next : int or str, optional\n    Controls the extrapolation mode for elements not in the interval defined by the knot sequence.  if ext=0 or ‘extrapolate’, return the extrapolated value. if ext=1 or ‘zeros’, return 0 if ext=2 or ‘raise’, raise a ValueError if ext=3 of ‘const’, return the boundary value.  The default value is 0. \ncheck_finite : bool, optional\n    Whether to check that the input arrays contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination or non-sensical results) if the inputs do contain infinities or NaNs. Default is False.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy.interpolate import InterpolatedUnivariateSpline\n>>> x = np.linspace(-3, 3, 50)\n>>> y = np.exp(-x**2) + 0.1 * np.random.randn(50)\n>>> spl = InterpolatedUnivariateSpline(x, y)\n>>> plt.plot(x, y, 'ro', ms=5)\n>>> xs = np.linspace(-3, 3, 1000)\n>>> plt.plot(xs, spl(xs), 'g', lw=3, alpha=0.7)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html
scipy.interpolate.InterpolatedUnivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate spline (or its nu-th derivative) at positions x.</p><pre><code>InterpolatedUnivariateSpline.__call__(x, nu=0, ext=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D array of points at which to return the value of the smoothed spline or its derivatives. Note: x can be unordered but the evaluation is more efficient if x is (partially) ordered. \nnu : int\n    The order of derivative of the spline to compute. \next : int\n    Controls the value returned for elements of x not in the interval defined by the knot sequence.  if ext=0 or ‘extrapolate’, return the extrapolated value. if ext=1 or ‘zeros’, return 0 if ext=2 or ‘raise’, raise a ValueError if ext=3 or ‘const’, return the boundary value.  The default value is 0, passed from the initialization of UnivariateSpline.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.__call__.html
scipy interpolate InterpolatedUnivariateSpline __call__	R	scipy.interpolate.InterpolatedUnivariateSpline.__call__										
scipy interpolate.InterpolatedUnivariateSpline.__call__	R	scipy.interpolate.InterpolatedUnivariateSpline.__call__										
scipy.interpolate.InterpolatedUnivariateSpline.derivative	A					[[scipy.interpolate.splder]]\\n[[scipy.interpolate.InterpolatedUnivariateSpline.antiderivative]]					<section class="prog__container"><p>Construct a new spline representing the derivative of this spline.</p><pre><code>InterpolatedUnivariateSpline.derivative(n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Order of derivative to evaluate. Default: 1</code></pre><span class="prog__sub">Returns:</span><pre><code>spline : UnivariateSpline\n    Spline of order k2=k-n representing the derivative of this spline.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 10, 70)\n>>> y = np.sin(x)\n>>> spl = UnivariateSpline(x, y, k=4, s=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.derivative.html
scipy interpolate InterpolatedUnivariateSpline derivative	R	scipy.interpolate.InterpolatedUnivariateSpline.derivative										
scipy interpolate.InterpolatedUnivariateSpline.derivative	R	scipy.interpolate.InterpolatedUnivariateSpline.derivative										
scipy.interpolate.InterpolatedUnivariateSpline.derivatives	A										<section class="prog__container"><p>Return all derivatives of the spline at the point x.</p><pre><code>InterpolatedUnivariateSpline.derivatives(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : float\n    The point to evaluate the derivatives at.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray, shape(k+1,)\n    Derivatives of the orders 0 to k.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 3, 11)\n>>> y = x**2\n>>> spl = UnivariateSpline(x, y)\n>>> spl.derivatives(1.5)\narray([2.25, 3.0, 2.0, 0])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.derivatives.html
scipy interpolate InterpolatedUnivariateSpline derivatives	R	scipy.interpolate.InterpolatedUnivariateSpline.derivatives										
scipy interpolate.InterpolatedUnivariateSpline.derivatives	R	scipy.interpolate.InterpolatedUnivariateSpline.derivatives										
scipy.interpolate.InterpolatedUnivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>InterpolatedUnivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.get_coeffs.html
scipy interpolate InterpolatedUnivariateSpline get_coeffs	R	scipy.interpolate.InterpolatedUnivariateSpline.get_coeffs										
scipy interpolate.InterpolatedUnivariateSpline.get_coeffs	R	scipy.interpolate.InterpolatedUnivariateSpline.get_coeffs										
scipy.interpolate.InterpolatedUnivariateSpline.get_knots	A										<section class="prog__container"><p>Return positions of interior knots of the spline.</p><pre><code>InterpolatedUnivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.get_knots.html
scipy interpolate InterpolatedUnivariateSpline get_knots	R	scipy.interpolate.InterpolatedUnivariateSpline.get_knots										
scipy interpolate.InterpolatedUnivariateSpline.get_knots	R	scipy.interpolate.InterpolatedUnivariateSpline.get_knots										
scipy.interpolate.InterpolatedUnivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline approximation.</p><pre><code>InterpolatedUnivariateSpline.get_residual()</code></pre><span class="prog__sub">Examples:</span><pre><code>sum((w[i] * (y[i]-spl(x[i])))**2, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.get_residual.html
scipy interpolate InterpolatedUnivariateSpline get_residual	R	scipy.interpolate.InterpolatedUnivariateSpline.get_residual										
scipy interpolate.InterpolatedUnivariateSpline.get_residual	R	scipy.interpolate.InterpolatedUnivariateSpline.get_residual										
scipy.interpolate.InterpolatedUnivariateSpline.integral	A										<section class="prog__container"><p>Return definite integral of the spline between two given points.</p><pre><code>InterpolatedUnivariateSpline.integral(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower limit of integration. \nb : float\n    Upper limit of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>integral : float\n    The value of the definite integral of the spline between limits.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 3, 11)\n>>> y = x**2\n>>> spl = UnivariateSpline(x, y)\n>>> spl.integral(0, 3)\n9.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.integral.html
scipy interpolate InterpolatedUnivariateSpline integral	R	scipy.interpolate.InterpolatedUnivariateSpline.integral										
scipy interpolate.InterpolatedUnivariateSpline.integral	R	scipy.interpolate.InterpolatedUnivariateSpline.integral										
scipy.interpolate.InterpolatedUnivariateSpline.roots	A										<section class="prog__container"><p>Return the zeros of the spline.</p><pre><code>InterpolatedUnivariateSpline.roots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.roots.html
scipy interpolate InterpolatedUnivariateSpline roots	R	scipy.interpolate.InterpolatedUnivariateSpline.roots										
scipy interpolate.InterpolatedUnivariateSpline.roots	R	scipy.interpolate.InterpolatedUnivariateSpline.roots										
scipy interpolate InterpolatedUnivariateSpline	R	scipy.interpolate.InterpolatedUnivariateSpline										
scipy interpolate.InterpolatedUnivariateSpline	R	scipy.interpolate.InterpolatedUnivariateSpline										
scipy.interpolate.InterpolatedUnivariateSpline.set_smoothing_factor	A										<section class="prog__container"><p>Continue spline computation with the given smoothing\nfactor s and with the knots found at the last call.</p><pre><code>InterpolatedUnivariateSpline.set_smoothing_factor(s)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.set_smoothing_factor.html
scipy interpolate InterpolatedUnivariateSpline set_smoothing_factor	R	scipy.interpolate.InterpolatedUnivariateSpline.set_smoothing_factor										
scipy interpolate.InterpolatedUnivariateSpline.set_smoothing_factor	R	scipy.interpolate.InterpolatedUnivariateSpline.set_smoothing_factor										
scipy.interpolate.krogh_interpolate	A					[[scipy.interpolate.KroghInterpolator]]					<section class="prog__container"><p>Convenience function for polynomial interpolation.</p><pre><code>scipy.interpolate.krogh_interpolate(xi, yi, x, der=0, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like\n    Known x-coordinates. \nyi : array_like\n    Known y-coordinates, of shape (xi.size, R).  Interpreted as vectors of length R, or scalars if R=1. \nx : array_like\n    Point or points at which to evaluate the derivatives. \nder : int or list, optional\n    How many derivatives to extract; None for all potentially nonzero derivatives (that is a number equal to the number of points), or a list of derivatives to extract. This number includes the function value as 0th derivative. \naxis : int, optional\n    Axis in the yi array corresponding to the x-coordinate values.</code></pre><span class="prog__sub">Returns:</span><pre><code>d : ndarray\n    If the interpolator’s values are R-dimensional then the returned array will be the number of derivatives by N by R. If x is a scalar, the middle dimension will be dropped; if the yi are scalars then the last dimension will be dropped.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.krogh_interpolate.html
scipy interpolate krogh_interpolate	R	scipy.interpolate.krogh_interpolate										
scipy interpolate.krogh_interpolate	R	scipy.interpolate.krogh_interpolate										
scipy.interpolate.KroghInterpolator	A										<section class="prog__container"><p>Interpolating polynomial for a set of points.</p><pre><code>class scipy.interpolate.KroghInterpolator(xi, yi, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like, length N\n    Known x-coordinates. Must be sorted in increasing order. \nyi : array_like\n    Known y-coordinates. When an xi occurs two or more times in a row, the corresponding yi’s represent derivative values. \naxis : int, optional\n    Axis in the yi array corresponding to the x-coordinate values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import KroghInterpolator\n>>> KroghInterpolator([0,0,1],[0,2,0])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.KroghInterpolator.html
scipy.interpolate.KroghInterpolator.__call__	A										<section class="prog__container"><p>Evaluate the interpolant</p><pre><code>KroghInterpolator.__call__(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.KroghInterpolator.__call__.html
scipy interpolate KroghInterpolator __call__	R	scipy.interpolate.KroghInterpolator.__call__										
scipy interpolate.KroghInterpolator.__call__	R	scipy.interpolate.KroghInterpolator.__call__										
scipy.interpolate.KroghInterpolator.derivative	A										<section class="prog__container"><p>Evaluate one derivative of the polynomial at the point x</p><pre><code>KroghInterpolator.derivative(x, der=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Point or points at which to evaluate the derivatives \nder : integer, optional\n    Which derivative to extract. This number includes the function value as 0th derivative.</code></pre><span class="prog__sub">Returns:</span><pre><code>d : ndarray\n    Derivative interpolated at the x-points.  Shape of d is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.KroghInterpolator.derivative.html
scipy interpolate KroghInterpolator derivative	R	scipy.interpolate.KroghInterpolator.derivative										
scipy interpolate.KroghInterpolator.derivative	R	scipy.interpolate.KroghInterpolator.derivative										
scipy.interpolate.KroghInterpolator.derivatives	A										<section class="prog__container"><p>Evaluate many derivatives of the polynomial at the point x</p><pre><code>KroghInterpolator.derivatives(x, der=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Point or points at which to evaluate the derivatives \nder : int or None, optional\n    How many derivatives to extract; None for all potentially nonzero derivatives (that is a number equal to the number of points). This number includes the function value as 0th derivative.</code></pre><span class="prog__sub">Returns:</span><pre><code>d : ndarray\n    Array with derivatives; d[j] contains the j-th derivative. Shape of d[j] is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import KroghInterpolator\n>>> KroghInterpolator([0,0,0],[1,2,3]).derivatives(0)\narray([1.0,2.0,3.0])\n>>> KroghInterpolator([0,0,0],[1,2,3]).derivatives([0,0])\narray([[1.0,1.0],\n       [2.0,2.0],\n       [3.0,3.0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.KroghInterpolator.derivatives.html
scipy interpolate KroghInterpolator derivatives	R	scipy.interpolate.KroghInterpolator.derivatives										
scipy interpolate.KroghInterpolator.derivatives	R	scipy.interpolate.KroghInterpolator.derivatives										
scipy interpolate KroghInterpolator	R	scipy.interpolate.KroghInterpolator										
scipy interpolate.KroghInterpolator	R	scipy.interpolate.KroghInterpolator										
scipy.interpolate.lagrange	A										<section class="prog__container"><p>Return a Lagrange interpolating polynomial.</p><pre><code>scipy.interpolate.lagrange(x, w)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    x represents the x-coordinates of a set of datapoints. \nw : array_like\n    w represents the y-coordinates of a set of datapoints, i.e. f(x).</code></pre><span class="prog__sub">Returns:</span><pre><code>lagrange : numpy.poly1d instance\n    The Lagrange interpolating polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.lagrange.html
scipy interpolate lagrange	R	scipy.interpolate.lagrange										
scipy interpolate.lagrange	R	scipy.interpolate.lagrange										
scipy.interpolate.LinearNDInterpolator	A										<section class="prog__container"><p>Piecewise linear interpolant in N dimensions.</p><pre><code>class scipy.interpolate.LinearNDInterpolator(points, values, fill_value=np.nan, rescale=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray of floats, shape (npoints, ndims); or Delaunay\n    Data point coordinates, or a precomputed Delaunay triangulation. \nvalues : ndarray of float or complex, shape (npoints, ...)\n    Data values. \nfill_value : float, optional\n    Value used to fill in for requested points outside of the convex hull of the input points.  If not provided, then the default is nan. \nrescale : bool, optional\n    Rescale points to unit cube before performing interpolation. This is useful if some of the input dimensions have incommensurable units and differ by many orders of magnitude.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LinearNDInterpolator.html
scipy.interpolate.LinearNDInterpolator.__call__	A										<section class="prog__container"><p>Evaluate interpolator at given points.</p><pre><code>LinearNDInterpolator.__call__(xi)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : ndarray of float, shape (..., ndim)\n    Points where to interpolate data at.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LinearNDInterpolator.__call__.html
scipy interpolate LinearNDInterpolator __call__	R	scipy.interpolate.LinearNDInterpolator.__call__										
scipy interpolate.LinearNDInterpolator.__call__	R	scipy.interpolate.LinearNDInterpolator.__call__										
scipy interpolate LinearNDInterpolator	R	scipy.interpolate.LinearNDInterpolator										
scipy interpolate.LinearNDInterpolator	R	scipy.interpolate.LinearNDInterpolator										
scipy.interpolate.LSQBivariateSpline	A										<section class="prog__container"><p>Weighted least-squares bivariate spline approximation.</p><pre><code>class scipy.interpolate.LSQBivariateSpline(x, y, z, tx, ty, w=None, bbox=[None, None, None, None], kx=3, ky=3, eps=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    1-D sequences of data points (order is not important). \ntx, ty : array_like\n    Strictly ordered 1-D sequences of knots coordinates. \nw : array_like, optional\n    Positive 1-D array of weights, of the same length as x, y and z. \nbbox : (4,) array_like, optional\n    Sequence of length 4 specifying the boundary of the rectangular approximation domain.  By default, bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]. \nkx, ky : ints, optional\n    Degrees of the bivariate spline. Default is 3. \neps : float, optional\n    A threshold for determining the effective rank of an over-determined linear system of equations. eps should have a value between 0 and 1, the default is 1e-16.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQBivariateSpline.html
scipy.interpolate.LSQBivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate the spline or its derivatives at given positions.</p><pre><code>LSQBivariateSpline.__call__(x, y, mth=None, dx=0, dy=0, grid=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Input coordinates. If grid is False, evaluate the spline at points (x[i], y[i]), i=0, ..., len(x)-1.  Standard Numpy broadcasting is obeyed. If grid is True: evaluate spline at the grid points defined by the coordinate arrays x, y. The arrays must be sorted to increasing order. \ndx : int\n    Order of x-derivative  New in version 0.14.0.  \ndy : int\n    Order of y-derivative  New in version 0.14.0.  \ngrid : bool\n    Whether to evaluate the results on a grid spanned by the input arrays, or at points specified by the input arrays.  New in version 0.14.0.  \nmth : str\n    Deprecated argument. Has no effect.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQBivariateSpline.__call__.html
scipy interpolate LSQBivariateSpline __call__	R	scipy.interpolate.LSQBivariateSpline.__call__										
scipy interpolate.LSQBivariateSpline.__call__	R	scipy.interpolate.LSQBivariateSpline.__call__										
scipy.interpolate.LSQBivariateSpline.ev	A										<section class="prog__container"><p>Evaluate the spline at points</p><pre><code>LSQBivariateSpline.ev(xi, yi, dx=0, dy=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi, yi : array_like\n    Input coordinates. Standard Numpy broadcasting is obeyed. \ndx : int, optional\n    Order of x-derivative  New in version 0.14.0.  \ndy : int, optional\n    Order of y-derivative  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQBivariateSpline.ev.html
scipy interpolate LSQBivariateSpline ev	R	scipy.interpolate.LSQBivariateSpline.ev										
scipy interpolate.LSQBivariateSpline.ev	R	scipy.interpolate.LSQBivariateSpline.ev										
scipy.interpolate.LSQBivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>LSQBivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQBivariateSpline.get_coeffs.html
scipy interpolate LSQBivariateSpline get_coeffs	R	scipy.interpolate.LSQBivariateSpline.get_coeffs										
scipy interpolate.LSQBivariateSpline.get_coeffs	R	scipy.interpolate.LSQBivariateSpline.get_coeffs										
scipy.interpolate.LSQBivariateSpline.get_knots	A										<section class="prog__container"><p>Return a tuple (tx,ty) where tx,ty contain knots positions\nof the spline with respect to x-, y-variable, respectively.\nThe position of interior and additional knots are given as\nt[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively.</p><pre><code>LSQBivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQBivariateSpline.get_knots.html
scipy interpolate LSQBivariateSpline get_knots	R	scipy.interpolate.LSQBivariateSpline.get_knots										
scipy interpolate.LSQBivariateSpline.get_knots	R	scipy.interpolate.LSQBivariateSpline.get_knots										
scipy.interpolate.LSQBivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline\napproximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0)</p><pre><code>LSQBivariateSpline.get_residual()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQBivariateSpline.get_residual.html
scipy interpolate LSQBivariateSpline get_residual	R	scipy.interpolate.LSQBivariateSpline.get_residual										
scipy interpolate.LSQBivariateSpline.get_residual	R	scipy.interpolate.LSQBivariateSpline.get_residual										
scipy.interpolate.LSQBivariateSpline.integral	A										<section class="prog__container"><p>Evaluate the integral of the spline over area [xa,xb] x [ya,yb].</p><pre><code>LSQBivariateSpline.integral(xa, xb, ya, yb)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xa, xb : float\n    The end-points of the x integration interval. \nya, yb : float\n    The end-points of the y integration interval.</code></pre><span class="prog__sub">Returns:</span><pre><code>integ : float\n    The value of the resulting integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQBivariateSpline.integral.html
scipy interpolate LSQBivariateSpline integral	R	scipy.interpolate.LSQBivariateSpline.integral										
scipy interpolate.LSQBivariateSpline.integral	R	scipy.interpolate.LSQBivariateSpline.integral										
scipy interpolate LSQBivariateSpline	R	scipy.interpolate.LSQBivariateSpline										
scipy interpolate.LSQBivariateSpline	R	scipy.interpolate.LSQBivariateSpline										
scipy.interpolate.LSQSphereBivariateSpline	A										<section class="prog__container"><p>Weighted least-squares bivariate spline approximation in spherical\ncoordinates.</p><pre><code>class scipy.interpolate.LSQSphereBivariateSpline(theta, phi, r, tt, tp, w=None, eps=1e-16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>theta, phi, r : array_like\n    1-D sequences of data points (order is not important). Coordinates must be given in radians. Theta must lie within the interval (0, pi), and phi must lie within the interval (0, 2pi). \ntt, tp : array_like\n    Strictly ordered 1-D sequences of knots coordinates. Coordinates must satisfy 0 < tt[i] < pi, 0 < tp[i] < 2*pi. \nw : array_like, optional\n    Positive 1-D sequence of weights, of the same length as theta, phi and r. \neps : float, optional\n    A threshold for determining the effective rank of an over-determined linear system of equations. eps should have a value between 0 and 1, the default is 1e-16.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> theta = np.linspace(0., np.pi, 7)\n>>> phi = np.linspace(0., 2*np.pi, 9)\n>>> data = np.empty((theta.shape[0], phi.shape[0]))\n>>> data[:,0], data[0,:], data[-1,:] = 0., 0., 0.\n>>> data[1:-1,1], data[1:-1,-1] = 1., 1.\n>>> data[1,1:-1], data[-2,1:-1] = 1., 1.\n>>> data[2:-2,2], data[2:-2,-2] = 2., 2.\n>>> data[2,2:-2], data[-3,2:-2] = 2., 2.\n>>> data[3,3:-2] = 3.\n>>> data = np.roll(data, 4, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQSphereBivariateSpline.html
scipy.interpolate.LSQSphereBivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate the spline or its derivatives at given positions.</p><pre><code>LSQSphereBivariateSpline.__call__(theta, phi, dtheta=0, dphi=0, grid=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>theta, phi : array_like\n    Input coordinates. If grid is False, evaluate the spline at points (theta[i], phi[i]), i=0, ..., len(x)-1.  Standard Numpy broadcasting is obeyed. If grid is True: evaluate spline at the grid points defined by the coordinate arrays theta, phi. The arrays must be sorted to increasing order. \ndtheta : int, optional\n    Order of theta-derivative  New in version 0.14.0.  \ndphi : int\n    Order of phi-derivative  New in version 0.14.0.  \ngrid : bool\n    Whether to evaluate the results on a grid spanned by the input arrays, or at points specified by the input arrays.  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQSphereBivariateSpline.__call__.html
scipy interpolate LSQSphereBivariateSpline __call__	R	scipy.interpolate.LSQSphereBivariateSpline.__call__										
scipy interpolate.LSQSphereBivariateSpline.__call__	R	scipy.interpolate.LSQSphereBivariateSpline.__call__										
scipy.interpolate.LSQSphereBivariateSpline.ev	A										<section class="prog__container"><p>Evaluate the spline at points</p><pre><code>LSQSphereBivariateSpline.ev(theta, phi, dtheta=0, dphi=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>theta, phi : array_like\n    Input coordinates. Standard Numpy broadcasting is obeyed. \ndtheta : int, optional\n    Order of theta-derivative  New in version 0.14.0.  \ndphi : int, optional\n    Order of phi-derivative  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQSphereBivariateSpline.ev.html
scipy interpolate LSQSphereBivariateSpline ev	R	scipy.interpolate.LSQSphereBivariateSpline.ev										
scipy interpolate.LSQSphereBivariateSpline.ev	R	scipy.interpolate.LSQSphereBivariateSpline.ev										
scipy.interpolate.LSQSphereBivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>LSQSphereBivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQSphereBivariateSpline.get_coeffs.html
scipy interpolate LSQSphereBivariateSpline get_coeffs	R	scipy.interpolate.LSQSphereBivariateSpline.get_coeffs										
scipy interpolate.LSQSphereBivariateSpline.get_coeffs	R	scipy.interpolate.LSQSphereBivariateSpline.get_coeffs										
scipy.interpolate.LSQSphereBivariateSpline.get_knots	A										<section class="prog__container"><p>Return a tuple (tx,ty) where tx,ty contain knots positions\nof the spline with respect to x-, y-variable, respectively.\nThe position of interior and additional knots are given as\nt[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively.</p><pre><code>LSQSphereBivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQSphereBivariateSpline.get_knots.html
scipy interpolate LSQSphereBivariateSpline get_knots	R	scipy.interpolate.LSQSphereBivariateSpline.get_knots										
scipy interpolate.LSQSphereBivariateSpline.get_knots	R	scipy.interpolate.LSQSphereBivariateSpline.get_knots										
scipy.interpolate.LSQSphereBivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline\napproximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0)</p><pre><code>LSQSphereBivariateSpline.get_residual()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQSphereBivariateSpline.get_residual.html
scipy interpolate LSQSphereBivariateSpline get_residual	R	scipy.interpolate.LSQSphereBivariateSpline.get_residual										
scipy interpolate.LSQSphereBivariateSpline.get_residual	R	scipy.interpolate.LSQSphereBivariateSpline.get_residual										
scipy interpolate LSQSphereBivariateSpline	R	scipy.interpolate.LSQSphereBivariateSpline										
scipy interpolate.LSQSphereBivariateSpline	R	scipy.interpolate.LSQSphereBivariateSpline										
scipy.interpolate.LSQUnivariateSpline.antiderivative	A					[[scipy.interpolate.splantider]]\\n[[scipy.interpolate.LSQUnivariateSpline.derivative]]					<section class="prog__container"><p>Construct a new spline representing the antiderivative of this spline.</p><pre><code>LSQUnivariateSpline.antiderivative(n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Order of antiderivative to evaluate. Default: 1</code></pre><span class="prog__sub">Returns:</span><pre><code>spline : UnivariateSpline\n    Spline of order k2=k+n representing the antiderivative of this spline.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, np.pi/2, 70)\n>>> y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2)\n>>> spl = UnivariateSpline(x, y, s=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.antiderivative.html
scipy interpolate LSQUnivariateSpline antiderivative	R	scipy.interpolate.LSQUnivariateSpline.antiderivative										
scipy interpolate.LSQUnivariateSpline.antiderivative	R	scipy.interpolate.LSQUnivariateSpline.antiderivative										
scipy.interpolate.LSQUnivariateSpline	A										<section class="prog__container"><p>One-dimensional spline with explicit internal knots.</p><pre><code>class scipy.interpolate.LSQUnivariateSpline(x, y, t, w=None, bbox=[None, None], k=3, ext=0, check_finite=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (N,) array_like\n    Input dimension of data points – must be increasing \ny : (N,) array_like\n    Input dimension of data points \nt : (M,) array_like\n    interior knots of the spline.  Must be in ascending order and: bbox[0] < t[0] < ... < t[-1] < bbox[-1]   \nw : (N,) array_like, optional\n    weights for spline fitting.  Must be positive.  If None (default), weights are all equal. \nbbox : (2,) array_like, optional\n    2-sequence specifying the boundary of the approximation interval. If None (default), bbox = [x[0], x[-1]]. \nk : int, optional\n    Degree of the smoothing spline.  Must be 1 <= k <= 5. Default is k=3, a cubic spline. \next : int or str, optional\n    Controls the extrapolation mode for elements not in the interval defined by the knot sequence.  if ext=0 or ‘extrapolate’, return the extrapolated value. if ext=1 or ‘zeros’, return 0 if ext=2 or ‘raise’, raise a ValueError if ext=3 of ‘const’, return the boundary value.  The default value is 0. \ncheck_finite : bool, optional\n    Whether to check that the input arrays contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination or non-sensical results) if the inputs do contain infinities or NaNs. Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>ValueError\n    If the interior knots do not satisfy the Schoenberg-Whitney conditions</code></pre><span class="prog__sub">Examples:</span><pre><code>bbox[0] < t[0] < ... < t[-1] < bbox[-1]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.html
scipy.interpolate.LSQUnivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate spline (or its nu-th derivative) at positions x.</p><pre><code>LSQUnivariateSpline.__call__(x, nu=0, ext=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D array of points at which to return the value of the smoothed spline or its derivatives. Note: x can be unordered but the evaluation is more efficient if x is (partially) ordered. \nnu : int\n    The order of derivative of the spline to compute. \next : int\n    Controls the value returned for elements of x not in the interval defined by the knot sequence.  if ext=0 or ‘extrapolate’, return the extrapolated value. if ext=1 or ‘zeros’, return 0 if ext=2 or ‘raise’, raise a ValueError if ext=3 or ‘const’, return the boundary value.  The default value is 0, passed from the initialization of UnivariateSpline.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.__call__.html
scipy interpolate LSQUnivariateSpline __call__	R	scipy.interpolate.LSQUnivariateSpline.__call__										
scipy interpolate.LSQUnivariateSpline.__call__	R	scipy.interpolate.LSQUnivariateSpline.__call__										
scipy.interpolate.LSQUnivariateSpline.derivative	A					[[scipy.interpolate.splder]]\\n[[scipy.interpolate.LSQUnivariateSpline.antiderivative]]					<section class="prog__container"><p>Construct a new spline representing the derivative of this spline.</p><pre><code>LSQUnivariateSpline.derivative(n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Order of derivative to evaluate. Default: 1</code></pre><span class="prog__sub">Returns:</span><pre><code>spline : UnivariateSpline\n    Spline of order k2=k-n representing the derivative of this spline.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 10, 70)\n>>> y = np.sin(x)\n>>> spl = UnivariateSpline(x, y, k=4, s=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.derivative.html
scipy interpolate LSQUnivariateSpline derivative	R	scipy.interpolate.LSQUnivariateSpline.derivative										
scipy interpolate.LSQUnivariateSpline.derivative	R	scipy.interpolate.LSQUnivariateSpline.derivative										
scipy.interpolate.LSQUnivariateSpline.derivatives	A										<section class="prog__container"><p>Return all derivatives of the spline at the point x.</p><pre><code>LSQUnivariateSpline.derivatives(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : float\n    The point to evaluate the derivatives at.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray, shape(k+1,)\n    Derivatives of the orders 0 to k.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 3, 11)\n>>> y = x**2\n>>> spl = UnivariateSpline(x, y)\n>>> spl.derivatives(1.5)\narray([2.25, 3.0, 2.0, 0])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.derivatives.html
scipy interpolate LSQUnivariateSpline derivatives	R	scipy.interpolate.LSQUnivariateSpline.derivatives										
scipy interpolate.LSQUnivariateSpline.derivatives	R	scipy.interpolate.LSQUnivariateSpline.derivatives										
scipy.interpolate.LSQUnivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>LSQUnivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.get_coeffs.html
scipy interpolate LSQUnivariateSpline get_coeffs	R	scipy.interpolate.LSQUnivariateSpline.get_coeffs										
scipy interpolate.LSQUnivariateSpline.get_coeffs	R	scipy.interpolate.LSQUnivariateSpline.get_coeffs										
scipy.interpolate.LSQUnivariateSpline.get_knots	A										<section class="prog__container"><p>Return positions of interior knots of the spline.</p><pre><code>LSQUnivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.get_knots.html
scipy interpolate LSQUnivariateSpline get_knots	R	scipy.interpolate.LSQUnivariateSpline.get_knots										
scipy interpolate.LSQUnivariateSpline.get_knots	R	scipy.interpolate.LSQUnivariateSpline.get_knots										
scipy.interpolate.LSQUnivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline approximation.</p><pre><code>LSQUnivariateSpline.get_residual()</code></pre><span class="prog__sub">Examples:</span><pre><code>sum((w[i] * (y[i]-spl(x[i])))**2, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.get_residual.html
scipy interpolate LSQUnivariateSpline get_residual	R	scipy.interpolate.LSQUnivariateSpline.get_residual										
scipy interpolate.LSQUnivariateSpline.get_residual	R	scipy.interpolate.LSQUnivariateSpline.get_residual										
scipy.interpolate.LSQUnivariateSpline.integral	A										<section class="prog__container"><p>Return definite integral of the spline between two given points.</p><pre><code>LSQUnivariateSpline.integral(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower limit of integration. \nb : float\n    Upper limit of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>integral : float\n    The value of the definite integral of the spline between limits.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 3, 11)\n>>> y = x**2\n>>> spl = UnivariateSpline(x, y)\n>>> spl.integral(0, 3)\n9.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.integral.html
scipy interpolate LSQUnivariateSpline integral	R	scipy.interpolate.LSQUnivariateSpline.integral										
scipy interpolate.LSQUnivariateSpline.integral	R	scipy.interpolate.LSQUnivariateSpline.integral										
scipy.interpolate.LSQUnivariateSpline.roots	A										<section class="prog__container"><p>Return the zeros of the spline.</p><pre><code>LSQUnivariateSpline.roots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.roots.html
scipy interpolate LSQUnivariateSpline roots	R	scipy.interpolate.LSQUnivariateSpline.roots										
scipy interpolate.LSQUnivariateSpline.roots	R	scipy.interpolate.LSQUnivariateSpline.roots										
scipy interpolate LSQUnivariateSpline	R	scipy.interpolate.LSQUnivariateSpline										
scipy interpolate.LSQUnivariateSpline	R	scipy.interpolate.LSQUnivariateSpline										
scipy.interpolate.LSQUnivariateSpline.set_smoothing_factor	A										<section class="prog__container"><p>Continue spline computation with the given smoothing\nfactor s and with the knots found at the last call.</p><pre><code>LSQUnivariateSpline.set_smoothing_factor(s)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.LSQUnivariateSpline.set_smoothing_factor.html
scipy interpolate LSQUnivariateSpline set_smoothing_factor	R	scipy.interpolate.LSQUnivariateSpline.set_smoothing_factor										
scipy interpolate.LSQUnivariateSpline.set_smoothing_factor	R	scipy.interpolate.LSQUnivariateSpline.set_smoothing_factor										
scipy.interpolate.NearestNDInterpolator	A										<section class="prog__container"><p>Nearest-neighbour interpolation in N dimensions.</p><pre><code>class scipy.interpolate.NearestNDInterpolator(points, values)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (Npoints, Ndims) ndarray of floats\n    Data point coordinates. \ny : (Npoints,) ndarray of float or complex\n    Data values. \nrescale : boolean, optional\n    Rescale points to unit cube before performing interpolation. This is useful if some of the input dimensions have incommensurable units and differ by many orders of magnitude.  New in version 0.14.0.  \ntree_options : dict, optional\n    Options passed to the underlying cKDTree.  New in version 0.17.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.NearestNDInterpolator.html
scipy.interpolate.NearestNDInterpolator.__call__	A										<section class="prog__container"><p>Evaluate interpolator at given points.</p><pre><code>NearestNDInterpolator.__call__(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : ndarray of float, shape (..., ndim)\n    Points where to interpolate data at.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.NearestNDInterpolator.__call__.html
scipy interpolate NearestNDInterpolator __call__	R	scipy.interpolate.NearestNDInterpolator.__call__										
scipy interpolate.NearestNDInterpolator.__call__	R	scipy.interpolate.NearestNDInterpolator.__call__										
scipy interpolate NearestNDInterpolator	R	scipy.interpolate.NearestNDInterpolator										
scipy interpolate.NearestNDInterpolator	R	scipy.interpolate.NearestNDInterpolator										
scipy.interpolate.pchip.antiderivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the antiderivative.</p><pre><code>pchip.antiderivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of antiderivative to evaluate. Default is 1, i.e. compute the first integral. If negative, the derivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>bp : BPoly\n    Piecewise polynomial of order k + nu representing the antiderivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.antiderivative.html
scipy interpolate pchip antiderivative	R	scipy.interpolate.pchip.antiderivative										
scipy interpolate.pchip.antiderivative	R	scipy.interpolate.pchip.antiderivative										
scipy.interpolate.pchip	A										<section class="prog__container"><p>alias of PchipInterpolator</p><pre><code>scipy.interpolate.pchip</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.html
scipy.interpolate.pchip.__call__	A										<section class="prog__container"><p>Evaluate the piecewise polynomial or its derivative.</p><pre><code>pchip.__call__(x, nu=0, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at. \nnu : int, optional\n    Order of derivative to evaluate. Must be non-negative. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.__call__.html
scipy interpolate pchip __call__	R	scipy.interpolate.pchip.__call__										
scipy interpolate.pchip.__call__	R	scipy.interpolate.pchip.__call__										
scipy.interpolate.pchip.construct_fast	A										<section class="prog__container"><p>Construct the piecewise polynomial without making checks.</p><pre><code>classmethod pchip.construct_fast(c, x, extrapolate=None, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.construct_fast.html
scipy interpolate pchip construct_fast	R	scipy.interpolate.pchip.construct_fast										
scipy interpolate.pchip.construct_fast	R	scipy.interpolate.pchip.construct_fast										
scipy.interpolate.pchip.derivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the derivative.</p><pre><code>pchip.derivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of derivative to evaluate. Default is 1, i.e. compute the first derivative. If negative, the antiderivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>bp : BPoly\n    Piecewise polynomial of order k - nu representing the derivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.derivative.html
scipy interpolate pchip derivative	R	scipy.interpolate.pchip.derivative										
scipy interpolate.pchip.derivative	R	scipy.interpolate.pchip.derivative										
scipy.interpolate.pchip.extend	A										<section class="prog__container"><p>Add additional breakpoints and coefficients to the polynomial.</p><pre><code>pchip.extend(c, x, right=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : ndarray, size (k, m, ...)\n    Additional coefficients for polynomials in intervals self.x[-1] <= x < x_right[0], x_right[0] <= x < x_right[1], ..., x_right[m-2] <= x < x_right[m-1] \nx : ndarray, size (m,)\n    Additional breakpoints. Must be sorted and either to the right or to the left of the current breakpoints. \nright : bool, optional\n    Whether the new intervals are to the right or to the left of the current intervals.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.extend.html
scipy interpolate pchip extend	R	scipy.interpolate.pchip.extend										
scipy interpolate.pchip.extend	R	scipy.interpolate.pchip.extend										
scipy.interpolate.pchip.from_derivatives	A										<section class="prog__container"><p>Construct a piecewise polynomial in the Bernstein basis,\ncompatible with the specified values and derivatives at breakpoints.</p><pre><code>classmethod pchip.from_derivatives(xi, yi, orders=None, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like\n    sorted 1D array of x-coordinates \nyi : array_like or list of array_likes\n    yi[i][j] is the j-th derivative known at xi[i] \norders : None or int or array_like of ints. Default: None.\n    Specifies the degree of local polynomials. If not None, some derivatives are ignored. \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import BPoly\n>>> BPoly.from_derivatives([0, 1], [[1, 2], [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.from_derivatives.html
scipy interpolate pchip from_derivatives	R	scipy.interpolate.pchip.from_derivatives										
scipy interpolate.pchip.from_derivatives	R	scipy.interpolate.pchip.from_derivatives										
scipy.interpolate.pchip.from_power_basis	A										<section class="prog__container"><p>Construct a piecewise polynomial in Bernstein basis\nfrom a power basis polynomial.</p><pre><code>classmethod pchip.from_power_basis(pp, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pp : PPoly\n    A piecewise polynomial in the power basis \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.from_power_basis.html
scipy interpolate pchip from_power_basis	R	scipy.interpolate.pchip.from_power_basis										
scipy interpolate.pchip.from_power_basis	R	scipy.interpolate.pchip.from_power_basis										
scipy.interpolate.pchip.integrate	A										<section class="prog__container"><p>Compute a definite integral over a piecewise polynomial.</p><pre><code>pchip.integrate(a, b, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower integration bound \nb : float\n    Upper integration bound \nextrapolate : {bool, ‘periodic’, None}, optional\n    Whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>array_like\n    Definite integral of the piecewise polynomial over [a, b]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.integrate.html
scipy interpolate pchip integrate	R	scipy.interpolate.pchip.integrate										
scipy interpolate.pchip.integrate	R	scipy.interpolate.pchip.integrate										
scipy.interpolate.pchip_interpolate	A					[[scipy.interpolate.PchipInterpolator]]					<section class="prog__container"><p>Convenience function for pchip interpolation.\nxi and yi are arrays of values used to approximate some function f,\nwith yi = f(xi).  The interpolant uses monotonic cubic splines\nto find the value of new points x and the derivatives there.</p><pre><code>scipy.interpolate.pchip_interpolate(xi, yi, x, der=0, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like\n    A sorted list of x-coordinates, of length N. \nyi :  array_like\n    A 1-D array of real values.  yi‘s length along the interpolation axis must be equal to the length of xi. If N-D array, use axis parameter to select correct axis. \nx : scalar or array_like\n    Of length M. \nder : int or list, optional\n    Derivatives to extract.  The 0-th derivative can be included to return the function value. \naxis : int, optional\n    Axis in the yi array corresponding to the x-coordinate values.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : scalar or array_like\n    The result, of length R or length M or M by R,</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip_interpolate.html
scipy interpolate pchip_interpolate	R	scipy.interpolate.pchip_interpolate										
scipy interpolate.pchip_interpolate	R	scipy.interpolate.pchip_interpolate										
scipy.interpolate.PchipInterpolator.antiderivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the antiderivative.</p><pre><code>PchipInterpolator.antiderivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of antiderivative to evaluate. Default is 1, i.e. compute the first integral. If negative, the derivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>bp : BPoly\n    Piecewise polynomial of order k + nu representing the antiderivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.antiderivative.html
scipy interpolate PchipInterpolator antiderivative	R	scipy.interpolate.PchipInterpolator.antiderivative										
scipy interpolate.PchipInterpolator.antiderivative	R	scipy.interpolate.PchipInterpolator.antiderivative										
scipy.interpolate.PchipInterpolator	A					[[scipy.interpolate.Akima1DInterpolator]]\\n[[scipy.interpolate.CubicSpline]]\\n[[scipy.interpolate.BPoly]]					<section class="prog__container"><p>PCHIP 1-d monotonic cubic interpolation.</p><pre><code>class scipy.interpolate.PchipInterpolator(x, y, axis=0, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    A 1-D array of monotonically increasing real values.  x cannot include duplicate values (otherwise f is overspecified) \ny : ndarray\n    A 1-D array of real values. y‘s length along the interpolation axis must be equal to the length of x. If N-D array, use axis parameter to select correct axis. \naxis : int, optional\n    Axis in the y array corresponding to the x-coordinate values. \nextrapolate : bool, optional\n    Whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.html
scipy.interpolate.PchipInterpolator.__call__	A										<section class="prog__container"><p>Evaluate the piecewise polynomial or its derivative.</p><pre><code>PchipInterpolator.__call__(x, nu=0, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at. \nnu : int, optional\n    Order of derivative to evaluate. Must be non-negative. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.__call__.html
scipy interpolate PchipInterpolator __call__	R	scipy.interpolate.PchipInterpolator.__call__										
scipy interpolate.PchipInterpolator.__call__	R	scipy.interpolate.PchipInterpolator.__call__										
scipy.interpolate.PchipInterpolator.construct_fast	A										<section class="prog__container"><p>Construct the piecewise polynomial without making checks.</p><pre><code>classmethod PchipInterpolator.construct_fast(c, x, extrapolate=None, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.construct_fast.html
scipy interpolate PchipInterpolator construct_fast	R	scipy.interpolate.PchipInterpolator.construct_fast										
scipy interpolate.PchipInterpolator.construct_fast	R	scipy.interpolate.PchipInterpolator.construct_fast										
scipy.interpolate.PchipInterpolator.derivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the derivative.</p><pre><code>PchipInterpolator.derivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of derivative to evaluate. Default is 1, i.e. compute the first derivative. If negative, the antiderivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>bp : BPoly\n    Piecewise polynomial of order k - nu representing the derivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.derivative.html
scipy interpolate PchipInterpolator derivative	R	scipy.interpolate.PchipInterpolator.derivative										
scipy interpolate.PchipInterpolator.derivative	R	scipy.interpolate.PchipInterpolator.derivative										
scipy.interpolate.PchipInterpolator.extend	A										<section class="prog__container"><p>Add additional breakpoints and coefficients to the polynomial.</p><pre><code>PchipInterpolator.extend(c, x, right=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : ndarray, size (k, m, ...)\n    Additional coefficients for polynomials in intervals self.x[-1] <= x < x_right[0], x_right[0] <= x < x_right[1], ..., x_right[m-2] <= x < x_right[m-1] \nx : ndarray, size (m,)\n    Additional breakpoints. Must be sorted and either to the right or to the left of the current breakpoints. \nright : bool, optional\n    Whether the new intervals are to the right or to the left of the current intervals.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.extend.html
scipy interpolate PchipInterpolator extend	R	scipy.interpolate.PchipInterpolator.extend										
scipy interpolate.PchipInterpolator.extend	R	scipy.interpolate.PchipInterpolator.extend										
scipy.interpolate.PchipInterpolator.from_derivatives	A										<section class="prog__container"><p>Construct a piecewise polynomial in the Bernstein basis,\ncompatible with the specified values and derivatives at breakpoints.</p><pre><code>classmethod PchipInterpolator.from_derivatives(xi, yi, orders=None, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : array_like\n    sorted 1D array of x-coordinates \nyi : array_like or list of array_likes\n    yi[i][j] is the j-th derivative known at xi[i] \norders : None or int or array_like of ints. Default: None.\n    Specifies the degree of local polynomials. If not None, some derivatives are ignored. \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import BPoly\n>>> BPoly.from_derivatives([0, 1], [[1, 2], [3, 4]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.from_derivatives.html
scipy interpolate PchipInterpolator from_derivatives	R	scipy.interpolate.PchipInterpolator.from_derivatives										
scipy interpolate.PchipInterpolator.from_derivatives	R	scipy.interpolate.PchipInterpolator.from_derivatives										
scipy.interpolate.PchipInterpolator.from_power_basis	A										<section class="prog__container"><p>Construct a piecewise polynomial in Bernstein basis\nfrom a power basis polynomial.</p><pre><code>classmethod PchipInterpolator.from_power_basis(pp, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pp : PPoly\n    A piecewise polynomial in the power basis \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.from_power_basis.html
scipy interpolate PchipInterpolator from_power_basis	R	scipy.interpolate.PchipInterpolator.from_power_basis										
scipy interpolate.PchipInterpolator.from_power_basis	R	scipy.interpolate.PchipInterpolator.from_power_basis										
scipy.interpolate.PchipInterpolator.integrate	A										<section class="prog__container"><p>Compute a definite integral over a piecewise polynomial.</p><pre><code>PchipInterpolator.integrate(a, b, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower integration bound \nb : float\n    Upper integration bound \nextrapolate : {bool, ‘periodic’, None}, optional\n    Whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>array_like\n    Definite integral of the piecewise polynomial over [a, b]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.integrate.html
scipy interpolate PchipInterpolator integrate	R	scipy.interpolate.PchipInterpolator.integrate										
scipy interpolate.PchipInterpolator.integrate	R	scipy.interpolate.PchipInterpolator.integrate										
scipy.interpolate.PchipInterpolator.roots	A										<section class="prog__container"><p>Return the roots of the interpolated function.</p><pre><code>PchipInterpolator.roots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PchipInterpolator.roots.html
scipy interpolate PchipInterpolator roots	R	scipy.interpolate.PchipInterpolator.roots										
scipy interpolate.PchipInterpolator.roots	R	scipy.interpolate.PchipInterpolator.roots										
scipy interpolate PchipInterpolator	R	scipy.interpolate.PchipInterpolator										
scipy interpolate.PchipInterpolator	R	scipy.interpolate.PchipInterpolator										
scipy.interpolate.pchip.roots	A										<section class="prog__container"><p>Return the roots of the interpolated function.</p><pre><code>pchip.roots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.pchip.roots.html
scipy interpolate pchip roots	R	scipy.interpolate.pchip.roots										
scipy interpolate.pchip.roots	R	scipy.interpolate.pchip.roots										
scipy interpolate pchip	R	scipy.interpolate.pchip										
scipy interpolate.pchip	R	scipy.interpolate.pchip										
scipy.interpolate.ppform.antiderivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the antiderivative.</p><pre><code>ppform.antiderivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of antiderivative to evaluate. Default is 1, i.e. compute the first integral. If negative, the derivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>pp : PPoly\n    Piecewise polynomial of order k2 = k + n representing the antiderivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.antiderivative.html
scipy interpolate ppform antiderivative	R	scipy.interpolate.ppform.antiderivative										
scipy interpolate.ppform.antiderivative	R	scipy.interpolate.ppform.antiderivative										
scipy.interpolate.ppform	A										<section class="prog__container"><p>Deprecated piecewise polynomial class.</p><pre><code>class scipy.interpolate.ppform(coeffs, breaks, fill=0.0, sort=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.html
scipy.interpolate.ppform.construct_fast	A										<section class="prog__container"><p>Construct the piecewise polynomial without making checks.</p><pre><code>classmethod ppform.construct_fast(c, x, extrapolate=None, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.construct_fast.html
scipy interpolate ppform construct_fast	R	scipy.interpolate.ppform.construct_fast										
scipy interpolate.ppform.construct_fast	R	scipy.interpolate.ppform.construct_fast										
scipy.interpolate.ppform.derivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the derivative.</p><pre><code>ppform.derivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of derivative to evaluate. Default is 1, i.e. compute the first derivative. If negative, the antiderivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>pp : PPoly\n    Piecewise polynomial of order k2 = k - n representing the derivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.derivative.html
scipy interpolate ppform derivative	R	scipy.interpolate.ppform.derivative										
scipy interpolate.ppform.derivative	R	scipy.interpolate.ppform.derivative										
scipy.interpolate.ppform.extend	A										<section class="prog__container"><p>Add additional breakpoints and coefficients to the polynomial.</p><pre><code>ppform.extend(c, x, right=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : ndarray, size (k, m, ...)\n    Additional coefficients for polynomials in intervals self.x[-1] <= x < x_right[0], x_right[0] <= x < x_right[1], ..., x_right[m-2] <= x < x_right[m-1] \nx : ndarray, size (m,)\n    Additional breakpoints. Must be sorted and either to the right or to the left of the current breakpoints. \nright : bool, optional\n    Whether the new intervals are to the right or to the left of the current intervals.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.extend.html
scipy interpolate ppform extend	R	scipy.interpolate.ppform.extend										
scipy interpolate.ppform.extend	R	scipy.interpolate.ppform.extend										
scipy.interpolate.ppform.from_bernstein_basis	A										<section class="prog__container"><p>Construct a piecewise polynomial in the power basis\nfrom a polynomial in Bernstein basis.</p><pre><code>classmethod ppform.from_bernstein_basis(bp, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>bp : BPoly\n    A Bernstein basis polynomial, as created by BPoly \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.from_bernstein_basis.html
scipy interpolate ppform from_bernstein_basis	R	scipy.interpolate.ppform.from_bernstein_basis										
scipy interpolate.ppform.from_bernstein_basis	R	scipy.interpolate.ppform.from_bernstein_basis										
scipy.interpolate.ppform.from_spline	A										<section class="prog__container"><p>Construct a piecewise polynomial from a spline</p><pre><code>classmethod ppform.from_spline(tck, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tck\n    A spline, as returned by splrep \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.from_spline.html
scipy interpolate ppform from_spline	R	scipy.interpolate.ppform.from_spline										
scipy interpolate.ppform.from_spline	R	scipy.interpolate.ppform.from_spline										
scipy.interpolate.ppform.integrate	A										<section class="prog__container"><p>Compute a definite integral over a piecewise polynomial.</p><pre><code>ppform.integrate(a, b, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower integration bound \nb : float\n    Upper integration bound \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>ig : array_like\n    Definite integral of the piecewise polynomial over [a, b]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.integrate.html
scipy interpolate ppform integrate	R	scipy.interpolate.ppform.integrate										
scipy interpolate.ppform.integrate	R	scipy.interpolate.ppform.integrate										
scipy.interpolate.ppform.roots	A					[[scipy.interpolate.PPoly.solve]]					<section class="prog__container"><p>Find real roots of the the piecewise polynomial.</p><pre><code>ppform.roots(discontinuity=True, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>discontinuity : bool, optional\n    Whether to report sign changes across discontinuities at breakpoints as roots. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to return roots from the polynomial extrapolated based on first and last intervals, ‘periodic’ works the same as False. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>roots : ndarray\n    Roots of the polynomial(s). If the PPoly object describes multiple polynomials, the return value is an object array whose each element is an ndarray containing the roots.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.roots.html
scipy interpolate ppform roots	R	scipy.interpolate.ppform.roots										
scipy interpolate.ppform.roots	R	scipy.interpolate.ppform.roots										
scipy interpolate ppform	R	scipy.interpolate.ppform										
scipy interpolate.ppform	R	scipy.interpolate.ppform										
scipy.interpolate.ppform.solve	A										<section class="prog__container"><p>Find real solutions of the the equation pp(x) == y.</p><pre><code>ppform.solve(y=0.0, discontinuity=True, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : float, optional\n    Right-hand side. Default is zero. \ndiscontinuity : bool, optional\n    Whether to report sign changes across discontinuities at breakpoints as roots. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to return roots from the polynomial extrapolated based on first and last intervals, ‘periodic’ works the same as False. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>roots : ndarray\n    Roots of the polynomial(s). If the PPoly object describes multiple polynomials, the return value is an object array whose each element is an ndarray containing the roots.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import PPoly\n>>> pp = PPoly(np.array([[1, -4, 3], [1, 0, 0]]).T, [-2, 1, 2])\n>>> pp.roots()\narray([-1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.ppform.solve.html
scipy interpolate ppform solve	R	scipy.interpolate.ppform.solve										
scipy interpolate.ppform.solve	R	scipy.interpolate.ppform.solve										
scipy.interpolate.PPoly.antiderivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the antiderivative.</p><pre><code>PPoly.antiderivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of antiderivative to evaluate. Default is 1, i.e. compute the first integral. If negative, the derivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>pp : PPoly\n    Piecewise polynomial of order k2 = k + n representing the antiderivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.antiderivative.html
scipy interpolate PPoly antiderivative	R	scipy.interpolate.PPoly.antiderivative										
scipy interpolate.PPoly.antiderivative	R	scipy.interpolate.PPoly.antiderivative										
scipy.interpolate.PPoly	A										<section class="prog__container"><p>Piecewise polynomial in terms of coefficients and breakpoints</p><pre><code>class scipy.interpolate.PPoly(c, x, extrapolate=None, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : ndarray, shape (k, m, ...)\n    Polynomial coefficients, order k and m intervals \nx : ndarray, shape (m+1,)\n    Polynomial breakpoints. These must be sorted in increasing order. \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True. \naxis : int, optional\n    Interpolation axis. Default is zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>S = sum(c[m, i] * (xp - x[i])**(k-m) for m in range(k+1))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.html
scipy.interpolate.PPoly.__call__	A										<section class="prog__container"><p>Evaluate the piecewise polynomial or its derivative.</p><pre><code>PPoly.__call__(x, nu=0, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Points to evaluate the interpolant at. \nnu : int, optional\n    Order of derivative to evaluate. Must be non-negative. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array_like\n    Interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.__call__.html
scipy interpolate PPoly __call__	R	scipy.interpolate.PPoly.__call__										
scipy interpolate.PPoly.__call__	R	scipy.interpolate.PPoly.__call__										
scipy.interpolate.PPoly.construct_fast	A										<section class="prog__container"><p>Construct the piecewise polynomial without making checks.</p><pre><code>classmethod PPoly.construct_fast(c, x, extrapolate=None, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.construct_fast.html
scipy interpolate PPoly construct_fast	R	scipy.interpolate.PPoly.construct_fast										
scipy interpolate.PPoly.construct_fast	R	scipy.interpolate.PPoly.construct_fast										
scipy.interpolate.PPoly.derivative	A										<section class="prog__container"><p>Construct a new piecewise polynomial representing the derivative.</p><pre><code>PPoly.derivative(nu=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nu : int, optional\n    Order of derivative to evaluate. Default is 1, i.e. compute the first derivative. If negative, the antiderivative is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>pp : PPoly\n    Piecewise polynomial of order k2 = k - n representing the derivative of this polynomial.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.derivative.html
scipy interpolate PPoly derivative	R	scipy.interpolate.PPoly.derivative										
scipy interpolate.PPoly.derivative	R	scipy.interpolate.PPoly.derivative										
scipy.interpolate.PPoly.extend	A										<section class="prog__container"><p>Add additional breakpoints and coefficients to the polynomial.</p><pre><code>PPoly.extend(c, x, right=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : ndarray, size (k, m, ...)\n    Additional coefficients for polynomials in intervals self.x[-1] <= x < x_right[0], x_right[0] <= x < x_right[1], ..., x_right[m-2] <= x < x_right[m-1] \nx : ndarray, size (m,)\n    Additional breakpoints. Must be sorted and either to the right or to the left of the current breakpoints. \nright : bool, optional\n    Whether the new intervals are to the right or to the left of the current intervals.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.extend.html
scipy interpolate PPoly extend	R	scipy.interpolate.PPoly.extend										
scipy interpolate.PPoly.extend	R	scipy.interpolate.PPoly.extend										
scipy.interpolate.PPoly.from_bernstein_basis	A										<section class="prog__container"><p>Construct a piecewise polynomial in the power basis\nfrom a polynomial in Bernstein basis.</p><pre><code>classmethod PPoly.from_bernstein_basis(bp, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>bp : BPoly\n    A Bernstein basis polynomial, as created by BPoly \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.from_bernstein_basis.html
scipy interpolate PPoly from_bernstein_basis	R	scipy.interpolate.PPoly.from_bernstein_basis										
scipy interpolate.PPoly.from_bernstein_basis	R	scipy.interpolate.PPoly.from_bernstein_basis										
scipy.interpolate.PPoly.from_spline	A										<section class="prog__container"><p>Construct a piecewise polynomial from a spline</p><pre><code>classmethod PPoly.from_spline(tck, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tck\n    A spline, as returned by splrep \nextrapolate : bool or ‘periodic’, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. Default is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.from_spline.html
scipy interpolate PPoly from_spline	R	scipy.interpolate.PPoly.from_spline										
scipy interpolate.PPoly.from_spline	R	scipy.interpolate.PPoly.from_spline										
scipy.interpolate.PPoly.integrate	A										<section class="prog__container"><p>Compute a definite integral over a piecewise polynomial.</p><pre><code>PPoly.integrate(a, b, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower integration bound \nb : float\n    Upper integration bound \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to extrapolate to out-of-bounds points based on first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation is used. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>ig : array_like\n    Definite integral of the piecewise polynomial over [a, b]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.integrate.html
scipy interpolate PPoly integrate	R	scipy.interpolate.PPoly.integrate										
scipy interpolate.PPoly.integrate	R	scipy.interpolate.PPoly.integrate										
scipy.interpolate.PPoly.roots	A					[[scipy.interpolate.PPoly.solve]]					<section class="prog__container"><p>Find real roots of the the piecewise polynomial.</p><pre><code>PPoly.roots(discontinuity=True, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>discontinuity : bool, optional\n    Whether to report sign changes across discontinuities at breakpoints as roots. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to return roots from the polynomial extrapolated based on first and last intervals, ‘periodic’ works the same as False. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>roots : ndarray\n    Roots of the polynomial(s). If the PPoly object describes multiple polynomials, the return value is an object array whose each element is an ndarray containing the roots.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.roots.html
scipy interpolate PPoly roots	R	scipy.interpolate.PPoly.roots										
scipy interpolate.PPoly.roots	R	scipy.interpolate.PPoly.roots										
scipy interpolate PPoly	R	scipy.interpolate.PPoly										
scipy interpolate.PPoly	R	scipy.interpolate.PPoly										
scipy.interpolate.PPoly.solve	A										<section class="prog__container"><p>Find real solutions of the the equation pp(x) == y.</p><pre><code>PPoly.solve(y=0.0, discontinuity=True, extrapolate=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : float, optional\n    Right-hand side. Default is zero. \ndiscontinuity : bool, optional\n    Whether to report sign changes across discontinuities at breakpoints as roots. \nextrapolate : {bool, ‘periodic’, None}, optional\n    If bool, determines whether to return roots from the polynomial extrapolated based on first and last intervals, ‘periodic’ works the same as False. If None (default), use self.extrapolate.</code></pre><span class="prog__sub">Returns:</span><pre><code>roots : ndarray\n    Roots of the polynomial(s). If the PPoly object describes multiple polynomials, the return value is an object array whose each element is an ndarray containing the roots.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import PPoly\n>>> pp = PPoly(np.array([[1, -4, 3], [1, 0, 0]]).T, [-2, 1, 2])\n>>> pp.roots()\narray([-1.,  1.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.PPoly.solve.html
scipy interpolate PPoly solve	R	scipy.interpolate.PPoly.solve										
scipy interpolate.PPoly.solve	R	scipy.interpolate.PPoly.solve										
scipy.interpolate.Rbf	A										<section class="prog__container"><p>A class for radial basis function approximation/interpolation of\nn-dimensional scattered data.</p><pre><code>class scipy.interpolate.Rbf(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*args : arrays\n    x, y, z, ..., d, where x, y, z, ... are the coordinates of the nodes and d is the array of values at the nodes \nfunction : str or callable, optional\n    The radial basis function, based on the radius, r, given by the norm (default is Euclidean distance); the default is ‘multiquadric’: 'multiquadric': sqrt((r/self.epsilon)**2 + 1) 'inverse': 1.0/sqrt((r/self.epsilon)**2 + 1) 'gaussian': exp(-(r/self.epsilon)**2) 'linear': r 'cubic': r**3 'quintic': r**5 'thin_plate': r**2 * log(r)   If callable, then it must take 2 arguments (self, r).  The epsilon parameter will be available as self.epsilon.  Other keyword arguments passed in will be available as well. \nepsilon : float, optional\n    Adjustable constant for gaussian or multiquadrics functions - defaults to approximate average distance between nodes (which is a good start). \nsmooth : float, optional\n    Values greater than zero increase the smoothness of the approximation.  0 is for interpolation (default), the function will always go through the nodal points in this case. \nnorm : callable, optional\n    A function that returns the ‘distance’ between two points, with inputs as arrays of positions (x, y, z, ...), and an output as an array of distance.  E.g, the default: def euclidean_norm(x1, x2):     return sqrt( ((x1 - x2)**2).sum(axis=0) )   which is called with x1=x1[ndims,newaxis,:] and x2=x2[ndims,:,newaxis] such that the result is a matrix of the distances from each point in x1 to each point in x2.</code></pre><span class="prog__sub">Examples:</span><pre><code>'multiquadric': sqrt((r/self.epsilon)**2 + 1)\n'inverse': 1.0/sqrt((r/self.epsilon)**2 + 1)\n'gaussian': exp(-(r/self.epsilon)**2)\n'linear': r\n'cubic': r**3\n'quintic': r**5\n'thin_plate': r**2 * log(r)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html
scipy interpolate Rbf	R	scipy.interpolate.Rbf										
scipy interpolate.Rbf	R	scipy.interpolate.Rbf										
scipy.interpolate.RectBivariateSpline	A										<section class="prog__container"><p>Bivariate spline approximation over a rectangular mesh.</p><pre><code>class scipy.interpolate.RectBivariateSpline(x, y, z, bbox=[None, None, None, None], kx=3, ky=3, s=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x,y : array_like\n    1-D arrays of coordinates in strictly ascending order. \nz : array_like\n    2-D array of data with shape (x.size,y.size). \nbbox : array_like, optional\n    Sequence of length 4 specifying the boundary of the rectangular approximation domain.  By default, bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]. \nkx, ky : ints, optional\n    Degrees of the bivariate spline. Default is 3. \ns : float, optional\n    Positive smoothing factor defined for estimation condition: sum((w[i]*(z[i]-s(x[i], y[i])))**2, axis=0) <= s Default is s=0, which is for interpolation.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.html
scipy.interpolate.RectBivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate the spline or its derivatives at given positions.</p><pre><code>RectBivariateSpline.__call__(x, y, mth=None, dx=0, dy=0, grid=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Input coordinates. If grid is False, evaluate the spline at points (x[i], y[i]), i=0, ..., len(x)-1.  Standard Numpy broadcasting is obeyed. If grid is True: evaluate spline at the grid points defined by the coordinate arrays x, y. The arrays must be sorted to increasing order. \ndx : int\n    Order of x-derivative  New in version 0.14.0.  \ndy : int\n    Order of y-derivative  New in version 0.14.0.  \ngrid : bool\n    Whether to evaluate the results on a grid spanned by the input arrays, or at points specified by the input arrays.  New in version 0.14.0.  \nmth : str\n    Deprecated argument. Has no effect.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.__call__.html
scipy interpolate RectBivariateSpline __call__	R	scipy.interpolate.RectBivariateSpline.__call__										
scipy interpolate.RectBivariateSpline.__call__	R	scipy.interpolate.RectBivariateSpline.__call__										
scipy.interpolate.RectBivariateSpline.ev	A										<section class="prog__container"><p>Evaluate the spline at points</p><pre><code>RectBivariateSpline.ev(xi, yi, dx=0, dy=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi, yi : array_like\n    Input coordinates. Standard Numpy broadcasting is obeyed. \ndx : int, optional\n    Order of x-derivative  New in version 0.14.0.  \ndy : int, optional\n    Order of y-derivative  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.ev.html
scipy interpolate RectBivariateSpline ev	R	scipy.interpolate.RectBivariateSpline.ev										
scipy interpolate.RectBivariateSpline.ev	R	scipy.interpolate.RectBivariateSpline.ev										
scipy.interpolate.RectBivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>RectBivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.get_coeffs.html
scipy interpolate RectBivariateSpline get_coeffs	R	scipy.interpolate.RectBivariateSpline.get_coeffs										
scipy interpolate.RectBivariateSpline.get_coeffs	R	scipy.interpolate.RectBivariateSpline.get_coeffs										
scipy.interpolate.RectBivariateSpline.get_knots	A										<section class="prog__container"><p>Return a tuple (tx,ty) where tx,ty contain knots positions\nof the spline with respect to x-, y-variable, respectively.\nThe position of interior and additional knots are given as\nt[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively.</p><pre><code>RectBivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.get_knots.html
scipy interpolate RectBivariateSpline get_knots	R	scipy.interpolate.RectBivariateSpline.get_knots										
scipy interpolate.RectBivariateSpline.get_knots	R	scipy.interpolate.RectBivariateSpline.get_knots										
scipy.interpolate.RectBivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline\napproximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0)</p><pre><code>RectBivariateSpline.get_residual()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.get_residual.html
scipy interpolate RectBivariateSpline get_residual	R	scipy.interpolate.RectBivariateSpline.get_residual										
scipy interpolate.RectBivariateSpline.get_residual	R	scipy.interpolate.RectBivariateSpline.get_residual										
scipy.interpolate.RectBivariateSpline.integral	A										<section class="prog__container"><p>Evaluate the integral of the spline over area [xa,xb] x [ya,yb].</p><pre><code>RectBivariateSpline.integral(xa, xb, ya, yb)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xa, xb : float\n    The end-points of the x integration interval. \nya, yb : float\n    The end-points of the y integration interval.</code></pre><span class="prog__sub">Returns:</span><pre><code>integ : float\n    The value of the resulting integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.integral.html
scipy interpolate RectBivariateSpline integral	R	scipy.interpolate.RectBivariateSpline.integral										
scipy interpolate.RectBivariateSpline.integral	R	scipy.interpolate.RectBivariateSpline.integral										
scipy interpolate RectBivariateSpline	R	scipy.interpolate.RectBivariateSpline										
scipy interpolate.RectBivariateSpline	R	scipy.interpolate.RectBivariateSpline										
scipy.interpolate.RectSphereBivariateSpline	A										<section class="prog__container"><p>Bivariate spline approximation over a rectangular mesh on a sphere.</p><pre><code>class scipy.interpolate.RectSphereBivariateSpline(u, v, r, s=0.0, pole_continuity=False, pole_values=None, pole_exact=False, pole_flat=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : array_like\n    1-D array of latitude coordinates in strictly ascending order. Coordinates must be given in radians and lie within the interval (0, pi). \nv : array_like\n    1-D array of longitude coordinates in strictly ascending order. Coordinates must be given in radians, and must lie within (0, 2pi). \nr : array_like\n    2-D array of data with shape (u.size, v.size). \ns : float, optional\n    Positive smoothing factor defined for estimation condition (s=0 is for interpolation). \npole_continuity : bool or (bool, bool), optional\n    Order of continuity at the poles u=0 (pole_continuity[0]) and u=pi (pole_continuity[1]).  The order of continuity at the pole will be 1 or 0 when this is True or False, respectively. Defaults to False. \npole_values : float or (float, float), optional\n    Data values at the poles u=0 and u=pi.  Either the whole parameter or each individual element can be None.  Defaults to None. \npole_exact : bool or (bool, bool), optional\n    Data value exactness at the poles u=0 and u=pi.  If True, the value is considered to be the right function value, and it will be fitted exactly. If False, the value will be considered to be a data value just like the other data values.  Defaults to False. \npole_flat : bool or (bool, bool), optional\n    For the poles at u=0 and u=pi, specify whether or not the approximation has vanishing derivatives.  Defaults to False.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> lats = np.linspace(10, 170, 9) * np.pi / 180.\n>>> lons = np.linspace(0, 350, 18) * np.pi / 180.\n>>> data = np.dot(np.atleast_2d(90. - np.linspace(-80., 80., 18)).T,\n...               np.atleast_2d(180. - np.abs(np.linspace(0., 350., 9)))).T</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectSphereBivariateSpline.html
scipy.interpolate.RectSphereBivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate the spline or its derivatives at given positions.</p><pre><code>RectSphereBivariateSpline.__call__(theta, phi, dtheta=0, dphi=0, grid=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>theta, phi : array_like\n    Input coordinates. If grid is False, evaluate the spline at points (theta[i], phi[i]), i=0, ..., len(x)-1.  Standard Numpy broadcasting is obeyed. If grid is True: evaluate spline at the grid points defined by the coordinate arrays theta, phi. The arrays must be sorted to increasing order. \ndtheta : int, optional\n    Order of theta-derivative  New in version 0.14.0.  \ndphi : int\n    Order of phi-derivative  New in version 0.14.0.  \ngrid : bool\n    Whether to evaluate the results on a grid spanned by the input arrays, or at points specified by the input arrays.  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectSphereBivariateSpline.__call__.html
scipy interpolate RectSphereBivariateSpline __call__	R	scipy.interpolate.RectSphereBivariateSpline.__call__										
scipy interpolate.RectSphereBivariateSpline.__call__	R	scipy.interpolate.RectSphereBivariateSpline.__call__										
scipy.interpolate.RectSphereBivariateSpline.ev	A										<section class="prog__container"><p>Evaluate the spline at points</p><pre><code>RectSphereBivariateSpline.ev(theta, phi, dtheta=0, dphi=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>theta, phi : array_like\n    Input coordinates. Standard Numpy broadcasting is obeyed. \ndtheta : int, optional\n    Order of theta-derivative  New in version 0.14.0.  \ndphi : int, optional\n    Order of phi-derivative  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectSphereBivariateSpline.ev.html
scipy interpolate RectSphereBivariateSpline ev	R	scipy.interpolate.RectSphereBivariateSpline.ev										
scipy interpolate.RectSphereBivariateSpline.ev	R	scipy.interpolate.RectSphereBivariateSpline.ev										
scipy.interpolate.RectSphereBivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>RectSphereBivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectSphereBivariateSpline.get_coeffs.html
scipy interpolate RectSphereBivariateSpline get_coeffs	R	scipy.interpolate.RectSphereBivariateSpline.get_coeffs										
scipy interpolate.RectSphereBivariateSpline.get_coeffs	R	scipy.interpolate.RectSphereBivariateSpline.get_coeffs										
scipy.interpolate.RectSphereBivariateSpline.get_knots	A										<section class="prog__container"><p>Return a tuple (tx,ty) where tx,ty contain knots positions\nof the spline with respect to x-, y-variable, respectively.\nThe position of interior and additional knots are given as\nt[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively.</p><pre><code>RectSphereBivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectSphereBivariateSpline.get_knots.html
scipy interpolate RectSphereBivariateSpline get_knots	R	scipy.interpolate.RectSphereBivariateSpline.get_knots										
scipy interpolate.RectSphereBivariateSpline.get_knots	R	scipy.interpolate.RectSphereBivariateSpline.get_knots										
scipy.interpolate.RectSphereBivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline\napproximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0)</p><pre><code>RectSphereBivariateSpline.get_residual()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectSphereBivariateSpline.get_residual.html
scipy interpolate RectSphereBivariateSpline get_residual	R	scipy.interpolate.RectSphereBivariateSpline.get_residual										
scipy interpolate.RectSphereBivariateSpline.get_residual	R	scipy.interpolate.RectSphereBivariateSpline.get_residual										
scipy interpolate RectSphereBivariateSpline	R	scipy.interpolate.RectSphereBivariateSpline										
scipy interpolate.RectSphereBivariateSpline	R	scipy.interpolate.RectSphereBivariateSpline										
scipy.interpolate.RegularGridInterpolator	A										<section class="prog__container"><p>Interpolation on a regular grid in arbitrary dimensions</p><pre><code>class scipy.interpolate.RegularGridInterpolator(points, values, method='linear', bounds_error=True, fill_value=nan)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : tuple of ndarray of float, with shapes (m1, ), ..., (mn, )\n    The points defining the regular grid in n dimensions. \nvalues : array_like, shape (m1, ..., mn, ...)\n    The data on the regular grid in n dimensions. \nmethod : str, optional\n    The method of interpolation to perform. Supported are “linear” and “nearest”. This parameter will become the default for the object’s __call__ method. Default is “linear”. \nbounds_error : bool, optional\n    If True, when interpolated values are requested outside of the domain of the input data, a ValueError is raised. If False, then fill_value is used. \nfill_value : number, optional\n    If provided, the value to use for points outside of the interpolation domain. If None, values outside the domain are extrapolated.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import RegularGridInterpolator\n>>> def f(x,y,z):\n...     return 2 * x**3 + 3 * y**2 - z\n>>> x = np.linspace(1, 4, 11)\n>>> y = np.linspace(4, 7, 22)\n>>> z = np.linspace(7, 9, 33)\n>>> data = f(*np.meshgrid(x, y, z, indexing='ij', sparse=True))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RegularGridInterpolator.html
scipy.interpolate.RegularGridInterpolator.__call__	A										<section class="prog__container"><p>Interpolation at coordinates</p><pre><code>RegularGridInterpolator.__call__(xi, method=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi : ndarray of shape (..., ndim)\n    The coordinates to sample the gridded data at \nmethod : str\n    The method of interpolation to perform. Supported are “linear” and “nearest”.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RegularGridInterpolator.__call__.html
scipy interpolate RegularGridInterpolator __call__	R	scipy.interpolate.RegularGridInterpolator.__call__										
scipy interpolate.RegularGridInterpolator.__call__	R	scipy.interpolate.RegularGridInterpolator.__call__										
scipy interpolate RegularGridInterpolator	R	scipy.interpolate.RegularGridInterpolator										
scipy interpolate.RegularGridInterpolator	R	scipy.interpolate.RegularGridInterpolator										
scipy.interpolate.SmoothBivariateSpline	A										<section class="prog__container"><p>Smooth bivariate spline approximation.</p><pre><code>class scipy.interpolate.SmoothBivariateSpline(x, y, z, w=None, bbox=[None, None, None, None], kx=3, ky=3, s=None, eps=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y, z : array_like\n    1-D sequences of data points (order is not important). \nw : array_like, optional\n    Positive 1-D sequence of weights, of same length as x, y and z. \nbbox : array_like, optional\n    Sequence of length 4 specifying the boundary of the rectangular approximation domain.  By default, bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]. \nkx, ky : ints, optional\n    Degrees of the bivariate spline. Default is 3. \ns : float, optional\n    Positive smoothing factor defined for estimation condition: sum((w[i]*(z[i]-s(x[i], y[i])))**2, axis=0) <= s Default s=len(w) which should be a good value if 1/w[i] is an estimate of the standard deviation of z[i]. \neps : float, optional\n    A threshold for determining the effective rank of an over-determined linear system of equations. eps should have a value between 0 and 1, the default is 1e-16.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothBivariateSpline.html
scipy.interpolate.SmoothBivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate the spline or its derivatives at given positions.</p><pre><code>SmoothBivariateSpline.__call__(x, y, mth=None, dx=0, dy=0, grid=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Input coordinates. If grid is False, evaluate the spline at points (x[i], y[i]), i=0, ..., len(x)-1.  Standard Numpy broadcasting is obeyed. If grid is True: evaluate spline at the grid points defined by the coordinate arrays x, y. The arrays must be sorted to increasing order. \ndx : int\n    Order of x-derivative  New in version 0.14.0.  \ndy : int\n    Order of y-derivative  New in version 0.14.0.  \ngrid : bool\n    Whether to evaluate the results on a grid spanned by the input arrays, or at points specified by the input arrays.  New in version 0.14.0.  \nmth : str\n    Deprecated argument. Has no effect.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothBivariateSpline.__call__.html
scipy interpolate SmoothBivariateSpline __call__	R	scipy.interpolate.SmoothBivariateSpline.__call__										
scipy interpolate.SmoothBivariateSpline.__call__	R	scipy.interpolate.SmoothBivariateSpline.__call__										
scipy.interpolate.SmoothBivariateSpline.ev	A										<section class="prog__container"><p>Evaluate the spline at points</p><pre><code>SmoothBivariateSpline.ev(xi, yi, dx=0, dy=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xi, yi : array_like\n    Input coordinates. Standard Numpy broadcasting is obeyed. \ndx : int, optional\n    Order of x-derivative  New in version 0.14.0.  \ndy : int, optional\n    Order of y-derivative  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothBivariateSpline.ev.html
scipy interpolate SmoothBivariateSpline ev	R	scipy.interpolate.SmoothBivariateSpline.ev										
scipy interpolate.SmoothBivariateSpline.ev	R	scipy.interpolate.SmoothBivariateSpline.ev										
scipy.interpolate.SmoothBivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>SmoothBivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothBivariateSpline.get_coeffs.html
scipy interpolate SmoothBivariateSpline get_coeffs	R	scipy.interpolate.SmoothBivariateSpline.get_coeffs										
scipy interpolate.SmoothBivariateSpline.get_coeffs	R	scipy.interpolate.SmoothBivariateSpline.get_coeffs										
scipy.interpolate.SmoothBivariateSpline.get_knots	A										<section class="prog__container"><p>Return a tuple (tx,ty) where tx,ty contain knots positions\nof the spline with respect to x-, y-variable, respectively.\nThe position of interior and additional knots are given as\nt[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively.</p><pre><code>SmoothBivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothBivariateSpline.get_knots.html
scipy interpolate SmoothBivariateSpline get_knots	R	scipy.interpolate.SmoothBivariateSpline.get_knots										
scipy interpolate.SmoothBivariateSpline.get_knots	R	scipy.interpolate.SmoothBivariateSpline.get_knots										
scipy.interpolate.SmoothBivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline\napproximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0)</p><pre><code>SmoothBivariateSpline.get_residual()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothBivariateSpline.get_residual.html
scipy interpolate SmoothBivariateSpline get_residual	R	scipy.interpolate.SmoothBivariateSpline.get_residual										
scipy interpolate.SmoothBivariateSpline.get_residual	R	scipy.interpolate.SmoothBivariateSpline.get_residual										
scipy.interpolate.SmoothBivariateSpline.integral	A										<section class="prog__container"><p>Evaluate the integral of the spline over area [xa,xb] x [ya,yb].</p><pre><code>SmoothBivariateSpline.integral(xa, xb, ya, yb)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xa, xb : float\n    The end-points of the x integration interval. \nya, yb : float\n    The end-points of the y integration interval.</code></pre><span class="prog__sub">Returns:</span><pre><code>integ : float\n    The value of the resulting integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothBivariateSpline.integral.html
scipy interpolate SmoothBivariateSpline integral	R	scipy.interpolate.SmoothBivariateSpline.integral										
scipy interpolate.SmoothBivariateSpline.integral	R	scipy.interpolate.SmoothBivariateSpline.integral										
scipy interpolate SmoothBivariateSpline	R	scipy.interpolate.SmoothBivariateSpline										
scipy interpolate.SmoothBivariateSpline	R	scipy.interpolate.SmoothBivariateSpline										
scipy.interpolate.SmoothSphereBivariateSpline	A										<section class="prog__container"><p>Smooth bivariate spline approximation in spherical coordinates.</p><pre><code>class scipy.interpolate.SmoothSphereBivariateSpline(theta, phi, r, w=None, s=0.0, eps=1e-16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>theta, phi, r : array_like\n    1-D sequences of data points (order is not important). Coordinates must be given in radians. Theta must lie within the interval (0, pi), and phi must lie within the interval (0, 2pi). \nw : array_like, optional\n    Positive 1-D sequence of weights. \ns : float, optional\n    Positive smoothing factor defined for estimation condition: sum((w(i)*(r(i) - s(theta(i), phi(i))))**2, axis=0) <= s Default s=len(w) which should be a good value if 1/w[i] is an estimate of the standard deviation of r[i]. \neps : float, optional\n    A threshold for determining the effective rank of an over-determined linear system of equations. eps should have a value between 0 and 1, the default is 1e-16.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> theta = np.linspace(0., np.pi, 7)\n>>> phi = np.linspace(0., 2*np.pi, 9)\n>>> data = np.empty((theta.shape[0], phi.shape[0]))\n>>> data[:,0], data[0,:], data[-1,:] = 0., 0., 0.\n>>> data[1:-1,1], data[1:-1,-1] = 1., 1.\n>>> data[1,1:-1], data[-2,1:-1] = 1., 1.\n>>> data[2:-2,2], data[2:-2,-2] = 2., 2.\n>>> data[2,2:-2], data[-3,2:-2] = 2., 2.\n>>> data[3,3:-2] = 3.\n>>> data = np.roll(data, 4, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothSphereBivariateSpline.html
scipy.interpolate.SmoothSphereBivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate the spline or its derivatives at given positions.</p><pre><code>SmoothSphereBivariateSpline.__call__(theta, phi, dtheta=0, dphi=0, grid=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>theta, phi : array_like\n    Input coordinates. If grid is False, evaluate the spline at points (theta[i], phi[i]), i=0, ..., len(x)-1.  Standard Numpy broadcasting is obeyed. If grid is True: evaluate spline at the grid points defined by the coordinate arrays theta, phi. The arrays must be sorted to increasing order. \ndtheta : int, optional\n    Order of theta-derivative  New in version 0.14.0.  \ndphi : int\n    Order of phi-derivative  New in version 0.14.0.  \ngrid : bool\n    Whether to evaluate the results on a grid spanned by the input arrays, or at points specified by the input arrays.  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothSphereBivariateSpline.__call__.html
scipy interpolate SmoothSphereBivariateSpline __call__	R	scipy.interpolate.SmoothSphereBivariateSpline.__call__										
scipy interpolate.SmoothSphereBivariateSpline.__call__	R	scipy.interpolate.SmoothSphereBivariateSpline.__call__										
scipy.interpolate.SmoothSphereBivariateSpline.ev	A										<section class="prog__container"><p>Evaluate the spline at points</p><pre><code>SmoothSphereBivariateSpline.ev(theta, phi, dtheta=0, dphi=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>theta, phi : array_like\n    Input coordinates. Standard Numpy broadcasting is obeyed. \ndtheta : int, optional\n    Order of theta-derivative  New in version 0.14.0.  \ndphi : int, optional\n    Order of phi-derivative  New in version 0.14.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothSphereBivariateSpline.ev.html
scipy interpolate SmoothSphereBivariateSpline ev	R	scipy.interpolate.SmoothSphereBivariateSpline.ev										
scipy interpolate.SmoothSphereBivariateSpline.ev	R	scipy.interpolate.SmoothSphereBivariateSpline.ev										
scipy.interpolate.SmoothSphereBivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>SmoothSphereBivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothSphereBivariateSpline.get_coeffs.html
scipy interpolate SmoothSphereBivariateSpline get_coeffs	R	scipy.interpolate.SmoothSphereBivariateSpline.get_coeffs										
scipy interpolate.SmoothSphereBivariateSpline.get_coeffs	R	scipy.interpolate.SmoothSphereBivariateSpline.get_coeffs										
scipy.interpolate.SmoothSphereBivariateSpline.get_knots	A										<section class="prog__container"><p>Return a tuple (tx,ty) where tx,ty contain knots positions\nof the spline with respect to x-, y-variable, respectively.\nThe position of interior and additional knots are given as\nt[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively.</p><pre><code>SmoothSphereBivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothSphereBivariateSpline.get_knots.html
scipy interpolate SmoothSphereBivariateSpline get_knots	R	scipy.interpolate.SmoothSphereBivariateSpline.get_knots										
scipy interpolate.SmoothSphereBivariateSpline.get_knots	R	scipy.interpolate.SmoothSphereBivariateSpline.get_knots										
scipy.interpolate.SmoothSphereBivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline\napproximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0)</p><pre><code>SmoothSphereBivariateSpline.get_residual()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.SmoothSphereBivariateSpline.get_residual.html
scipy interpolate SmoothSphereBivariateSpline get_residual	R	scipy.interpolate.SmoothSphereBivariateSpline.get_residual										
scipy interpolate.SmoothSphereBivariateSpline.get_residual	R	scipy.interpolate.SmoothSphereBivariateSpline.get_residual										
scipy interpolate SmoothSphereBivariateSpline	R	scipy.interpolate.SmoothSphereBivariateSpline										
scipy interpolate.SmoothSphereBivariateSpline	R	scipy.interpolate.SmoothSphereBivariateSpline										
scipy.interpolate.spalde	A					[[scipy.interpolate.splprep]]\\n[[scipy.interpolate.splrep]]\\n[[scipy.interpolate.splint]]\\n[[scipy.interpolate.sproot]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.bisplrep]]\\n[[scipy.interpolate.bisplev]]\\n[[scipy.interpolate.UnivariateSpline]]\\n[[scipy.interpolate.BivariateSpline]]					<section class="prog__container"><p>Evaluate all derivatives of a B-spline.</p><pre><code>scipy.interpolate.spalde(x, tck)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A point or a set of points at which to evaluate the derivatives. Note that t(k) <= x <= t(n-k+1) must hold for each x. \ntck : tuple\n    A tuple (t,c,k) containing the vector of knots, the B-spline coefficients, and the degree of the spline.</code></pre><span class="prog__sub">Returns:</span><pre><code>results : {ndarray, list of ndarrays}\n    An array (or a list of arrays) containing all derivatives up to order k inclusive for each point x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.spalde.html
scipy interpolate spalde	R	scipy.interpolate.spalde										
scipy interpolate.spalde	R	scipy.interpolate.spalde										
scipy.interpolate.splantider	A					[[scipy.interpolate.splder]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.spalde]]					<section class="prog__container"><p>Compute the spline for the antiderivative (integral) of a given spline.</p><pre><code>scipy.interpolate.splantider(tck, n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tck : tuple of (t, c, k)\n    Spline whose antiderivative to compute \nn : int, optional\n    Order of antiderivative to evaluate. Default: 1</code></pre><span class="prog__sub">Returns:</span><pre><code>tck_ader : tuple of (t2, c2, k2)\n    Spline of order k2=k+n representing the antiderivative of the input spline.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import splrep, splder, splantider, splev\n>>> x = np.linspace(0, np.pi/2, 70)\n>>> y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2)\n>>> spl = splrep(x, y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splantider.html
scipy interpolate splantider	R	scipy.interpolate.splantider										
scipy interpolate.splantider	R	scipy.interpolate.splantider										
scipy.interpolate.splder	A					[[scipy.interpolate.splantider]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.spalde]]					<section class="prog__container"><p>Compute the spline representation of the derivative of a given spline</p><pre><code>scipy.interpolate.splder(tck, n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tck : tuple of (t, c, k)\n    Spline whose derivative to compute \nn : int, optional\n    Order of derivative to evaluate. Default: 1</code></pre><span class="prog__sub">Returns:</span><pre><code>tck_der : tuple of (t2, c2, k2)\n    Spline of order k2=k-n representing the derivative of the input spline.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import splrep, splder, sproot\n>>> x = np.linspace(0, 10, 70)\n>>> y = np.sin(x)\n>>> spl = splrep(x, y, k=4)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splder.html
scipy interpolate splder	R	scipy.interpolate.splder										
scipy interpolate.splder	R	scipy.interpolate.splder										
scipy.interpolate.spleval	A										<section class="prog__container"><p>Evaluate a fixed spline represented by the given tuple at the new x-values</p><pre><code>scipy.interpolate.spleval(xck, xnew, deriv=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>(xj, cvals, k) : tuple\n    Parameters that define the fixed spline \nxj : array_like\n    Interior knot points \ncvals : array_like\n    Curvature \nk : int\n    Order of the spline \nxnew : array_like\n    Locations to calculate spline \nderiv : int\n    Deriv</code></pre><span class="prog__sub">Returns:</span><pre><code>spleval : ndarray\n    If cvals represents more than one curve (cvals.ndim > 1) and/or xnew is N-d, then the result is xnew.shape + cvals.shape[1:] providing the interpolation of multiple curves.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.spleval.html
scipy interpolate spleval	R	scipy.interpolate.spleval										
scipy interpolate.spleval	R	scipy.interpolate.spleval										
scipy.interpolate.splev	A					[[scipy.interpolate.splprep]]\\n[[scipy.interpolate.splrep]]\\n[[scipy.interpolate.sproot]]\\n[[scipy.interpolate.spalde]]\\n[[scipy.interpolate.splint]]\\n[[scipy.interpolate.bisplrep]]\\n[[scipy.interpolate.bisplev]]					<section class="prog__container"><p>Evaluate a B-spline or its derivatives.</p><pre><code>scipy.interpolate.splev(x, tck, der=0, ext=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    An array of points at which to return the value of the smoothed spline or its derivatives.  If tck was returned from splprep, then the parameter values, u should be given. \ntck : tuple\n    A sequence of length 3 returned by splrep or splprep containing the knots, coefficients, and degree of the spline. \nder : int, optional\n    The order of derivative of the spline to compute (must be less than or equal to k). \next : int, optional\n    Controls the value returned for elements of x not in the interval defined by the knot sequence.  if ext=0, return the extrapolated value. if ext=1, return 0 if ext=2, raise a ValueError if ext=3, return the boundary value.  The default value is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray or list of ndarrays\n    An array of values representing the spline function evaluated at the points in x.  If tck was returned from splprep, then this is a list of arrays representing the curve in N-dimensional space.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splev.html
scipy interpolate splev	R	scipy.interpolate.splev										
scipy interpolate.splev	R	scipy.interpolate.splev										
scipy.interpolate.spline	A										<section class="prog__container"><p>Interpolate a curve at new points using a spline fit</p><pre><code>scipy.interpolate.spline(xk, yk, xnew, order=3, kind='smoothest', conds=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xk, yk : array_like\n    The x and y values that define the curve. \nxnew : array_like\n    The x values where spline should estimate the y values. \norder : int\n    Default is 3. \nkind : string\n    One of {‘smoothest’} \nconds : Don’t know\n    Don’t know</code></pre><span class="prog__sub">Returns:</span><pre><code>spline : ndarray\n    An array of y values; the spline evaluated at the positions xnew.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.spline.html
scipy interpolate spline	R	scipy.interpolate.spline										
scipy interpolate.spline	R	scipy.interpolate.spline										
scipy.interpolate.splint	A					[[scipy.interpolate.splprep]]\\n[[scipy.interpolate.splrep]]\\n[[scipy.interpolate.sproot]]\\n[[scipy.interpolate.spalde]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.bisplrep]]\\n[[scipy.interpolate.bisplev]]\\n[[scipy.interpolate.UnivariateSpline]]\\n[[scipy.interpolate.BivariateSpline]]					<section class="prog__container"><p>Evaluate the definite integral of a B-spline.</p><pre><code>scipy.interpolate.splint(a, b, tck, full_output=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : float\n    The end-points of the integration interval. \ntck : tuple\n    A tuple (t,c,k) containing the vector of knots, the B-spline coefficients, and the degree of the spline (see splev). \nfull_output : int, optional\n    Non-zero to return optional output.</code></pre><span class="prog__sub">Returns:</span><pre><code>integral : float\n    The resulting integral. \nwrk : ndarray\n    An array containing the integrals of the normalized B-splines defined on the set of knots.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splint.html
scipy interpolate splint	R	scipy.interpolate.splint										
scipy interpolate.splint	R	scipy.interpolate.splint										
scipy.interpolate.splmake	A										<section class="prog__container"><p>Return a representation of a spline given data-points at internal knots</p><pre><code>scipy.interpolate.splmake(xk, yk, order=3, kind='smoothest', conds=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xk : array_like\n    The input array of x values of rank 1 \nyk : array_like\n    The input array of y values of rank N. yk can be an N-d array to represent more than one curve, through the same xk points. The first dimension is assumed to be the interpolating dimension and is the same length of xk. \norder : int, optional\n    Order of the spline \nkind : str, optional\n    Can be ‘smoothest’, ‘not_a_knot’, ‘fixed’, ‘clamped’, ‘natural’, ‘periodic’, ‘symmetric’, ‘user’, ‘mixed’ and it is ignored if order < 2 \nconds : optional\n    Conds</code></pre><span class="prog__sub">Returns:</span><pre><code>splmake : tuple\n    Return a (xk, cvals, k) representation of a spline given data-points where the (internal) knots are at the data-points.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splmake.html
scipy interpolate splmake	R	scipy.interpolate.splmake										
scipy interpolate.splmake	R	scipy.interpolate.splmake										
scipy.interpolate.splprep	A					[[scipy.interpolate.splrep]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.sproot]]\\n[[scipy.interpolate.spalde]]\\n[[scipy.interpolate.splint]]\\n[[scipy.interpolate.bisplrep]]\\n[[scipy.interpolate.bisplev]]\\n[[scipy.interpolate.UnivariateSpline]]\\n[[scipy.interpolate.BivariateSpline]]					<section class="prog__container"><p>Find the B-spline representation of an N-dimensional curve.</p><pre><code>scipy.interpolate.splprep(x, w=None, u=None, ub=None, ue=None, k=3, task=0, s=None, t=None, full_output=0, nest=None, per=0, quiet=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A list of sample vector arrays representing the curve. \nw : array_like, optional\n    Strictly positive rank-1 array of weights the same length as x[0]. The weights are used in computing the weighted least-squares spline fit. If the errors in the x values have standard-deviation given by the vector d, then w should be 1/d. Default is ones(len(x[0])). \nu : array_like, optional\n    An array of parameter values. If not given, these values are calculated automatically as M = len(x[0]), where  v[0] = 0 v[i] = v[i-1] + distance(x[i], x[i-1]) u[i] = v[i] / v[M-1]  \nub, ue : int, optional\n    The end-points of the parameters interval.  Defaults to u[0] and u[-1]. \nk : int, optional\n    Degree of the spline. Cubic splines are recommended. Even values of k should be avoided especially with a small s-value. 1 <= k <= 5, default is 3. \ntask : int, optional\n    If task==0 (default), find t and c for a given smoothing factor, s. If task==1, find t and c for another value of the smoothing factor, s. There must have been a previous call with task=0 or task=1 for the same set of data. If task=-1 find the weighted least square spline for a given set of knots, t. \ns : float, optional\n    A smoothing condition.  The amount of smoothness is determined by satisfying the conditions: sum((w * (y - g))**2,axis=0) <= s, where g(x) is the smoothed interpolation of (x,y).  The user can use s to control the trade-off between closeness and smoothness of fit.  Larger s means more smoothing while smaller values of s indicate less smoothing. Recommended values of s depend on the weights, w.  If the weights represent the inverse of the standard-deviation of y, then a good s value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)), where m is the number of data points in x, y, and w. \nt : int, optional\n    The knots needed for task=-1. \nfull_output : int, optional\n    If non-zero, then return optional outputs. \nnest : int, optional\n    An over-estimate of the total number of knots of the spline to help in determining the storage space.  By default nest=m/2. Always large enough is nest=m+k+1. \nper : int, optional\n    If non-zero, data points are considered periodic with period x[m-1] - x[0] and a smooth periodic spline approximation is returned.  Values of y[m-1] and w[m-1] are not used. \nquiet : int, optional\n    Non-zero to suppress messages. This parameter is deprecated; use standard Python warning filters instead.</code></pre><span class="prog__sub">Returns:</span><pre><code>tck : tuple\n    A tuple (t,c,k) containing the vector of knots, the B-spline coefficients, and the degree of the spline. \nu : array\n    An array of the values of the parameter. \nfp : float\n    The weighted sum of squared residuals of the spline approximation. \nier : int\n    An integer flag about splrep success.  Success is indicated if ier<=0. If ier in [1,2,3] an error occurred but was not raised. Otherwise an error is raised. \nmsg : str\n    A message corresponding to the integer flag, ier.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splprep.html
scipy interpolate splprep	R	scipy.interpolate.splprep										
scipy interpolate.splprep	R	scipy.interpolate.splprep										
scipy.interpolate.splrep	A					[[scipy.interpolate.UnivariateSpline]]\\n[[scipy.interpolate.BivariateSpline]]\\n[[scipy.interpolate.splprep]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.sproot]]\\n[[scipy.interpolate.spalde]]\\n[[scipy.interpolate.splint]]\\n[[scipy.interpolate.bisplrep]]\\n[[scipy.interpolate.bisplev]]					<section class="prog__container"><p>Find the B-spline representation of 1-D curve.</p><pre><code>scipy.interpolate.splrep(x, y, w=None, xb=None, xe=None, k=3, task=0, s=None, t=None, full_output=0, per=0, quiet=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    The data points defining a curve y = f(x). \nw : array_like, optional\n    Strictly positive rank-1 array of weights the same length as x and y. The weights are used in computing the weighted least-squares spline fit. If the errors in the y values have standard-deviation given by the vector d, then w should be 1/d. Default is ones(len(x)). \nxb, xe : float, optional\n    The interval to fit.  If None, these default to x[0] and x[-1] respectively. \nk : int, optional\n    The degree of the spline fit. It is recommended to use cubic splines. Even values of k should be avoided especially with small s values. 1 <= k <= 5 \ntask : {1, 0, -1}, optional\n    If task==0 find t and c for a given smoothing factor, s. If task==1 find t and c for another value of the smoothing factor, s. There must have been a previous call with task=0 or task=1 for the same set of data (t will be stored an used internally) If task=-1 find the weighted least square spline for a given set of knots, t. These should be interior knots as knots on the ends will be added automatically. \ns : float, optional\n    A smoothing condition. The amount of smoothness is determined by satisfying the conditions: sum((w * (y - g))**2,axis=0) <= s where g(x) is the smoothed interpolation of (x,y). The user can use s to control the tradeoff between closeness and smoothness of fit. Larger s means more smoothing while smaller values of s indicate less smoothing. Recommended values of s depend on the weights, w. If the weights represent the inverse of the standard-deviation of y, then a good s value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) where m is the number of datapoints in x, y, and w. default : s=m-sqrt(2*m) if weights are supplied. s = 0.0 (interpolating) if no weights are supplied. \nt : array_like, optional\n    The knots needed for task=-1. If given then task is automatically set to -1. \nfull_output : bool, optional\n    If non-zero, then return optional outputs. \nper : bool, optional\n    If non-zero, data points are considered periodic with period x[m-1] - x[0] and a smooth periodic spline approximation is returned. Values of y[m-1] and w[m-1] are not used. \nquiet : bool, optional\n    Non-zero to suppress messages. This parameter is deprecated; use standard Python warning filters instead.</code></pre><span class="prog__sub">Returns:</span><pre><code>tck : tuple\n    (t,c,k) a tuple containing the vector of knots, the B-spline coefficients, and the degree of the spline. \nfp : array, optional\n    The weighted sum of squared residuals of the spline approximation. \nier : int, optional\n    An integer flag about splrep success. Success is indicated if ier<=0. If ier in [1,2,3] an error occurred but was not raised. Otherwise an error is raised. \nmsg : str, optional\n    A message corresponding to the integer flag, ier.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy.interpolate import splev, splrep\n>>> x = np.linspace(0, 10, 10)\n>>> y = np.sin(x)\n>>> tck = splrep(x, y)\n>>> x2 = np.linspace(0, 10, 200)\n>>> y2 = splev(x2, tck)\n>>> plt.plot(x, y, 'o', x2, y2)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splrep.html
scipy interpolate splrep	R	scipy.interpolate.splrep										
scipy interpolate.splrep	R	scipy.interpolate.splrep										
scipy.interpolate.spltopp	A										<section class="prog__container"><p>Return a piece-wise polynomial object from a fixed-spline tuple.</p><pre><code>scipy.interpolate.spltopp(xk, cvals, k)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.spltopp.html
scipy interpolate spltopp	R	scipy.interpolate.spltopp										
scipy interpolate.spltopp	R	scipy.interpolate.spltopp										
scipy.interpolate.sproot	A					[[scipy.interpolate.splprep]]\\n[[scipy.interpolate.splrep]]\\n[[scipy.interpolate.splint]]\\n[[scipy.interpolate.spalde]]\\n[[scipy.interpolate.splev]]\\n[[scipy.interpolate.bisplrep]]\\n[[scipy.interpolate.bisplev]]\\n[[scipy.interpolate.UnivariateSpline]]\\n[[scipy.interpolate.BivariateSpline]]					<section class="prog__container"><p>Find the roots of a cubic B-spline.</p><pre><code>scipy.interpolate.sproot(tck, mest=10)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tck : tuple\n    A tuple (t,c,k) containing the vector of knots, the B-spline coefficients, and the degree of the spline. The number of knots must be >= 8, and the degree must be 3. The knots must be a montonically increasing sequence. \nmest : int, optional\n    An estimate of the number of zeros (Default is 10).</code></pre><span class="prog__sub">Returns:</span><pre><code>zeros : ndarray\n    An array giving the roots of the spline.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.sproot.html
scipy interpolate sproot	R	scipy.interpolate.sproot										
scipy interpolate.sproot	R	scipy.interpolate.sproot										
scipy.interpolate.UnivariateSpline.antiderivative	A					[[scipy.interpolate.splantider]]\\n[[scipy.interpolate.UnivariateSpline.derivative]]					<section class="prog__container"><p>Construct a new spline representing the antiderivative of this spline.</p><pre><code>UnivariateSpline.antiderivative(n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Order of antiderivative to evaluate. Default: 1</code></pre><span class="prog__sub">Returns:</span><pre><code>spline : UnivariateSpline\n    Spline of order k2=k+n representing the antiderivative of this spline.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, np.pi/2, 70)\n>>> y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2)\n>>> spl = UnivariateSpline(x, y, s=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.antiderivative.html
scipy interpolate UnivariateSpline antiderivative	R	scipy.interpolate.UnivariateSpline.antiderivative										
scipy interpolate.UnivariateSpline.antiderivative	R	scipy.interpolate.UnivariateSpline.antiderivative										
scipy.interpolate.UnivariateSpline	A										<section class="prog__container"><p>One-dimensional smoothing spline fit to a given set of data points.</p><pre><code>class scipy.interpolate.UnivariateSpline(x, y, w=None, bbox=[None, None], k=3, s=None, ext=0, check_finite=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (N,) array_like\n    1-D array of independent input data. Must be increasing. \ny : (N,) array_like\n    1-D array of dependent input data, of the same length as x. \nw : (N,) array_like, optional\n    Weights for spline fitting.  Must be positive.  If None (default), weights are all equal. \nbbox : (2,) array_like, optional\n    2-sequence specifying the boundary of the approximation interval. If None (default), bbox=[x[0], x[-1]]. \nk : int, optional\n    Degree of the smoothing spline.  Must be <= 5. Default is k=3, a cubic spline. \ns : float or None, optional\n    Positive smoothing factor used to choose the number of knots.  Number of knots will be increased until the smoothing condition is satisfied: sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) <= s   If None (default), s = len(w) which should be a good value if 1/w[i] is an estimate of the standard deviation of y[i]. If 0, spline will interpolate through all data points. \next : int or str, optional\n    Controls the extrapolation mode for elements not in the interval defined by the knot sequence.  if ext=0 or ‘extrapolate’, return the extrapolated value. if ext=1 or ‘zeros’, return 0 if ext=2 or ‘raise’, raise a ValueError if ext=3 of ‘const’, return the boundary value.  The default value is 0. \ncheck_finite : bool, optional\n    Whether to check that the input arrays contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination or non-sensical results) if the inputs do contain infinities or NaNs. Default is False.</code></pre><span class="prog__sub">Examples:</span><pre><code>sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) <= s</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html
scipy.interpolate.UnivariateSpline.__call__	A										<section class="prog__container"><p>Evaluate spline (or its nu-th derivative) at positions x.</p><pre><code>UnivariateSpline.__call__(x, nu=0, ext=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    A 1-D array of points at which to return the value of the smoothed spline or its derivatives. Note: x can be unordered but the evaluation is more efficient if x is (partially) ordered. \nnu : int\n    The order of derivative of the spline to compute. \next : int\n    Controls the value returned for elements of x not in the interval defined by the knot sequence.  if ext=0 or ‘extrapolate’, return the extrapolated value. if ext=1 or ‘zeros’, return 0 if ext=2 or ‘raise’, raise a ValueError if ext=3 or ‘const’, return the boundary value.  The default value is 0, passed from the initialization of UnivariateSpline.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.__call__.html
scipy interpolate UnivariateSpline __call__	R	scipy.interpolate.UnivariateSpline.__call__										
scipy interpolate.UnivariateSpline.__call__	R	scipy.interpolate.UnivariateSpline.__call__										
scipy.interpolate.UnivariateSpline.derivative	A					[[scipy.interpolate.splder]]\\n[[scipy.interpolate.UnivariateSpline.antiderivative]]					<section class="prog__container"><p>Construct a new spline representing the derivative of this spline.</p><pre><code>UnivariateSpline.derivative(n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, optional\n    Order of derivative to evaluate. Default: 1</code></pre><span class="prog__sub">Returns:</span><pre><code>spline : UnivariateSpline\n    Spline of order k2=k-n representing the derivative of this spline.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 10, 70)\n>>> y = np.sin(x)\n>>> spl = UnivariateSpline(x, y, k=4, s=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.derivative.html
scipy interpolate UnivariateSpline derivative	R	scipy.interpolate.UnivariateSpline.derivative										
scipy interpolate.UnivariateSpline.derivative	R	scipy.interpolate.UnivariateSpline.derivative										
scipy.interpolate.UnivariateSpline.derivatives	A										<section class="prog__container"><p>Return all derivatives of the spline at the point x.</p><pre><code>UnivariateSpline.derivatives(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : float\n    The point to evaluate the derivatives at.</code></pre><span class="prog__sub">Returns:</span><pre><code>der : ndarray, shape(k+1,)\n    Derivatives of the orders 0 to k.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 3, 11)\n>>> y = x**2\n>>> spl = UnivariateSpline(x, y)\n>>> spl.derivatives(1.5)\narray([2.25, 3.0, 2.0, 0])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.derivatives.html
scipy interpolate UnivariateSpline derivatives	R	scipy.interpolate.UnivariateSpline.derivatives										
scipy interpolate.UnivariateSpline.derivatives	R	scipy.interpolate.UnivariateSpline.derivatives										
scipy.interpolate.UnivariateSpline.get_coeffs	A										<section class="prog__container"><p>Return spline coefficients.</p><pre><code>UnivariateSpline.get_coeffs()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.get_coeffs.html
scipy interpolate UnivariateSpline get_coeffs	R	scipy.interpolate.UnivariateSpline.get_coeffs										
scipy interpolate.UnivariateSpline.get_coeffs	R	scipy.interpolate.UnivariateSpline.get_coeffs										
scipy.interpolate.UnivariateSpline.get_knots	A										<section class="prog__container"><p>Return positions of interior knots of the spline.</p><pre><code>UnivariateSpline.get_knots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.get_knots.html
scipy interpolate UnivariateSpline get_knots	R	scipy.interpolate.UnivariateSpline.get_knots										
scipy interpolate.UnivariateSpline.get_knots	R	scipy.interpolate.UnivariateSpline.get_knots										
scipy.interpolate.UnivariateSpline.get_residual	A										<section class="prog__container"><p>Return weighted sum of squared residuals of the spline approximation.</p><pre><code>UnivariateSpline.get_residual()</code></pre><span class="prog__sub">Examples:</span><pre><code>sum((w[i] * (y[i]-spl(x[i])))**2, axis=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.get_residual.html
scipy interpolate UnivariateSpline get_residual	R	scipy.interpolate.UnivariateSpline.get_residual										
scipy interpolate.UnivariateSpline.get_residual	R	scipy.interpolate.UnivariateSpline.get_residual										
scipy.interpolate.UnivariateSpline.integral	A										<section class="prog__container"><p>Return definite integral of the spline between two given points.</p><pre><code>UnivariateSpline.integral(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    Lower limit of integration. \nb : float\n    Upper limit of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>integral : float\n    The value of the definite integral of the spline between limits.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.interpolate import UnivariateSpline\n>>> x = np.linspace(0, 3, 11)\n>>> y = x**2\n>>> spl = UnivariateSpline(x, y)\n>>> spl.integral(0, 3)\n9.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.integral.html
scipy interpolate UnivariateSpline integral	R	scipy.interpolate.UnivariateSpline.integral										
scipy interpolate.UnivariateSpline.integral	R	scipy.interpolate.UnivariateSpline.integral										
scipy.interpolate.UnivariateSpline.roots	A										<section class="prog__container"><p>Return the zeros of the spline.</p><pre><code>UnivariateSpline.roots()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.roots.html
scipy interpolate UnivariateSpline roots	R	scipy.interpolate.UnivariateSpline.roots										
scipy interpolate.UnivariateSpline.roots	R	scipy.interpolate.UnivariateSpline.roots										
scipy interpolate UnivariateSpline	R	scipy.interpolate.UnivariateSpline										
scipy interpolate.UnivariateSpline	R	scipy.interpolate.UnivariateSpline										
scipy.interpolate.UnivariateSpline.set_smoothing_factor	A										<section class="prog__container"><p>Continue spline computation with the given smoothing\nfactor s and with the knots found at the last call.</p><pre><code>UnivariateSpline.set_smoothing_factor(s)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.set_smoothing_factor.html
scipy interpolate UnivariateSpline set_smoothing_factor	R	scipy.interpolate.UnivariateSpline.set_smoothing_factor										
scipy interpolate.UnivariateSpline.set_smoothing_factor	R	scipy.interpolate.UnivariateSpline.set_smoothing_factor										
scipy.io.arff.loadarff	A										<section class="prog__container"><p>Read an arff file.</p><pre><code>scipy.io.arff.loadarff(f)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : file-like or str\n    File-like object to read from, or filename to open.</code></pre><span class="prog__sub">Returns:</span><pre><code>data : record array\n    The data of the arff file, accessible by attribute names. \nmeta : MetaData\n    Contains information about the arff file such as name and type of attributes, the relation (name of the dataset), etc...</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.io import arff\n>>> from cStringIO import StringIO\n>>> content = """\n... @relation foo\n... @attribute width  numeric\n... @attribute height numeric\n... @attribute color  {red,green,blue,yellow,black}\n... @data\n... 5.0,3.25,blue\n... 4.5,3.75,green\n... 3.0,4.00,red\n... """\n>>> f = StringIO(content)\n>>> data, meta = arff.loadarff(f)\n>>> data\narray([(5.0, 3.25, 'blue'), (4.5, 3.75, 'green'), (3.0, 4.0, 'red')],\n      dtype=[('width', '<f8'), ('height', '<f8'), ('color', '|S6')])\n>>> meta\nDataset: foo\n    width's type is numeric\n    height's type is numeric\n    color's type is nominal, range is ('red', 'green', 'blue', 'yellow', 'black')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.arff.loadarff.html
scipy io arff loadarff	R	scipy.io.arff.loadarff										
scipy io.arff.loadarff	R	scipy.io.arff.loadarff										
scipy.io.arff.MetaData	A										<section class="prog__container"><p>Small container to keep useful informations on a ARFF dataset.</p><pre><code>class scipy.io.arff.MetaData(rel, attr)</code></pre><span class="prog__sub">Examples:</span><pre><code>data, meta = loadarff('iris.arff')\n# This will print the attributes names of the iris.arff dataset\nfor i in meta:\n    print i\n# This works too\nmeta.names()\n# Getting attribute type\ntypes = meta.types()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.arff.MetaData.html
scipy.io.arff.MetaData.names	A										<section class="prog__container"><p>Return the list of attribute names.</p><pre><code>MetaData.names()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.arff.MetaData.names.html
scipy io arff MetaData names	R	scipy.io.arff.MetaData.names										
scipy io.arff.MetaData.names	R	scipy.io.arff.MetaData.names										
scipy io arff MetaData	R	scipy.io.arff.MetaData										
scipy io.arff.MetaData	R	scipy.io.arff.MetaData										
scipy.io.arff.MetaData.types	A										<section class="prog__container"><p>Return the list of attribute types.</p><pre><code>MetaData.types()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.arff.MetaData.types.html
scipy io arff MetaData types	R	scipy.io.arff.MetaData.types										
scipy io.arff.MetaData.types	R	scipy.io.arff.MetaData.types										
scipy.io.FortranFile	A										<section class="prog__container"><p>A file object for unformatted sequential files from Fortran code.</p><pre><code>class scipy.io.FortranFile(filename, mode='r', header_dtype=<type 'numpy.uint32'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>filename : file or str\n    Open file object or filename. \nmode : {‘r’, ‘w’}, optional\n    Read-write mode, default is ‘r’. \nheader_dtype : dtype, optional\n    Data type of the header. Size and endiness must match the input/output file.</code></pre><span class="prog__sub">Examples:</span><pre><code>OPEN(1, FILE=myfilename, FORM='unformatted')\n\nWRITE(1) myvariable</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.FortranFile.html
scipy.io.FortranFile.close	A										<section class="prog__container"><p>Closes the file. It is unsupported to call any other methods off this\nobject after closing it. Note that this class supports the ‘with’\nstatement in modern versions of Python, to call this automatically</p><pre><code>FortranFile.close()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.FortranFile.close.html
scipy io FortranFile close	R	scipy.io.FortranFile.close										
scipy io.FortranFile.close	R	scipy.io.FortranFile.close										
scipy.io.FortranFile.read_ints	A					[[scipy.io.FortranFile.read_reals]]\\n[[scipy.io.FortranFile.read_record]]					<section class="prog__container"><p>Reads a record of a given type from the file, defaulting to an integer\ntype (INTEGER*4 in Fortran)</p><pre><code>FortranFile.read_ints(dtype='i4')</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : dtype, optional\n    Data type specifying the size and endiness of the data.</code></pre><span class="prog__sub">Returns:</span><pre><code>data : ndarray\n    A one-dimensional array object.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.FortranFile.read_ints.html
scipy io FortranFile read_ints	R	scipy.io.FortranFile.read_ints										
scipy io.FortranFile.read_ints	R	scipy.io.FortranFile.read_ints										
scipy.io.FortranFile.read_reals	A					[[scipy.io.FortranFile.read_ints]]\\n[[scipy.io.FortranFile.read_record]]					<section class="prog__container"><p>Reads a record of a given type from the file, defaulting to a floating\npoint number (real*8 in Fortran)</p><pre><code>FortranFile.read_reals(dtype='f8')</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : dtype, optional\n    Data type specifying the size and endiness of the data.</code></pre><span class="prog__sub">Returns:</span><pre><code>data : ndarray\n    A one-dimensional array object.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.FortranFile.read_reals.html
scipy io FortranFile read_reals	R	scipy.io.FortranFile.read_reals										
scipy io.FortranFile.read_reals	R	scipy.io.FortranFile.read_reals										
scipy.io.FortranFile.read_record	A					[[scipy.io.FortranFile.read_reals]]\\n[[scipy.io.FortranFile.read_ints]]					<section class="prog__container"><p>Reads a record of a given type from the file.</p><pre><code>FortranFile.read_record(dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dtype : dtype, optional\n    Data type specifying the size and endiness of the data.</code></pre><span class="prog__sub">Returns:</span><pre><code>data : ndarray\n    A one-dimensional array object.</code></pre><span class="prog__sub">Examples:</span><pre><code>record = f.read_record([('a', '<f4'), ('b', '<i4')])\nrecord['a']  # access the variable 'a'</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.FortranFile.read_record.html
scipy io FortranFile read_record	R	scipy.io.FortranFile.read_record										
scipy io.FortranFile.read_record	R	scipy.io.FortranFile.read_record										
scipy io FortranFile	R	scipy.io.FortranFile										
scipy io.FortranFile	R	scipy.io.FortranFile										
scipy.io.FortranFile.write_record	A										<section class="prog__container"><p>Write a record (including sizes) to the file.</p><pre><code>FortranFile.write_record(s)</code></pre><span class="prog__sub">Parameters:</span><pre><code>s : array_like\n    The data to write.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.FortranFile.write_record.html
scipy io FortranFile write_record	R	scipy.io.FortranFile.write_record										
scipy io.FortranFile.write_record	R	scipy.io.FortranFile.write_record										
scipy.io.hb_read	A										<section class="prog__container"><p>Read HB-format file.</p><pre><code>scipy.io.hb_read(file)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str-like or file-like\n    If a string-like object, file is the name of the file to read. If a file-like object, the data are read from it.</code></pre><span class="prog__sub">Returns:</span><pre><code>data : scipy.sparse.csc_matrix instance\n    The data read from the HB file as a sparse matrix.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.hb_read.html
scipy io hb_read	R	scipy.io.hb_read										
scipy io.hb_read	R	scipy.io.hb_read										
scipy.io.hb_write	A										<section class="prog__container"><p>Write HB-format file.</p><pre><code>scipy.io.hb_write(file, m, hb_info=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file : str-like or file-like\n    if a string-like object, file is the name of the file to read. If a file-like object, the data are read from it. \nm : sparse-matrix\n    the sparse matrix to write \nhb_info : HBInfo\n    contains the meta-data for write</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.hb_write.html
scipy io hb_write	R	scipy.io.hb_write										
scipy io.hb_write	R	scipy.io.hb_write										
scipy.io.loadmat	A										<section class="prog__container"><p>Load MATLAB file.</p><pre><code>scipy.io.loadmat(file_name, mdict=None, appendmat=True, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file_name : str\n    Name of the mat file (do not need .mat extension if appendmat==True). Can also pass open file-like object. \nmdict : dict, optional\n    Dictionary in which to insert matfile variables. \nappendmat : bool, optional\n    True to append the .mat extension to the end of the given filename, if not already present. \nbyte_order : str or None, optional\n    None by default, implying byte order guessed from mat file. Otherwise can be one of (‘native’, ‘=’, ‘little’, ‘<’, ‘BIG’, ‘>’). \nmat_dtype : bool, optional\n    If True, return arrays in same dtype as would be loaded into MATLAB (instead of the dtype with which they are saved). \nsqueeze_me : bool, optional\n    Whether to squeeze unit matrix dimensions or not. \nchars_as_strings : bool, optional\n    Whether to convert char arrays to string arrays. \nmatlab_compatible : bool, optional\n    Returns matrices as would be loaded by MATLAB (implies squeeze_me=False, chars_as_strings=False, mat_dtype=True, struct_as_record=True). \nstruct_as_record : bool, optional\n    Whether to load MATLAB structs as numpy record arrays, or as old-style numpy arrays with dtype=object.  Setting this flag to False replicates the behavior of scipy version 0.7.x (returning numpy object arrays).  The default setting is True, because it allows easier round-trip load and save of MATLAB files. \nverify_compressed_data_integrity : bool, optional\n    Whether the length of compressed sequences in the MATLAB file should be checked, to ensure that they are not longer than we expect. It is advisable to enable this (the default) because overlong compressed sequences in MATLAB files generally indicate that the files have experienced some sort of corruption. \nvariable_names : None or sequence\n    If None (the default) - read all variables in file. Otherwise variable_names should be a sequence of strings, giving names of the matlab variables to read from the file.  The reader will skip any variable with a name not in this sequence, possibly saving some read processing.</code></pre><span class="prog__sub">Returns:</span><pre><code>mat_dict : dict\n    dictionary with variable names as keys, and loaded matrices as values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html
scipy io loadmat	R	scipy.io.loadmat										
scipy io.loadmat	R	scipy.io.loadmat										
scipy.io.mminfo	A										<section class="prog__container"><p>Return size and storage parameters from Matrix Market file-like ‘source’.</p><pre><code>scipy.io.mminfo(source)</code></pre><span class="prog__sub">Parameters:</span><pre><code>source : str or file-like\n    Matrix Market filename (extension .mtx) or open file-like object</code></pre><span class="prog__sub">Returns:</span><pre><code>rows : int\n    Number of matrix rows. \ncols : int\n    Number of matrix columns. \nentries : int\n    Number of non-zero entries of a sparse matrix or rows*cols for a dense matrix. \nformat : str\n    Either ‘coordinate’ or ‘array’. \nfield : str\n    Either ‘real’, ‘complex’, ‘pattern’, or ‘integer’. \nsymmetry : str\n    Either ‘general’, ‘symmetric’, ‘skew-symmetric’, or ‘hermitian’.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.mminfo.html
scipy io mminfo	R	scipy.io.mminfo										
scipy io.mminfo	R	scipy.io.mminfo										
scipy.io.mmread	A										<section class="prog__container"><p>Reads the contents of a Matrix Market file-like ‘source’ into a matrix.</p><pre><code>scipy.io.mmread(source)</code></pre><span class="prog__sub">Parameters:</span><pre><code>source : str or file-like\n    Matrix Market filename (extensions .mtx, .mtz.gz) or open file-like object.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : ndarray or coo_matrix\n    Dense or sparse matrix depending on the matrix format in the Matrix Market file.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.mmread.html
scipy io mmread	R	scipy.io.mmread										
scipy io.mmread	R	scipy.io.mmread										
scipy.io.mmwrite	A										<section class="prog__container"><p>Writes the sparse or dense array a to Matrix Market file-like target.</p><pre><code>scipy.io.mmwrite(target, a, comment='', field=None, precision=None, symmetry=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>target : str or file-like\n    Matrix Market filename (extension .mtx) or open file-like object. \na : array like\n    Sparse or dense 2D array. \ncomment : str, optional\n    Comments to be prepended to the Matrix Market file. \nfield : None or str, optional\n    Either ‘real’, ‘complex’, ‘pattern’, or ‘integer’. \nprecision : None or int, optional\n    Number of digits to display for real or complex values. \nsymmetry : None or str, optional\n    Either ‘general’, ‘symmetric’, ‘skew-symmetric’, or ‘hermitian’. If symmetry is None the symmetry type of ‘a’ is determined by its values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.mmwrite.html
scipy io mmwrite	R	scipy.io.mmwrite										
scipy io.mmwrite	R	scipy.io.mmwrite										
scipy.io.netcdf_file	A										<section class="prog__container"><p>A file object for NetCDF data.</p><pre><code>class scipy.io.netcdf_file(filename, mode='r', mmap=None, version=1, maskandscale=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>filename : string or file-like\n    string -> filename \nmode : {‘r’, ‘w’, ‘a’}, optional\n    read-write-append mode, default is ‘r’ \nmmap : None or bool, optional\n    Whether to mmap filename when reading.  Default is True when filename is a file name, False when filename is a file-like object. Note that when mmap is in use, data arrays returned refer directly to the mmapped data on disk, and the file cannot be closed as long as references to it exist. \nversion : {1, 2}, optional\n    version of netcdf to read / write, where 1 means Classic format and 2 means 64-bit offset format.  Default is 1.  See here for more info. \nmaskandscale : bool, optional\n    Whether to automatically scale and/or mask data based on attributes. Default is False.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.io import netcdf\n>>> f = netcdf.netcdf_file('simple.nc', 'w')\n>>> f.history = 'Created for a test'\n>>> f.createDimension('time', 10)\n>>> time = f.createVariable('time', 'i', ('time',))\n>>> time[:] = np.arange(10)\n>>> time.units = 'days since 2008-01-01'\n>>> f.close()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_file.html
scipy.io.netcdf_file.close	A										<section class="prog__container"><p>Closes the NetCDF file.</p><pre><code>netcdf_file.close()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_file.close.html
scipy io netcdf_file close	R	scipy.io.netcdf_file.close										
scipy io.netcdf_file.close	R	scipy.io.netcdf_file.close										
scipy.io.netcdf_file.createDimension	A					[[scipy.io.netcdf_file.createVariable]]					<section class="prog__container"><p>Adds a dimension to the Dimension section of the NetCDF data structure.</p><pre><code>netcdf_file.createDimension(name, length)</code></pre><span class="prog__sub">Parameters:</span><pre><code>name : str\n    Name of the dimension (Eg, ‘lat’ or ‘time’). \nlength : int\n    Length of the dimension.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_file.createDimension.html
scipy io netcdf_file createDimension	R	scipy.io.netcdf_file.createDimension										
scipy io.netcdf_file.createDimension	R	scipy.io.netcdf_file.createDimension										
scipy.io.netcdf_file.createVariable	A					[[scipy.io.netcdf_file.createDimension]]					<section class="prog__container"><p>Create an empty variable for the netcdf_file object, specifying its data\ntype and the dimensions it uses.</p><pre><code>netcdf_file.createVariable(name, type, dimensions)</code></pre><span class="prog__sub">Parameters:</span><pre><code>name : str\n    Name of the new variable. \ntype : dtype or str\n    Data type of the variable. \ndimensions : sequence of str\n    List of the dimension names used by the variable, in the desired order.</code></pre><span class="prog__sub">Returns:</span><pre><code>variable : netcdf_variable\n    The newly created netcdf_variable object. This object has also been added to the netcdf_file object as well.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_file.createVariable.html
scipy io netcdf_file createVariable	R	scipy.io.netcdf_file.createVariable										
scipy io.netcdf_file.createVariable	R	scipy.io.netcdf_file.createVariable										
scipy.io.netcdf_file.flush	A										<section class="prog__container"><p>Perform a sync-to-disk flush if the netcdf_file object is in write mode.</p><pre><code>netcdf_file.flush()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_file.flush.html
scipy io netcdf_file flush	R	scipy.io.netcdf_file.flush										
scipy io.netcdf_file.flush	R	scipy.io.netcdf_file.flush										
scipy io netcdf_file	R	scipy.io.netcdf_file										
scipy io.netcdf_file	R	scipy.io.netcdf_file										
scipy.io.netcdf_file.sync	A										<section class="prog__container"><p>Perform a sync-to-disk flush if the netcdf_file object is in write mode.</p><pre><code>netcdf_file.sync()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_file.sync.html
scipy io netcdf_file sync	R	scipy.io.netcdf_file.sync										
scipy io.netcdf_file.sync	R	scipy.io.netcdf_file.sync										
scipy.io.netcdf_variable	A					[[scipy.io.netcdf_variable.isrec]]\\n[[scipy.io.netcdf_variable.shape]]					<section class="prog__container"><p>A data object for the netcdf module.</p><pre><code>class scipy.io.netcdf_variable(data, typecode, size, shape, dimensions, attributes=None, maskandscale=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    The data array that holds the values for the variable. Typically, this is initialized as empty, but with the proper shape. \ntypecode : dtype character code\n    Desired data-type for the data array. \nsize : int\n    Desired element size for the data array. \nshape : sequence of ints\n    The shape of the array.  This should match the lengths of the variable’s dimensions. \ndimensions : sequence of strings\n    The names of the dimensions used by the variable.  Must be in the same order of the dimension lengths given by shape. \nattributes : dict, optional\n    Attribute values (any type) keyed by string names.  These attributes become attributes for the netcdf_variable object. \nmaskandscale : bool, optional\n    Whether to automatically scale and/or mask data based on attributes. Default is False.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_variable.html
scipy.io.netcdf_variable.assignValue	A										<section class="prog__container"><p>Assign a scalar value to a netcdf_variable of length one.</p><pre><code>netcdf_variable.assignValue(value)</code></pre><span class="prog__sub">Parameters:</span><pre><code>value : scalar\n    Scalar value (of compatible type) to assign to a length-one netcdf variable. This value will be written to file.</code></pre><span class="prog__sub">Returns:</span><pre><code>ValueError\n    If the input is not a scalar, or if the destination is not a length-one netcdf variable.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_variable.assignValue.html
scipy io netcdf_variable assignValue	R	scipy.io.netcdf_variable.assignValue										
scipy io.netcdf_variable.assignValue	R	scipy.io.netcdf_variable.assignValue										
scipy.io.netcdf_variable.getValue	A										<section class="prog__container"><p>Retrieve a scalar value from a netcdf_variable of length one.</p><pre><code>netcdf_variable.getValue()</code></pre><span class="prog__sub">Parameters:</span><pre><code>ValueError\n    If the netcdf variable is an array of length greater than one, this exception will be raised.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_variable.getValue.html
scipy io netcdf_variable getValue	R	scipy.io.netcdf_variable.getValue										
scipy io.netcdf_variable.getValue	R	scipy.io.netcdf_variable.getValue										
scipy.io.netcdf_variable.isrec	A										<section class="prog__container"><p>Returns whether the variable has a record dimension or not.</p><pre><code>netcdf_variable.isrec</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_variable.isrec.html
scipy io netcdf_variable isrec	R	scipy.io.netcdf_variable.isrec										
scipy io.netcdf_variable.isrec	R	scipy.io.netcdf_variable.isrec										
scipy.io.netcdf_variable.itemsize	A										<section class="prog__container"><p>Return the itemsize of the variable.</p><pre><code>netcdf_variable.itemsize()</code></pre><span class="prog__sub">Parameters:</span><pre><code>itemsize : int\n    The element size of the variable (eg, 8 for float64).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_variable.itemsize.html
scipy io netcdf_variable itemsize	R	scipy.io.netcdf_variable.itemsize										
scipy io.netcdf_variable.itemsize	R	scipy.io.netcdf_variable.itemsize										
scipy io netcdf_variable	R	scipy.io.netcdf_variable										
scipy io.netcdf_variable	R	scipy.io.netcdf_variable										
scipy.io.netcdf_variable.shape	A										<section class="prog__container"><p>Returns the shape tuple of the data variable.</p><pre><code>netcdf_variable.shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_variable.shape.html
scipy io netcdf_variable shape	R	scipy.io.netcdf_variable.shape										
scipy io.netcdf_variable.shape	R	scipy.io.netcdf_variable.shape										
scipy.io.netcdf_variable.typecode	A										<section class="prog__container"><p>Return the typecode of the variable.</p><pre><code>netcdf_variable.typecode()</code></pre><span class="prog__sub">Parameters:</span><pre><code>typecode : char\n    The character typecode of the variable (eg, ‘i’ for int).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.netcdf_variable.typecode.html
scipy io netcdf_variable typecode	R	scipy.io.netcdf_variable.typecode										
scipy io.netcdf_variable.typecode	R	scipy.io.netcdf_variable.typecode										
scipy.io.readsav	A										<section class="prog__container"><p>Read an IDL .sav file.</p><pre><code>scipy.io.readsav(file_name, idict=None, python_dict=False, uncompressed_file_name=None, verbose=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file_name : str\n    Name of the IDL save file. \nidict : dict, optional\n    Dictionary in which to insert .sav file variables. \npython_dict : bool, optional\n    By default, the object return is not a Python dictionary, but a case-insensitive dictionary with item, attribute, and call access to variables. To get a standard Python dictionary, set this option to True. \nuncompressed_file_name : str, optional\n    This option only has an effect for .sav files written with the /compress option. If a file name is specified, compressed .sav files are uncompressed to this file. Otherwise, readsav will use the tempfile module to determine a temporary filename automatically, and will remove the temporary file upon successfully reading it in. \nverbose : bool, optional\n    Whether to print out information about the save file, including the records read, and available variables.</code></pre><span class="prog__sub">Returns:</span><pre><code>idl_dict : AttrDict or dict\n    If python_dict is set to False (default), this function returns a case-insensitive dictionary with item, attribute, and call access to variables. If python_dict is set to True, this function returns a Python dictionary with all variable names in lowercase. If idict was specified, then variables are written to the dictionary specified, and the updated dictionary is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.readsav.html
scipy io readsav	R	scipy.io.readsav										
scipy io.readsav	R	scipy.io.readsav										
scipy.io.savemat	A										<section class="prog__container"><p>Save a dictionary of names and arrays into a MATLAB-style .mat file.</p><pre><code>scipy.io.savemat(file_name, mdict, appendmat=True, format='5', long_field_names=False, do_compression=False, oned_as='row')</code></pre><span class="prog__sub">Parameters:</span><pre><code>file_name : str or file-like object\n    Name of the .mat file (.mat extension not needed if appendmat == True). Can also pass open file_like object. \nmdict : dict\n    Dictionary from which to save matfile variables. \nappendmat : bool, optional\n    True (the default) to append the .mat extension to the end of the given filename, if not already present. \nformat : {‘5’, ‘4’}, string, optional\n    ‘5’ (the default) for MATLAB 5 and up (to 7.2), ‘4’ for MATLAB 4 .mat files. \nlong_field_names : bool, optional\n    False (the default) - maximum field name length in a structure is 31 characters which is the documented maximum length. True - maximum field name length in a structure is 63 characters which works for MATLAB 7.6+. \ndo_compression : bool, optional\n    Whether or not to compress matrices on write.  Default is False. \noned_as : {‘row’, ‘column’}, optional\n    If ‘column’, write 1-D numpy arrays as column vectors. If ‘row’, write 1-D numpy arrays as row vectors.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.savemat.html
scipy io savemat	R	scipy.io.savemat										
scipy io.savemat	R	scipy.io.savemat										
scipy.io.wavfile.read	A										<section class="prog__container"><p>Open a WAV file</p><pre><code>scipy.io.wavfile.read(filename, mmap=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>filename : string or open file handle\n    Input wav file. \nmmap : bool, optional\n    Whether to read data as memory-mapped. Only to be used on real files (Default: False).  New in version 0.12.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>rate : int\n    Sample rate of wav file. \ndata : numpy array\n    Data read from wav file.  Data-type is determined from the file; see Notes.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.wavfile.read.html
scipy io wavfile read	R	scipy.io.wavfile.read										
scipy io.wavfile.read	R	scipy.io.wavfile.read										
scipy.io.wavfile.write	A										<section class="prog__container"><p>Write a numpy array as a WAV file.</p><pre><code>scipy.io.wavfile.write(filename, rate, data)</code></pre><span class="prog__sub">Parameters:</span><pre><code>filename : string or open file handle\n    Output wav file. \nrate : int\n    The sample rate (in samples/sec). \ndata : ndarray\n    A 1-D or 2-D numpy array of either integer or float data-type.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.wavfile.write.html
scipy io wavfile write	R	scipy.io.wavfile.write										
scipy io.wavfile.write	R	scipy.io.wavfile.write										
scipy.io.whosmat	A										<section class="prog__container"><p>List variables inside a MATLAB file.</p><pre><code>scipy.io.whosmat(file_name, appendmat=True, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>file_name : str\n    Name of the mat file (do not need .mat extension if appendmat==True) Can also pass open file-like object. \nappendmat : bool, optional\n    True to append the .mat extension to the end of the given filename, if not already present. \nbyte_order : str or None, optional\n    None by default, implying byte order guessed from mat file. Otherwise can be one of (‘native’, ‘=’, ‘little’, ‘<’, ‘BIG’, ‘>’). \nmat_dtype : bool, optional\n    If True, return arrays in same dtype as would be loaded into MATLAB (instead of the dtype with which they are saved). \nsqueeze_me : bool, optional\n    Whether to squeeze unit matrix dimensions or not. \nchars_as_strings : bool, optional\n    Whether to convert char arrays to string arrays. \nmatlab_compatible : bool, optional\n    Returns matrices as would be loaded by MATLAB (implies squeeze_me=False, chars_as_strings=False, mat_dtype=True, struct_as_record=True). \nstruct_as_record : bool, optional\n    Whether to load MATLAB structs as numpy record arrays, or as old-style numpy arrays with dtype=object.  Setting this flag to False replicates the behavior of scipy version 0.7.x (returning numpy object arrays).  The default setting is True, because it allows easier round-trip load and save of MATLAB files.</code></pre><span class="prog__sub">Returns:</span><pre><code>variables : list of tuples\n    A list of tuples, where each tuple holds the matrix name (a string), its shape (tuple of ints), and its data class (a string). Possible data classes are: int8, uint8, int16, uint16, int32, uint32, int64, uint64, single, double, cell, struct, object, char, sparse, function, opaque, logical, unknown.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.whosmat.html
scipy io whosmat	R	scipy.io.whosmat										
scipy io.whosmat	R	scipy.io.whosmat										
scipy.linalg.blas.caxpy	A										<section class="prog__container"><p>Wrapper for caxpy.</p><pre><code>scipy.linalg.blas.caxpy(x, y[, n, a, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)\ny : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>z : rank-1 array(‘F’) with bounds (*) and y storage</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.caxpy.html
scipy linalg blas caxpy	R	scipy.linalg.blas.caxpy										
scipy linalg.blas.caxpy	R	scipy.linalg.blas.caxpy										
scipy.linalg.blas.ccopy	A										<section class="prog__container"><p>Wrapper for ccopy.</p><pre><code>scipy.linalg.blas.ccopy(x, y[, n, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)\ny : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘F’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ccopy.html
scipy linalg blas ccopy	R	scipy.linalg.blas.ccopy										
scipy linalg.blas.ccopy	R	scipy.linalg.blas.ccopy										
scipy.linalg.blas.cdotc	A										<section class="prog__container"><p>Wrapper for cdotc.</p><pre><code>scipy.linalg.blas.cdotc(x, y[, n, offx, incx, offy, incy]) = <fortran cdotc></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)\ny : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>xy : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cdotc.html
scipy linalg blas cdotc	R	scipy.linalg.blas.cdotc										
scipy linalg.blas.cdotc	R	scipy.linalg.blas.cdotc										
scipy.linalg.blas.cdotu	A										<section class="prog__container"><p>Wrapper for cdotu.</p><pre><code>scipy.linalg.blas.cdotu(x, y[, n, offx, incx, offy, incy]) = <fortran cdotu></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)\ny : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>xy : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cdotu.html
scipy linalg blas cdotu	R	scipy.linalg.blas.cdotu										
scipy linalg.blas.cdotu	R	scipy.linalg.blas.cdotu										
scipy.linalg.blas.cgemm	A										<section class="prog__container"><p>Wrapper for cgemm.</p><pre><code>scipy.linalg.blas.cgemm(alpha, a, b[, beta, c, trans_a, trans_b, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (lda,ka)\nb : input rank-2 array(‘F’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cgemm.html
scipy linalg blas cgemm	R	scipy.linalg.blas.cgemm										
scipy linalg.blas.cgemm	R	scipy.linalg.blas.cgemm										
scipy.linalg.blas.cgemv	A										<section class="prog__container"><p>Wrapper for cgemv.</p><pre><code>scipy.linalg.blas.cgemv(alpha, a, x[, beta, y, offx, incx, offy, incy, trans, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (m,n)\nx : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘F’) with bounds (ly)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cgemv.html
scipy linalg blas cgemv	R	scipy.linalg.blas.cgemv										
scipy linalg.blas.cgemv	R	scipy.linalg.blas.cgemv										
scipy.linalg.blas.cgerc	A										<section class="prog__container"><p>Wrapper for cgerc.</p><pre><code>scipy.linalg.blas.cgerc(alpha, x, y[, incx, incy, a, overwrite_x, overwrite_y, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘F’) with bounds (m)\ny : input rank-1 array(‘F’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cgerc.html
scipy linalg blas cgerc	R	scipy.linalg.blas.cgerc										
scipy linalg.blas.cgerc	R	scipy.linalg.blas.cgerc										
scipy.linalg.blas.cgeru	A										<section class="prog__container"><p>Wrapper for cgeru.</p><pre><code>scipy.linalg.blas.cgeru(alpha, x, y[, incx, incy, a, overwrite_x, overwrite_y, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘F’) with bounds (m)\ny : input rank-1 array(‘F’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cgeru.html
scipy linalg blas cgeru	R	scipy.linalg.blas.cgeru										
scipy linalg.blas.cgeru	R	scipy.linalg.blas.cgeru										
scipy.linalg.blas.chemm	A										<section class="prog__container"><p>Wrapper for chemm.</p><pre><code>scipy.linalg.blas.chemm(alpha, a, b[, beta, c, side, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (lda,ka)\nb : input rank-2 array(‘F’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.chemm.html
scipy linalg blas chemm	R	scipy.linalg.blas.chemm										
scipy linalg.blas.chemm	R	scipy.linalg.blas.chemm										
scipy.linalg.blas.chemv	A										<section class="prog__container"><p>Wrapper for chemv.</p><pre><code>scipy.linalg.blas.chemv(alpha, a, x[, beta, y, offx, incx, offy, incy, lower, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (n,n)\nx : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘F’) with bounds (ly)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.chemv.html
scipy linalg blas chemv	R	scipy.linalg.blas.chemv										
scipy linalg.blas.chemv	R	scipy.linalg.blas.chemv										
scipy.linalg.blas.cher2	A										<section class="prog__container"><p>Wrapper for cher2.</p><pre><code>scipy.linalg.blas.cher2(alpha, x, y[, lower, incx, offx, incy, offy, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘F’) with bounds (*)\ny : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cher2.html
scipy.linalg.blas.cher2k	A										<section class="prog__container"><p>Wrapper for cher2k.</p><pre><code>scipy.linalg.blas.cher2k(alpha, a, b[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (lda,ka)\nb : input rank-2 array(‘F’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cher2k.html
scipy linalg blas cher2k	R	scipy.linalg.blas.cher2k										
scipy linalg.blas.cher2k	R	scipy.linalg.blas.cher2k										
scipy linalg blas cher2	R	scipy.linalg.blas.cher2										
scipy linalg.blas.cher2	R	scipy.linalg.blas.cher2										
scipy.linalg.blas.cher	A										<section class="prog__container"><p>Wrapper for cher.</p><pre><code>scipy.linalg.blas.cher(alpha, x[, lower, incx, offx, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cher.html
scipy.linalg.blas.cherk	A										<section class="prog__container"><p>Wrapper for cherk.</p><pre><code>scipy.linalg.blas.cherk(alpha, a[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (lda,ka)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cherk.html
scipy linalg blas cherk	R	scipy.linalg.blas.cherk										
scipy linalg.blas.cherk	R	scipy.linalg.blas.cherk										
scipy linalg blas cher	R	scipy.linalg.blas.cher										
scipy linalg.blas.cher	R	scipy.linalg.blas.cher										
scipy.linalg.blas.crotg	A										<section class="prog__container"><p>Wrapper for crotg.</p><pre><code>scipy.linalg.blas.crotg(a, b) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input complex\nb : input complex</code></pre><span class="prog__sub">Returns:</span><pre><code>c : complex\ns : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.crotg.html
scipy linalg blas crotg	R	scipy.linalg.blas.crotg										
scipy linalg.blas.crotg	R	scipy.linalg.blas.crotg										
scipy.linalg.blas.cscal	A										<section class="prog__container"><p>Wrapper for cscal.</p><pre><code>scipy.linalg.blas.cscal(a, x[, n, offx, incx]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input complex\nx : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘F’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cscal.html
scipy linalg blas cscal	R	scipy.linalg.blas.cscal										
scipy linalg.blas.cscal	R	scipy.linalg.blas.cscal										
scipy.linalg.blas.csrot	A										<section class="prog__container"><p>Wrapper for csrot.</p><pre><code>scipy.linalg.blas.csrot(x, y, c, s[, n, offx, incx, offy, incy, overwrite_x, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)\ny : input rank-1 array(‘F’) with bounds (*)\nc : input float\ns : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘F’) with bounds (*)\ny : rank-1 array(‘F’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.csrot.html
scipy linalg blas csrot	R	scipy.linalg.blas.csrot										
scipy linalg.blas.csrot	R	scipy.linalg.blas.csrot										
scipy.linalg.blas.csscal	A										<section class="prog__container"><p>Wrapper for csscal.</p><pre><code>scipy.linalg.blas.csscal(a, x[, n, offx, incx, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input float\nx : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘F’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.csscal.html
scipy linalg blas csscal	R	scipy.linalg.blas.csscal										
scipy linalg.blas.csscal	R	scipy.linalg.blas.csscal										
scipy.linalg.blas.cswap	A										<section class="prog__container"><p>Wrapper for cswap.</p><pre><code>scipy.linalg.blas.cswap(x, y[, n, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)\ny : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘F’) with bounds (*)\ny : rank-1 array(‘F’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.cswap.html
scipy linalg blas cswap	R	scipy.linalg.blas.cswap										
scipy linalg.blas.cswap	R	scipy.linalg.blas.cswap										
scipy.linalg.blas.csymm	A										<section class="prog__container"><p>Wrapper for csymm.</p><pre><code>scipy.linalg.blas.csymm(alpha, a, b[, beta, c, side, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (lda,ka)\nb : input rank-2 array(‘F’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.csymm.html
scipy linalg blas csymm	R	scipy.linalg.blas.csymm										
scipy linalg.blas.csymm	R	scipy.linalg.blas.csymm										
scipy.linalg.blas.csyr2k	A										<section class="prog__container"><p>Wrapper for csyr2k.</p><pre><code>scipy.linalg.blas.csyr2k(alpha, a, b[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (lda,ka)\nb : input rank-2 array(‘F’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.csyr2k.html
scipy linalg blas csyr2k	R	scipy.linalg.blas.csyr2k										
scipy linalg.blas.csyr2k	R	scipy.linalg.blas.csyr2k										
scipy.linalg.blas.csyr	A										<section class="prog__container"><p>Wrapper for csyr.</p><pre><code>scipy.linalg.blas.csyr(alpha, x[, lower, incx, offx, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.csyr.html
scipy.linalg.blas.csyrk	A										<section class="prog__container"><p>Wrapper for csyrk.</p><pre><code>scipy.linalg.blas.csyrk(alpha, a[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘F’) with bounds (lda,ka)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.csyrk.html
scipy linalg blas csyrk	R	scipy.linalg.blas.csyrk										
scipy linalg.blas.csyrk	R	scipy.linalg.blas.csyrk										
scipy linalg blas csyr	R	scipy.linalg.blas.csyr										
scipy linalg.blas.csyr	R	scipy.linalg.blas.csyr										
scipy.linalg.blas.ctrmv	A										<section class="prog__container"><p>Wrapper for ctrmv.</p><pre><code>scipy.linalg.blas.ctrmv(a, x[, offx, incx, lower, trans, unitdiag, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\nx : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘F’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ctrmv.html
scipy linalg blas ctrmv	R	scipy.linalg.blas.ctrmv										
scipy linalg.blas.ctrmv	R	scipy.linalg.blas.ctrmv										
scipy.linalg.blas.dasum	A										<section class="prog__container"><p>Wrapper for dasum.</p><pre><code>scipy.linalg.blas.dasum(x[, n, offx, incx]) = <fortran dasum></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>s : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dasum.html
scipy linalg blas dasum	R	scipy.linalg.blas.dasum										
scipy linalg.blas.dasum	R	scipy.linalg.blas.dasum										
scipy.linalg.blas.daxpy	A										<section class="prog__container"><p>Wrapper for daxpy.</p><pre><code>scipy.linalg.blas.daxpy(x, y[, n, a, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)\ny : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>z : rank-1 array(‘d’) with bounds (*) and y storage</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.daxpy.html
scipy linalg blas daxpy	R	scipy.linalg.blas.daxpy										
scipy linalg.blas.daxpy	R	scipy.linalg.blas.daxpy										
scipy.linalg.blas.dcopy	A										<section class="prog__container"><p>Wrapper for dcopy.</p><pre><code>scipy.linalg.blas.dcopy(x, y[, n, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)\ny : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘d’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dcopy.html
scipy linalg blas dcopy	R	scipy.linalg.blas.dcopy										
scipy linalg.blas.dcopy	R	scipy.linalg.blas.dcopy										
scipy.linalg.blas.ddot	A										<section class="prog__container"><p>Wrapper for ddot.</p><pre><code>scipy.linalg.blas.ddot(x, y[, n, offx, incx, offy, incy]) = <fortran ddot></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)\ny : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>xy : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ddot.html
scipy linalg blas ddot	R	scipy.linalg.blas.ddot										
scipy linalg.blas.ddot	R	scipy.linalg.blas.ddot										
scipy.linalg.blas.dgemm	A										<section class="prog__container"><p>Wrapper for dgemm.</p><pre><code>scipy.linalg.blas.dgemm(alpha, a, b[, beta, c, trans_a, trans_b, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘d’) with bounds (lda,ka)\nb : input rank-2 array(‘d’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dgemm.html
scipy linalg blas dgemm	R	scipy.linalg.blas.dgemm										
scipy linalg.blas.dgemm	R	scipy.linalg.blas.dgemm										
scipy.linalg.blas.dgemv	A										<section class="prog__container"><p>Wrapper for dgemv.</p><pre><code>scipy.linalg.blas.dgemv(alpha, a, x[, beta, y, offx, incx, offy, incy, trans, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘d’) with bounds (m,n)\nx : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘d’) with bounds (ly)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dgemv.html
scipy linalg blas dgemv	R	scipy.linalg.blas.dgemv										
scipy linalg.blas.dgemv	R	scipy.linalg.blas.dgemv										
scipy.linalg.blas.dger	A										<section class="prog__container"><p>Wrapper for dger.</p><pre><code>scipy.linalg.blas.dger(alpha, x, y[, incx, incy, a, overwrite_x, overwrite_y, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\nx : input rank-1 array(‘d’) with bounds (m)\ny : input rank-1 array(‘d’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘d’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dger.html
scipy linalg blas dger	R	scipy.linalg.blas.dger										
scipy linalg.blas.dger	R	scipy.linalg.blas.dger										
scipy.linalg.blas.dnrm2	A										<section class="prog__container"><p>Wrapper for dnrm2.</p><pre><code>scipy.linalg.blas.dnrm2(x[, n, offx, incx]) = <fortran dnrm2></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>n2 : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dnrm2.html
scipy linalg blas dnrm2	R	scipy.linalg.blas.dnrm2										
scipy linalg.blas.dnrm2	R	scipy.linalg.blas.dnrm2										
scipy.linalg.blas.drot	A										<section class="prog__container"><p>Wrapper for drot.</p><pre><code>scipy.linalg.blas.drot(x, y, c, s[, n, offx, incx, offy, incy, overwrite_x, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)\ny : input rank-1 array(‘d’) with bounds (*)\nc : input float\ns : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘d’) with bounds (*)\ny : rank-1 array(‘d’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.drot.html
scipy.linalg.blas.drotg	A										<section class="prog__container"><p>Wrapper for drotg.</p><pre><code>scipy.linalg.blas.drotg(a, b) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input float\nb : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>c : float\ns : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.drotg.html
scipy linalg blas drotg	R	scipy.linalg.blas.drotg										
scipy linalg.blas.drotg	R	scipy.linalg.blas.drotg										
scipy.linalg.blas.drotm	A										<section class="prog__container"><p>Wrapper for drotm.</p><pre><code>scipy.linalg.blas.drotm(x, y, param[, n, offx, incx, offy, incy, overwrite_x, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)\ny : input rank-1 array(‘d’) with bounds (*)\nparam : input rank-1 array(‘d’) with bounds (5)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘d’) with bounds (*)\ny : rank-1 array(‘d’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.drotm.html
scipy.linalg.blas.drotmg	A										<section class="prog__container"><p>Wrapper for drotmg.</p><pre><code>scipy.linalg.blas.drotmg(d1, d2, x1, y1) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>d1 : input float\nd2 : input float\nx1 : input float\ny1 : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>param : rank-1 array(‘d’) with bounds (5)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.drotmg.html
scipy linalg blas drotmg	R	scipy.linalg.blas.drotmg										
scipy linalg.blas.drotmg	R	scipy.linalg.blas.drotmg										
scipy linalg blas drotm	R	scipy.linalg.blas.drotm										
scipy linalg.blas.drotm	R	scipy.linalg.blas.drotm										
scipy linalg blas drot	R	scipy.linalg.blas.drot										
scipy linalg.blas.drot	R	scipy.linalg.blas.drot										
scipy.linalg.blas.dscal	A										<section class="prog__container"><p>Wrapper for dscal.</p><pre><code>scipy.linalg.blas.dscal(a, x[, n, offx, incx]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input float\nx : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘d’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dscal.html
scipy linalg blas dscal	R	scipy.linalg.blas.dscal										
scipy linalg.blas.dscal	R	scipy.linalg.blas.dscal										
scipy.linalg.blas.dswap	A										<section class="prog__container"><p>Wrapper for dswap.</p><pre><code>scipy.linalg.blas.dswap(x, y[, n, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)\ny : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘d’) with bounds (*)\ny : rank-1 array(‘d’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dswap.html
scipy linalg blas dswap	R	scipy.linalg.blas.dswap										
scipy linalg.blas.dswap	R	scipy.linalg.blas.dswap										
scipy.linalg.blas.dsymm	A										<section class="prog__container"><p>Wrapper for dsymm.</p><pre><code>scipy.linalg.blas.dsymm(alpha, a, b[, beta, c, side, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘d’) with bounds (lda,ka)\nb : input rank-2 array(‘d’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dsymm.html
scipy linalg blas dsymm	R	scipy.linalg.blas.dsymm										
scipy linalg.blas.dsymm	R	scipy.linalg.blas.dsymm										
scipy.linalg.blas.dsymv	A										<section class="prog__container"><p>Wrapper for dsymv.</p><pre><code>scipy.linalg.blas.dsymv(alpha, a, x[, beta, y, offx, incx, offy, incy, lower, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘d’) with bounds (n,n)\nx : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘d’) with bounds (ly)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dsymv.html
scipy linalg blas dsymv	R	scipy.linalg.blas.dsymv										
scipy linalg.blas.dsymv	R	scipy.linalg.blas.dsymv										
scipy.linalg.blas.dsyr2	A										<section class="prog__container"><p>Wrapper for dsyr2.</p><pre><code>scipy.linalg.blas.dsyr2(alpha, x, y[, lower, incx, offx, incy, offy, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\nx : input rank-1 array(‘d’) with bounds (*)\ny : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘d’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dsyr2.html
scipy.linalg.blas.dsyr2k	A										<section class="prog__container"><p>Wrapper for dsyr2k.</p><pre><code>scipy.linalg.blas.dsyr2k(alpha, a, b[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘d’) with bounds (lda,ka)\nb : input rank-2 array(‘d’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dsyr2k.html
scipy linalg blas dsyr2k	R	scipy.linalg.blas.dsyr2k										
scipy linalg.blas.dsyr2k	R	scipy.linalg.blas.dsyr2k										
scipy linalg blas dsyr2	R	scipy.linalg.blas.dsyr2										
scipy linalg.blas.dsyr2	R	scipy.linalg.blas.dsyr2										
scipy.linalg.blas.dsyr	A										<section class="prog__container"><p>Wrapper for dsyr.</p><pre><code>scipy.linalg.blas.dsyr(alpha, x[, lower, incx, offx, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\nx : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘d’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dsyr.html
scipy.linalg.blas.dsyrk	A										<section class="prog__container"><p>Wrapper for dsyrk.</p><pre><code>scipy.linalg.blas.dsyrk(alpha, a[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘d’) with bounds (lda,ka)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dsyrk.html
scipy linalg blas dsyrk	R	scipy.linalg.blas.dsyrk										
scipy linalg.blas.dsyrk	R	scipy.linalg.blas.dsyrk										
scipy linalg blas dsyr	R	scipy.linalg.blas.dsyr										
scipy linalg.blas.dsyr	R	scipy.linalg.blas.dsyr										
scipy.linalg.blas.dtrmv	A										<section class="prog__container"><p>Wrapper for dtrmv.</p><pre><code>scipy.linalg.blas.dtrmv(a, x[, offx, incx, lower, trans, unitdiag, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\nx : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘d’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dtrmv.html
scipy linalg blas dtrmv	R	scipy.linalg.blas.dtrmv										
scipy linalg.blas.dtrmv	R	scipy.linalg.blas.dtrmv										
scipy.linalg.blas.dzasum	A										<section class="prog__container"><p>Wrapper for dzasum.</p><pre><code>scipy.linalg.blas.dzasum(x[, n, offx, incx]) = <fortran dzasum></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>s : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dzasum.html
scipy linalg blas dzasum	R	scipy.linalg.blas.dzasum										
scipy linalg.blas.dzasum	R	scipy.linalg.blas.dzasum										
scipy.linalg.blas.dznrm2	A										<section class="prog__container"><p>Wrapper for dznrm2.</p><pre><code>scipy.linalg.blas.dznrm2(x[, n, offx, incx]) = <fortran dznrm2></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>n2 : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.dznrm2.html
scipy linalg blas dznrm2	R	scipy.linalg.blas.dznrm2										
scipy linalg.blas.dznrm2	R	scipy.linalg.blas.dznrm2										
scipy.linalg.blas.find_best_blas_type	A										<section class="prog__container"><p>Find best-matching BLAS/LAPACK type.</p><pre><code>scipy.linalg.blas.find_best_blas_type(arrays=(), dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arrays : sequence of ndarrays, optional\n    Arrays can be given to determine optimal prefix of BLAS routines. If not given, double-precision routines will be used, otherwise the most generic type in arrays will be used. \ndtype : str or dtype, optional\n    Data-type specifier. Not used if arrays is non-empty.</code></pre><span class="prog__sub">Returns:</span><pre><code>prefix : str\n    BLAS/LAPACK prefix character. \ndtype : dtype\n    Inferred Numpy data type. \nprefer_fortran : bool\n    Whether to prefer Fortran order routines over C order.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.find_best_blas_type.html
scipy linalg blas find_best_blas_type	R	scipy.linalg.blas.find_best_blas_type										
scipy linalg.blas.find_best_blas_type	R	scipy.linalg.blas.find_best_blas_type										
scipy.linalg.blas.get_blas_funcs	A										<section class="prog__container"><p>Return available BLAS function objects from names.</p><pre><code>scipy.linalg.blas.get_blas_funcs(names, arrays=(), dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>names : str or sequence of str\n    Name(s) of BLAS functions without type prefix. \narrays : sequence of ndarrays, optional\n    Arrays can be given to determine optimal prefix of BLAS routines. If not given, double-precision routines will be used, otherwise the most generic type in arrays will be used. \ndtype : str or dtype, optional\n    Data-type specifier. Not used if arrays is non-empty.</code></pre><span class="prog__sub">Returns:</span><pre><code>funcs : list\n    List containing the found function(s).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.get_blas_funcs.html
scipy linalg blas get_blas_funcs	R	scipy.linalg.blas.get_blas_funcs										
scipy linalg.blas.get_blas_funcs	R	scipy.linalg.blas.get_blas_funcs										
scipy.linalg.blas.icamax	A										<section class="prog__container"><p>Wrapper for icamax.</p><pre><code>scipy.linalg.blas.icamax(x[, n, offx, incx]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>k : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.icamax.html
scipy linalg blas icamax	R	scipy.linalg.blas.icamax										
scipy linalg.blas.icamax	R	scipy.linalg.blas.icamax										
scipy.linalg.blas.idamax	A										<section class="prog__container"><p>Wrapper for idamax.</p><pre><code>scipy.linalg.blas.idamax(x[, n, offx, incx]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>k : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.idamax.html
scipy linalg blas idamax	R	scipy.linalg.blas.idamax										
scipy linalg.blas.idamax	R	scipy.linalg.blas.idamax										
scipy.linalg.blas.isamax	A										<section class="prog__container"><p>Wrapper for isamax.</p><pre><code>scipy.linalg.blas.isamax(x[, n, offx, incx]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>k : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.isamax.html
scipy linalg blas isamax	R	scipy.linalg.blas.isamax										
scipy linalg.blas.isamax	R	scipy.linalg.blas.isamax										
scipy.linalg.blas.izamax	A										<section class="prog__container"><p>Wrapper for izamax.</p><pre><code>scipy.linalg.blas.izamax(x[, n, offx, incx]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>k : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.izamax.html
scipy linalg blas izamax	R	scipy.linalg.blas.izamax										
scipy linalg.blas.izamax	R	scipy.linalg.blas.izamax										
scipy.linalg.blas.sasum	A										<section class="prog__container"><p>Wrapper for sasum.</p><pre><code>scipy.linalg.blas.sasum(x[, n, offx, incx]) = <fortran sasum></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>s : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.sasum.html
scipy linalg blas sasum	R	scipy.linalg.blas.sasum										
scipy linalg.blas.sasum	R	scipy.linalg.blas.sasum										
scipy.linalg.blas.saxpy	A										<section class="prog__container"><p>Wrapper for saxpy.</p><pre><code>scipy.linalg.blas.saxpy(x, y[, n, a, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)\ny : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>z : rank-1 array(‘f’) with bounds (*) and y storage</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.saxpy.html
scipy linalg blas saxpy	R	scipy.linalg.blas.saxpy										
scipy linalg.blas.saxpy	R	scipy.linalg.blas.saxpy										
scipy.linalg.blas.scasum	A										<section class="prog__container"><p>Wrapper for scasum.</p><pre><code>scipy.linalg.blas.scasum(x[, n, offx, incx]) = <fortran scasum></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>s : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.scasum.html
scipy linalg blas scasum	R	scipy.linalg.blas.scasum										
scipy linalg.blas.scasum	R	scipy.linalg.blas.scasum										
scipy.linalg.blas.scnrm2	A										<section class="prog__container"><p>Wrapper for scnrm2.</p><pre><code>scipy.linalg.blas.scnrm2(x[, n, offx, incx]) = <fortran scnrm2></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>n2 : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.scnrm2.html
scipy linalg blas scnrm2	R	scipy.linalg.blas.scnrm2										
scipy linalg.blas.scnrm2	R	scipy.linalg.blas.scnrm2										
scipy.linalg.blas.scopy	A										<section class="prog__container"><p>Wrapper for scopy.</p><pre><code>scipy.linalg.blas.scopy(x, y[, n, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)\ny : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘f’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.scopy.html
scipy linalg blas scopy	R	scipy.linalg.blas.scopy										
scipy linalg.blas.scopy	R	scipy.linalg.blas.scopy										
scipy.linalg.blas.sdot	A										<section class="prog__container"><p>Wrapper for sdot.</p><pre><code>scipy.linalg.blas.sdot(x, y[, n, offx, incx, offy, incy]) = <fortran sdot></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)\ny : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>xy : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.sdot.html
scipy linalg blas sdot	R	scipy.linalg.blas.sdot										
scipy linalg.blas.sdot	R	scipy.linalg.blas.sdot										
scipy.linalg.blas.sgemm	A										<section class="prog__container"><p>Wrapper for sgemm.</p><pre><code>scipy.linalg.blas.sgemm(alpha, a, b[, beta, c, trans_a, trans_b, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘f’) with bounds (lda,ka)\nb : input rank-2 array(‘f’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.sgemm.html
scipy linalg blas sgemm	R	scipy.linalg.blas.sgemm										
scipy linalg.blas.sgemm	R	scipy.linalg.blas.sgemm										
scipy.linalg.blas.sgemv	A										<section class="prog__container"><p>Wrapper for sgemv.</p><pre><code>scipy.linalg.blas.sgemv(alpha, a, x[, beta, y, offx, incx, offy, incy, trans, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘f’) with bounds (m,n)\nx : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘f’) with bounds (ly)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.sgemv.html
scipy linalg blas sgemv	R	scipy.linalg.blas.sgemv										
scipy linalg.blas.sgemv	R	scipy.linalg.blas.sgemv										
scipy.linalg.blas.sger	A										<section class="prog__container"><p>Wrapper for sger.</p><pre><code>scipy.linalg.blas.sger(alpha, x, y[, incx, incy, a, overwrite_x, overwrite_y, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\nx : input rank-1 array(‘f’) with bounds (m)\ny : input rank-1 array(‘f’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘f’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.sger.html
scipy linalg blas sger	R	scipy.linalg.blas.sger										
scipy linalg.blas.sger	R	scipy.linalg.blas.sger										
scipy.linalg.blas.snrm2	A										<section class="prog__container"><p>Wrapper for snrm2.</p><pre><code>scipy.linalg.blas.snrm2(x[, n, offx, incx]) = <fortran snrm2></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>n2 : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.snrm2.html
scipy linalg blas snrm2	R	scipy.linalg.blas.snrm2										
scipy linalg.blas.snrm2	R	scipy.linalg.blas.snrm2										
scipy.linalg.blas.srot	A										<section class="prog__container"><p>Wrapper for srot.</p><pre><code>scipy.linalg.blas.srot(x, y, c, s[, n, offx, incx, offy, incy, overwrite_x, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)\ny : input rank-1 array(‘f’) with bounds (*)\nc : input float\ns : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘f’) with bounds (*)\ny : rank-1 array(‘f’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.srot.html
scipy.linalg.blas.srotg	A										<section class="prog__container"><p>Wrapper for srotg.</p><pre><code>scipy.linalg.blas.srotg(a, b) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input float\nb : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>c : float\ns : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.srotg.html
scipy linalg blas srotg	R	scipy.linalg.blas.srotg										
scipy linalg.blas.srotg	R	scipy.linalg.blas.srotg										
scipy.linalg.blas.srotm	A										<section class="prog__container"><p>Wrapper for srotm.</p><pre><code>scipy.linalg.blas.srotm(x, y, param[, n, offx, incx, offy, incy, overwrite_x, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)\ny : input rank-1 array(‘f’) with bounds (*)\nparam : input rank-1 array(‘f’) with bounds (5)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘f’) with bounds (*)\ny : rank-1 array(‘f’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.srotm.html
scipy.linalg.blas.srotmg	A										<section class="prog__container"><p>Wrapper for srotmg.</p><pre><code>scipy.linalg.blas.srotmg(d1, d2, x1, y1) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>d1 : input float\nd2 : input float\nx1 : input float\ny1 : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>param : rank-1 array(‘f’) with bounds (5)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.srotmg.html
scipy linalg blas srotmg	R	scipy.linalg.blas.srotmg										
scipy linalg.blas.srotmg	R	scipy.linalg.blas.srotmg										
scipy linalg blas srotm	R	scipy.linalg.blas.srotm										
scipy linalg.blas.srotm	R	scipy.linalg.blas.srotm										
scipy linalg blas srot	R	scipy.linalg.blas.srot										
scipy linalg.blas.srot	R	scipy.linalg.blas.srot										
scipy.linalg.blas.sscal	A										<section class="prog__container"><p>Wrapper for sscal.</p><pre><code>scipy.linalg.blas.sscal(a, x[, n, offx, incx]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input float\nx : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘f’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.sscal.html
scipy linalg blas sscal	R	scipy.linalg.blas.sscal										
scipy linalg.blas.sscal	R	scipy.linalg.blas.sscal										
scipy.linalg.blas.sswap	A										<section class="prog__container"><p>Wrapper for sswap.</p><pre><code>scipy.linalg.blas.sswap(x, y[, n, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘f’) with bounds (*)\ny : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘f’) with bounds (*)\ny : rank-1 array(‘f’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.sswap.html
scipy linalg blas sswap	R	scipy.linalg.blas.sswap										
scipy linalg.blas.sswap	R	scipy.linalg.blas.sswap										
scipy.linalg.blas.ssymm	A										<section class="prog__container"><p>Wrapper for ssymm.</p><pre><code>scipy.linalg.blas.ssymm(alpha, a, b[, beta, c, side, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘f’) with bounds (lda,ka)\nb : input rank-2 array(‘f’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ssymm.html
scipy linalg blas ssymm	R	scipy.linalg.blas.ssymm										
scipy linalg.blas.ssymm	R	scipy.linalg.blas.ssymm										
scipy.linalg.blas.ssymv	A										<section class="prog__container"><p>Wrapper for ssymv.</p><pre><code>scipy.linalg.blas.ssymv(alpha, a, x[, beta, y, offx, incx, offy, incy, lower, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘f’) with bounds (n,n)\nx : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘f’) with bounds (ly)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ssymv.html
scipy linalg blas ssymv	R	scipy.linalg.blas.ssymv										
scipy linalg.blas.ssymv	R	scipy.linalg.blas.ssymv										
scipy.linalg.blas.ssyr2	A										<section class="prog__container"><p>Wrapper for ssyr2.</p><pre><code>scipy.linalg.blas.ssyr2(alpha, x, y[, lower, incx, offx, incy, offy, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\nx : input rank-1 array(‘f’) with bounds (*)\ny : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘f’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ssyr2.html
scipy.linalg.blas.ssyr2k	A										<section class="prog__container"><p>Wrapper for ssyr2k.</p><pre><code>scipy.linalg.blas.ssyr2k(alpha, a, b[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘f’) with bounds (lda,ka)\nb : input rank-2 array(‘f’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ssyr2k.html
scipy linalg blas ssyr2k	R	scipy.linalg.blas.ssyr2k										
scipy linalg.blas.ssyr2k	R	scipy.linalg.blas.ssyr2k										
scipy linalg blas ssyr2	R	scipy.linalg.blas.ssyr2										
scipy linalg.blas.ssyr2	R	scipy.linalg.blas.ssyr2										
scipy.linalg.blas.ssyr	A										<section class="prog__container"><p>Wrapper for ssyr.</p><pre><code>scipy.linalg.blas.ssyr(alpha, x[, lower, incx, offx, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\nx : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘f’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ssyr.html
scipy.linalg.blas.ssyrk	A										<section class="prog__container"><p>Wrapper for ssyrk.</p><pre><code>scipy.linalg.blas.ssyrk(alpha, a[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input float\na : input rank-2 array(‘f’) with bounds (lda,ka)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ssyrk.html
scipy linalg blas ssyrk	R	scipy.linalg.blas.ssyrk										
scipy linalg.blas.ssyrk	R	scipy.linalg.blas.ssyrk										
scipy linalg blas ssyr	R	scipy.linalg.blas.ssyr										
scipy linalg.blas.ssyr	R	scipy.linalg.blas.ssyr										
scipy.linalg.blas.strmv	A										<section class="prog__container"><p>Wrapper for strmv.</p><pre><code>scipy.linalg.blas.strmv(a, x[, offx, incx, lower, trans, unitdiag, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\nx : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘f’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.strmv.html
scipy linalg blas strmv	R	scipy.linalg.blas.strmv										
scipy linalg.blas.strmv	R	scipy.linalg.blas.strmv										
scipy.linalg.blas.zaxpy	A										<section class="prog__container"><p>Wrapper for zaxpy.</p><pre><code>scipy.linalg.blas.zaxpy(x, y[, n, a, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)\ny : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>z : rank-1 array(‘D’) with bounds (*) and y storage</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zaxpy.html
scipy linalg blas zaxpy	R	scipy.linalg.blas.zaxpy										
scipy linalg.blas.zaxpy	R	scipy.linalg.blas.zaxpy										
scipy.linalg.blas.zcopy	A										<section class="prog__container"><p>Wrapper for zcopy.</p><pre><code>scipy.linalg.blas.zcopy(x, y[, n, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)\ny : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘D’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zcopy.html
scipy linalg blas zcopy	R	scipy.linalg.blas.zcopy										
scipy linalg.blas.zcopy	R	scipy.linalg.blas.zcopy										
scipy.linalg.blas.zdotc	A										<section class="prog__container"><p>Wrapper for zdotc.</p><pre><code>scipy.linalg.blas.zdotc(x, y[, n, offx, incx, offy, incy]) = <fortran zdotc></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)\ny : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>xy : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zdotc.html
scipy linalg blas zdotc	R	scipy.linalg.blas.zdotc										
scipy linalg.blas.zdotc	R	scipy.linalg.blas.zdotc										
scipy.linalg.blas.zdotu	A										<section class="prog__container"><p>Wrapper for zdotu.</p><pre><code>scipy.linalg.blas.zdotu(x, y[, n, offx, incx, offy, incy]) = <fortran zdotu></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)\ny : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>xy : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zdotu.html
scipy linalg blas zdotu	R	scipy.linalg.blas.zdotu										
scipy linalg.blas.zdotu	R	scipy.linalg.blas.zdotu										
scipy.linalg.blas.zdrot	A										<section class="prog__container"><p>Wrapper for zdrot.</p><pre><code>scipy.linalg.blas.zdrot(x, y, c, s[, n, offx, incx, offy, incy, overwrite_x, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)\ny : input rank-1 array(‘D’) with bounds (*)\nc : input float\ns : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘D’) with bounds (*)\ny : rank-1 array(‘D’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zdrot.html
scipy linalg blas zdrot	R	scipy.linalg.blas.zdrot										
scipy linalg.blas.zdrot	R	scipy.linalg.blas.zdrot										
scipy.linalg.blas.zdscal	A										<section class="prog__container"><p>Wrapper for zdscal.</p><pre><code>scipy.linalg.blas.zdscal(a, x[, n, offx, incx, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input float\nx : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘D’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zdscal.html
scipy linalg blas zdscal	R	scipy.linalg.blas.zdscal										
scipy linalg.blas.zdscal	R	scipy.linalg.blas.zdscal										
scipy.linalg.blas.zgemm	A										<section class="prog__container"><p>Wrapper for zgemm.</p><pre><code>scipy.linalg.blas.zgemm(alpha, a, b[, beta, c, trans_a, trans_b, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (lda,ka)\nb : input rank-2 array(‘D’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zgemm.html
scipy linalg blas zgemm	R	scipy.linalg.blas.zgemm										
scipy linalg.blas.zgemm	R	scipy.linalg.blas.zgemm										
scipy.linalg.blas.zgemv	A										<section class="prog__container"><p>Wrapper for zgemv.</p><pre><code>scipy.linalg.blas.zgemv(alpha, a, x[, beta, y, offx, incx, offy, incy, trans, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (m,n)\nx : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘D’) with bounds (ly)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zgemv.html
scipy linalg blas zgemv	R	scipy.linalg.blas.zgemv										
scipy linalg.blas.zgemv	R	scipy.linalg.blas.zgemv										
scipy.linalg.blas.zgerc	A										<section class="prog__container"><p>Wrapper for zgerc.</p><pre><code>scipy.linalg.blas.zgerc(alpha, x, y[, incx, incy, a, overwrite_x, overwrite_y, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘D’) with bounds (m)\ny : input rank-1 array(‘D’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zgerc.html
scipy linalg blas zgerc	R	scipy.linalg.blas.zgerc										
scipy linalg.blas.zgerc	R	scipy.linalg.blas.zgerc										
scipy.linalg.blas.zgeru	A										<section class="prog__container"><p>Wrapper for zgeru.</p><pre><code>scipy.linalg.blas.zgeru(alpha, x, y[, incx, incy, a, overwrite_x, overwrite_y, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘D’) with bounds (m)\ny : input rank-1 array(‘D’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zgeru.html
scipy linalg blas zgeru	R	scipy.linalg.blas.zgeru										
scipy linalg.blas.zgeru	R	scipy.linalg.blas.zgeru										
scipy.linalg.blas.zhemm	A										<section class="prog__container"><p>Wrapper for zhemm.</p><pre><code>scipy.linalg.blas.zhemm(alpha, a, b[, beta, c, side, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (lda,ka)\nb : input rank-2 array(‘D’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zhemm.html
scipy linalg blas zhemm	R	scipy.linalg.blas.zhemm										
scipy linalg.blas.zhemm	R	scipy.linalg.blas.zhemm										
scipy.linalg.blas.zhemv	A										<section class="prog__container"><p>Wrapper for zhemv.</p><pre><code>scipy.linalg.blas.zhemv(alpha, a, x[, beta, y, offx, incx, offy, incy, lower, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (n,n)\nx : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>y : rank-1 array(‘D’) with bounds (ly)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zhemv.html
scipy linalg blas zhemv	R	scipy.linalg.blas.zhemv										
scipy linalg.blas.zhemv	R	scipy.linalg.blas.zhemv										
scipy.linalg.blas.zher2	A										<section class="prog__container"><p>Wrapper for zher2.</p><pre><code>scipy.linalg.blas.zher2(alpha, x, y[, lower, incx, offx, incy, offy, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘D’) with bounds (*)\ny : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zher2.html
scipy.linalg.blas.zher2k	A										<section class="prog__container"><p>Wrapper for zher2k.</p><pre><code>scipy.linalg.blas.zher2k(alpha, a, b[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (lda,ka)\nb : input rank-2 array(‘D’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zher2k.html
scipy linalg blas zher2k	R	scipy.linalg.blas.zher2k										
scipy linalg.blas.zher2k	R	scipy.linalg.blas.zher2k										
scipy linalg blas zher2	R	scipy.linalg.blas.zher2										
scipy linalg.blas.zher2	R	scipy.linalg.blas.zher2										
scipy.linalg.blas.zher	A										<section class="prog__container"><p>Wrapper for zher.</p><pre><code>scipy.linalg.blas.zher(alpha, x[, lower, incx, offx, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zher.html
scipy.linalg.blas.zherk	A										<section class="prog__container"><p>Wrapper for zherk.</p><pre><code>scipy.linalg.blas.zherk(alpha, a[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (lda,ka)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zherk.html
scipy linalg blas zherk	R	scipy.linalg.blas.zherk										
scipy linalg.blas.zherk	R	scipy.linalg.blas.zherk										
scipy linalg blas zher	R	scipy.linalg.blas.zher										
scipy linalg.blas.zher	R	scipy.linalg.blas.zher										
scipy.linalg.blas.zrotg	A										<section class="prog__container"><p>Wrapper for zrotg.</p><pre><code>scipy.linalg.blas.zrotg(a, b) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input complex\nb : input complex</code></pre><span class="prog__sub">Returns:</span><pre><code>c : complex\ns : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zrotg.html
scipy linalg blas zrotg	R	scipy.linalg.blas.zrotg										
scipy linalg.blas.zrotg	R	scipy.linalg.blas.zrotg										
scipy.linalg.blas.zscal	A										<section class="prog__container"><p>Wrapper for zscal.</p><pre><code>scipy.linalg.blas.zscal(a, x[, n, offx, incx]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input complex\nx : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘D’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zscal.html
scipy linalg blas zscal	R	scipy.linalg.blas.zscal										
scipy linalg.blas.zscal	R	scipy.linalg.blas.zscal										
scipy.linalg.blas.zswap	A										<section class="prog__container"><p>Wrapper for zswap.</p><pre><code>scipy.linalg.blas.zswap(x, y[, n, offx, incx, offy, incy]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)\ny : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘D’) with bounds (*)\ny : rank-1 array(‘D’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zswap.html
scipy linalg blas zswap	R	scipy.linalg.blas.zswap										
scipy linalg.blas.zswap	R	scipy.linalg.blas.zswap										
scipy.linalg.blas.zsymm	A										<section class="prog__container"><p>Wrapper for zsymm.</p><pre><code>scipy.linalg.blas.zsymm(alpha, a, b[, beta, c, side, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (lda,ka)\nb : input rank-2 array(‘D’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zsymm.html
scipy linalg blas zsymm	R	scipy.linalg.blas.zsymm										
scipy linalg.blas.zsymm	R	scipy.linalg.blas.zsymm										
scipy.linalg.blas.zsyr2k	A										<section class="prog__container"><p>Wrapper for zsyr2k.</p><pre><code>scipy.linalg.blas.zsyr2k(alpha, a, b[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (lda,ka)\nb : input rank-2 array(‘D’) with bounds (ldb,kb)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zsyr2k.html
scipy linalg blas zsyr2k	R	scipy.linalg.blas.zsyr2k										
scipy linalg.blas.zsyr2k	R	scipy.linalg.blas.zsyr2k										
scipy.linalg.blas.zsyr	A										<section class="prog__container"><p>Wrapper for zsyr.</p><pre><code>scipy.linalg.blas.zsyr(alpha, x[, lower, incx, offx, n, a, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\nx : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zsyr.html
scipy.linalg.blas.zsyrk	A										<section class="prog__container"><p>Wrapper for zsyrk.</p><pre><code>scipy.linalg.blas.zsyrk(alpha, a[, beta, c, trans, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : input complex\na : input rank-2 array(‘D’) with bounds (lda,ka)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (n,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.zsyrk.html
scipy linalg blas zsyrk	R	scipy.linalg.blas.zsyrk										
scipy linalg.blas.zsyrk	R	scipy.linalg.blas.zsyrk										
scipy linalg blas zsyr	R	scipy.linalg.blas.zsyr										
scipy linalg.blas.zsyr	R	scipy.linalg.blas.zsyr										
scipy.linalg.blas.ztrmv	A										<section class="prog__container"><p>Wrapper for ztrmv.</p><pre><code>scipy.linalg.blas.ztrmv(a, x[, offx, incx, lower, trans, unitdiag, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\nx : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘D’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.blas.ztrmv.html
scipy linalg blas ztrmv	R	scipy.linalg.blas.ztrmv										
scipy linalg.blas.ztrmv	R	scipy.linalg.blas.ztrmv										
scipy.linalg.block_diag	A										<section class="prog__container"><p>Create a block diagonal matrix from provided arrays.</p><pre><code>scipy.linalg.block_diag(*arrs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A, B, C, ... : array_like, up to 2-D\n    Input arrays.  A 1-D array or array_like sequence of length n is treated as a 2-D array with shape (1,n).</code></pre><span class="prog__sub">Returns:</span><pre><code>D : ndarray\n    Array with A, B, C, ... on the diagonal.  D has the same dtype as A.</code></pre><span class="prog__sub">Examples:</span><pre><code>[[A, 0, 0],\n [0, B, 0],\n [0, 0, C]]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.block_diag.html
scipy linalg block_diag	R	scipy.linalg.block_diag										
scipy linalg.block_diag	R	scipy.linalg.block_diag										
scipy.linalg.cho_factor	A										<section class="prog__container"><p>Compute the Cholesky decomposition of a matrix, to use in cho_solve</p><pre><code>scipy.linalg.cho_factor(a, lower=False, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    Matrix to be decomposed \nlower : bool, optional\n    Whether to compute the upper or lower triangular Cholesky factorization (Default: upper-triangular) \noverwrite_a : bool, optional\n    Whether to overwrite data in a (may improve performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : (M, M) ndarray\n    Matrix whose upper or lower triangle contains the Cholesky factor of a. Other parts of the matrix contain random data. \nlower : bool\n    Flag indicating whether the factor is in the lower or upper triangle</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_factor.html
scipy linalg cho_factor	R	scipy.linalg.cho_factor										
scipy linalg.cho_factor	R	scipy.linalg.cho_factor										
scipy.linalg.cholesky	A										<section class="prog__container"><p>Compute the Cholesky decomposition of a matrix.</p><pre><code>scipy.linalg.cholesky(a, lower=False, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    Matrix to be decomposed \nlower : bool, optional\n    Whether to compute the upper or lower triangular Cholesky factorization.  Default is upper-triangular. \noverwrite_a : bool, optional\n    Whether to overwrite data in a (may improve performance). \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : (M, M) ndarray\n    Upper- or lower-triangular Cholesky factor of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import array, linalg, dot\n>>> a = array([[1,-2j],[2j,5]])\n>>> L = linalg.cholesky(a, lower=True)\n>>> L\narray([[ 1.+0.j,  0.+0.j],\n       [ 0.+2.j,  1.+0.j]])\n>>> dot(L, L.T.conj())\narray([[ 1.+0.j,  0.-2.j],\n       [ 0.+2.j,  5.+0.j]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cholesky.html
scipy.linalg.cholesky_banded	A										<section class="prog__container"><p>Cholesky decompose a banded Hermitian positive-definite matrix</p><pre><code>scipy.linalg.cholesky_banded(ab, overwrite_ab=False, lower=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : (u + 1, M) array_like\n    Banded matrix \noverwrite_ab : bool, optional\n    Discard data in ab (may enhance performance) \nlower : bool, optional\n    Is the matrix in the lower form. (Default is upper form) \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : (u + 1, M) ndarray\n    Cholesky factorization of a, in the same banded format as ab</code></pre><span class="prog__sub">Examples:</span><pre><code>ab[u + i - j, j] == a[i,j]        (if upper form; i <= j)\nab[    i - j, j] == a[i,j]        (if lower form; i >= j)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cholesky_banded.html
scipy linalg cholesky_banded	R	scipy.linalg.cholesky_banded										
scipy linalg.cholesky_banded	R	scipy.linalg.cholesky_banded										
scipy linalg cholesky	R	scipy.linalg.cholesky										
scipy linalg.cholesky	R	scipy.linalg.cholesky										
scipy.linalg.cho_solve	A										<section class="prog__container"><p>Solve the linear equations A x = b, given the Cholesky factorization of A.</p><pre><code>scipy.linalg.cho_solve(c_and_lower, b, overwrite_b=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>(c, lower) : tuple, (array, bool)\n    Cholesky factorization of a, as given by cho_factor \nb : array\n    Right-hand side \noverwrite_b : bool, optional\n    Whether to overwrite data in b (may improve performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array\n    The solution to the system A x = b</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_solve.html
scipy.linalg.cho_solve_banded	A										<section class="prog__container"><p>Solve the linear equations A x = b, given the Cholesky factorization of A.</p><pre><code>scipy.linalg.cho_solve_banded(cb_and_lower, b, overwrite_b=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>(cb, lower) : tuple, (array, bool)\n    cb is the Cholesky factorization of A, as given by cholesky_banded. lower must be the same value that was given to cholesky_banded. \nb : array\n    Right-hand side \noverwrite_b : bool, optional\n    If True, the function will overwrite the values in b. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array\n    The solution to the system A x = b</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_solve_banded.html
scipy linalg cho_solve_banded	R	scipy.linalg.cho_solve_banded										
scipy linalg.cho_solve_banded	R	scipy.linalg.cho_solve_banded										
scipy linalg cho_solve	R	scipy.linalg.cho_solve										
scipy linalg.cho_solve	R	scipy.linalg.cho_solve										
scipy.linalg.circulant	A										<section class="prog__container"><p>Construct a circulant matrix.</p><pre><code>scipy.linalg.circulant(c)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : (N,) array_like\n    1-D array, the first column of the matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>A : (N, N) ndarray\n    A circulant matrix whose first column is c.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import circulant\n>>> circulant([1, 2, 3])\narray([[1, 3, 2],\n       [2, 1, 3],\n       [3, 2, 1]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.circulant.html
scipy linalg circulant	R	scipy.linalg.circulant										
scipy linalg.circulant	R	scipy.linalg.circulant										
scipy.linalg.companion	A										<section class="prog__container"><p>Create a companion matrix.</p><pre><code>scipy.linalg.companion(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (N,) array_like\n    1-D array of polynomial coefficients.  The length of a must be at least two, and a[0] must not be zero.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : (N-1, N-1) ndarray\n    The first row of c is -a[1:]/a[0], and the first sub-diagonal is all ones.  The data-type of the array is the same as the data-type of 1.0*a[0].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import companion\n>>> companion([1, -10, 31, -30])\narray([[ 10., -31.,  30.],\n       [  1.,   0.,   0.],\n       [  0.,   1.,   0.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.companion.html
scipy linalg companion	R	scipy.linalg.companion										
scipy linalg.companion	R	scipy.linalg.companion										
scipy.linalg.coshm	A										<section class="prog__container"><p>Compute the hyperbolic matrix cosine.</p><pre><code>scipy.linalg.coshm(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>coshm : (N, N) ndarray\n    Hyperbolic matrix cosine of A</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import tanhm, sinhm, coshm\n>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])\n>>> c = coshm(a)\n>>> c\narray([[ 11.24592233,  38.76236492],\n       [ 12.92078831,  50.00828725]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.coshm.html
scipy linalg coshm	R	scipy.linalg.coshm										
scipy linalg.coshm	R	scipy.linalg.coshm										
scipy.linalg.cosm	A										<section class="prog__container"><p>Compute the matrix cosine.</p><pre><code>scipy.linalg.cosm(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Input array</code></pre><span class="prog__sub">Returns:</span><pre><code>cosm : (N, N) ndarray\n    Matrix cosine of A</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import expm, sinm, cosm</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cosm.html
scipy linalg cosm	R	scipy.linalg.cosm										
scipy linalg.cosm	R	scipy.linalg.cosm										
scipy.linalg.det	A										<section class="prog__container"><p>Compute the determinant of a matrix</p><pre><code>scipy.linalg.det(a, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    A square matrix. \noverwrite_a : bool, optional\n    Allow overwriting data in a (may enhance performance). \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>det : float or complex\n    Determinant of a.</code></pre><span class="prog__sub">Examples:</span><pre><code>a    b    c\nd    e    f = A\ng    h    i\n\ndet(A) = a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.det.html
scipy linalg det	R	scipy.linalg.det										
scipy linalg.det	R	scipy.linalg.det										
scipy.linalg.dft	A										<section class="prog__container"><p>Discrete Fourier transform matrix.</p><pre><code>scipy.linalg.dft(n, scale=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Size the matrix to create. \nscale : str, optional\n    Must be None, ‘sqrtn’, or ‘n’. If scale is ‘sqrtn’, the matrix is divided by sqrt(n). If scale is ‘n’, the matrix is divided by n. If scale is None (the default), the matrix is not normalized, and the return value is simply the Vandermonde matrix of the roots of unity.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : (n, n) ndarray\n    The DFT matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import dft\n>>> np.set_printoptions(precision=5, suppress=True)\n>>> x = np.array([1, 2, 3, 0, 3, 2, 1, 0])\n>>> m = dft(8)\n>>> m.dot(x)   # Compute the DFT of x\narray([ 12.+0.j,  -2.-2.j,   0.-4.j,  -2.+2.j,   4.+0.j,  -2.-2.j,\n        -0.+4.j,  -2.+2.j])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.dft.html
scipy linalg dft	R	scipy.linalg.dft										
scipy linalg.dft	R	scipy.linalg.dft										
scipy.linalg.diagsvd	A										<section class="prog__container"><p>Construct the sigma matrix in SVD from singular values and size M, N.</p><pre><code>scipy.linalg.diagsvd(s, M, N)</code></pre><span class="prog__sub">Parameters:</span><pre><code>s : (M,) or (N,) array_like\n    Singular values \nM : int\n    Size of the matrix whose singular values are s. \nN : int\n    Size of the matrix whose singular values are s.</code></pre><span class="prog__sub">Returns:</span><pre><code>S : (M, N) ndarray\n    The S-matrix in the singular value decomposition</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.diagsvd.html
scipy linalg diagsvd	R	scipy.linalg.diagsvd										
scipy linalg.diagsvd	R	scipy.linalg.diagsvd										
scipy.linalg.eig	A										<section class="prog__container"><p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p><pre><code>scipy.linalg.eig(a, b=None, left=False, right=True, overwrite_a=False, overwrite_b=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    A complex or real matrix whose eigenvalues and eigenvectors will be computed. \nb : (M, M) array_like, optional\n    Right-hand side matrix in a generalized eigenvalue problem. Default is None, identity matrix is assumed. \nleft : bool, optional\n    Whether to calculate and return left eigenvectors.  Default is False. \nright : bool, optional\n    Whether to calculate and return right eigenvectors.  Default is True. \noverwrite_a : bool, optional\n    Whether to overwrite a; may improve performance.  Default is False. \noverwrite_b : bool, optional\n    Whether to overwrite b; may improve performance.  Default is False. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (M,) double or complex ndarray\n    The eigenvalues, each repeated according to its multiplicity. \nvl : (M, M) double or complex ndarray\n    The normalized left eigenvector corresponding to the eigenvalue w[i] is the column vl[:,i]. Only returned if left=True. \nvr : (M, M) double or complex ndarray\n    The normalized right eigenvector corresponding to the eigenvalue w[i] is the column vr[:,i].  Only returned if right=True.</code></pre><span class="prog__sub">Examples:</span><pre><code>a   vr[:,i] = w[i]        b   vr[:,i]\na.H vl[:,i] = w[i].conj() b.H vl[:,i]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html
scipy.linalg.eig_banded	A										<section class="prog__container"><p>Solve real symmetric or complex hermitian band matrix eigenvalue problem.</p><pre><code>scipy.linalg.eig_banded(a_band, lower=False, eigvals_only=False, overwrite_a_band=False, select='a', select_range=None, max_ev=0, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a_band : (u+1, M) array_like\n    The bands of the M by M matrix a. \nlower : bool, optional\n    Is the matrix in the lower form. (Default is upper form) \neigvals_only : bool, optional\n    Compute only the eigenvalues and no eigenvectors. (Default: calculate also eigenvectors) \noverwrite_a_band : bool, optional\n    Discard data in a_band (may enhance performance) \nselect : {‘a’, ‘v’, ‘i’}, optional\n    Which eigenvalues to calculate       select calculated    ‘a’ All eigenvalues  ‘v’ Eigenvalues in the interval (min, max]  ‘i’ Eigenvalues with indices min <= i <= max    \nselect_range : (min, max), optional\n    Range of selected eigenvalues \nmax_ev : int, optional\n    For select==’v’, maximum number of eigenvalues expected. For other values of select, has no meaning. In doubt, leave this parameter untouched. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (M,) ndarray\n    The eigenvalues, in ascending order, each repeated according to its multiplicity. \nv : (M, M) float or complex ndarray\n    The normalized eigenvector corresponding to the eigenvalue w[i] is the column v[:,i]. \nRaises LinAlgError if eigenvalue computation does not converge</code></pre><span class="prog__sub">Examples:</span><pre><code>a v[:,i] = w[i] v[:,i]\nv.H v    = identity</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig_banded.html
scipy linalg eig_banded	R	scipy.linalg.eig_banded										
scipy linalg.eig_banded	R	scipy.linalg.eig_banded										
scipy.linalg.eigh	A										<section class="prog__container"><p>Solve an ordinary or generalized eigenvalue problem for a complex\nHermitian or real symmetric matrix.</p><pre><code>scipy.linalg.eigh(a, b=None, lower=True, eigvals_only=False, overwrite_a=False, overwrite_b=False, turbo=True, eigvals=None, type=1, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    A complex Hermitian or real symmetric matrix whose eigenvalues and eigenvectors will be computed. \nb : (M, M) array_like, optional\n    A complex Hermitian or real symmetric definite positive matrix in. If omitted, identity matrix is assumed. \nlower : bool, optional\n    Whether the pertinent array data is taken from the lower or upper triangle of a. (Default: lower) \neigvals_only : bool, optional\n    Whether to calculate only eigenvalues and no eigenvectors. (Default: both are calculated) \nturbo : bool, optional\n    Use divide and conquer algorithm (faster but expensive in memory, only for generalized eigenvalue problem and if eigvals=None) \neigvals : tuple (lo, hi), optional\n    Indexes of the smallest and largest (in ascending order) eigenvalues and corresponding eigenvectors to be returned: 0 <= lo <= hi <= M-1. If omitted, all eigenvalues and eigenvectors are returned. \ntype : int, optional\n    Specifies the problem type to be solved:  type = 1: a   v[:,i] = w[i] b v[:,i] type = 2: a b v[:,i] = w[i]   v[:,i] type = 3: b a v[:,i] = w[i]   v[:,i]  \noverwrite_a : bool, optional\n    Whether to overwrite data in a (may improve performance) \noverwrite_b : bool, optional\n    Whether to overwrite data in b (may improve performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (N,) float ndarray\n    The N (1<=N<=M) selected eigenvalues, in ascending order, each repeated according to its multiplicity. \nv : (M, N) complex ndarray\n    (if eigvals_only == False) The normalized selected eigenvector corresponding to the eigenvalue w[i] is the column v[:,i]. Normalization:  type 1 and 3: v.conj() a      v  = w type 2: inv(v).conj() a  inv(v) = w type = 1 or 2: v.conj() b      v  = I type = 3: v.conj() inv(b) v  = I</code></pre><span class="prog__sub">Examples:</span><pre><code>a v[:,i] = w[i] b v[:,i]\nv[i,:].conj() a v[:,i] = w[i]\nv[i,:].conj() b v[:,i] = 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigh.html
scipy linalg eigh	R	scipy.linalg.eigh										
scipy linalg.eigh	R	scipy.linalg.eigh										
scipy linalg eig	R	scipy.linalg.eig										
scipy linalg.eig	R	scipy.linalg.eig										
scipy.linalg.eigvals	A										<section class="prog__container"><p>Compute eigenvalues from an ordinary or generalized eigenvalue problem.</p><pre><code>scipy.linalg.eigvals(a, b=None, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    A complex or real matrix whose eigenvalues and eigenvectors will be computed. \nb : (M, M) array_like, optional\n    Right-hand side matrix in a generalized eigenvalue problem. If omitted, identity matrix is assumed. \noverwrite_a : bool, optional\n    Whether to overwrite data in a (may improve performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (M,) double or complex ndarray\n    The eigenvalues, each repeated according to its multiplicity, but not in any specific order.</code></pre><span class="prog__sub">Examples:</span><pre><code>a   vr[:,i] = w[i]        b   vr[:,i]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigvals.html
scipy.linalg.eigvals_banded	A										<section class="prog__container"><p>Solve real symmetric or complex hermitian band matrix eigenvalue problem.</p><pre><code>scipy.linalg.eigvals_banded(a_band, lower=False, overwrite_a_band=False, select='a', select_range=None, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a_band : (u+1, M) array_like\n    The bands of the M by M matrix a. \nlower : bool, optional\n    Is the matrix in the lower form. (Default is upper form) \noverwrite_a_band : bool, optional\n    Discard data in a_band (may enhance performance) \nselect : {‘a’, ‘v’, ‘i’}, optional\n    Which eigenvalues to calculate       select calculated    ‘a’ All eigenvalues  ‘v’ Eigenvalues in the interval (min, max]  ‘i’ Eigenvalues with indices min <= i <= max    \nselect_range : (min, max), optional\n    Range of selected eigenvalues \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (M,) ndarray\n    The eigenvalues, in ascending order, each repeated according to its multiplicity. \nRaises LinAlgError if eigenvalue computation does not converge</code></pre><span class="prog__sub">Examples:</span><pre><code>a v[:,i] = w[i] v[:,i]\nv.H v    = identity</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigvals_banded.html
scipy linalg eigvals_banded	R	scipy.linalg.eigvals_banded										
scipy linalg.eigvals_banded	R	scipy.linalg.eigvals_banded										
scipy.linalg.eigvalsh	A										<section class="prog__container"><p>Solve an ordinary or generalized eigenvalue problem for a complex\nHermitian or real symmetric matrix.</p><pre><code>scipy.linalg.eigvalsh(a, b=None, lower=True, overwrite_a=False, overwrite_b=False, turbo=True, eigvals=None, type=1, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    A complex Hermitian or real symmetric matrix whose eigenvalues and eigenvectors will be computed. \nb : (M, M) array_like, optional\n    A complex Hermitian or real symmetric definite positive matrix in. If omitted, identity matrix is assumed. \nlower : bool, optional\n    Whether the pertinent array data is taken from the lower or upper triangle of a. (Default: lower) \nturbo : bool, optional\n    Use divide and conquer algorithm (faster but expensive in memory, only for generalized eigenvalue problem and if eigvals=None) \neigvals : tuple (lo, hi), optional\n    Indexes of the smallest and largest (in ascending order) eigenvalues and corresponding eigenvectors to be returned: 0 <= lo < hi <= M-1. If omitted, all eigenvalues and eigenvectors are returned. \ntype : int, optional\n    Specifies the problem type to be solved:  type = 1: a   v[:,i] = w[i] b v[:,i] type = 2: a b v[:,i] = w[i]   v[:,i] type = 3: b a v[:,i] = w[i]   v[:,i]  \noverwrite_a : bool, optional\n    Whether to overwrite data in a (may improve performance) \noverwrite_b : bool, optional\n    Whether to overwrite data in b (may improve performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (N,) float ndarray\n    The N (1<=N<=M) selected eigenvalues, in ascending order, each repeated according to its multiplicity.</code></pre><span class="prog__sub">Examples:</span><pre><code>a v[:,i] = w[i] b v[:,i]\nv[i,:].conj() a v[:,i] = w[i]\nv[i,:].conj() b v[:,i] = 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigvalsh.html
scipy linalg eigvalsh	R	scipy.linalg.eigvalsh										
scipy linalg.eigvalsh	R	scipy.linalg.eigvalsh										
scipy linalg eigvals	R	scipy.linalg.eigvals										
scipy linalg.eigvals	R	scipy.linalg.eigvals										
scipy.linalg.expm	A										<section class="prog__container"><p>Compute the matrix exponential using Pade approximation.</p><pre><code>scipy.linalg.expm(A, q=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like or sparse matrix\n    Matrix to be exponentiated.</code></pre><span class="prog__sub">Returns:</span><pre><code>expm : (N, N) ndarray\n    Matrix exponential of A.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import expm, sinm, cosm</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.expm.html
scipy.linalg.expm_cond	A										<section class="prog__container"><p>Relative condition number of the matrix exponential in the Frobenius norm.</p><pre><code>scipy.linalg.expm_cond(A, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : 2d array_like\n    Square input matrix with shape (N, N). \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>kappa : float\n    The relative condition number of the matrix exponential in the Frobenius norm</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.expm_cond.html
scipy linalg expm_cond	R	scipy.linalg.expm_cond										
scipy linalg.expm_cond	R	scipy.linalg.expm_cond										
scipy.linalg.expm_frechet	A										<section class="prog__container"><p>Frechet derivative of the matrix exponential of A in the direction E.</p><pre><code>scipy.linalg.expm_frechet(A, E, method=None, compute_expm=True, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Matrix of which to take the matrix exponential. \nE : (N, N) array_like\n    Matrix direction in which to take the Frechet derivative. \nmethod : str, optional\n    Choice of algorithm.  Should be one of  SPS (default) blockEnlarge  \ncompute_expm : bool, optional\n    Whether to compute also expm_A in addition to expm_frechet_AE. Default is True. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>expm_A : ndarray\n    Matrix exponential of A. \nexpm_frechet_AE : ndarray\n    Frechet derivative of the matrix exponential of A in the direction E. \nFor compute_expm = False, only expm_frechet_AE is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import scipy.linalg\n>>> A = np.random.randn(3, 3)\n>>> E = np.random.randn(3, 3)\n>>> expm_A, expm_frechet_AE = scipy.linalg.expm_frechet(A, E)\n>>> expm_A.shape, expm_frechet_AE.shape\n((3, 3), (3, 3))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.expm_frechet.html
scipy linalg expm_frechet	R	scipy.linalg.expm_frechet										
scipy linalg.expm_frechet	R	scipy.linalg.expm_frechet										
scipy linalg expm	R	scipy.linalg.expm										
scipy linalg.expm	R	scipy.linalg.expm										
scipy.linalg.find_best_blas_type	A										<section class="prog__container"><p>Find best-matching BLAS/LAPACK type.</p><pre><code>scipy.linalg.find_best_blas_type(arrays=(), dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arrays : sequence of ndarrays, optional\n    Arrays can be given to determine optimal prefix of BLAS routines. If not given, double-precision routines will be used, otherwise the most generic type in arrays will be used. \ndtype : str or dtype, optional\n    Data-type specifier. Not used if arrays is non-empty.</code></pre><span class="prog__sub">Returns:</span><pre><code>prefix : str\n    BLAS/LAPACK prefix character. \ndtype : dtype\n    Inferred Numpy data type. \nprefer_fortran : bool\n    Whether to prefer Fortran order routines over C order.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.find_best_blas_type.html
scipy linalg find_best_blas_type	R	scipy.linalg.find_best_blas_type										
scipy linalg.find_best_blas_type	R	scipy.linalg.find_best_blas_type										
scipy.linalg.fractional_matrix_power	A										<section class="prog__container"><p>Compute the fractional power of a matrix.</p><pre><code>scipy.linalg.fractional_matrix_power(A, t)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Matrix whose fractional power to evaluate. \nt : float\n    Fractional power.</code></pre><span class="prog__sub">Returns:</span><pre><code>X : (N, N) array_like\n    The fractional power of the matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import fractional_matrix_power\n>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])\n>>> b = fractional_matrix_power(a, 0.5)\n>>> b\narray([[ 0.75592895,  1.13389342],\n       [ 0.37796447,  1.88982237]])\n>>> np.dot(b, b)      # Verify square root\narray([[ 1.,  3.],\n       [ 1.,  4.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.fractional_matrix_power.html
scipy linalg fractional_matrix_power	R	scipy.linalg.fractional_matrix_power										
scipy linalg.fractional_matrix_power	R	scipy.linalg.fractional_matrix_power										
scipy.linalg.funm	A										<section class="prog__container"><p>Evaluate a matrix function specified by a callable.</p><pre><code>scipy.linalg.funm(A, func, disp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Matrix at which to evaluate the function \nfunc : callable\n    Callable object that evaluates a scalar function f. Must be vectorized (eg. using vectorize). \ndisp : bool, optional\n    Print warning if error in the result is estimated large instead of returning estimated error. (Default: True)</code></pre><span class="prog__sub">Returns:</span><pre><code>funm : (N, N) ndarray\n    Value of the matrix function specified by func evaluated at A \nerrest : float\n    (if disp == False) 1-norm of the estimated error, ||err||_1 / ||A||_1</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import eigh\n>>> def funm_herm(a, func, check_finite=False):\n...     w, v = eigh(a, check_finite=check_finite)\n...     ## if you further know that your matrix is positive semidefinite,\n...     ## you can optionally guard against precision errors by doing\n...     # w = np.maximum(w, 0)\n...     w = func(w)\n...     return (v * w).dot(v.conj().T)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.funm.html
scipy linalg funm	R	scipy.linalg.funm										
scipy linalg.funm	R	scipy.linalg.funm										
scipy.linalg.get_blas_funcs	A										<section class="prog__container"><p>Return available BLAS function objects from names.</p><pre><code>scipy.linalg.get_blas_funcs(names, arrays=(), dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>names : str or sequence of str\n    Name(s) of BLAS functions without type prefix. \narrays : sequence of ndarrays, optional\n    Arrays can be given to determine optimal prefix of BLAS routines. If not given, double-precision routines will be used, otherwise the most generic type in arrays will be used. \ndtype : str or dtype, optional\n    Data-type specifier. Not used if arrays is non-empty.</code></pre><span class="prog__sub">Returns:</span><pre><code>funcs : list\n    List containing the found function(s).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.get_blas_funcs.html
scipy linalg get_blas_funcs	R	scipy.linalg.get_blas_funcs										
scipy linalg.get_blas_funcs	R	scipy.linalg.get_blas_funcs										
scipy.linalg.get_lapack_funcs	A										<section class="prog__container"><p>Return available LAPACK function objects from names.</p><pre><code>scipy.linalg.get_lapack_funcs(names, arrays=(), dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>names : str or sequence of str\n    Name(s) of LAPACK functions without type prefix. \narrays : sequence of ndarrays, optional\n    Arrays can be given to determine optimal prefix of LAPACK routines. If not given, double-precision routines will be used, otherwise the most generic type in arrays will be used. \ndtype : str or dtype, optional\n    Data-type specifier. Not used if arrays is non-empty.</code></pre><span class="prog__sub">Returns:</span><pre><code>funcs : list\n    List containing the found function(s).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.get_lapack_funcs.html
scipy linalg get_lapack_funcs	R	scipy.linalg.get_lapack_funcs										
scipy linalg.get_lapack_funcs	R	scipy.linalg.get_lapack_funcs										
scipy.linalg.hadamard	A										<section class="prog__container"><p>Construct a Hadamard matrix.</p><pre><code>scipy.linalg.hadamard(n, dtype=<type 'int'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The order of the matrix.  n must be a power of 2. \ndtype : dtype, optional\n    The data type of the array to be constructed.</code></pre><span class="prog__sub">Returns:</span><pre><code>H : (n, n) ndarray\n    The Hadamard matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import hadamard\n>>> hadamard(2, dtype=complex)\narray([[ 1.+0.j,  1.+0.j],\n       [ 1.+0.j, -1.-0.j]])\n>>> hadamard(4)\narray([[ 1,  1,  1,  1],\n       [ 1, -1,  1, -1],\n       [ 1,  1, -1, -1],\n       [ 1, -1, -1,  1]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.hadamard.html
scipy linalg hadamard	R	scipy.linalg.hadamard										
scipy linalg.hadamard	R	scipy.linalg.hadamard										
scipy.linalg.hankel	A										<section class="prog__container"><p>Construct a Hankel matrix.</p><pre><code>scipy.linalg.hankel(c, r=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    First column of the matrix.  Whatever the actual shape of c, it will be converted to a 1-D array. \nr : array_like, optional\n    Last row of the matrix. If None, r = zeros_like(c) is assumed. r[0] is ignored; the last row of the returned matrix is [c[-1], r[1:]].  Whatever the actual shape of r, it will be converted to a 1-D array.</code></pre><span class="prog__sub">Returns:</span><pre><code>A : (len(c), len(r)) ndarray\n    The Hankel matrix. Dtype is the same as (c[0] + r[0]).dtype.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import hankel\n>>> hankel([1, 17, 99])\narray([[ 1, 17, 99],\n       [17, 99,  0],\n       [99,  0,  0]])\n>>> hankel([1,2,3,4], [4,7,7,8,9])\narray([[1, 2, 3, 4, 7],\n       [2, 3, 4, 7, 7],\n       [3, 4, 7, 7, 8],\n       [4, 7, 7, 8, 9]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.hankel.html
scipy linalg hankel	R	scipy.linalg.hankel										
scipy linalg.hankel	R	scipy.linalg.hankel										
scipy.linalg.helmert	A										<section class="prog__container"><p>Create a Helmert matrix of order n.</p><pre><code>scipy.linalg.helmert(n, full=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The size of the array to create. \nfull : bool, optional\n    If True the (n, n) ndarray will be returned. Otherwise the submatrix that does not include the first row will be returned. Default: False.</code></pre><span class="prog__sub">Returns:</span><pre><code>M : ndarray\n    The Helmert matrix. The shape is (n, n) or (n-1, n) depending on the full argument.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import helmert\n>>> helmert(5, full=True)\narray([[ 0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ],\n       [ 0.70710678, -0.70710678,  0.        ,  0.        ,  0.        ],\n       [ 0.40824829,  0.40824829, -0.81649658,  0.        ,  0.        ],\n       [ 0.28867513,  0.28867513,  0.28867513, -0.8660254 ,  0.        ],\n       [ 0.2236068 ,  0.2236068 ,  0.2236068 ,  0.2236068 , -0.89442719]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.helmert.html
scipy linalg helmert	R	scipy.linalg.helmert										
scipy linalg.helmert	R	scipy.linalg.helmert										
scipy.linalg.hessenberg	A										<section class="prog__container"><p>Compute Hessenberg form of a matrix.</p><pre><code>scipy.linalg.hessenberg(a, calc_q=False, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    Matrix to bring into Hessenberg form. \ncalc_q : bool, optional\n    Whether to compute the transformation matrix.  Default is False. \noverwrite_a : bool, optional\n    Whether to overwrite a; may improve performance. Default is False. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>H : (M, M) ndarray\n    Hessenberg form of a. \nQ : (M, M) ndarray\n    Unitary/orthogonal similarity transformation matrix A = Q H Q^H. Only returned if calc_q=True.</code></pre><span class="prog__sub">Examples:</span><pre><code>A = Q H Q^H</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.hessenberg.html
scipy linalg hessenberg	R	scipy.linalg.hessenberg										
scipy linalg.hessenberg	R	scipy.linalg.hessenberg										
scipy.linalg.hilbert	A										<section class="prog__container"><p>Create a Hilbert matrix of order n.</p><pre><code>scipy.linalg.hilbert(n)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The size of the array to create.</code></pre><span class="prog__sub">Returns:</span><pre><code>h : (n, n) ndarray\n    The Hilbert matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import hilbert\n>>> hilbert(3)\narray([[ 1.        ,  0.5       ,  0.33333333],\n       [ 0.5       ,  0.33333333,  0.25      ],\n       [ 0.33333333,  0.25      ,  0.2       ]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.hilbert.html
scipy linalg hilbert	R	scipy.linalg.hilbert										
scipy linalg.hilbert	R	scipy.linalg.hilbert										
scipy.linalg.interpolative.estimate_rank	A										<section class="prog__container"><p>Estimate matrix rank to a specified relative precision using randomized\nmethods.</p><pre><code>scipy.linalg.interpolative.estimate_rank(A, eps)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : numpy.ndarray or scipy.sparse.linalg.LinearOperator\n    Matrix whose rank is to be estimated, given as either a numpy.ndarray or a scipy.sparse.linalg.LinearOperator with the rmatvec method (to apply the matrix adjoint). \neps : float\n    Relative error for numerical rank definition.</code></pre><span class="prog__sub">Returns:</span><pre><code>int\n    Estimated matrix rank.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.estimate_rank.html
scipy linalg interpolative estimate_rank	R	scipy.linalg.interpolative.estimate_rank										
scipy linalg.interpolative.estimate_rank	R	scipy.linalg.interpolative.estimate_rank										
scipy.linalg.interpolative.estimate_spectral_norm	A										<section class="prog__container"><p>Estimate spectral norm of a matrix by the randomized power method.</p><pre><code>scipy.linalg.interpolative.estimate_spectral_norm(A, its=20)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : scipy.sparse.linalg.LinearOperator\n    Matrix given as a scipy.sparse.linalg.LinearOperator with the matvec and rmatvec methods (to apply the matrix and its adjoint). \nits : int, optional\n    Number of power method iterations.</code></pre><span class="prog__sub">Returns:</span><pre><code>float\n    Spectral norm estimate.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.estimate_spectral_norm.html
scipy.linalg.interpolative.estimate_spectral_norm_diff	A										<section class="prog__container"><p>Estimate spectral norm of the difference of two matrices by the randomized\npower method.</p><pre><code>scipy.linalg.interpolative.estimate_spectral_norm_diff(A, B, its=20)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : scipy.sparse.linalg.LinearOperator\n    First matrix given as a scipy.sparse.linalg.LinearOperator with the matvec and rmatvec methods (to apply the matrix and its adjoint). \nB : scipy.sparse.linalg.LinearOperator\n    Second matrix given as a scipy.sparse.linalg.LinearOperator with the matvec and rmatvec methods (to apply the matrix and its adjoint). \nits : int, optional\n    Number of power method iterations.</code></pre><span class="prog__sub">Returns:</span><pre><code>float\n    Spectral norm estimate of matrix difference.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.estimate_spectral_norm_diff.html
scipy linalg interpolative estimate_spectral_norm_diff	R	scipy.linalg.interpolative.estimate_spectral_norm_diff										
scipy linalg.interpolative.estimate_spectral_norm_diff	R	scipy.linalg.interpolative.estimate_spectral_norm_diff										
scipy linalg interpolative estimate_spectral_norm	R	scipy.linalg.interpolative.estimate_spectral_norm										
scipy linalg.interpolative.estimate_spectral_norm	R	scipy.linalg.interpolative.estimate_spectral_norm										
scipy.linalg.interpolative.id_to_svd	A										<section class="prog__container"><p>Convert ID to SVD.</p><pre><code>scipy.linalg.interpolative.id_to_svd(B, idx, proj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>B : numpy.ndarray\n    Skeleton matrix. \nidx : numpy.ndarray\n    Column index array. \nproj : numpy.ndarray\n    Interpolation coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>U : numpy.ndarray\n    Left singular vectors. \nS : numpy.ndarray\n    Singular values. \nV : numpy.ndarray\n    Right singular vectors.</code></pre><span class="prog__sub">Examples:</span><pre><code>U, S, V = id_to_svd(B, idx, proj)\nA = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.id_to_svd.html
scipy linalg interpolative id_to_svd	R	scipy.linalg.interpolative.id_to_svd										
scipy linalg.interpolative.id_to_svd	R	scipy.linalg.interpolative.id_to_svd										
scipy.linalg.interpolative.interp_decomp	A										<section class="prog__container"><p>Compute ID of a matrix.</p><pre><code>scipy.linalg.interpolative.interp_decomp(A, eps_or_k, rand=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : numpy.ndarray or scipy.sparse.linalg.LinearOperator with rmatvec\n    Matrix to be factored \neps_or_k : float or int\n    Relative error (if eps_or_k < 1) or rank (if eps_or_k >= 1) of approximation. \nrand : bool, optional\n    Whether to use random sampling if A is of type numpy.ndarray (randomized algorithms are always used if A is of type scipy.sparse.linalg.LinearOperator).</code></pre><span class="prog__sub">Returns:</span><pre><code>k : int\n    Rank required to achieve specified relative precision if eps_or_k < 1. \nidx : numpy.ndarray\n    Column index array. \nproj : numpy.ndarray\n    Interpolation coefficients.</code></pre><span class="prog__sub">Examples:</span><pre><code>numpy.dot(A[:,idx[:k]], proj) = A[:,idx[k:]]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.interp_decomp.html
scipy linalg interpolative interp_decomp	R	scipy.linalg.interpolative.interp_decomp										
scipy linalg.interpolative.interp_decomp	R	scipy.linalg.interpolative.interp_decomp										
scipy.linalg.interpolative.rand	A										<section class="prog__container"><p>Generate standard uniform pseudorandom numbers via a very efficient lagged\nFibonacci method.</p><pre><code>scipy.linalg.interpolative.rand(*shape)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape\n    Shape of output array</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.rand.html
scipy linalg interpolative rand	R	scipy.linalg.interpolative.rand										
scipy linalg.interpolative.rand	R	scipy.linalg.interpolative.rand										
scipy.linalg.interpolative.reconstruct_interp_matrix	A										<section class="prog__container"><p>Reconstruct interpolation matrix from ID.</p><pre><code>scipy.linalg.interpolative.reconstruct_interp_matrix(idx, proj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>idx : numpy.ndarray\n    Column index array. \nproj : numpy.ndarray\n    Interpolation coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>numpy.ndarray\n    Interpolation matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>P = numpy.hstack([numpy.eye(proj.shape[0]), proj])[:,numpy.argsort(idx)]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.reconstruct_interp_matrix.html
scipy linalg interpolative reconstruct_interp_matrix	R	scipy.linalg.interpolative.reconstruct_interp_matrix										
scipy linalg.interpolative.reconstruct_interp_matrix	R	scipy.linalg.interpolative.reconstruct_interp_matrix										
scipy.linalg.interpolative.reconstruct_matrix_from_id	A										<section class="prog__container"><p>Reconstruct matrix from its ID.</p><pre><code>scipy.linalg.interpolative.reconstruct_matrix_from_id(B, idx, proj)</code></pre><span class="prog__sub">Parameters:</span><pre><code>B : numpy.ndarray\n    Skeleton matrix. \nidx : numpy.ndarray\n    Column index array. \nproj : numpy.ndarray\n    Interpolation coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>numpy.ndarray\n    Reconstructed matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.reconstruct_matrix_from_id.html
scipy linalg interpolative reconstruct_matrix_from_id	R	scipy.linalg.interpolative.reconstruct_matrix_from_id										
scipy linalg.interpolative.reconstruct_matrix_from_id	R	scipy.linalg.interpolative.reconstruct_matrix_from_id										
scipy.linalg.interpolative.reconstruct_skel_matrix	A										<section class="prog__container"><p>Reconstruct skeleton matrix from ID.</p><pre><code>scipy.linalg.interpolative.reconstruct_skel_matrix(A, k, idx)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : numpy.ndarray\n    Original matrix. \nk : int\n    Rank of ID. \nidx : numpy.ndarray\n    Column index array.</code></pre><span class="prog__sub">Returns:</span><pre><code>numpy.ndarray\n    Skeleton matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>B = A[:,idx[:k]]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.reconstruct_skel_matrix.html
scipy linalg interpolative reconstruct_skel_matrix	R	scipy.linalg.interpolative.reconstruct_skel_matrix										
scipy linalg.interpolative.reconstruct_skel_matrix	R	scipy.linalg.interpolative.reconstruct_skel_matrix										
scipy.linalg.interpolative.seed	A										<section class="prog__container"><p>Seed the internal random number generator used in this ID package.</p><pre><code>scipy.linalg.interpolative.seed(seed=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>seed : int, sequence, ‘default’, optional\n    If ‘default’, the random seed is reset to a default value. If seed is a sequence containing 55 floating-point numbers in range [0,1], these are used to set the internal state of the generator. If the value is an integer, the internal state is obtained from numpy.random.RandomState (MT19937) with the integer used as the initial seed. If seed is omitted (None), numpy.random is used to initialize the generator.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.seed.html
scipy linalg interpolative seed	R	scipy.linalg.interpolative.seed										
scipy linalg.interpolative.seed	R	scipy.linalg.interpolative.seed										
scipy.linalg.interpolative.svd	A										<section class="prog__container"><p>Compute SVD of a matrix via an ID.</p><pre><code>scipy.linalg.interpolative.svd(A, eps_or_k, rand=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : numpy.ndarray or scipy.sparse.linalg.LinearOperator\n    Matrix to be factored, given as either a numpy.ndarray or a scipy.sparse.linalg.LinearOperator with the matvec and rmatvec methods (to apply the matrix and its adjoint). \neps_or_k : float or int\n    Relative error (if eps_or_k < 1) or rank (if eps_or_k >= 1) of approximation. \nrand : bool, optional\n    Whether to use random sampling if A is of type numpy.ndarray (randomized algorithms are always used if A is of type scipy.sparse.linalg.LinearOperator).</code></pre><span class="prog__sub">Returns:</span><pre><code>U : numpy.ndarray\n    Left singular vectors. \nS : numpy.ndarray\n    Singular values. \nV : numpy.ndarray\n    Right singular vectors.</code></pre><span class="prog__sub">Examples:</span><pre><code>A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.interpolative.svd.html
scipy linalg interpolative svd	R	scipy.linalg.interpolative.svd										
scipy linalg.interpolative.svd	R	scipy.linalg.interpolative.svd										
scipy.linalg.inv	A										<section class="prog__container"><p>Compute the inverse of a matrix.</p><pre><code>scipy.linalg.inv(a, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Square matrix to be inverted. \noverwrite_a : bool, optional\n    Discard data in a (may improve performance). Default is False. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>ainv : ndarray\n    Inverse of the matrix a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import linalg\n>>> a = np.array([[1., 2.], [3., 4.]])\n>>> linalg.inv(a)\narray([[-2. ,  1. ],\n       [ 1.5, -0.5]])\n>>> np.dot(a, linalg.inv(a))\narray([[ 1.,  0.],\n       [ 0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.inv.html
scipy.linalg.invhilbert	A										<section class="prog__container"><p>Compute the inverse of the Hilbert matrix of order n.</p><pre><code>scipy.linalg.invhilbert(n, exact=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The order of the Hilbert matrix. \nexact : bool, optional\n    If False, the data type of the array that is returned is np.float64, and the array is an approximation of the inverse. If True, the array is the exact integer inverse array.  To represent the exact inverse when n > 14, the returned array is an object array of long integers.  For n <= 14, the exact inverse is returned as an array with data type np.int64.</code></pre><span class="prog__sub">Returns:</span><pre><code>invh : (n, n) ndarray\n    The data type of the array is np.float64 if exact is False. If exact is True, the data type is either np.int64 (for n <= 14) or object (for n > 14).  In the latter case, the objects in the array will be long integers.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import invhilbert\n>>> invhilbert(4)\narray([[   16.,  -120.,   240.,  -140.],\n       [ -120.,  1200., -2700.,  1680.],\n       [  240., -2700.,  6480., -4200.],\n       [ -140.,  1680., -4200.,  2800.]])\n>>> invhilbert(4, exact=True)\narray([[   16,  -120,   240,  -140],\n       [ -120,  1200, -2700,  1680],\n       [  240, -2700,  6480, -4200],\n       [ -140,  1680, -4200,  2800]], dtype=int64)\n>>> invhilbert(16)[7,7]\n4.2475099528537506e+19\n>>> invhilbert(16, exact=True)[7,7]\n42475099528537378560L</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.invhilbert.html
scipy linalg invhilbert	R	scipy.linalg.invhilbert										
scipy linalg.invhilbert	R	scipy.linalg.invhilbert										
scipy.linalg.invpascal	A					[[scipy.linalg.pascal]]					<section class="prog__container"><p>Returns the inverse of the n x n Pascal matrix.</p><pre><code>scipy.linalg.invpascal(n, kind='symmetric', exact=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The size of the matrix to create; that is, the result is an n x n matrix. \nkind : str, optional\n    Must be one of ‘symmetric’, ‘lower’, or ‘upper’. Default is ‘symmetric’. \nexact : bool, optional\n    If exact is True, the result is either an array of type numpy.int64 (if n <= 35) or an object array of Python integers. If exact is False, the coefficients in the matrix are computed using scipy.special.comb with exact=False.  The result will be a floating point array, and for large n, the values in the array will not be the exact coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>invp : (n, n) ndarray\n    The inverse of the Pascal matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import invpascal, pascal\n>>> invp = invpascal(5)\n>>> invp\narray([[  5, -10,  10,  -5,   1],\n       [-10,  30, -35,  19,  -4],\n       [ 10, -35,  46, -27,   6],\n       [ -5,  19, -27,  17,  -4],\n       [  1,  -4,   6,  -4,   1]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.invpascal.html
scipy linalg invpascal	R	scipy.linalg.invpascal										
scipy linalg.invpascal	R	scipy.linalg.invpascal										
scipy linalg inv	R	scipy.linalg.inv										
scipy linalg.inv	R	scipy.linalg.inv										
scipy.linalg.kron	A										<section class="prog__container"><p>Kronecker product.</p><pre><code>scipy.linalg.kron(a, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) ndarray\n    Input array \nb : (P, Q) ndarray\n    Input array</code></pre><span class="prog__sub">Returns:</span><pre><code>A : (M*P, N*Q) ndarray\n    Kronecker product of a and b.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[0,0]*b    a[0,1]*b  ... a[0,-1]*b\na[1,0]*b    a[1,1]*b  ... a[1,-1]*b\n...\na[-1,0]*b   a[-1,1]*b ... a[-1,-1]*b</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.kron.html
scipy linalg kron	R	scipy.linalg.kron										
scipy linalg.kron	R	scipy.linalg.kron										
scipy.linalg.lapack.cgbsv	A										<section class="prog__container"><p>Wrapper for cgbsv.</p><pre><code>scipy.linalg.lapack.cgbsv(kl, ku, ab, b[, overwrite_ab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>kl : input int\nku : input int\nab : input rank-2 array(‘F’) with bounds (2*kl+ku+1,n)\nb : input rank-2 array(‘F’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>lub : rank-2 array(‘F’) with bounds (2*kl+ku+1,n) and ab storage\npiv : rank-1 array(‘i’) with bounds (n)\nx : rank-2 array(‘F’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgbsv.html
scipy linalg lapack cgbsv	R	scipy.linalg.lapack.cgbsv										
scipy linalg.lapack.cgbsv	R	scipy.linalg.lapack.cgbsv										
scipy.linalg.lapack.cgbtrf	A										<section class="prog__container"><p>Wrapper for cgbtrf.</p><pre><code>scipy.linalg.lapack.cgbtrf(ab, kl, ku[, m, n, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘F’) with bounds (ldab,*)\nkl : input int\nku : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘F’) with bounds (ldab,*) and ab storage\nipiv : rank-1 array(‘i’) with bounds (MIN(m,n))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgbtrf.html
scipy linalg lapack cgbtrf	R	scipy.linalg.lapack.cgbtrf										
scipy linalg.lapack.cgbtrf	R	scipy.linalg.lapack.cgbtrf										
scipy.linalg.lapack.cgbtrs	A										<section class="prog__container"><p>Wrapper for cgbtrs.</p><pre><code>scipy.linalg.lapack.cgbtrs(ab, kl, ku, b, ipiv[, trans, n, ldab, ldb, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘F’) with bounds (ldab,*)\nkl : input int\nku : input int\nb : input rank-2 array(‘F’) with bounds (ldb,*)\nipiv : input rank-1 array(‘i’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘F’) with bounds (ldb,*) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgbtrs.html
scipy linalg lapack cgbtrs	R	scipy.linalg.lapack.cgbtrs										
scipy linalg.lapack.cgbtrs	R	scipy.linalg.lapack.cgbtrs										
scipy.linalg.lapack.cgebal	A										<section class="prog__container"><p>Wrapper for cgebal.</p><pre><code>scipy.linalg.lapack.cgebal(a[, scale, permute, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>ba : rank-2 array(‘F’) with bounds (m,n) and a storage\nlo : int\nhi : int\npivscale : rank-1 array(‘f’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgebal.html
scipy linalg lapack cgebal	R	scipy.linalg.lapack.cgebal										
scipy linalg.lapack.cgebal	R	scipy.linalg.lapack.cgebal										
scipy.linalg.lapack.cgees	A										<section class="prog__container"><p>Wrapper for cgees.</p><pre><code>scipy.linalg.lapack.cgees(cselect, a[, compute_v, sort_t, lwork, cselect_extra_args, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>cselect : call-back function\na : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>t : rank-2 array(‘F’) with bounds (n,n) and a storage\nsdim : int\nw : rank-1 array(‘F’) with bounds (n)\nvs : rank-2 array(‘F’) with bounds (ldvs,n)\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre><span class="prog__sub">Examples:</span><pre><code>def cselect(arg): return cselect\nRequired arguments:\n  arg : input complex\nReturn objects:\n  cselect : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgees.html
scipy linalg lapack cgees	R	scipy.linalg.lapack.cgees										
scipy linalg.lapack.cgees	R	scipy.linalg.lapack.cgees										
scipy.linalg.lapack.cgeev	A										<section class="prog__container"><p>Wrapper for cgeev.</p><pre><code>scipy.linalg.lapack.cgeev(a[, compute_vl, compute_vr, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘F’) with bounds (n)\nvl : rank-2 array(‘F’) with bounds (ldvl,n)\nvr : rank-2 array(‘F’) with bounds (ldvr,n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgeev.html
scipy.linalg.lapack.cgeev_lwork	A										<section class="prog__container"><p>Wrapper for cgeev_lwork.</p><pre><code>scipy.linalg.lapack.cgeev_lwork(n[, compute_vl, compute_vr]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgeev_lwork.html
scipy linalg lapack cgeev_lwork	R	scipy.linalg.lapack.cgeev_lwork										
scipy linalg.lapack.cgeev_lwork	R	scipy.linalg.lapack.cgeev_lwork										
scipy linalg lapack cgeev	R	scipy.linalg.lapack.cgeev										
scipy linalg.lapack.cgeev	R	scipy.linalg.lapack.cgeev										
scipy.linalg.lapack.cgegv	A										<section class="prog__container"><p>cgegv is deprecated!\nThe *gegv family of routines has been deprecated in\nLAPACK 3.6.0 in favor of the *ggev family of routines.\nThe corresponding wrappers will be removed from SciPy in\na future release.</p><pre><code>scipy.linalg.lapack.cgegv(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\nb : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : rank-1 array(‘F’) with bounds (n)\nbeta : rank-1 array(‘F’) with bounds (n)\nvl : rank-2 array(‘F’) with bounds (ldvl,n)\nvr : rank-2 array(‘F’) with bounds (ldvr,n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgegv.html
scipy linalg lapack cgegv	R	scipy.linalg.lapack.cgegv										
scipy linalg.lapack.cgegv	R	scipy.linalg.lapack.cgegv										
scipy.linalg.lapack.cgehrd	A										<section class="prog__container"><p>Wrapper for cgehrd.</p><pre><code>scipy.linalg.lapack.cgehrd(a[, lo, hi, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>ht : rank-2 array(‘F’) with bounds (n,n) and a storage\ntau : rank-1 array(‘F’) with bounds (n - 1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgehrd.html
scipy.linalg.lapack.cgehrd_lwork	A										<section class="prog__container"><p>Wrapper for cgehrd_lwork.</p><pre><code>scipy.linalg.lapack.cgehrd_lwork(n[, lo, hi]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgehrd_lwork.html
scipy linalg lapack cgehrd_lwork	R	scipy.linalg.lapack.cgehrd_lwork										
scipy linalg.lapack.cgehrd_lwork	R	scipy.linalg.lapack.cgehrd_lwork										
scipy linalg lapack cgehrd	R	scipy.linalg.lapack.cgehrd										
scipy linalg.lapack.cgehrd	R	scipy.linalg.lapack.cgehrd										
scipy.linalg.lapack.cgelsd	A										<section class="prog__container"><p>Wrapper for cgelsd.</p><pre><code>scipy.linalg.lapack.cgelsd(a, b, lwork, size_rwork, size_iwork[, cond, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)\nb : input rank-2 array(‘F’) with bounds (maxmn,nrhs)\nlwork : input int\nsize_rwork : input int\nsize_iwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘F’) with bounds (maxmn,nrhs) and b storage\ns : rank-1 array(‘f’) with bounds (minmn)\nrank : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgelsd.html
scipy.linalg.lapack.cgelsd_lwork	A										<section class="prog__container"><p>Wrapper for cgelsd_lwork.</p><pre><code>scipy.linalg.lapack.cgelsd_lwork(m, n, nrhs[, cond, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\nrwork : float\niwork : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgelsd_lwork.html
scipy linalg lapack cgelsd_lwork	R	scipy.linalg.lapack.cgelsd_lwork										
scipy linalg.lapack.cgelsd_lwork	R	scipy.linalg.lapack.cgelsd_lwork										
scipy linalg lapack cgelsd	R	scipy.linalg.lapack.cgelsd										
scipy linalg.lapack.cgelsd	R	scipy.linalg.lapack.cgelsd										
scipy.linalg.lapack.cgelss	A										<section class="prog__container"><p>Wrapper for cgelss.</p><pre><code>scipy.linalg.lapack.cgelss(a, b[, cond, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)\nb : input rank-2 array(‘F’) with bounds (maxmn,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>v : rank-2 array(‘F’) with bounds (m,n) and a storage\nx : rank-2 array(‘F’) with bounds (maxmn,nrhs) and b storage\ns : rank-1 array(‘f’) with bounds (minmn)\nrank : int\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgelss.html
scipy.linalg.lapack.cgelss_lwork	A										<section class="prog__container"><p>Wrapper for cgelss_lwork.</p><pre><code>scipy.linalg.lapack.cgelss_lwork(m, n, nrhs[, cond, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgelss_lwork.html
scipy linalg lapack cgelss_lwork	R	scipy.linalg.lapack.cgelss_lwork										
scipy linalg.lapack.cgelss_lwork	R	scipy.linalg.lapack.cgelss_lwork										
scipy linalg lapack cgelss	R	scipy.linalg.lapack.cgelss										
scipy linalg.lapack.cgelss	R	scipy.linalg.lapack.cgelss										
scipy.linalg.lapack.cgelsy	A										<section class="prog__container"><p>Wrapper for cgelsy.</p><pre><code>scipy.linalg.lapack.cgelsy(a, b, jptv, cond, lwork[, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)\nb : input rank-2 array(‘F’) with bounds (maxmn,nrhs)\njptv : input rank-1 array(‘i’) with bounds (n)\ncond : input float\nlwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>v : rank-2 array(‘F’) with bounds (m,n) and a storage\nx : rank-2 array(‘F’) with bounds (maxmn,nrhs) and b storage\nj : rank-1 array(‘i’) with bounds (n) and jptv storage\nrank : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgelsy.html
scipy.linalg.lapack.cgelsy_lwork	A										<section class="prog__container"><p>Wrapper for cgelsy_lwork.</p><pre><code>scipy.linalg.lapack.cgelsy_lwork(m, n, nrhs, cond[, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int\ncond : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgelsy_lwork.html
scipy linalg lapack cgelsy_lwork	R	scipy.linalg.lapack.cgelsy_lwork										
scipy linalg.lapack.cgelsy_lwork	R	scipy.linalg.lapack.cgelsy_lwork										
scipy linalg lapack cgelsy	R	scipy.linalg.lapack.cgelsy										
scipy linalg.lapack.cgelsy	R	scipy.linalg.lapack.cgelsy										
scipy.linalg.lapack.cgeqp3	A										<section class="prog__container"><p>Wrapper for cgeqp3.</p><pre><code>scipy.linalg.lapack.cgeqp3(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘F’) with bounds (m,n) and a storage\njpvt : rank-1 array(‘i’) with bounds (n)\ntau : rank-1 array(‘F’) with bounds (MIN(m,n))\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgeqp3.html
scipy linalg lapack cgeqp3	R	scipy.linalg.lapack.cgeqp3										
scipy linalg.lapack.cgeqp3	R	scipy.linalg.lapack.cgeqp3										
scipy.linalg.lapack.cgeqrf	A										<section class="prog__container"><p>Wrapper for cgeqrf.</p><pre><code>scipy.linalg.lapack.cgeqrf(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘F’) with bounds (m,n) and a storage\ntau : rank-1 array(‘F’) with bounds (MIN(m,n))\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgeqrf.html
scipy linalg lapack cgeqrf	R	scipy.linalg.lapack.cgeqrf										
scipy linalg.lapack.cgeqrf	R	scipy.linalg.lapack.cgeqrf										
scipy.linalg.lapack.cgerqf	A										<section class="prog__container"><p>Wrapper for cgerqf.</p><pre><code>scipy.linalg.lapack.cgerqf(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘F’) with bounds (m,n) and a storage\ntau : rank-1 array(‘F’) with bounds (MIN(m,n))\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgerqf.html
scipy linalg lapack cgerqf	R	scipy.linalg.lapack.cgerqf										
scipy linalg.lapack.cgerqf	R	scipy.linalg.lapack.cgerqf										
scipy.linalg.lapack.cgesdd	A										<section class="prog__container"><p>Wrapper for cgesdd.</p><pre><code>scipy.linalg.lapack.cgesdd(a[, compute_uv, full_matrices, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>u : rank-2 array(‘F’) with bounds (u0,u1)\ns : rank-1 array(‘f’) with bounds (minmn)\nvt : rank-2 array(‘F’) with bounds (vt0,vt1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgesdd.html
scipy.linalg.lapack.cgesdd_lwork	A										<section class="prog__container"><p>Wrapper for cgesdd_lwork.</p><pre><code>scipy.linalg.lapack.cgesdd_lwork(m, n[, compute_uv, full_matrices]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgesdd_lwork.html
scipy linalg lapack cgesdd_lwork	R	scipy.linalg.lapack.cgesdd_lwork										
scipy linalg.lapack.cgesdd_lwork	R	scipy.linalg.lapack.cgesdd_lwork										
scipy linalg lapack cgesdd	R	scipy.linalg.lapack.cgesdd										
scipy linalg.lapack.cgesdd	R	scipy.linalg.lapack.cgesdd										
scipy.linalg.lapack.cgesv	A										<section class="prog__container"><p>Wrapper for cgesv.</p><pre><code>scipy.linalg.lapack.cgesv(a, b[, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\nb : input rank-2 array(‘F’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘F’) with bounds (n,n) and a storage\npiv : rank-1 array(‘i’) with bounds (n)\nx : rank-2 array(‘F’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgesv.html
scipy.linalg.lapack.cgesvd	A										<section class="prog__container"><p>Wrapper for cgesvd.</p><pre><code>scipy.linalg.lapack.cgesvd(a[, compute_uv, full_matrices, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>u : rank-2 array(‘F’) with bounds (u0,u1)\ns : rank-1 array(‘f’) with bounds (minmn)\nvt : rank-2 array(‘F’) with bounds (vt0,vt1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgesvd.html
scipy.linalg.lapack.cgesvd_lwork	A										<section class="prog__container"><p>Wrapper for cgesvd_lwork.</p><pre><code>scipy.linalg.lapack.cgesvd_lwork(m, n[, compute_uv, full_matrices]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgesvd_lwork.html
scipy linalg lapack cgesvd_lwork	R	scipy.linalg.lapack.cgesvd_lwork										
scipy linalg.lapack.cgesvd_lwork	R	scipy.linalg.lapack.cgesvd_lwork										
scipy linalg lapack cgesvd	R	scipy.linalg.lapack.cgesvd										
scipy linalg.lapack.cgesvd	R	scipy.linalg.lapack.cgesvd										
scipy linalg lapack cgesv	R	scipy.linalg.lapack.cgesv										
scipy linalg.lapack.cgesv	R	scipy.linalg.lapack.cgesv										
scipy.linalg.lapack.cgetrf	A										<section class="prog__container"><p>Wrapper for cgetrf.</p><pre><code>scipy.linalg.lapack.cgetrf(a[, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘F’) with bounds (m,n) and a storage\npiv : rank-1 array(‘i’) with bounds (MIN(m,n))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgetrf.html
scipy linalg lapack cgetrf	R	scipy.linalg.lapack.cgetrf										
scipy linalg.lapack.cgetrf	R	scipy.linalg.lapack.cgetrf										
scipy.linalg.lapack.cgetri	A										<section class="prog__container"><p>Wrapper for cgetri.</p><pre><code>scipy.linalg.lapack.cgetri(lu, piv[, lwork, overwrite_lu]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>lu : input rank-2 array(‘F’) with bounds (n,n)\npiv : input rank-1 array(‘i’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_a : rank-2 array(‘F’) with bounds (n,n) and lu storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgetri.html
scipy.linalg.lapack.cgetri_lwork	A										<section class="prog__container"><p>Wrapper for cgetri_lwork.</p><pre><code>scipy.linalg.lapack.cgetri_lwork(n) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgetri_lwork.html
scipy linalg lapack cgetri_lwork	R	scipy.linalg.lapack.cgetri_lwork										
scipy linalg.lapack.cgetri_lwork	R	scipy.linalg.lapack.cgetri_lwork										
scipy linalg lapack cgetri	R	scipy.linalg.lapack.cgetri										
scipy linalg.lapack.cgetri	R	scipy.linalg.lapack.cgetri										
scipy.linalg.lapack.cgetrs	A										<section class="prog__container"><p>Wrapper for cgetrs.</p><pre><code>scipy.linalg.lapack.cgetrs(lu, piv, b[, trans, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>lu : input rank-2 array(‘F’) with bounds (n,n)\npiv : input rank-1 array(‘i’) with bounds (n)\nb : input rank-2 array(‘F’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘F’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgetrs.html
scipy linalg lapack cgetrs	R	scipy.linalg.lapack.cgetrs										
scipy linalg.lapack.cgetrs	R	scipy.linalg.lapack.cgetrs										
scipy.linalg.lapack.cgges	A										<section class="prog__container"><p>Wrapper for cgges.</p><pre><code>scipy.linalg.lapack.cgges(cselect, a, b[, jobvsl, jobvsr, sort_t, ldvsl, ldvsr, lwork, cselect_extra_args, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>cselect : call-back function\na : input rank-2 array(‘F’) with bounds (lda,*)\nb : input rank-2 array(‘F’) with bounds (ldb,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (lda,*)\nb : rank-2 array(‘F’) with bounds (ldb,*)\nsdim : int\nalpha : rank-1 array(‘F’) with bounds (n)\nbeta : rank-1 array(‘F’) with bounds (n)\nvsl : rank-2 array(‘F’) with bounds (ldvsl,n)\nvsr : rank-2 array(‘F’) with bounds (ldvsr,n)\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre><span class="prog__sub">Examples:</span><pre><code>def cselect(alpha,beta): return cselect\nRequired arguments:\n  alpha : input complex\n  beta : input complex\nReturn objects:\n  cselect : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgges.html
scipy linalg lapack cgges	R	scipy.linalg.lapack.cgges										
scipy linalg.lapack.cgges	R	scipy.linalg.lapack.cgges										
scipy.linalg.lapack.cggev	A										<section class="prog__container"><p>Wrapper for cggev.</p><pre><code>scipy.linalg.lapack.cggev(a, b[, compute_vl, compute_vr, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\nb : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : rank-1 array(‘F’) with bounds (n)\nbeta : rank-1 array(‘F’) with bounds (n)\nvl : rank-2 array(‘F’) with bounds (ldvl,n)\nvr : rank-2 array(‘F’) with bounds (ldvr,n)\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cggev.html
scipy linalg lapack cggev	R	scipy.linalg.lapack.cggev										
scipy linalg.lapack.cggev	R	scipy.linalg.lapack.cggev										
scipy.linalg.lapack.cgtsv	A										<section class="prog__container"><p>Wrapper for cgtsv.</p><pre><code>scipy.linalg.lapack.cgtsv(dl, d, du, b[, overwrite_dl, overwrite_d, overwrite_du, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>dl : input rank-1 array(‘F’) with bounds (n - 1)\nd : input rank-1 array(‘F’) with bounds (*)\ndu : input rank-1 array(‘F’) with bounds (n - 1)\nb : input rank-2 array(‘F’) with bounds (,)</code></pre><span class="prog__sub">Returns:</span><pre><code>du2 : rank-1 array(‘F’) with bounds (n - 1) and dl storage\nd : rank-1 array(‘F’) with bounds (*)\ndu : rank-1 array(‘F’) with bounds (n - 1)\nx : rank-2 array(‘F’) with bounds (,) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cgtsv.html
scipy linalg lapack cgtsv	R	scipy.linalg.lapack.cgtsv										
scipy linalg.lapack.cgtsv	R	scipy.linalg.lapack.cgtsv										
scipy.linalg.lapack.chbevd	A										<section class="prog__container"><p>Wrapper for chbevd.</p><pre><code>scipy.linalg.lapack.chbevd(ab[, compute_v, lower, ldab, lrwork, liwork, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘F’) with bounds (ldab,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘F’) with bounds (ldz,ldz)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.chbevd.html
scipy linalg lapack chbevd	R	scipy.linalg.lapack.chbevd										
scipy linalg.lapack.chbevd	R	scipy.linalg.lapack.chbevd										
scipy.linalg.lapack.chbevx	A										<section class="prog__container"><p>Wrapper for chbevx.</p><pre><code>scipy.linalg.lapack.chbevx(ab, vl, vu, il, iu[, ldab, compute_v, range, lower, abstol, mmax, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘F’) with bounds (ldab,*)\nvl : input float\nvu : input float\nil : input int\niu : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘F’) with bounds (ldz,mmax)\nm : int\nifail : rank-1 array(‘i’) with bounds ((compute_v?n:1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.chbevx.html
scipy linalg lapack chbevx	R	scipy.linalg.lapack.chbevx										
scipy linalg.lapack.chbevx	R	scipy.linalg.lapack.chbevx										
scipy.linalg.lapack.cheev	A										<section class="prog__container"><p>Wrapper for cheev.</p><pre><code>scipy.linalg.lapack.cheev(a[, compute_v, lower, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nv : rank-2 array(‘F’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cheev.html
scipy.linalg.lapack.cheevd	A										<section class="prog__container"><p>Wrapper for cheevd.</p><pre><code>scipy.linalg.lapack.cheevd(a[, compute_v, lower, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nv : rank-2 array(‘F’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cheevd.html
scipy linalg lapack cheevd	R	scipy.linalg.lapack.cheevd										
scipy linalg.lapack.cheevd	R	scipy.linalg.lapack.cheevd										
scipy.linalg.lapack.cheevr	A										<section class="prog__container"><p>Wrapper for cheevr.</p><pre><code>scipy.linalg.lapack.cheevr(a[, jobz, range, uplo, il, iu, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘F’) with bounds (n,m)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cheevr.html
scipy linalg lapack cheevr	R	scipy.linalg.lapack.cheevr										
scipy linalg.lapack.cheevr	R	scipy.linalg.lapack.cheevr										
scipy linalg lapack cheev	R	scipy.linalg.lapack.cheev										
scipy linalg.lapack.cheev	R	scipy.linalg.lapack.cheev										
scipy.linalg.lapack.chegv	A										<section class="prog__container"><p>Wrapper for chegv.</p><pre><code>scipy.linalg.lapack.chegv(a, b[, itype, jobz, uplo, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\nb : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (n,n)\nw : rank-1 array(‘f’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.chegv.html
scipy.linalg.lapack.chegvd	A										<section class="prog__container"><p>Wrapper for chegvd.</p><pre><code>scipy.linalg.lapack.chegvd(a, b[, itype, jobz, uplo, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\nb : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (n,n)\nw : rank-1 array(‘f’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.chegvd.html
scipy linalg lapack chegvd	R	scipy.linalg.lapack.chegvd										
scipy linalg.lapack.chegvd	R	scipy.linalg.lapack.chegvd										
scipy linalg lapack chegv	R	scipy.linalg.lapack.chegv										
scipy linalg.lapack.chegv	R	scipy.linalg.lapack.chegv										
scipy.linalg.lapack.chegvx	A										<section class="prog__container"><p>Wrapper for chegvx.</p><pre><code>scipy.linalg.lapack.chegvx(a, b, iu[, itype, jobz, uplo, il, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\nb : input rank-2 array(‘F’) with bounds (n,n)\niu : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘F’) with bounds (n,m)\nifail : rank-1 array(‘i’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.chegvx.html
scipy linalg lapack chegvx	R	scipy.linalg.lapack.chegvx										
scipy linalg.lapack.chegvx	R	scipy.linalg.lapack.chegvx										
scipy.linalg.lapack.clange	A										<section class="prog__container"><p>Wrapper for clange.</p><pre><code>scipy.linalg.lapack.clange(norm, a) = <fortran clange></code></pre><span class="prog__sub">Parameters:</span><pre><code>norm : input string(len=1)\na : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>n2 : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.clange.html
scipy linalg lapack clange	R	scipy.linalg.lapack.clange										
scipy linalg.lapack.clange	R	scipy.linalg.lapack.clange										
scipy.linalg.lapack.clarf	A										<section class="prog__container"><p>Wrapper for clarf.</p><pre><code>scipy.linalg.lapack.clarf(v, tau, c, work[, side, incv, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : input rank-1 array(‘F’) with bounds (*)\ntau : input complex\nc : input rank-2 array(‘F’) with bounds (m,n)\nwork : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.clarf.html
scipy.linalg.lapack.clarfg	A										<section class="prog__container"><p>Wrapper for clarfg.</p><pre><code>scipy.linalg.lapack.clarfg(n, alpha, x[, incx, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int\nalpha : input complex\nx : input rank-1 array(‘F’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : complex\nx : rank-1 array(‘F’) with bounds (*)\ntau : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.clarfg.html
scipy linalg lapack clarfg	R	scipy.linalg.lapack.clarfg										
scipy linalg.lapack.clarfg	R	scipy.linalg.lapack.clarfg										
scipy linalg lapack clarf	R	scipy.linalg.lapack.clarf										
scipy linalg.lapack.clarf	R	scipy.linalg.lapack.clarf										
scipy.linalg.lapack.clartg	A										<section class="prog__container"><p>Wrapper for clartg.</p><pre><code>scipy.linalg.lapack.clartg(f, g) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>f : input complex\ng : input complex</code></pre><span class="prog__sub">Returns:</span><pre><code>cs : float\nsn : complex\nr : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.clartg.html
scipy linalg lapack clartg	R	scipy.linalg.lapack.clartg										
scipy linalg.lapack.clartg	R	scipy.linalg.lapack.clartg										
scipy.linalg.lapack.claswp	A										<section class="prog__container"><p>Wrapper for claswp.</p><pre><code>scipy.linalg.lapack.claswp(a, piv[, k1, k2, off, inc, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (nrows,n)\npiv : input rank-1 array(‘i’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (nrows,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.claswp.html
scipy linalg lapack claswp	R	scipy.linalg.lapack.claswp										
scipy linalg.lapack.claswp	R	scipy.linalg.lapack.claswp										
scipy.linalg.lapack.clauum	A										<section class="prog__container"><p>Wrapper for clauum.</p><pre><code>scipy.linalg.lapack.clauum(c[, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘F’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.clauum.html
scipy linalg lapack clauum	R	scipy.linalg.lapack.clauum										
scipy linalg.lapack.clauum	R	scipy.linalg.lapack.clauum										
scipy.linalg.lapack.cpbsv	A										<section class="prog__container"><p>Wrapper for cpbsv.</p><pre><code>scipy.linalg.lapack.cpbsv(ab, b[, lower, ldab, overwrite_ab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘F’) with bounds (ldab,n)\nb : input rank-2 array(‘F’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (ldab,n) and ab storage\nx : rank-2 array(‘F’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cpbsv.html
scipy linalg lapack cpbsv	R	scipy.linalg.lapack.cpbsv										
scipy linalg.lapack.cpbsv	R	scipy.linalg.lapack.cpbsv										
scipy.linalg.lapack.cpbtrf	A										<section class="prog__container"><p>Wrapper for cpbtrf.</p><pre><code>scipy.linalg.lapack.cpbtrf(ab[, lower, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘F’) with bounds (ldab,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (ldab,n) and ab storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cpbtrf.html
scipy linalg lapack cpbtrf	R	scipy.linalg.lapack.cpbtrf										
scipy linalg.lapack.cpbtrf	R	scipy.linalg.lapack.cpbtrf										
scipy.linalg.lapack.cpbtrs	A										<section class="prog__container"><p>Wrapper for cpbtrs.</p><pre><code>scipy.linalg.lapack.cpbtrs(ab, b[, lower, ldab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘F’) with bounds (ldab,n)\nb : input rank-2 array(‘F’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘F’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cpbtrs.html
scipy linalg lapack cpbtrs	R	scipy.linalg.lapack.cpbtrs										
scipy linalg.lapack.cpbtrs	R	scipy.linalg.lapack.cpbtrs										
scipy.linalg.lapack.cposv	A										<section class="prog__container"><p>Wrapper for cposv.</p><pre><code>scipy.linalg.lapack.cposv(a, b[, lower, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\nb : input rank-2 array(‘F’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (n,n) and a storage\nx : rank-2 array(‘F’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cposv.html
scipy linalg lapack cposv	R	scipy.linalg.lapack.cposv										
scipy linalg.lapack.cposv	R	scipy.linalg.lapack.cposv										
scipy.linalg.lapack.cpotrf	A										<section class="prog__container"><p>Wrapper for cpotrf.</p><pre><code>scipy.linalg.lapack.cpotrf(a[, lower, clean, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘F’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cpotrf.html
scipy linalg lapack cpotrf	R	scipy.linalg.lapack.cpotrf										
scipy linalg.lapack.cpotrf	R	scipy.linalg.lapack.cpotrf										
scipy.linalg.lapack.cpotri	A										<section class="prog__container"><p>Wrapper for cpotri.</p><pre><code>scipy.linalg.lapack.cpotri(c[, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_a : rank-2 array(‘F’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cpotri.html
scipy linalg lapack cpotri	R	scipy.linalg.lapack.cpotri										
scipy linalg.lapack.cpotri	R	scipy.linalg.lapack.cpotri										
scipy.linalg.lapack.cpotrs	A										<section class="prog__container"><p>Wrapper for cpotrs.</p><pre><code>scipy.linalg.lapack.cpotrs(c, b[, lower, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘F’) with bounds (n,n)\nb : input rank-2 array(‘F’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘F’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cpotrs.html
scipy linalg lapack cpotrs	R	scipy.linalg.lapack.cpotrs										
scipy linalg.lapack.cpotrs	R	scipy.linalg.lapack.cpotrs										
scipy.linalg.lapack.cptsv	A										<section class="prog__container"><p>Wrapper for cptsv.</p><pre><code>scipy.linalg.lapack.cptsv(d, e, b[, overwrite_d, overwrite_e, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>d : input rank-1 array(‘f’) with bounds (*)\ne : input rank-1 array(‘F’) with bounds (n - 1)\nb : input rank-2 array(‘F’) with bounds (,)</code></pre><span class="prog__sub">Returns:</span><pre><code>d : rank-1 array(‘f’) with bounds (*)\ndu : rank-1 array(‘F’) with bounds (n - 1) and e storage\nx : rank-2 array(‘F’) with bounds (,) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cptsv.html
scipy linalg lapack cptsv	R	scipy.linalg.lapack.cptsv										
scipy linalg.lapack.cptsv	R	scipy.linalg.lapack.cptsv										
scipy.linalg.lapack.crot	A										<section class="prog__container"><p>Wrapper for crot.</p><pre><code>scipy.linalg.lapack.crot(x, y, c, s[, n, offx, incx, offy, incy, overwrite_x, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘F’) with bounds (*)\ny : input rank-1 array(‘F’) with bounds (*)\nc : input float\ns : input complex</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘F’) with bounds (*)\ny : rank-1 array(‘F’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.crot.html
scipy linalg lapack crot	R	scipy.linalg.lapack.crot										
scipy linalg.lapack.crot	R	scipy.linalg.lapack.crot										
scipy.linalg.lapack.ctrsyl	A										<section class="prog__container"><p>Wrapper for ctrsyl.</p><pre><code>scipy.linalg.lapack.ctrsyl(a, b, c[, trana, tranb, isgn, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,m)\nb : input rank-2 array(‘F’) with bounds (n,n)\nc : input rank-2 array(‘F’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘F’) with bounds (m,n) and c storage\nscale : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ctrsyl.html
scipy linalg lapack ctrsyl	R	scipy.linalg.lapack.ctrsyl										
scipy linalg.lapack.ctrsyl	R	scipy.linalg.lapack.ctrsyl										
scipy.linalg.lapack.ctrtri	A										<section class="prog__container"><p>Wrapper for ctrtri.</p><pre><code>scipy.linalg.lapack.ctrtri(c[, lower, unitdiag, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘F’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_c : rank-2 array(‘F’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ctrtri.html
scipy linalg lapack ctrtri	R	scipy.linalg.lapack.ctrtri										
scipy linalg.lapack.ctrtri	R	scipy.linalg.lapack.ctrtri										
scipy.linalg.lapack.ctrtrs	A										<section class="prog__container"><p>Wrapper for ctrtrs.</p><pre><code>scipy.linalg.lapack.ctrtrs(a, b[, lower, trans, unitdiag, lda, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (lda,n)\nb : input rank-2 array(‘F’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘F’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ctrtrs.html
scipy linalg lapack ctrtrs	R	scipy.linalg.lapack.ctrtrs										
scipy linalg.lapack.ctrtrs	R	scipy.linalg.lapack.ctrtrs										
scipy.linalg.lapack.cunghr	A										<section class="prog__container"><p>Wrapper for cunghr.</p><pre><code>scipy.linalg.lapack.cunghr(a, tau[, lo, hi, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (n,n)\ntau : input rank-1 array(‘F’) with bounds (n - 1)</code></pre><span class="prog__sub">Returns:</span><pre><code>ht : rank-2 array(‘F’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cunghr.html
scipy linalg lapack cunghr	R	scipy.linalg.lapack.cunghr										
scipy linalg.lapack.cunghr	R	scipy.linalg.lapack.cunghr										
scipy.linalg.lapack.cungqr	A										<section class="prog__container"><p>Wrapper for cungqr.</p><pre><code>scipy.linalg.lapack.cungqr(a, tau[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)\ntau : input rank-1 array(‘F’) with bounds (k)</code></pre><span class="prog__sub">Returns:</span><pre><code>q : rank-2 array(‘F’) with bounds (m,n) and a storage\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cungqr.html
scipy linalg lapack cungqr	R	scipy.linalg.lapack.cungqr										
scipy linalg.lapack.cungqr	R	scipy.linalg.lapack.cungqr										
scipy.linalg.lapack.cungrq	A										<section class="prog__container"><p>Wrapper for cungrq.</p><pre><code>scipy.linalg.lapack.cungrq(a, tau[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘F’) with bounds (m,n)\ntau : input rank-1 array(‘F’) with bounds (k)</code></pre><span class="prog__sub">Returns:</span><pre><code>q : rank-2 array(‘F’) with bounds (m,n) and a storage\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cungrq.html
scipy linalg lapack cungrq	R	scipy.linalg.lapack.cungrq										
scipy linalg.lapack.cungrq	R	scipy.linalg.lapack.cungrq										
scipy.linalg.lapack.cunmqr	A										<section class="prog__container"><p>Wrapper for cunmqr.</p><pre><code>scipy.linalg.lapack.cunmqr(side, trans, a, tau, c, lwork[, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>side : input string(len=1)\ntrans : input string(len=1)\na : input rank-2 array(‘F’) with bounds (lda,k)\ntau : input rank-1 array(‘F’) with bounds (k)\nc : input rank-2 array(‘F’) with bounds (ldc,n)\nlwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>cq : rank-2 array(‘F’) with bounds (ldc,n) and c storage\nwork : rank-1 array(‘F’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.cunmqr.html
scipy linalg lapack cunmqr	R	scipy.linalg.lapack.cunmqr										
scipy linalg.lapack.cunmqr	R	scipy.linalg.lapack.cunmqr										
scipy.linalg.lapack.dgbsv	A										<section class="prog__container"><p>Wrapper for dgbsv.</p><pre><code>scipy.linalg.lapack.dgbsv(kl, ku, ab, b[, overwrite_ab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>kl : input int\nku : input int\nab : input rank-2 array(‘d’) with bounds (2*kl+ku+1,n)\nb : input rank-2 array(‘d’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>lub : rank-2 array(‘d’) with bounds (2*kl+ku+1,n) and ab storage\npiv : rank-1 array(‘i’) with bounds (n)\nx : rank-2 array(‘d’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgbsv.html
scipy linalg lapack dgbsv	R	scipy.linalg.lapack.dgbsv										
scipy linalg.lapack.dgbsv	R	scipy.linalg.lapack.dgbsv										
scipy.linalg.lapack.dgbtrf	A										<section class="prog__container"><p>Wrapper for dgbtrf.</p><pre><code>scipy.linalg.lapack.dgbtrf(ab, kl, ku[, m, n, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘d’) with bounds (ldab,*)\nkl : input int\nku : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘d’) with bounds (ldab,*) and ab storage\nipiv : rank-1 array(‘i’) with bounds (MIN(m,n))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgbtrf.html
scipy linalg lapack dgbtrf	R	scipy.linalg.lapack.dgbtrf										
scipy linalg.lapack.dgbtrf	R	scipy.linalg.lapack.dgbtrf										
scipy.linalg.lapack.dgbtrs	A										<section class="prog__container"><p>Wrapper for dgbtrs.</p><pre><code>scipy.linalg.lapack.dgbtrs(ab, kl, ku, b, ipiv[, trans, n, ldab, ldb, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘d’) with bounds (ldab,*)\nkl : input int\nku : input int\nb : input rank-2 array(‘d’) with bounds (ldb,*)\nipiv : input rank-1 array(‘i’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘d’) with bounds (ldb,*) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgbtrs.html
scipy linalg lapack dgbtrs	R	scipy.linalg.lapack.dgbtrs										
scipy linalg.lapack.dgbtrs	R	scipy.linalg.lapack.dgbtrs										
scipy.linalg.lapack.dgebal	A										<section class="prog__container"><p>Wrapper for dgebal.</p><pre><code>scipy.linalg.lapack.dgebal(a[, scale, permute, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>ba : rank-2 array(‘d’) with bounds (m,n) and a storage\nlo : int\nhi : int\npivscale : rank-1 array(‘d’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgebal.html
scipy linalg lapack dgebal	R	scipy.linalg.lapack.dgebal										
scipy linalg.lapack.dgebal	R	scipy.linalg.lapack.dgebal										
scipy.linalg.lapack.dgees	A										<section class="prog__container"><p>Wrapper for dgees.</p><pre><code>scipy.linalg.lapack.dgees(dselect, a[, compute_v, sort_t, lwork, dselect_extra_args, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>dselect : call-back function\na : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>t : rank-2 array(‘d’) with bounds (n,n) and a storage\nsdim : int\nwr : rank-1 array(‘d’) with bounds (n)\nwi : rank-1 array(‘d’) with bounds (n)\nvs : rank-2 array(‘d’) with bounds (ldvs,n)\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre><span class="prog__sub">Examples:</span><pre><code>def dselect(arg1,arg2): return dselect\nRequired arguments:\n  arg1 : input float\n  arg2 : input float\nReturn objects:\n  dselect : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgees.html
scipy linalg lapack dgees	R	scipy.linalg.lapack.dgees										
scipy linalg.lapack.dgees	R	scipy.linalg.lapack.dgees										
scipy.linalg.lapack.dgeev	A										<section class="prog__container"><p>Wrapper for dgeev.</p><pre><code>scipy.linalg.lapack.dgeev(a[, compute_vl, compute_vr, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>wr : rank-1 array(‘d’) with bounds (n)\nwi : rank-1 array(‘d’) with bounds (n)\nvl : rank-2 array(‘d’) with bounds (ldvl,n)\nvr : rank-2 array(‘d’) with bounds (ldvr,n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgeev.html
scipy.linalg.lapack.dgeev_lwork	A										<section class="prog__container"><p>Wrapper for dgeev_lwork.</p><pre><code>scipy.linalg.lapack.dgeev_lwork(n[, compute_vl, compute_vr]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgeev_lwork.html
scipy linalg lapack dgeev_lwork	R	scipy.linalg.lapack.dgeev_lwork										
scipy linalg.lapack.dgeev_lwork	R	scipy.linalg.lapack.dgeev_lwork										
scipy linalg lapack dgeev	R	scipy.linalg.lapack.dgeev										
scipy linalg.lapack.dgeev	R	scipy.linalg.lapack.dgeev										
scipy.linalg.lapack.dgegv	A										<section class="prog__container"><p>dgegv is deprecated!\nThe *gegv family of routines has been deprecated in\nLAPACK 3.6.0 in favor of the *ggev family of routines.\nThe corresponding wrappers will be removed from SciPy in\na future release.</p><pre><code>scipy.linalg.lapack.dgegv(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\nb : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>alphar : rank-1 array(‘d’) with bounds (n)\nalphai : rank-1 array(‘d’) with bounds (n)\nbeta : rank-1 array(‘d’) with bounds (n)\nvl : rank-2 array(‘d’) with bounds (ldvl,n)\nvr : rank-2 array(‘d’) with bounds (ldvr,n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgegv.html
scipy linalg lapack dgegv	R	scipy.linalg.lapack.dgegv										
scipy linalg.lapack.dgegv	R	scipy.linalg.lapack.dgegv										
scipy.linalg.lapack.dgehrd	A										<section class="prog__container"><p>Wrapper for dgehrd.</p><pre><code>scipy.linalg.lapack.dgehrd(a[, lo, hi, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>ht : rank-2 array(‘d’) with bounds (n,n) and a storage\ntau : rank-1 array(‘d’) with bounds (n - 1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgehrd.html
scipy.linalg.lapack.dgehrd_lwork	A										<section class="prog__container"><p>Wrapper for dgehrd_lwork.</p><pre><code>scipy.linalg.lapack.dgehrd_lwork(n[, lo, hi]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgehrd_lwork.html
scipy linalg lapack dgehrd_lwork	R	scipy.linalg.lapack.dgehrd_lwork										
scipy linalg.lapack.dgehrd_lwork	R	scipy.linalg.lapack.dgehrd_lwork										
scipy linalg lapack dgehrd	R	scipy.linalg.lapack.dgehrd										
scipy linalg.lapack.dgehrd	R	scipy.linalg.lapack.dgehrd										
scipy.linalg.lapack.dgelsd	A										<section class="prog__container"><p>Wrapper for dgelsd.</p><pre><code>scipy.linalg.lapack.dgelsd(a, b, lwork, size_iwork[, cond, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)\nb : input rank-2 array(‘d’) with bounds (maxmn,nrhs)\nlwork : input int\nsize_iwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘d’) with bounds (maxmn,nrhs) and b storage\ns : rank-1 array(‘d’) with bounds (minmn)\nrank : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgelsd.html
scipy.linalg.lapack.dgelsd_lwork	A										<section class="prog__container"><p>Wrapper for dgelsd_lwork.</p><pre><code>scipy.linalg.lapack.dgelsd_lwork(m, n, nrhs[, cond, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\niwork : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgelsd_lwork.html
scipy linalg lapack dgelsd_lwork	R	scipy.linalg.lapack.dgelsd_lwork										
scipy linalg.lapack.dgelsd_lwork	R	scipy.linalg.lapack.dgelsd_lwork										
scipy linalg lapack dgelsd	R	scipy.linalg.lapack.dgelsd										
scipy linalg.lapack.dgelsd	R	scipy.linalg.lapack.dgelsd										
scipy.linalg.lapack.dgelss	A										<section class="prog__container"><p>Wrapper for dgelss.</p><pre><code>scipy.linalg.lapack.dgelss(a, b[, cond, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)\nb : input rank-2 array(‘d’) with bounds (maxmn,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>v : rank-2 array(‘d’) with bounds (m,n) and a storage\nx : rank-2 array(‘d’) with bounds (maxmn,nrhs) and b storage\ns : rank-1 array(‘d’) with bounds (minmn)\nrank : int\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgelss.html
scipy.linalg.lapack.dgelss_lwork	A										<section class="prog__container"><p>Wrapper for dgelss_lwork.</p><pre><code>scipy.linalg.lapack.dgelss_lwork(m, n, nrhs[, cond, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgelss_lwork.html
scipy linalg lapack dgelss_lwork	R	scipy.linalg.lapack.dgelss_lwork										
scipy linalg.lapack.dgelss_lwork	R	scipy.linalg.lapack.dgelss_lwork										
scipy linalg lapack dgelss	R	scipy.linalg.lapack.dgelss										
scipy linalg.lapack.dgelss	R	scipy.linalg.lapack.dgelss										
scipy.linalg.lapack.dgelsy	A										<section class="prog__container"><p>Wrapper for dgelsy.</p><pre><code>scipy.linalg.lapack.dgelsy(a, b, jptv, cond, lwork[, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)\nb : input rank-2 array(‘d’) with bounds (maxmn,nrhs)\njptv : input rank-1 array(‘i’) with bounds (n)\ncond : input float\nlwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>v : rank-2 array(‘d’) with bounds (m,n) and a storage\nx : rank-2 array(‘d’) with bounds (maxmn,nrhs) and b storage\nj : rank-1 array(‘i’) with bounds (n) and jptv storage\nrank : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgelsy.html
scipy.linalg.lapack.dgelsy_lwork	A										<section class="prog__container"><p>Wrapper for dgelsy_lwork.</p><pre><code>scipy.linalg.lapack.dgelsy_lwork(m, n, nrhs, cond[, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int\ncond : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgelsy_lwork.html
scipy linalg lapack dgelsy_lwork	R	scipy.linalg.lapack.dgelsy_lwork										
scipy linalg.lapack.dgelsy_lwork	R	scipy.linalg.lapack.dgelsy_lwork										
scipy linalg lapack dgelsy	R	scipy.linalg.lapack.dgelsy										
scipy linalg.lapack.dgelsy	R	scipy.linalg.lapack.dgelsy										
scipy.linalg.lapack.dgeqp3	A										<section class="prog__container"><p>Wrapper for dgeqp3.</p><pre><code>scipy.linalg.lapack.dgeqp3(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘d’) with bounds (m,n) and a storage\njpvt : rank-1 array(‘i’) with bounds (n)\ntau : rank-1 array(‘d’) with bounds (MIN(m,n))\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgeqp3.html
scipy linalg lapack dgeqp3	R	scipy.linalg.lapack.dgeqp3										
scipy linalg.lapack.dgeqp3	R	scipy.linalg.lapack.dgeqp3										
scipy.linalg.lapack.dgeqrf	A										<section class="prog__container"><p>Wrapper for dgeqrf.</p><pre><code>scipy.linalg.lapack.dgeqrf(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘d’) with bounds (m,n) and a storage\ntau : rank-1 array(‘d’) with bounds (MIN(m,n))\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgeqrf.html
scipy linalg lapack dgeqrf	R	scipy.linalg.lapack.dgeqrf										
scipy linalg.lapack.dgeqrf	R	scipy.linalg.lapack.dgeqrf										
scipy.linalg.lapack.dgerqf	A										<section class="prog__container"><p>Wrapper for dgerqf.</p><pre><code>scipy.linalg.lapack.dgerqf(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘d’) with bounds (m,n) and a storage\ntau : rank-1 array(‘d’) with bounds (MIN(m,n))\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgerqf.html
scipy linalg lapack dgerqf	R	scipy.linalg.lapack.dgerqf										
scipy linalg.lapack.dgerqf	R	scipy.linalg.lapack.dgerqf										
scipy.linalg.lapack.dgesdd	A										<section class="prog__container"><p>Wrapper for dgesdd.</p><pre><code>scipy.linalg.lapack.dgesdd(a[, compute_uv, full_matrices, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>u : rank-2 array(‘d’) with bounds (u0,u1)\ns : rank-1 array(‘d’) with bounds (minmn)\nvt : rank-2 array(‘d’) with bounds (vt0,vt1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgesdd.html
scipy.linalg.lapack.dgesdd_lwork	A										<section class="prog__container"><p>Wrapper for dgesdd_lwork.</p><pre><code>scipy.linalg.lapack.dgesdd_lwork(m, n[, compute_uv, full_matrices]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgesdd_lwork.html
scipy linalg lapack dgesdd_lwork	R	scipy.linalg.lapack.dgesdd_lwork										
scipy linalg.lapack.dgesdd_lwork	R	scipy.linalg.lapack.dgesdd_lwork										
scipy linalg lapack dgesdd	R	scipy.linalg.lapack.dgesdd										
scipy linalg.lapack.dgesdd	R	scipy.linalg.lapack.dgesdd										
scipy.linalg.lapack.dgesv	A										<section class="prog__container"><p>Wrapper for dgesv.</p><pre><code>scipy.linalg.lapack.dgesv(a, b[, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\nb : input rank-2 array(‘d’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘d’) with bounds (n,n) and a storage\npiv : rank-1 array(‘i’) with bounds (n)\nx : rank-2 array(‘d’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgesv.html
scipy.linalg.lapack.dgesvd	A										<section class="prog__container"><p>Wrapper for dgesvd.</p><pre><code>scipy.linalg.lapack.dgesvd(a[, compute_uv, full_matrices, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>u : rank-2 array(‘d’) with bounds (u0,u1)\ns : rank-1 array(‘d’) with bounds (minmn)\nvt : rank-2 array(‘d’) with bounds (vt0,vt1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgesvd.html
scipy.linalg.lapack.dgesvd_lwork	A										<section class="prog__container"><p>Wrapper for dgesvd_lwork.</p><pre><code>scipy.linalg.lapack.dgesvd_lwork(m, n[, compute_uv, full_matrices]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgesvd_lwork.html
scipy linalg lapack dgesvd_lwork	R	scipy.linalg.lapack.dgesvd_lwork										
scipy linalg.lapack.dgesvd_lwork	R	scipy.linalg.lapack.dgesvd_lwork										
scipy linalg lapack dgesvd	R	scipy.linalg.lapack.dgesvd										
scipy linalg.lapack.dgesvd	R	scipy.linalg.lapack.dgesvd										
scipy linalg lapack dgesv	R	scipy.linalg.lapack.dgesv										
scipy linalg.lapack.dgesv	R	scipy.linalg.lapack.dgesv										
scipy.linalg.lapack.dgetrf	A										<section class="prog__container"><p>Wrapper for dgetrf.</p><pre><code>scipy.linalg.lapack.dgetrf(a[, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘d’) with bounds (m,n) and a storage\npiv : rank-1 array(‘i’) with bounds (MIN(m,n))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgetrf.html
scipy linalg lapack dgetrf	R	scipy.linalg.lapack.dgetrf										
scipy linalg.lapack.dgetrf	R	scipy.linalg.lapack.dgetrf										
scipy.linalg.lapack.dgetri	A										<section class="prog__container"><p>Wrapper for dgetri.</p><pre><code>scipy.linalg.lapack.dgetri(lu, piv[, lwork, overwrite_lu]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>lu : input rank-2 array(‘d’) with bounds (n,n)\npiv : input rank-1 array(‘i’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_a : rank-2 array(‘d’) with bounds (n,n) and lu storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgetri.html
scipy.linalg.lapack.dgetri_lwork	A										<section class="prog__container"><p>Wrapper for dgetri_lwork.</p><pre><code>scipy.linalg.lapack.dgetri_lwork(n) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgetri_lwork.html
scipy linalg lapack dgetri_lwork	R	scipy.linalg.lapack.dgetri_lwork										
scipy linalg.lapack.dgetri_lwork	R	scipy.linalg.lapack.dgetri_lwork										
scipy linalg lapack dgetri	R	scipy.linalg.lapack.dgetri										
scipy linalg.lapack.dgetri	R	scipy.linalg.lapack.dgetri										
scipy.linalg.lapack.dgetrs	A										<section class="prog__container"><p>Wrapper for dgetrs.</p><pre><code>scipy.linalg.lapack.dgetrs(lu, piv, b[, trans, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>lu : input rank-2 array(‘d’) with bounds (n,n)\npiv : input rank-1 array(‘i’) with bounds (n)\nb : input rank-2 array(‘d’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘d’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgetrs.html
scipy linalg lapack dgetrs	R	scipy.linalg.lapack.dgetrs										
scipy linalg.lapack.dgetrs	R	scipy.linalg.lapack.dgetrs										
scipy.linalg.lapack.dgges	A										<section class="prog__container"><p>Wrapper for dgges.</p><pre><code>scipy.linalg.lapack.dgges(dselect, a, b[, jobvsl, jobvsr, sort_t, ldvsl, ldvsr, lwork, dselect_extra_args, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>dselect : call-back function\na : input rank-2 array(‘d’) with bounds (lda,*)\nb : input rank-2 array(‘d’) with bounds (ldb,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘d’) with bounds (lda,*)\nb : rank-2 array(‘d’) with bounds (ldb,*)\nsdim : int\nalphar : rank-1 array(‘d’) with bounds (n)\nalphai : rank-1 array(‘d’) with bounds (n)\nbeta : rank-1 array(‘d’) with bounds (n)\nvsl : rank-2 array(‘d’) with bounds (ldvsl,n)\nvsr : rank-2 array(‘d’) with bounds (ldvsr,n)\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre><span class="prog__sub">Examples:</span><pre><code>def dselect(alphar,alphai,beta): return dselect\nRequired arguments:\n  alphar : input float\n  alphai : input float\n  beta : input float\nReturn objects:\n  dselect : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgges.html
scipy linalg lapack dgges	R	scipy.linalg.lapack.dgges										
scipy linalg.lapack.dgges	R	scipy.linalg.lapack.dgges										
scipy.linalg.lapack.dggev	A										<section class="prog__container"><p>Wrapper for dggev.</p><pre><code>scipy.linalg.lapack.dggev(a, b[, compute_vl, compute_vr, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\nb : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>alphar : rank-1 array(‘d’) with bounds (n)\nalphai : rank-1 array(‘d’) with bounds (n)\nbeta : rank-1 array(‘d’) with bounds (n)\nvl : rank-2 array(‘d’) with bounds (ldvl,n)\nvr : rank-2 array(‘d’) with bounds (ldvr,n)\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dggev.html
scipy linalg lapack dggev	R	scipy.linalg.lapack.dggev										
scipy linalg.lapack.dggev	R	scipy.linalg.lapack.dggev										
scipy.linalg.lapack.dgtsv	A										<section class="prog__container"><p>Wrapper for dgtsv.</p><pre><code>scipy.linalg.lapack.dgtsv(dl, d, du, b[, overwrite_dl, overwrite_d, overwrite_du, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>dl : input rank-1 array(‘d’) with bounds (n - 1)\nd : input rank-1 array(‘d’) with bounds (*)\ndu : input rank-1 array(‘d’) with bounds (n - 1)\nb : input rank-2 array(‘d’) with bounds (,)</code></pre><span class="prog__sub">Returns:</span><pre><code>du2 : rank-1 array(‘d’) with bounds (n - 1) and dl storage\nd : rank-1 array(‘d’) with bounds (*)\ndu : rank-1 array(‘d’) with bounds (n - 1)\nx : rank-2 array(‘d’) with bounds (,) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dgtsv.html
scipy linalg lapack dgtsv	R	scipy.linalg.lapack.dgtsv										
scipy linalg.lapack.dgtsv	R	scipy.linalg.lapack.dgtsv										
scipy.linalg.lapack.dlamch	A										<section class="prog__container"><p>Wrapper for dlamch.</p><pre><code>scipy.linalg.lapack.dlamch(cmach) = <fortran dlamch></code></pre><span class="prog__sub">Parameters:</span><pre><code>cmach</code></pre><span class="prog__sub">Returns:</span><pre><code>dlamch</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dlamch.html
scipy linalg lapack dlamch	R	scipy.linalg.lapack.dlamch										
scipy linalg.lapack.dlamch	R	scipy.linalg.lapack.dlamch										
scipy.linalg.lapack.dlange	A										<section class="prog__container"><p>Wrapper for dlange.</p><pre><code>scipy.linalg.lapack.dlange(norm, a) = <fortran dlange></code></pre><span class="prog__sub">Parameters:</span><pre><code>norm : input string(len=1)\na : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>n2 : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dlange.html
scipy linalg lapack dlange	R	scipy.linalg.lapack.dlange										
scipy linalg.lapack.dlange	R	scipy.linalg.lapack.dlange										
scipy.linalg.lapack.dlarf	A										<section class="prog__container"><p>Wrapper for dlarf.</p><pre><code>scipy.linalg.lapack.dlarf(v, tau, c, work[, side, incv, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : input rank-1 array(‘d’) with bounds (*)\ntau : input float\nc : input rank-2 array(‘d’) with bounds (m,n)\nwork : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dlarf.html
scipy.linalg.lapack.dlarfg	A										<section class="prog__container"><p>Wrapper for dlarfg.</p><pre><code>scipy.linalg.lapack.dlarfg(n, alpha, x[, incx, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int\nalpha : input float\nx : input rank-1 array(‘d’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : float\nx : rank-1 array(‘d’) with bounds (*)\ntau : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dlarfg.html
scipy linalg lapack dlarfg	R	scipy.linalg.lapack.dlarfg										
scipy linalg.lapack.dlarfg	R	scipy.linalg.lapack.dlarfg										
scipy linalg lapack dlarf	R	scipy.linalg.lapack.dlarf										
scipy linalg.lapack.dlarf	R	scipy.linalg.lapack.dlarf										
scipy.linalg.lapack.dlartg	A										<section class="prog__container"><p>Wrapper for dlartg.</p><pre><code>scipy.linalg.lapack.dlartg(f, g) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>f : input float\ng : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>cs : float\nsn : float\nr : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dlartg.html
scipy linalg lapack dlartg	R	scipy.linalg.lapack.dlartg										
scipy linalg.lapack.dlartg	R	scipy.linalg.lapack.dlartg										
scipy.linalg.lapack.dlasd4	A										<section class="prog__container"><p>Wrapper for dlasd4.</p><pre><code>scipy.linalg.lapack.dlasd4(i, d, z[, rho]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>i : input int\nd : input rank-1 array(‘d’) with bounds (n)\nz : input rank-1 array(‘d’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>delta : rank-1 array(‘d’) with bounds (n)\nsigma : float\nwork : rank-1 array(‘d’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dlasd4.html
scipy linalg lapack dlasd4	R	scipy.linalg.lapack.dlasd4										
scipy linalg.lapack.dlasd4	R	scipy.linalg.lapack.dlasd4										
scipy.linalg.lapack.dlaswp	A										<section class="prog__container"><p>Wrapper for dlaswp.</p><pre><code>scipy.linalg.lapack.dlaswp(a, piv[, k1, k2, off, inc, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (nrows,n)\npiv : input rank-1 array(‘i’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘d’) with bounds (nrows,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dlaswp.html
scipy linalg lapack dlaswp	R	scipy.linalg.lapack.dlaswp										
scipy linalg.lapack.dlaswp	R	scipy.linalg.lapack.dlaswp										
scipy.linalg.lapack.dlauum	A										<section class="prog__container"><p>Wrapper for dlauum.</p><pre><code>scipy.linalg.lapack.dlauum(c[, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘d’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dlauum.html
scipy linalg lapack dlauum	R	scipy.linalg.lapack.dlauum										
scipy linalg.lapack.dlauum	R	scipy.linalg.lapack.dlauum										
scipy.linalg.lapack.dorghr	A										<section class="prog__container"><p>Wrapper for dorghr.</p><pre><code>scipy.linalg.lapack.dorghr(a, tau[, lo, hi, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\ntau : input rank-1 array(‘d’) with bounds (n - 1)</code></pre><span class="prog__sub">Returns:</span><pre><code>ht : rank-2 array(‘d’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dorghr.html
scipy linalg lapack dorghr	R	scipy.linalg.lapack.dorghr										
scipy linalg.lapack.dorghr	R	scipy.linalg.lapack.dorghr										
scipy.linalg.lapack.dorgqr	A										<section class="prog__container"><p>Wrapper for dorgqr.</p><pre><code>scipy.linalg.lapack.dorgqr(a, tau[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)\ntau : input rank-1 array(‘d’) with bounds (k)</code></pre><span class="prog__sub">Returns:</span><pre><code>q : rank-2 array(‘d’) with bounds (m,n) and a storage\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dorgqr.html
scipy linalg lapack dorgqr	R	scipy.linalg.lapack.dorgqr										
scipy linalg.lapack.dorgqr	R	scipy.linalg.lapack.dorgqr										
scipy.linalg.lapack.dorgrq	A										<section class="prog__container"><p>Wrapper for dorgrq.</p><pre><code>scipy.linalg.lapack.dorgrq(a, tau[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,n)\ntau : input rank-1 array(‘d’) with bounds (k)</code></pre><span class="prog__sub">Returns:</span><pre><code>q : rank-2 array(‘d’) with bounds (m,n) and a storage\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dorgrq.html
scipy linalg lapack dorgrq	R	scipy.linalg.lapack.dorgrq										
scipy linalg.lapack.dorgrq	R	scipy.linalg.lapack.dorgrq										
scipy.linalg.lapack.dormqr	A										<section class="prog__container"><p>Wrapper for dormqr.</p><pre><code>scipy.linalg.lapack.dormqr(side, trans, a, tau, c, lwork[, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>side : input string(len=1)\ntrans : input string(len=1)\na : input rank-2 array(‘d’) with bounds (lda,k)\ntau : input rank-1 array(‘d’) with bounds (k)\nc : input rank-2 array(‘d’) with bounds (ldc,n)\nlwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>cq : rank-2 array(‘d’) with bounds (ldc,n) and c storage\nwork : rank-1 array(‘d’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dormqr.html
scipy linalg lapack dormqr	R	scipy.linalg.lapack.dormqr										
scipy linalg.lapack.dormqr	R	scipy.linalg.lapack.dormqr										
scipy.linalg.lapack.dpbsv	A										<section class="prog__container"><p>Wrapper for dpbsv.</p><pre><code>scipy.linalg.lapack.dpbsv(ab, b[, lower, ldab, overwrite_ab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘d’) with bounds (ldab,n)\nb : input rank-2 array(‘d’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (ldab,n) and ab storage\nx : rank-2 array(‘d’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dpbsv.html
scipy linalg lapack dpbsv	R	scipy.linalg.lapack.dpbsv										
scipy linalg.lapack.dpbsv	R	scipy.linalg.lapack.dpbsv										
scipy.linalg.lapack.dpbtrf	A										<section class="prog__container"><p>Wrapper for dpbtrf.</p><pre><code>scipy.linalg.lapack.dpbtrf(ab[, lower, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘d’) with bounds (ldab,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (ldab,n) and ab storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dpbtrf.html
scipy linalg lapack dpbtrf	R	scipy.linalg.lapack.dpbtrf										
scipy linalg.lapack.dpbtrf	R	scipy.linalg.lapack.dpbtrf										
scipy.linalg.lapack.dpbtrs	A										<section class="prog__container"><p>Wrapper for dpbtrs.</p><pre><code>scipy.linalg.lapack.dpbtrs(ab, b[, lower, ldab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘d’) with bounds (ldab,n)\nb : input rank-2 array(‘d’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘d’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dpbtrs.html
scipy linalg lapack dpbtrs	R	scipy.linalg.lapack.dpbtrs										
scipy linalg.lapack.dpbtrs	R	scipy.linalg.lapack.dpbtrs										
scipy.linalg.lapack.dposv	A										<section class="prog__container"><p>Wrapper for dposv.</p><pre><code>scipy.linalg.lapack.dposv(a, b[, lower, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\nb : input rank-2 array(‘d’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (n,n) and a storage\nx : rank-2 array(‘d’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dposv.html
scipy linalg lapack dposv	R	scipy.linalg.lapack.dposv										
scipy linalg.lapack.dposv	R	scipy.linalg.lapack.dposv										
scipy.linalg.lapack.dpotrf	A										<section class="prog__container"><p>Wrapper for dpotrf.</p><pre><code>scipy.linalg.lapack.dpotrf(a[, lower, clean, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘d’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dpotrf.html
scipy linalg lapack dpotrf	R	scipy.linalg.lapack.dpotrf										
scipy linalg.lapack.dpotrf	R	scipy.linalg.lapack.dpotrf										
scipy.linalg.lapack.dpotri	A										<section class="prog__container"><p>Wrapper for dpotri.</p><pre><code>scipy.linalg.lapack.dpotri(c[, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_a : rank-2 array(‘d’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dpotri.html
scipy linalg lapack dpotri	R	scipy.linalg.lapack.dpotri										
scipy linalg.lapack.dpotri	R	scipy.linalg.lapack.dpotri										
scipy.linalg.lapack.dpotrs	A										<section class="prog__container"><p>Wrapper for dpotrs.</p><pre><code>scipy.linalg.lapack.dpotrs(c, b[, lower, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘d’) with bounds (n,n)\nb : input rank-2 array(‘d’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘d’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dpotrs.html
scipy linalg lapack dpotrs	R	scipy.linalg.lapack.dpotrs										
scipy linalg.lapack.dpotrs	R	scipy.linalg.lapack.dpotrs										
scipy.linalg.lapack.dptsv	A										<section class="prog__container"><p>Wrapper for dptsv.</p><pre><code>scipy.linalg.lapack.dptsv(d, e, b[, overwrite_d, overwrite_e, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>d : input rank-1 array(‘d’) with bounds (*)\ne : input rank-1 array(‘d’) with bounds (n - 1)\nb : input rank-2 array(‘d’) with bounds (,)</code></pre><span class="prog__sub">Returns:</span><pre><code>d : rank-1 array(‘d’) with bounds (*)\ndu : rank-1 array(‘d’) with bounds (n - 1) and e storage\nx : rank-2 array(‘d’) with bounds (,) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dptsv.html
scipy linalg lapack dptsv	R	scipy.linalg.lapack.dptsv										
scipy linalg.lapack.dptsv	R	scipy.linalg.lapack.dptsv										
scipy.linalg.lapack.dsbev	A										<section class="prog__container"><p>Wrapper for dsbev.</p><pre><code>scipy.linalg.lapack.dsbev(ab[, compute_v, lower, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘d’) with bounds (ldab,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘d’) with bounds (ldz,ldz)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsbev.html
scipy.linalg.lapack.dsbevd	A										<section class="prog__container"><p>Wrapper for dsbevd.</p><pre><code>scipy.linalg.lapack.dsbevd(ab[, compute_v, lower, ldab, liwork, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘d’) with bounds (ldab,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘d’) with bounds (ldz,ldz)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsbevd.html
scipy linalg lapack dsbevd	R	scipy.linalg.lapack.dsbevd										
scipy linalg.lapack.dsbevd	R	scipy.linalg.lapack.dsbevd										
scipy linalg lapack dsbev	R	scipy.linalg.lapack.dsbev										
scipy linalg.lapack.dsbev	R	scipy.linalg.lapack.dsbev										
scipy.linalg.lapack.dsbevx	A										<section class="prog__container"><p>Wrapper for dsbevx.</p><pre><code>scipy.linalg.lapack.dsbevx(ab, vl, vu, il, iu[, ldab, compute_v, range, lower, abstol, mmax, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘d’) with bounds (ldab,*)\nvl : input float\nvu : input float\nil : input int\niu : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘d’) with bounds (ldz,mmax)\nm : int\nifail : rank-1 array(‘i’) with bounds ((compute_v?n:1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsbevx.html
scipy linalg lapack dsbevx	R	scipy.linalg.lapack.dsbevx										
scipy linalg.lapack.dsbevx	R	scipy.linalg.lapack.dsbevx										
scipy.linalg.lapack.dsyev	A										<section class="prog__container"><p>Wrapper for dsyev.</p><pre><code>scipy.linalg.lapack.dsyev(a[, compute_v, lower, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nv : rank-2 array(‘d’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsyev.html
scipy.linalg.lapack.dsyevd	A										<section class="prog__container"><p>Wrapper for dsyevd.</p><pre><code>scipy.linalg.lapack.dsyevd(a[, compute_v, lower, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nv : rank-2 array(‘d’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsyevd.html
scipy linalg lapack dsyevd	R	scipy.linalg.lapack.dsyevd										
scipy linalg.lapack.dsyevd	R	scipy.linalg.lapack.dsyevd										
scipy.linalg.lapack.dsyevr	A										<section class="prog__container"><p>Wrapper for dsyevr.</p><pre><code>scipy.linalg.lapack.dsyevr(a[, jobz, range, uplo, il, iu, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘d’) with bounds (n,m)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsyevr.html
scipy linalg lapack dsyevr	R	scipy.linalg.lapack.dsyevr										
scipy linalg.lapack.dsyevr	R	scipy.linalg.lapack.dsyevr										
scipy linalg lapack dsyev	R	scipy.linalg.lapack.dsyev										
scipy linalg.lapack.dsyev	R	scipy.linalg.lapack.dsyev										
scipy.linalg.lapack.dsygv	A										<section class="prog__container"><p>Wrapper for dsygv.</p><pre><code>scipy.linalg.lapack.dsygv(a, b[, itype, jobz, uplo, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\nb : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘d’) with bounds (n,n)\nw : rank-1 array(‘d’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsygv.html
scipy.linalg.lapack.dsygvd	A										<section class="prog__container"><p>Wrapper for dsygvd.</p><pre><code>scipy.linalg.lapack.dsygvd(a, b[, itype, jobz, uplo, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\nb : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘d’) with bounds (n,n)\nw : rank-1 array(‘d’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsygvd.html
scipy linalg lapack dsygvd	R	scipy.linalg.lapack.dsygvd										
scipy linalg.lapack.dsygvd	R	scipy.linalg.lapack.dsygvd										
scipy linalg lapack dsygv	R	scipy.linalg.lapack.dsygv										
scipy linalg.lapack.dsygv	R	scipy.linalg.lapack.dsygv										
scipy.linalg.lapack.dsygvx	A										<section class="prog__container"><p>Wrapper for dsygvx.</p><pre><code>scipy.linalg.lapack.dsygvx(a, b, iu[, itype, jobz, uplo, il, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (n,n)\nb : input rank-2 array(‘d’) with bounds (n,n)\niu : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘d’) with bounds (n,m)\nifail : rank-1 array(‘i’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dsygvx.html
scipy linalg lapack dsygvx	R	scipy.linalg.lapack.dsygvx										
scipy linalg.lapack.dsygvx	R	scipy.linalg.lapack.dsygvx										
scipy.linalg.lapack.dtrsyl	A										<section class="prog__container"><p>Wrapper for dtrsyl.</p><pre><code>scipy.linalg.lapack.dtrsyl(a, b, c[, trana, tranb, isgn, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (m,m)\nb : input rank-2 array(‘d’) with bounds (n,n)\nc : input rank-2 array(‘d’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘d’) with bounds (m,n) and c storage\nscale : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dtrsyl.html
scipy linalg lapack dtrsyl	R	scipy.linalg.lapack.dtrsyl										
scipy linalg.lapack.dtrsyl	R	scipy.linalg.lapack.dtrsyl										
scipy.linalg.lapack.dtrtri	A										<section class="prog__container"><p>Wrapper for dtrtri.</p><pre><code>scipy.linalg.lapack.dtrtri(c[, lower, unitdiag, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘d’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_c : rank-2 array(‘d’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dtrtri.html
scipy linalg lapack dtrtri	R	scipy.linalg.lapack.dtrtri										
scipy linalg.lapack.dtrtri	R	scipy.linalg.lapack.dtrtri										
scipy.linalg.lapack.dtrtrs	A										<section class="prog__container"><p>Wrapper for dtrtrs.</p><pre><code>scipy.linalg.lapack.dtrtrs(a, b[, lower, trans, unitdiag, lda, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘d’) with bounds (lda,n)\nb : input rank-2 array(‘d’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘d’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.dtrtrs.html
scipy linalg lapack dtrtrs	R	scipy.linalg.lapack.dtrtrs										
scipy linalg.lapack.dtrtrs	R	scipy.linalg.lapack.dtrtrs										
scipy.linalg.lapack.ilaver	A										<section class="prog__container"><p>Wrapper for ilaver.</p><pre><code>scipy.linalg.lapack.ilaver = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>major : int\nminor : int\npatch : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ilaver.html
scipy linalg lapack ilaver	R	scipy.linalg.lapack.ilaver										
scipy linalg.lapack.ilaver	R	scipy.linalg.lapack.ilaver										
scipy.linalg.lapack.sgbsv	A										<section class="prog__container"><p>Wrapper for sgbsv.</p><pre><code>scipy.linalg.lapack.sgbsv(kl, ku, ab, b[, overwrite_ab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>kl : input int\nku : input int\nab : input rank-2 array(‘f’) with bounds (2*kl+ku+1,n)\nb : input rank-2 array(‘f’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>lub : rank-2 array(‘f’) with bounds (2*kl+ku+1,n) and ab storage\npiv : rank-1 array(‘i’) with bounds (n)\nx : rank-2 array(‘f’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgbsv.html
scipy linalg lapack sgbsv	R	scipy.linalg.lapack.sgbsv										
scipy linalg.lapack.sgbsv	R	scipy.linalg.lapack.sgbsv										
scipy.linalg.lapack.sgbtrf	A										<section class="prog__container"><p>Wrapper for sgbtrf.</p><pre><code>scipy.linalg.lapack.sgbtrf(ab, kl, ku[, m, n, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘f’) with bounds (ldab,*)\nkl : input int\nku : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘f’) with bounds (ldab,*) and ab storage\nipiv : rank-1 array(‘i’) with bounds (MIN(m,n))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgbtrf.html
scipy linalg lapack sgbtrf	R	scipy.linalg.lapack.sgbtrf										
scipy linalg.lapack.sgbtrf	R	scipy.linalg.lapack.sgbtrf										
scipy.linalg.lapack.sgbtrs	A										<section class="prog__container"><p>Wrapper for sgbtrs.</p><pre><code>scipy.linalg.lapack.sgbtrs(ab, kl, ku, b, ipiv[, trans, n, ldab, ldb, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘f’) with bounds (ldab,*)\nkl : input int\nku : input int\nb : input rank-2 array(‘f’) with bounds (ldb,*)\nipiv : input rank-1 array(‘i’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘f’) with bounds (ldb,*) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgbtrs.html
scipy linalg lapack sgbtrs	R	scipy.linalg.lapack.sgbtrs										
scipy linalg.lapack.sgbtrs	R	scipy.linalg.lapack.sgbtrs										
scipy.linalg.lapack.sgebal	A										<section class="prog__container"><p>Wrapper for sgebal.</p><pre><code>scipy.linalg.lapack.sgebal(a[, scale, permute, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>ba : rank-2 array(‘f’) with bounds (m,n) and a storage\nlo : int\nhi : int\npivscale : rank-1 array(‘f’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgebal.html
scipy linalg lapack sgebal	R	scipy.linalg.lapack.sgebal										
scipy linalg.lapack.sgebal	R	scipy.linalg.lapack.sgebal										
scipy.linalg.lapack.sgees	A										<section class="prog__container"><p>Wrapper for sgees.</p><pre><code>scipy.linalg.lapack.sgees(sselect, a[, compute_v, sort_t, lwork, sselect_extra_args, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>sselect : call-back function\na : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>t : rank-2 array(‘f’) with bounds (n,n) and a storage\nsdim : int\nwr : rank-1 array(‘f’) with bounds (n)\nwi : rank-1 array(‘f’) with bounds (n)\nvs : rank-2 array(‘f’) with bounds (ldvs,n)\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre><span class="prog__sub">Examples:</span><pre><code>def sselect(arg1,arg2): return sselect\nRequired arguments:\n  arg1 : input float\n  arg2 : input float\nReturn objects:\n  sselect : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgees.html
scipy linalg lapack sgees	R	scipy.linalg.lapack.sgees										
scipy linalg.lapack.sgees	R	scipy.linalg.lapack.sgees										
scipy.linalg.lapack.sgeev	A										<section class="prog__container"><p>Wrapper for sgeev.</p><pre><code>scipy.linalg.lapack.sgeev(a[, compute_vl, compute_vr, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>wr : rank-1 array(‘f’) with bounds (n)\nwi : rank-1 array(‘f’) with bounds (n)\nvl : rank-2 array(‘f’) with bounds (ldvl,n)\nvr : rank-2 array(‘f’) with bounds (ldvr,n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgeev.html
scipy.linalg.lapack.sgeev_lwork	A										<section class="prog__container"><p>Wrapper for sgeev_lwork.</p><pre><code>scipy.linalg.lapack.sgeev_lwork(n[, compute_vl, compute_vr]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgeev_lwork.html
scipy linalg lapack sgeev_lwork	R	scipy.linalg.lapack.sgeev_lwork										
scipy linalg.lapack.sgeev_lwork	R	scipy.linalg.lapack.sgeev_lwork										
scipy linalg lapack sgeev	R	scipy.linalg.lapack.sgeev										
scipy linalg.lapack.sgeev	R	scipy.linalg.lapack.sgeev										
scipy.linalg.lapack.sgegv	A										<section class="prog__container"><p>sgegv is deprecated!\nThe *gegv family of routines has been deprecated in\nLAPACK 3.6.0 in favor of the *ggev family of routines.\nThe corresponding wrappers will be removed from SciPy in\na future release.</p><pre><code>scipy.linalg.lapack.sgegv(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\nb : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>alphar : rank-1 array(‘f’) with bounds (n)\nalphai : rank-1 array(‘f’) with bounds (n)\nbeta : rank-1 array(‘f’) with bounds (n)\nvl : rank-2 array(‘f’) with bounds (ldvl,n)\nvr : rank-2 array(‘f’) with bounds (ldvr,n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgegv.html
scipy linalg lapack sgegv	R	scipy.linalg.lapack.sgegv										
scipy linalg.lapack.sgegv	R	scipy.linalg.lapack.sgegv										
scipy.linalg.lapack.sgehrd	A										<section class="prog__container"><p>Wrapper for sgehrd.</p><pre><code>scipy.linalg.lapack.sgehrd(a[, lo, hi, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>ht : rank-2 array(‘f’) with bounds (n,n) and a storage\ntau : rank-1 array(‘f’) with bounds (n - 1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgehrd.html
scipy.linalg.lapack.sgehrd_lwork	A										<section class="prog__container"><p>Wrapper for sgehrd_lwork.</p><pre><code>scipy.linalg.lapack.sgehrd_lwork(n[, lo, hi]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgehrd_lwork.html
scipy linalg lapack sgehrd_lwork	R	scipy.linalg.lapack.sgehrd_lwork										
scipy linalg.lapack.sgehrd_lwork	R	scipy.linalg.lapack.sgehrd_lwork										
scipy linalg lapack sgehrd	R	scipy.linalg.lapack.sgehrd										
scipy linalg.lapack.sgehrd	R	scipy.linalg.lapack.sgehrd										
scipy.linalg.lapack.sgelsd	A										<section class="prog__container"><p>Wrapper for sgelsd.</p><pre><code>scipy.linalg.lapack.sgelsd(a, b, lwork, size_iwork[, cond, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)\nb : input rank-2 array(‘f’) with bounds (maxmn,nrhs)\nlwork : input int\nsize_iwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘f’) with bounds (maxmn,nrhs) and b storage\ns : rank-1 array(‘f’) with bounds (minmn)\nrank : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgelsd.html
scipy.linalg.lapack.sgelsd_lwork	A										<section class="prog__container"><p>Wrapper for sgelsd_lwork.</p><pre><code>scipy.linalg.lapack.sgelsd_lwork(m, n, nrhs[, cond, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\niwork : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgelsd_lwork.html
scipy linalg lapack sgelsd_lwork	R	scipy.linalg.lapack.sgelsd_lwork										
scipy linalg.lapack.sgelsd_lwork	R	scipy.linalg.lapack.sgelsd_lwork										
scipy linalg lapack sgelsd	R	scipy.linalg.lapack.sgelsd										
scipy linalg.lapack.sgelsd	R	scipy.linalg.lapack.sgelsd										
scipy.linalg.lapack.sgelss	A										<section class="prog__container"><p>Wrapper for sgelss.</p><pre><code>scipy.linalg.lapack.sgelss(a, b[, cond, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)\nb : input rank-2 array(‘f’) with bounds (maxmn,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>v : rank-2 array(‘f’) with bounds (m,n) and a storage\nx : rank-2 array(‘f’) with bounds (maxmn,nrhs) and b storage\ns : rank-1 array(‘f’) with bounds (minmn)\nrank : int\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgelss.html
scipy.linalg.lapack.sgelss_lwork	A										<section class="prog__container"><p>Wrapper for sgelss_lwork.</p><pre><code>scipy.linalg.lapack.sgelss_lwork(m, n, nrhs[, cond, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgelss_lwork.html
scipy linalg lapack sgelss_lwork	R	scipy.linalg.lapack.sgelss_lwork										
scipy linalg.lapack.sgelss_lwork	R	scipy.linalg.lapack.sgelss_lwork										
scipy linalg lapack sgelss	R	scipy.linalg.lapack.sgelss										
scipy linalg.lapack.sgelss	R	scipy.linalg.lapack.sgelss										
scipy.linalg.lapack.sgelsy	A										<section class="prog__container"><p>Wrapper for sgelsy.</p><pre><code>scipy.linalg.lapack.sgelsy(a, b, jptv, cond, lwork[, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)\nb : input rank-2 array(‘f’) with bounds (maxmn,nrhs)\njptv : input rank-1 array(‘i’) with bounds (n)\ncond : input float\nlwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>v : rank-2 array(‘f’) with bounds (m,n) and a storage\nx : rank-2 array(‘f’) with bounds (maxmn,nrhs) and b storage\nj : rank-1 array(‘i’) with bounds (n) and jptv storage\nrank : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgelsy.html
scipy.linalg.lapack.sgelsy_lwork	A										<section class="prog__container"><p>Wrapper for sgelsy_lwork.</p><pre><code>scipy.linalg.lapack.sgelsy_lwork(m, n, nrhs, cond[, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int\ncond : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgelsy_lwork.html
scipy linalg lapack sgelsy_lwork	R	scipy.linalg.lapack.sgelsy_lwork										
scipy linalg.lapack.sgelsy_lwork	R	scipy.linalg.lapack.sgelsy_lwork										
scipy linalg lapack sgelsy	R	scipy.linalg.lapack.sgelsy										
scipy linalg.lapack.sgelsy	R	scipy.linalg.lapack.sgelsy										
scipy.linalg.lapack.sgeqp3	A										<section class="prog__container"><p>Wrapper for sgeqp3.</p><pre><code>scipy.linalg.lapack.sgeqp3(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘f’) with bounds (m,n) and a storage\njpvt : rank-1 array(‘i’) with bounds (n)\ntau : rank-1 array(‘f’) with bounds (MIN(m,n))\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgeqp3.html
scipy linalg lapack sgeqp3	R	scipy.linalg.lapack.sgeqp3										
scipy linalg.lapack.sgeqp3	R	scipy.linalg.lapack.sgeqp3										
scipy.linalg.lapack.sgeqrf	A										<section class="prog__container"><p>Wrapper for sgeqrf.</p><pre><code>scipy.linalg.lapack.sgeqrf(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘f’) with bounds (m,n) and a storage\ntau : rank-1 array(‘f’) with bounds (MIN(m,n))\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgeqrf.html
scipy linalg lapack sgeqrf	R	scipy.linalg.lapack.sgeqrf										
scipy linalg.lapack.sgeqrf	R	scipy.linalg.lapack.sgeqrf										
scipy.linalg.lapack.sgerqf	A										<section class="prog__container"><p>Wrapper for sgerqf.</p><pre><code>scipy.linalg.lapack.sgerqf(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘f’) with bounds (m,n) and a storage\ntau : rank-1 array(‘f’) with bounds (MIN(m,n))\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgerqf.html
scipy linalg lapack sgerqf	R	scipy.linalg.lapack.sgerqf										
scipy linalg.lapack.sgerqf	R	scipy.linalg.lapack.sgerqf										
scipy.linalg.lapack.sgesdd	A										<section class="prog__container"><p>Wrapper for sgesdd.</p><pre><code>scipy.linalg.lapack.sgesdd(a[, compute_uv, full_matrices, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>u : rank-2 array(‘f’) with bounds (u0,u1)\ns : rank-1 array(‘f’) with bounds (minmn)\nvt : rank-2 array(‘f’) with bounds (vt0,vt1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgesdd.html
scipy.linalg.lapack.sgesdd_lwork	A										<section class="prog__container"><p>Wrapper for sgesdd_lwork.</p><pre><code>scipy.linalg.lapack.sgesdd_lwork(m, n[, compute_uv, full_matrices]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgesdd_lwork.html
scipy linalg lapack sgesdd_lwork	R	scipy.linalg.lapack.sgesdd_lwork										
scipy linalg.lapack.sgesdd_lwork	R	scipy.linalg.lapack.sgesdd_lwork										
scipy linalg lapack sgesdd	R	scipy.linalg.lapack.sgesdd										
scipy linalg.lapack.sgesdd	R	scipy.linalg.lapack.sgesdd										
scipy.linalg.lapack.sgesv	A										<section class="prog__container"><p>Wrapper for sgesv.</p><pre><code>scipy.linalg.lapack.sgesv(a, b[, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\nb : input rank-2 array(‘f’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘f’) with bounds (n,n) and a storage\npiv : rank-1 array(‘i’) with bounds (n)\nx : rank-2 array(‘f’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgesv.html
scipy.linalg.lapack.sgesvd	A										<section class="prog__container"><p>Wrapper for sgesvd.</p><pre><code>scipy.linalg.lapack.sgesvd(a[, compute_uv, full_matrices, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>u : rank-2 array(‘f’) with bounds (u0,u1)\ns : rank-1 array(‘f’) with bounds (minmn)\nvt : rank-2 array(‘f’) with bounds (vt0,vt1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgesvd.html
scipy.linalg.lapack.sgesvd_lwork	A										<section class="prog__container"><p>Wrapper for sgesvd_lwork.</p><pre><code>scipy.linalg.lapack.sgesvd_lwork(m, n[, compute_uv, full_matrices]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgesvd_lwork.html
scipy linalg lapack sgesvd_lwork	R	scipy.linalg.lapack.sgesvd_lwork										
scipy linalg.lapack.sgesvd_lwork	R	scipy.linalg.lapack.sgesvd_lwork										
scipy linalg lapack sgesvd	R	scipy.linalg.lapack.sgesvd										
scipy linalg.lapack.sgesvd	R	scipy.linalg.lapack.sgesvd										
scipy linalg lapack sgesv	R	scipy.linalg.lapack.sgesv										
scipy linalg.lapack.sgesv	R	scipy.linalg.lapack.sgesv										
scipy.linalg.lapack.sgetrf	A										<section class="prog__container"><p>Wrapper for sgetrf.</p><pre><code>scipy.linalg.lapack.sgetrf(a[, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘f’) with bounds (m,n) and a storage\npiv : rank-1 array(‘i’) with bounds (MIN(m,n))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgetrf.html
scipy linalg lapack sgetrf	R	scipy.linalg.lapack.sgetrf										
scipy linalg.lapack.sgetrf	R	scipy.linalg.lapack.sgetrf										
scipy.linalg.lapack.sgetri	A										<section class="prog__container"><p>Wrapper for sgetri.</p><pre><code>scipy.linalg.lapack.sgetri(lu, piv[, lwork, overwrite_lu]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>lu : input rank-2 array(‘f’) with bounds (n,n)\npiv : input rank-1 array(‘i’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_a : rank-2 array(‘f’) with bounds (n,n) and lu storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgetri.html
scipy.linalg.lapack.sgetri_lwork	A										<section class="prog__container"><p>Wrapper for sgetri_lwork.</p><pre><code>scipy.linalg.lapack.sgetri_lwork(n) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgetri_lwork.html
scipy linalg lapack sgetri_lwork	R	scipy.linalg.lapack.sgetri_lwork										
scipy linalg.lapack.sgetri_lwork	R	scipy.linalg.lapack.sgetri_lwork										
scipy linalg lapack sgetri	R	scipy.linalg.lapack.sgetri										
scipy linalg.lapack.sgetri	R	scipy.linalg.lapack.sgetri										
scipy.linalg.lapack.sgetrs	A										<section class="prog__container"><p>Wrapper for sgetrs.</p><pre><code>scipy.linalg.lapack.sgetrs(lu, piv, b[, trans, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>lu : input rank-2 array(‘f’) with bounds (n,n)\npiv : input rank-1 array(‘i’) with bounds (n)\nb : input rank-2 array(‘f’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘f’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgetrs.html
scipy linalg lapack sgetrs	R	scipy.linalg.lapack.sgetrs										
scipy linalg.lapack.sgetrs	R	scipy.linalg.lapack.sgetrs										
scipy.linalg.lapack.sgges	A										<section class="prog__container"><p>Wrapper for sgges.</p><pre><code>scipy.linalg.lapack.sgges(sselect, a, b[, jobvsl, jobvsr, sort_t, ldvsl, ldvsr, lwork, sselect_extra_args, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>sselect : call-back function\na : input rank-2 array(‘f’) with bounds (lda,*)\nb : input rank-2 array(‘f’) with bounds (ldb,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘f’) with bounds (lda,*)\nb : rank-2 array(‘f’) with bounds (ldb,*)\nsdim : int\nalphar : rank-1 array(‘f’) with bounds (n)\nalphai : rank-1 array(‘f’) with bounds (n)\nbeta : rank-1 array(‘f’) with bounds (n)\nvsl : rank-2 array(‘f’) with bounds (ldvsl,n)\nvsr : rank-2 array(‘f’) with bounds (ldvsr,n)\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre><span class="prog__sub">Examples:</span><pre><code>def sselect(alphar,alphai,beta): return sselect\nRequired arguments:\n  alphar : input float\n  alphai : input float\n  beta : input float\nReturn objects:\n  sselect : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgges.html
scipy linalg lapack sgges	R	scipy.linalg.lapack.sgges										
scipy linalg.lapack.sgges	R	scipy.linalg.lapack.sgges										
scipy.linalg.lapack.sggev	A										<section class="prog__container"><p>Wrapper for sggev.</p><pre><code>scipy.linalg.lapack.sggev(a, b[, compute_vl, compute_vr, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\nb : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>alphar : rank-1 array(‘f’) with bounds (n)\nalphai : rank-1 array(‘f’) with bounds (n)\nbeta : rank-1 array(‘f’) with bounds (n)\nvl : rank-2 array(‘f’) with bounds (ldvl,n)\nvr : rank-2 array(‘f’) with bounds (ldvr,n)\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sggev.html
scipy linalg lapack sggev	R	scipy.linalg.lapack.sggev										
scipy linalg.lapack.sggev	R	scipy.linalg.lapack.sggev										
scipy.linalg.lapack.sgtsv	A										<section class="prog__container"><p>Wrapper for sgtsv.</p><pre><code>scipy.linalg.lapack.sgtsv(dl, d, du, b[, overwrite_dl, overwrite_d, overwrite_du, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>dl : input rank-1 array(‘f’) with bounds (n - 1)\nd : input rank-1 array(‘f’) with bounds (*)\ndu : input rank-1 array(‘f’) with bounds (n - 1)\nb : input rank-2 array(‘f’) with bounds (,)</code></pre><span class="prog__sub">Returns:</span><pre><code>du2 : rank-1 array(‘f’) with bounds (n - 1) and dl storage\nd : rank-1 array(‘f’) with bounds (*)\ndu : rank-1 array(‘f’) with bounds (n - 1)\nx : rank-2 array(‘f’) with bounds (,) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sgtsv.html
scipy linalg lapack sgtsv	R	scipy.linalg.lapack.sgtsv										
scipy linalg.lapack.sgtsv	R	scipy.linalg.lapack.sgtsv										
scipy.linalg.lapack.slamch	A										<section class="prog__container"><p>Wrapper for slamch.</p><pre><code>scipy.linalg.lapack.slamch(cmach) = <fortran slamch></code></pre><span class="prog__sub">Parameters:</span><pre><code>cmach</code></pre><span class="prog__sub">Returns:</span><pre><code>slamch</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.slamch.html
scipy linalg lapack slamch	R	scipy.linalg.lapack.slamch										
scipy linalg.lapack.slamch	R	scipy.linalg.lapack.slamch										
scipy.linalg.lapack.slange	A										<section class="prog__container"><p>Wrapper for slange.</p><pre><code>scipy.linalg.lapack.slange(norm, a) = <fortran slange></code></pre><span class="prog__sub">Parameters:</span><pre><code>norm : input string(len=1)\na : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>n2 : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.slange.html
scipy linalg lapack slange	R	scipy.linalg.lapack.slange										
scipy linalg.lapack.slange	R	scipy.linalg.lapack.slange										
scipy.linalg.lapack.slarf	A										<section class="prog__container"><p>Wrapper for slarf.</p><pre><code>scipy.linalg.lapack.slarf(v, tau, c, work[, side, incv, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : input rank-1 array(‘f’) with bounds (*)\ntau : input float\nc : input rank-2 array(‘f’) with bounds (m,n)\nwork : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.slarf.html
scipy.linalg.lapack.slarfg	A										<section class="prog__container"><p>Wrapper for slarfg.</p><pre><code>scipy.linalg.lapack.slarfg(n, alpha, x[, incx, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int\nalpha : input float\nx : input rank-1 array(‘f’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : float\nx : rank-1 array(‘f’) with bounds (*)\ntau : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.slarfg.html
scipy linalg lapack slarfg	R	scipy.linalg.lapack.slarfg										
scipy linalg.lapack.slarfg	R	scipy.linalg.lapack.slarfg										
scipy linalg lapack slarf	R	scipy.linalg.lapack.slarf										
scipy linalg.lapack.slarf	R	scipy.linalg.lapack.slarf										
scipy.linalg.lapack.slartg	A										<section class="prog__container"><p>Wrapper for slartg.</p><pre><code>scipy.linalg.lapack.slartg(f, g) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>f : input float\ng : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>cs : float\nsn : float\nr : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.slartg.html
scipy linalg lapack slartg	R	scipy.linalg.lapack.slartg										
scipy linalg.lapack.slartg	R	scipy.linalg.lapack.slartg										
scipy.linalg.lapack.slasd4	A										<section class="prog__container"><p>Wrapper for slasd4.</p><pre><code>scipy.linalg.lapack.slasd4(i, d, z[, rho]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>i : input int\nd : input rank-1 array(‘f’) with bounds (n)\nz : input rank-1 array(‘f’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>delta : rank-1 array(‘f’) with bounds (n)\nsigma : float\nwork : rank-1 array(‘f’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.slasd4.html
scipy linalg lapack slasd4	R	scipy.linalg.lapack.slasd4										
scipy linalg.lapack.slasd4	R	scipy.linalg.lapack.slasd4										
scipy.linalg.lapack.slaswp	A										<section class="prog__container"><p>Wrapper for slaswp.</p><pre><code>scipy.linalg.lapack.slaswp(a, piv[, k1, k2, off, inc, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (nrows,n)\npiv : input rank-1 array(‘i’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘f’) with bounds (nrows,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.slaswp.html
scipy linalg lapack slaswp	R	scipy.linalg.lapack.slaswp										
scipy linalg.lapack.slaswp	R	scipy.linalg.lapack.slaswp										
scipy.linalg.lapack.slauum	A										<section class="prog__container"><p>Wrapper for slauum.</p><pre><code>scipy.linalg.lapack.slauum(c[, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘f’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.slauum.html
scipy linalg lapack slauum	R	scipy.linalg.lapack.slauum										
scipy linalg.lapack.slauum	R	scipy.linalg.lapack.slauum										
scipy.linalg.lapack.sorghr	A										<section class="prog__container"><p>Wrapper for sorghr.</p><pre><code>scipy.linalg.lapack.sorghr(a, tau[, lo, hi, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\ntau : input rank-1 array(‘f’) with bounds (n - 1)</code></pre><span class="prog__sub">Returns:</span><pre><code>ht : rank-2 array(‘f’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sorghr.html
scipy linalg lapack sorghr	R	scipy.linalg.lapack.sorghr										
scipy linalg.lapack.sorghr	R	scipy.linalg.lapack.sorghr										
scipy.linalg.lapack.sorgqr	A										<section class="prog__container"><p>Wrapper for sorgqr.</p><pre><code>scipy.linalg.lapack.sorgqr(a, tau[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)\ntau : input rank-1 array(‘f’) with bounds (k)</code></pre><span class="prog__sub">Returns:</span><pre><code>q : rank-2 array(‘f’) with bounds (m,n) and a storage\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sorgqr.html
scipy linalg lapack sorgqr	R	scipy.linalg.lapack.sorgqr										
scipy linalg.lapack.sorgqr	R	scipy.linalg.lapack.sorgqr										
scipy.linalg.lapack.sorgrq	A										<section class="prog__container"><p>Wrapper for sorgrq.</p><pre><code>scipy.linalg.lapack.sorgrq(a, tau[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,n)\ntau : input rank-1 array(‘f’) with bounds (k)</code></pre><span class="prog__sub">Returns:</span><pre><code>q : rank-2 array(‘f’) with bounds (m,n) and a storage\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sorgrq.html
scipy linalg lapack sorgrq	R	scipy.linalg.lapack.sorgrq										
scipy linalg.lapack.sorgrq	R	scipy.linalg.lapack.sorgrq										
scipy.linalg.lapack.sormqr	A										<section class="prog__container"><p>Wrapper for sormqr.</p><pre><code>scipy.linalg.lapack.sormqr(side, trans, a, tau, c, lwork[, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>side : input string(len=1)\ntrans : input string(len=1)\na : input rank-2 array(‘f’) with bounds (lda,k)\ntau : input rank-1 array(‘f’) with bounds (k)\nc : input rank-2 array(‘f’) with bounds (ldc,n)\nlwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>cq : rank-2 array(‘f’) with bounds (ldc,n) and c storage\nwork : rank-1 array(‘f’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sormqr.html
scipy linalg lapack sormqr	R	scipy.linalg.lapack.sormqr										
scipy linalg.lapack.sormqr	R	scipy.linalg.lapack.sormqr										
scipy.linalg.lapack.spbsv	A										<section class="prog__container"><p>Wrapper for spbsv.</p><pre><code>scipy.linalg.lapack.spbsv(ab, b[, lower, ldab, overwrite_ab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘f’) with bounds (ldab,n)\nb : input rank-2 array(‘f’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (ldab,n) and ab storage\nx : rank-2 array(‘f’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.spbsv.html
scipy linalg lapack spbsv	R	scipy.linalg.lapack.spbsv										
scipy linalg.lapack.spbsv	R	scipy.linalg.lapack.spbsv										
scipy.linalg.lapack.spbtrf	A										<section class="prog__container"><p>Wrapper for spbtrf.</p><pre><code>scipy.linalg.lapack.spbtrf(ab[, lower, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘f’) with bounds (ldab,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (ldab,n) and ab storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.spbtrf.html
scipy linalg lapack spbtrf	R	scipy.linalg.lapack.spbtrf										
scipy linalg.lapack.spbtrf	R	scipy.linalg.lapack.spbtrf										
scipy.linalg.lapack.spbtrs	A										<section class="prog__container"><p>Wrapper for spbtrs.</p><pre><code>scipy.linalg.lapack.spbtrs(ab, b[, lower, ldab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘f’) with bounds (ldab,n)\nb : input rank-2 array(‘f’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘f’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.spbtrs.html
scipy linalg lapack spbtrs	R	scipy.linalg.lapack.spbtrs										
scipy linalg.lapack.spbtrs	R	scipy.linalg.lapack.spbtrs										
scipy.linalg.lapack.sposv	A										<section class="prog__container"><p>Wrapper for sposv.</p><pre><code>scipy.linalg.lapack.sposv(a, b[, lower, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\nb : input rank-2 array(‘f’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (n,n) and a storage\nx : rank-2 array(‘f’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sposv.html
scipy linalg lapack sposv	R	scipy.linalg.lapack.sposv										
scipy linalg.lapack.sposv	R	scipy.linalg.lapack.sposv										
scipy.linalg.lapack.spotrf	A										<section class="prog__container"><p>Wrapper for spotrf.</p><pre><code>scipy.linalg.lapack.spotrf(a[, lower, clean, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘f’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.spotrf.html
scipy linalg lapack spotrf	R	scipy.linalg.lapack.spotrf										
scipy linalg.lapack.spotrf	R	scipy.linalg.lapack.spotrf										
scipy.linalg.lapack.spotri	A										<section class="prog__container"><p>Wrapper for spotri.</p><pre><code>scipy.linalg.lapack.spotri(c[, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_a : rank-2 array(‘f’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.spotri.html
scipy linalg lapack spotri	R	scipy.linalg.lapack.spotri										
scipy linalg.lapack.spotri	R	scipy.linalg.lapack.spotri										
scipy.linalg.lapack.spotrs	A										<section class="prog__container"><p>Wrapper for spotrs.</p><pre><code>scipy.linalg.lapack.spotrs(c, b[, lower, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘f’) with bounds (n,n)\nb : input rank-2 array(‘f’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘f’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.spotrs.html
scipy linalg lapack spotrs	R	scipy.linalg.lapack.spotrs										
scipy linalg.lapack.spotrs	R	scipy.linalg.lapack.spotrs										
scipy.linalg.lapack.sptsv	A										<section class="prog__container"><p>Wrapper for sptsv.</p><pre><code>scipy.linalg.lapack.sptsv(d, e, b[, overwrite_d, overwrite_e, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>d : input rank-1 array(‘f’) with bounds (*)\ne : input rank-1 array(‘f’) with bounds (n - 1)\nb : input rank-2 array(‘f’) with bounds (,)</code></pre><span class="prog__sub">Returns:</span><pre><code>d : rank-1 array(‘f’) with bounds (*)\ndu : rank-1 array(‘f’) with bounds (n - 1) and e storage\nx : rank-2 array(‘f’) with bounds (,) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.sptsv.html
scipy linalg lapack sptsv	R	scipy.linalg.lapack.sptsv										
scipy linalg.lapack.sptsv	R	scipy.linalg.lapack.sptsv										
scipy.linalg.lapack.ssbev	A										<section class="prog__container"><p>Wrapper for ssbev.</p><pre><code>scipy.linalg.lapack.ssbev(ab[, compute_v, lower, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘f’) with bounds (ldab,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘f’) with bounds (ldz,ldz)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssbev.html
scipy.linalg.lapack.ssbevd	A										<section class="prog__container"><p>Wrapper for ssbevd.</p><pre><code>scipy.linalg.lapack.ssbevd(ab[, compute_v, lower, ldab, liwork, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘f’) with bounds (ldab,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘f’) with bounds (ldz,ldz)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssbevd.html
scipy linalg lapack ssbevd	R	scipy.linalg.lapack.ssbevd										
scipy linalg.lapack.ssbevd	R	scipy.linalg.lapack.ssbevd										
scipy linalg lapack ssbev	R	scipy.linalg.lapack.ssbev										
scipy linalg.lapack.ssbev	R	scipy.linalg.lapack.ssbev										
scipy.linalg.lapack.ssbevx	A										<section class="prog__container"><p>Wrapper for ssbevx.</p><pre><code>scipy.linalg.lapack.ssbevx(ab, vl, vu, il, iu[, ldab, compute_v, range, lower, abstol, mmax, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘f’) with bounds (ldab,*)\nvl : input float\nvu : input float\nil : input int\niu : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘f’) with bounds (ldz,mmax)\nm : int\nifail : rank-1 array(‘i’) with bounds ((compute_v?n:1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssbevx.html
scipy linalg lapack ssbevx	R	scipy.linalg.lapack.ssbevx										
scipy linalg.lapack.ssbevx	R	scipy.linalg.lapack.ssbevx										
scipy.linalg.lapack.ssyev	A										<section class="prog__container"><p>Wrapper for ssyev.</p><pre><code>scipy.linalg.lapack.ssyev(a[, compute_v, lower, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nv : rank-2 array(‘f’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssyev.html
scipy.linalg.lapack.ssyevd	A										<section class="prog__container"><p>Wrapper for ssyevd.</p><pre><code>scipy.linalg.lapack.ssyevd(a[, compute_v, lower, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nv : rank-2 array(‘f’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssyevd.html
scipy linalg lapack ssyevd	R	scipy.linalg.lapack.ssyevd										
scipy linalg.lapack.ssyevd	R	scipy.linalg.lapack.ssyevd										
scipy.linalg.lapack.ssyevr	A										<section class="prog__container"><p>Wrapper for ssyevr.</p><pre><code>scipy.linalg.lapack.ssyevr(a[, jobz, range, uplo, il, iu, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘f’) with bounds (n,m)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssyevr.html
scipy linalg lapack ssyevr	R	scipy.linalg.lapack.ssyevr										
scipy linalg.lapack.ssyevr	R	scipy.linalg.lapack.ssyevr										
scipy linalg lapack ssyev	R	scipy.linalg.lapack.ssyev										
scipy linalg.lapack.ssyev	R	scipy.linalg.lapack.ssyev										
scipy.linalg.lapack.ssygv	A										<section class="prog__container"><p>Wrapper for ssygv.</p><pre><code>scipy.linalg.lapack.ssygv(a, b[, itype, jobz, uplo, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\nb : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘f’) with bounds (n,n)\nw : rank-1 array(‘f’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssygv.html
scipy.linalg.lapack.ssygvd	A										<section class="prog__container"><p>Wrapper for ssygvd.</p><pre><code>scipy.linalg.lapack.ssygvd(a, b[, itype, jobz, uplo, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\nb : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘f’) with bounds (n,n)\nw : rank-1 array(‘f’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssygvd.html
scipy linalg lapack ssygvd	R	scipy.linalg.lapack.ssygvd										
scipy linalg.lapack.ssygvd	R	scipy.linalg.lapack.ssygvd										
scipy linalg lapack ssygv	R	scipy.linalg.lapack.ssygv										
scipy linalg.lapack.ssygv	R	scipy.linalg.lapack.ssygv										
scipy.linalg.lapack.ssygvx	A										<section class="prog__container"><p>Wrapper for ssygvx.</p><pre><code>scipy.linalg.lapack.ssygvx(a, b, iu[, itype, jobz, uplo, il, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (n,n)\nb : input rank-2 array(‘f’) with bounds (n,n)\niu : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘f’) with bounds (n)\nz : rank-2 array(‘f’) with bounds (n,m)\nifail : rank-1 array(‘i’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ssygvx.html
scipy linalg lapack ssygvx	R	scipy.linalg.lapack.ssygvx										
scipy linalg.lapack.ssygvx	R	scipy.linalg.lapack.ssygvx										
scipy.linalg.lapack.strsyl	A										<section class="prog__container"><p>Wrapper for strsyl.</p><pre><code>scipy.linalg.lapack.strsyl(a, b, c[, trana, tranb, isgn, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (m,m)\nb : input rank-2 array(‘f’) with bounds (n,n)\nc : input rank-2 array(‘f’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘f’) with bounds (m,n) and c storage\nscale : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.strsyl.html
scipy linalg lapack strsyl	R	scipy.linalg.lapack.strsyl										
scipy linalg.lapack.strsyl	R	scipy.linalg.lapack.strsyl										
scipy.linalg.lapack.strtri	A										<section class="prog__container"><p>Wrapper for strtri.</p><pre><code>scipy.linalg.lapack.strtri(c[, lower, unitdiag, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘f’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_c : rank-2 array(‘f’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.strtri.html
scipy linalg lapack strtri	R	scipy.linalg.lapack.strtri										
scipy linalg.lapack.strtri	R	scipy.linalg.lapack.strtri										
scipy.linalg.lapack.strtrs	A										<section class="prog__container"><p>Wrapper for strtrs.</p><pre><code>scipy.linalg.lapack.strtrs(a, b[, lower, trans, unitdiag, lda, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘f’) with bounds (lda,n)\nb : input rank-2 array(‘f’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘f’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.strtrs.html
scipy linalg lapack strtrs	R	scipy.linalg.lapack.strtrs										
scipy linalg.lapack.strtrs	R	scipy.linalg.lapack.strtrs										
scipy.linalg.lapack.zgbsv	A										<section class="prog__container"><p>Wrapper for zgbsv.</p><pre><code>scipy.linalg.lapack.zgbsv(kl, ku, ab, b[, overwrite_ab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>kl : input int\nku : input int\nab : input rank-2 array(‘D’) with bounds (2*kl+ku+1,n)\nb : input rank-2 array(‘D’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>lub : rank-2 array(‘D’) with bounds (2*kl+ku+1,n) and ab storage\npiv : rank-1 array(‘i’) with bounds (n)\nx : rank-2 array(‘D’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgbsv.html
scipy linalg lapack zgbsv	R	scipy.linalg.lapack.zgbsv										
scipy linalg.lapack.zgbsv	R	scipy.linalg.lapack.zgbsv										
scipy.linalg.lapack.zgbtrf	A										<section class="prog__container"><p>Wrapper for zgbtrf.</p><pre><code>scipy.linalg.lapack.zgbtrf(ab, kl, ku[, m, n, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘D’) with bounds (ldab,*)\nkl : input int\nku : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘D’) with bounds (ldab,*) and ab storage\nipiv : rank-1 array(‘i’) with bounds (MIN(m,n))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgbtrf.html
scipy linalg lapack zgbtrf	R	scipy.linalg.lapack.zgbtrf										
scipy linalg.lapack.zgbtrf	R	scipy.linalg.lapack.zgbtrf										
scipy.linalg.lapack.zgbtrs	A										<section class="prog__container"><p>Wrapper for zgbtrs.</p><pre><code>scipy.linalg.lapack.zgbtrs(ab, kl, ku, b, ipiv[, trans, n, ldab, ldb, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘D’) with bounds (ldab,*)\nkl : input int\nku : input int\nb : input rank-2 array(‘D’) with bounds (ldb,*)\nipiv : input rank-1 array(‘i’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘D’) with bounds (ldb,*) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgbtrs.html
scipy linalg lapack zgbtrs	R	scipy.linalg.lapack.zgbtrs										
scipy linalg.lapack.zgbtrs	R	scipy.linalg.lapack.zgbtrs										
scipy.linalg.lapack.zgebal	A										<section class="prog__container"><p>Wrapper for zgebal.</p><pre><code>scipy.linalg.lapack.zgebal(a[, scale, permute, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>ba : rank-2 array(‘D’) with bounds (m,n) and a storage\nlo : int\nhi : int\npivscale : rank-1 array(‘d’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgebal.html
scipy linalg lapack zgebal	R	scipy.linalg.lapack.zgebal										
scipy linalg.lapack.zgebal	R	scipy.linalg.lapack.zgebal										
scipy.linalg.lapack.zgees	A										<section class="prog__container"><p>Wrapper for zgees.</p><pre><code>scipy.linalg.lapack.zgees(zselect, a[, compute_v, sort_t, lwork, zselect_extra_args, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>zselect : call-back function\na : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>t : rank-2 array(‘D’) with bounds (n,n) and a storage\nsdim : int\nw : rank-1 array(‘D’) with bounds (n)\nvs : rank-2 array(‘D’) with bounds (ldvs,n)\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre><span class="prog__sub">Examples:</span><pre><code>def zselect(arg): return zselect\nRequired arguments:\n  arg : input complex\nReturn objects:\n  zselect : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgees.html
scipy linalg lapack zgees	R	scipy.linalg.lapack.zgees										
scipy linalg.lapack.zgees	R	scipy.linalg.lapack.zgees										
scipy.linalg.lapack.zgeev	A										<section class="prog__container"><p>Wrapper for zgeev.</p><pre><code>scipy.linalg.lapack.zgeev(a[, compute_vl, compute_vr, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘D’) with bounds (n)\nvl : rank-2 array(‘D’) with bounds (ldvl,n)\nvr : rank-2 array(‘D’) with bounds (ldvr,n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgeev.html
scipy.linalg.lapack.zgeev_lwork	A										<section class="prog__container"><p>Wrapper for zgeev_lwork.</p><pre><code>scipy.linalg.lapack.zgeev_lwork(n[, compute_vl, compute_vr]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgeev_lwork.html
scipy linalg lapack zgeev_lwork	R	scipy.linalg.lapack.zgeev_lwork										
scipy linalg.lapack.zgeev_lwork	R	scipy.linalg.lapack.zgeev_lwork										
scipy linalg lapack zgeev	R	scipy.linalg.lapack.zgeev										
scipy linalg.lapack.zgeev	R	scipy.linalg.lapack.zgeev										
scipy.linalg.lapack.zgegv	A										<section class="prog__container"><p>zgegv is deprecated!\nThe *gegv family of routines has been deprecated in\nLAPACK 3.6.0 in favor of the *ggev family of routines.\nThe corresponding wrappers will be removed from SciPy in\na future release.</p><pre><code>scipy.linalg.lapack.zgegv(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\nb : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : rank-1 array(‘D’) with bounds (n)\nbeta : rank-1 array(‘D’) with bounds (n)\nvl : rank-2 array(‘D’) with bounds (ldvl,n)\nvr : rank-2 array(‘D’) with bounds (ldvr,n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgegv.html
scipy linalg lapack zgegv	R	scipy.linalg.lapack.zgegv										
scipy linalg.lapack.zgegv	R	scipy.linalg.lapack.zgegv										
scipy.linalg.lapack.zgehrd	A										<section class="prog__container"><p>Wrapper for zgehrd.</p><pre><code>scipy.linalg.lapack.zgehrd(a[, lo, hi, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>ht : rank-2 array(‘D’) with bounds (n,n) and a storage\ntau : rank-1 array(‘D’) with bounds (n - 1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgehrd.html
scipy.linalg.lapack.zgehrd_lwork	A										<section class="prog__container"><p>Wrapper for zgehrd_lwork.</p><pre><code>scipy.linalg.lapack.zgehrd_lwork(n[, lo, hi]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgehrd_lwork.html
scipy linalg lapack zgehrd_lwork	R	scipy.linalg.lapack.zgehrd_lwork										
scipy linalg.lapack.zgehrd_lwork	R	scipy.linalg.lapack.zgehrd_lwork										
scipy linalg lapack zgehrd	R	scipy.linalg.lapack.zgehrd										
scipy linalg.lapack.zgehrd	R	scipy.linalg.lapack.zgehrd										
scipy.linalg.lapack.zgelsd	A										<section class="prog__container"><p>Wrapper for zgelsd.</p><pre><code>scipy.linalg.lapack.zgelsd(a, b, lwork, size_rwork, size_iwork[, cond, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)\nb : input rank-2 array(‘D’) with bounds (maxmn,nrhs)\nlwork : input int\nsize_rwork : input int\nsize_iwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘D’) with bounds (maxmn,nrhs) and b storage\ns : rank-1 array(‘d’) with bounds (minmn)\nrank : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgelsd.html
scipy.linalg.lapack.zgelsd_lwork	A										<section class="prog__container"><p>Wrapper for zgelsd_lwork.</p><pre><code>scipy.linalg.lapack.zgelsd_lwork(m, n, nrhs[, cond, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\nrwork : float\niwork : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgelsd_lwork.html
scipy linalg lapack zgelsd_lwork	R	scipy.linalg.lapack.zgelsd_lwork										
scipy linalg.lapack.zgelsd_lwork	R	scipy.linalg.lapack.zgelsd_lwork										
scipy linalg lapack zgelsd	R	scipy.linalg.lapack.zgelsd										
scipy linalg.lapack.zgelsd	R	scipy.linalg.lapack.zgelsd										
scipy.linalg.lapack.zgelss	A										<section class="prog__container"><p>Wrapper for zgelss.</p><pre><code>scipy.linalg.lapack.zgelss(a, b[, cond, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)\nb : input rank-2 array(‘D’) with bounds (maxmn,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>v : rank-2 array(‘D’) with bounds (m,n) and a storage\nx : rank-2 array(‘D’) with bounds (maxmn,nrhs) and b storage\ns : rank-1 array(‘d’) with bounds (minmn)\nrank : int\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgelss.html
scipy.linalg.lapack.zgelss_lwork	A										<section class="prog__container"><p>Wrapper for zgelss_lwork.</p><pre><code>scipy.linalg.lapack.zgelss_lwork(m, n, nrhs[, cond, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgelss_lwork.html
scipy linalg lapack zgelss_lwork	R	scipy.linalg.lapack.zgelss_lwork										
scipy linalg.lapack.zgelss_lwork	R	scipy.linalg.lapack.zgelss_lwork										
scipy linalg lapack zgelss	R	scipy.linalg.lapack.zgelss										
scipy linalg.lapack.zgelss	R	scipy.linalg.lapack.zgelss										
scipy.linalg.lapack.zgelsy	A										<section class="prog__container"><p>Wrapper for zgelsy.</p><pre><code>scipy.linalg.lapack.zgelsy(a, b, jptv, cond, lwork[, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)\nb : input rank-2 array(‘D’) with bounds (maxmn,nrhs)\njptv : input rank-1 array(‘i’) with bounds (n)\ncond : input float\nlwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>v : rank-2 array(‘D’) with bounds (m,n) and a storage\nx : rank-2 array(‘D’) with bounds (maxmn,nrhs) and b storage\nj : rank-1 array(‘i’) with bounds (n) and jptv storage\nrank : int\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgelsy.html
scipy.linalg.lapack.zgelsy_lwork	A										<section class="prog__container"><p>Wrapper for zgelsy_lwork.</p><pre><code>scipy.linalg.lapack.zgelsy_lwork(m, n, nrhs, cond[, lwork]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int\nnrhs : input int\ncond : input float</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgelsy_lwork.html
scipy linalg lapack zgelsy_lwork	R	scipy.linalg.lapack.zgelsy_lwork										
scipy linalg.lapack.zgelsy_lwork	R	scipy.linalg.lapack.zgelsy_lwork										
scipy linalg lapack zgelsy	R	scipy.linalg.lapack.zgelsy										
scipy linalg.lapack.zgelsy	R	scipy.linalg.lapack.zgelsy										
scipy.linalg.lapack.zgeqp3	A										<section class="prog__container"><p>Wrapper for zgeqp3.</p><pre><code>scipy.linalg.lapack.zgeqp3(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘D’) with bounds (m,n) and a storage\njpvt : rank-1 array(‘i’) with bounds (n)\ntau : rank-1 array(‘D’) with bounds (MIN(m,n))\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgeqp3.html
scipy linalg lapack zgeqp3	R	scipy.linalg.lapack.zgeqp3										
scipy linalg.lapack.zgeqp3	R	scipy.linalg.lapack.zgeqp3										
scipy.linalg.lapack.zgeqrf	A										<section class="prog__container"><p>Wrapper for zgeqrf.</p><pre><code>scipy.linalg.lapack.zgeqrf(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘D’) with bounds (m,n) and a storage\ntau : rank-1 array(‘D’) with bounds (MIN(m,n))\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgeqrf.html
scipy linalg lapack zgeqrf	R	scipy.linalg.lapack.zgeqrf										
scipy linalg.lapack.zgeqrf	R	scipy.linalg.lapack.zgeqrf										
scipy.linalg.lapack.zgerqf	A										<section class="prog__container"><p>Wrapper for zgerqf.</p><pre><code>scipy.linalg.lapack.zgerqf(a[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>qr : rank-2 array(‘D’) with bounds (m,n) and a storage\ntau : rank-1 array(‘D’) with bounds (MIN(m,n))\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgerqf.html
scipy linalg lapack zgerqf	R	scipy.linalg.lapack.zgerqf										
scipy linalg.lapack.zgerqf	R	scipy.linalg.lapack.zgerqf										
scipy.linalg.lapack.zgesdd	A										<section class="prog__container"><p>Wrapper for zgesdd.</p><pre><code>scipy.linalg.lapack.zgesdd(a[, compute_uv, full_matrices, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>u : rank-2 array(‘D’) with bounds (u0,u1)\ns : rank-1 array(‘d’) with bounds (minmn)\nvt : rank-2 array(‘D’) with bounds (vt0,vt1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgesdd.html
scipy.linalg.lapack.zgesdd_lwork	A										<section class="prog__container"><p>Wrapper for zgesdd_lwork.</p><pre><code>scipy.linalg.lapack.zgesdd_lwork(m, n[, compute_uv, full_matrices]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgesdd_lwork.html
scipy linalg lapack zgesdd_lwork	R	scipy.linalg.lapack.zgesdd_lwork										
scipy linalg.lapack.zgesdd_lwork	R	scipy.linalg.lapack.zgesdd_lwork										
scipy linalg lapack zgesdd	R	scipy.linalg.lapack.zgesdd										
scipy linalg.lapack.zgesdd	R	scipy.linalg.lapack.zgesdd										
scipy.linalg.lapack.zgesv	A										<section class="prog__container"><p>Wrapper for zgesv.</p><pre><code>scipy.linalg.lapack.zgesv(a, b[, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\nb : input rank-2 array(‘D’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘D’) with bounds (n,n) and a storage\npiv : rank-1 array(‘i’) with bounds (n)\nx : rank-2 array(‘D’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgesv.html
scipy.linalg.lapack.zgesvd	A										<section class="prog__container"><p>Wrapper for zgesvd.</p><pre><code>scipy.linalg.lapack.zgesvd(a[, compute_uv, full_matrices, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>u : rank-2 array(‘D’) with bounds (u0,u1)\ns : rank-1 array(‘d’) with bounds (minmn)\nvt : rank-2 array(‘D’) with bounds (vt0,vt1)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgesvd.html
scipy.linalg.lapack.zgesvd_lwork	A										<section class="prog__container"><p>Wrapper for zgesvd_lwork.</p><pre><code>scipy.linalg.lapack.zgesvd_lwork(m, n[, compute_uv, full_matrices]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : input int\nn : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgesvd_lwork.html
scipy linalg lapack zgesvd_lwork	R	scipy.linalg.lapack.zgesvd_lwork										
scipy linalg.lapack.zgesvd_lwork	R	scipy.linalg.lapack.zgesvd_lwork										
scipy linalg lapack zgesvd	R	scipy.linalg.lapack.zgesvd										
scipy linalg.lapack.zgesvd	R	scipy.linalg.lapack.zgesvd										
scipy linalg lapack zgesv	R	scipy.linalg.lapack.zgesv										
scipy linalg.lapack.zgesv	R	scipy.linalg.lapack.zgesv										
scipy.linalg.lapack.zgetrf	A										<section class="prog__container"><p>Wrapper for zgetrf.</p><pre><code>scipy.linalg.lapack.zgetrf(a[, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : rank-2 array(‘D’) with bounds (m,n) and a storage\npiv : rank-1 array(‘i’) with bounds (MIN(m,n))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgetrf.html
scipy linalg lapack zgetrf	R	scipy.linalg.lapack.zgetrf										
scipy linalg.lapack.zgetrf	R	scipy.linalg.lapack.zgetrf										
scipy.linalg.lapack.zgetri	A										<section class="prog__container"><p>Wrapper for zgetri.</p><pre><code>scipy.linalg.lapack.zgetri(lu, piv[, lwork, overwrite_lu]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>lu : input rank-2 array(‘D’) with bounds (n,n)\npiv : input rank-1 array(‘i’) with bounds (n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_a : rank-2 array(‘D’) with bounds (n,n) and lu storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgetri.html
scipy.linalg.lapack.zgetri_lwork	A										<section class="prog__container"><p>Wrapper for zgetri_lwork.</p><pre><code>scipy.linalg.lapack.zgetri_lwork(n) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>work : complex\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgetri_lwork.html
scipy linalg lapack zgetri_lwork	R	scipy.linalg.lapack.zgetri_lwork										
scipy linalg.lapack.zgetri_lwork	R	scipy.linalg.lapack.zgetri_lwork										
scipy linalg lapack zgetri	R	scipy.linalg.lapack.zgetri										
scipy linalg.lapack.zgetri	R	scipy.linalg.lapack.zgetri										
scipy.linalg.lapack.zgetrs	A										<section class="prog__container"><p>Wrapper for zgetrs.</p><pre><code>scipy.linalg.lapack.zgetrs(lu, piv, b[, trans, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>lu : input rank-2 array(‘D’) with bounds (n,n)\npiv : input rank-1 array(‘i’) with bounds (n)\nb : input rank-2 array(‘D’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘D’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgetrs.html
scipy linalg lapack zgetrs	R	scipy.linalg.lapack.zgetrs										
scipy linalg.lapack.zgetrs	R	scipy.linalg.lapack.zgetrs										
scipy.linalg.lapack.zgges	A										<section class="prog__container"><p>Wrapper for zgges.</p><pre><code>scipy.linalg.lapack.zgges(zselect, a, b[, jobvsl, jobvsr, sort_t, ldvsl, ldvsr, lwork, zselect_extra_args, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>zselect : call-back function\na : input rank-2 array(‘D’) with bounds (lda,*)\nb : input rank-2 array(‘D’) with bounds (ldb,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (lda,*)\nb : rank-2 array(‘D’) with bounds (ldb,*)\nsdim : int\nalpha : rank-1 array(‘D’) with bounds (n)\nbeta : rank-1 array(‘D’) with bounds (n)\nvsl : rank-2 array(‘D’) with bounds (ldvsl,n)\nvsr : rank-2 array(‘D’) with bounds (ldvsr,n)\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre><span class="prog__sub">Examples:</span><pre><code>def zselect(alpha,beta): return zselect\nRequired arguments:\n  alpha : input complex\n  beta : input complex\nReturn objects:\n  zselect : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgges.html
scipy linalg lapack zgges	R	scipy.linalg.lapack.zgges										
scipy linalg.lapack.zgges	R	scipy.linalg.lapack.zgges										
scipy.linalg.lapack.zggev	A										<section class="prog__container"><p>Wrapper for zggev.</p><pre><code>scipy.linalg.lapack.zggev(a, b[, compute_vl, compute_vr, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\nb : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : rank-1 array(‘D’) with bounds (n)\nbeta : rank-1 array(‘D’) with bounds (n)\nvl : rank-2 array(‘D’) with bounds (ldvl,n)\nvr : rank-2 array(‘D’) with bounds (ldvr,n)\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zggev.html
scipy linalg lapack zggev	R	scipy.linalg.lapack.zggev										
scipy linalg.lapack.zggev	R	scipy.linalg.lapack.zggev										
scipy.linalg.lapack.zgtsv	A										<section class="prog__container"><p>Wrapper for zgtsv.</p><pre><code>scipy.linalg.lapack.zgtsv(dl, d, du, b[, overwrite_dl, overwrite_d, overwrite_du, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>dl : input rank-1 array(‘D’) with bounds (n - 1)\nd : input rank-1 array(‘D’) with bounds (*)\ndu : input rank-1 array(‘D’) with bounds (n - 1)\nb : input rank-2 array(‘D’) with bounds (,)</code></pre><span class="prog__sub">Returns:</span><pre><code>du2 : rank-1 array(‘D’) with bounds (n - 1) and dl storage\nd : rank-1 array(‘D’) with bounds (*)\ndu : rank-1 array(‘D’) with bounds (n - 1)\nx : rank-2 array(‘D’) with bounds (,) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zgtsv.html
scipy linalg lapack zgtsv	R	scipy.linalg.lapack.zgtsv										
scipy linalg.lapack.zgtsv	R	scipy.linalg.lapack.zgtsv										
scipy.linalg.lapack.zhbevd	A										<section class="prog__container"><p>Wrapper for zhbevd.</p><pre><code>scipy.linalg.lapack.zhbevd(ab[, compute_v, lower, ldab, lrwork, liwork, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘D’) with bounds (ldab,*)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘D’) with bounds (ldz,ldz)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zhbevd.html
scipy linalg lapack zhbevd	R	scipy.linalg.lapack.zhbevd										
scipy linalg.lapack.zhbevd	R	scipy.linalg.lapack.zhbevd										
scipy.linalg.lapack.zhbevx	A										<section class="prog__container"><p>Wrapper for zhbevx.</p><pre><code>scipy.linalg.lapack.zhbevx(ab, vl, vu, il, iu[, ldab, compute_v, range, lower, abstol, mmax, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘D’) with bounds (ldab,*)\nvl : input float\nvu : input float\nil : input int\niu : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘D’) with bounds (ldz,mmax)\nm : int\nifail : rank-1 array(‘i’) with bounds ((compute_v?n:1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zhbevx.html
scipy linalg lapack zhbevx	R	scipy.linalg.lapack.zhbevx										
scipy linalg.lapack.zhbevx	R	scipy.linalg.lapack.zhbevx										
scipy.linalg.lapack.zheev	A										<section class="prog__container"><p>Wrapper for zheev.</p><pre><code>scipy.linalg.lapack.zheev(a[, compute_v, lower, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nv : rank-2 array(‘D’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zheev.html
scipy.linalg.lapack.zheevd	A										<section class="prog__container"><p>Wrapper for zheevd.</p><pre><code>scipy.linalg.lapack.zheevd(a[, compute_v, lower, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nv : rank-2 array(‘D’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zheevd.html
scipy linalg lapack zheevd	R	scipy.linalg.lapack.zheevd										
scipy linalg.lapack.zheevd	R	scipy.linalg.lapack.zheevd										
scipy.linalg.lapack.zheevr	A										<section class="prog__container"><p>Wrapper for zheevr.</p><pre><code>scipy.linalg.lapack.zheevr(a[, jobz, range, uplo, il, iu, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘D’) with bounds (n,m)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zheevr.html
scipy linalg lapack zheevr	R	scipy.linalg.lapack.zheevr										
scipy linalg.lapack.zheevr	R	scipy.linalg.lapack.zheevr										
scipy linalg lapack zheev	R	scipy.linalg.lapack.zheev										
scipy linalg.lapack.zheev	R	scipy.linalg.lapack.zheev										
scipy.linalg.lapack.zhegv	A										<section class="prog__container"><p>Wrapper for zhegv.</p><pre><code>scipy.linalg.lapack.zhegv(a, b[, itype, jobz, uplo, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\nb : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (n,n)\nw : rank-1 array(‘d’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zhegv.html
scipy.linalg.lapack.zhegvd	A										<section class="prog__container"><p>Wrapper for zhegvd.</p><pre><code>scipy.linalg.lapack.zhegvd(a, b[, itype, jobz, uplo, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\nb : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (n,n)\nw : rank-1 array(‘d’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zhegvd.html
scipy linalg lapack zhegvd	R	scipy.linalg.lapack.zhegvd										
scipy linalg.lapack.zhegvd	R	scipy.linalg.lapack.zhegvd										
scipy linalg lapack zhegv	R	scipy.linalg.lapack.zhegv										
scipy linalg.lapack.zhegv	R	scipy.linalg.lapack.zhegv										
scipy.linalg.lapack.zhegvx	A										<section class="prog__container"><p>Wrapper for zhegvx.</p><pre><code>scipy.linalg.lapack.zhegvx(a, b, iu[, itype, jobz, uplo, il, lwork, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\nb : input rank-2 array(‘D’) with bounds (n,n)\niu : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>w : rank-1 array(‘d’) with bounds (n)\nz : rank-2 array(‘D’) with bounds (n,m)\nifail : rank-1 array(‘i’) with bounds (n)\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zhegvx.html
scipy linalg lapack zhegvx	R	scipy.linalg.lapack.zhegvx										
scipy linalg.lapack.zhegvx	R	scipy.linalg.lapack.zhegvx										
scipy.linalg.lapack.zlange	A										<section class="prog__container"><p>Wrapper for zlange.</p><pre><code>scipy.linalg.lapack.zlange(norm, a) = <fortran zlange></code></pre><span class="prog__sub">Parameters:</span><pre><code>norm : input string(len=1)\na : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>n2 : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zlange.html
scipy linalg lapack zlange	R	scipy.linalg.lapack.zlange										
scipy linalg.lapack.zlange	R	scipy.linalg.lapack.zlange										
scipy.linalg.lapack.zlarf	A										<section class="prog__container"><p>Wrapper for zlarf.</p><pre><code>scipy.linalg.lapack.zlarf(v, tau, c, work[, side, incv, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : input rank-1 array(‘D’) with bounds (*)\ntau : input complex\nc : input rank-2 array(‘D’) with bounds (m,n)\nwork : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (m,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zlarf.html
scipy.linalg.lapack.zlarfg	A										<section class="prog__container"><p>Wrapper for zlarfg.</p><pre><code>scipy.linalg.lapack.zlarfg(n, alpha, x[, incx, overwrite_x]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : input int\nalpha : input complex\nx : input rank-1 array(‘D’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : complex\nx : rank-1 array(‘D’) with bounds (*)\ntau : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zlarfg.html
scipy linalg lapack zlarfg	R	scipy.linalg.lapack.zlarfg										
scipy linalg.lapack.zlarfg	R	scipy.linalg.lapack.zlarfg										
scipy linalg lapack zlarf	R	scipy.linalg.lapack.zlarf										
scipy linalg.lapack.zlarf	R	scipy.linalg.lapack.zlarf										
scipy.linalg.lapack.zlartg	A										<section class="prog__container"><p>Wrapper for zlartg.</p><pre><code>scipy.linalg.lapack.zlartg(f, g) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>f : input complex\ng : input complex</code></pre><span class="prog__sub">Returns:</span><pre><code>cs : float\nsn : complex\nr : complex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zlartg.html
scipy linalg lapack zlartg	R	scipy.linalg.lapack.zlartg										
scipy linalg.lapack.zlartg	R	scipy.linalg.lapack.zlartg										
scipy.linalg.lapack.zlaswp	A										<section class="prog__container"><p>Wrapper for zlaswp.</p><pre><code>scipy.linalg.lapack.zlaswp(a, piv[, k1, k2, off, inc, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (nrows,n)\npiv : input rank-1 array(‘i’) with bounds (*)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (nrows,n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zlaswp.html
scipy linalg lapack zlaswp	R	scipy.linalg.lapack.zlaswp										
scipy linalg.lapack.zlaswp	R	scipy.linalg.lapack.zlaswp										
scipy.linalg.lapack.zlauum	A										<section class="prog__container"><p>Wrapper for zlauum.</p><pre><code>scipy.linalg.lapack.zlauum(c[, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>a : rank-2 array(‘D’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zlauum.html
scipy linalg lapack zlauum	R	scipy.linalg.lapack.zlauum										
scipy linalg.lapack.zlauum	R	scipy.linalg.lapack.zlauum										
scipy.linalg.lapack.zpbsv	A										<section class="prog__container"><p>Wrapper for zpbsv.</p><pre><code>scipy.linalg.lapack.zpbsv(ab, b[, lower, ldab, overwrite_ab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘D’) with bounds (ldab,n)\nb : input rank-2 array(‘D’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (ldab,n) and ab storage\nx : rank-2 array(‘D’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zpbsv.html
scipy linalg lapack zpbsv	R	scipy.linalg.lapack.zpbsv										
scipy linalg.lapack.zpbsv	R	scipy.linalg.lapack.zpbsv										
scipy.linalg.lapack.zpbtrf	A										<section class="prog__container"><p>Wrapper for zpbtrf.</p><pre><code>scipy.linalg.lapack.zpbtrf(ab[, lower, ldab, overwrite_ab]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘D’) with bounds (ldab,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (ldab,n) and ab storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zpbtrf.html
scipy linalg lapack zpbtrf	R	scipy.linalg.lapack.zpbtrf										
scipy linalg.lapack.zpbtrf	R	scipy.linalg.lapack.zpbtrf										
scipy.linalg.lapack.zpbtrs	A										<section class="prog__container"><p>Wrapper for zpbtrs.</p><pre><code>scipy.linalg.lapack.zpbtrs(ab, b[, lower, ldab, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : input rank-2 array(‘D’) with bounds (ldab,n)\nb : input rank-2 array(‘D’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘D’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zpbtrs.html
scipy linalg lapack zpbtrs	R	scipy.linalg.lapack.zpbtrs										
scipy linalg.lapack.zpbtrs	R	scipy.linalg.lapack.zpbtrs										
scipy.linalg.lapack.zposv	A										<section class="prog__container"><p>Wrapper for zposv.</p><pre><code>scipy.linalg.lapack.zposv(a, b[, lower, overwrite_a, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\nb : input rank-2 array(‘D’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (n,n) and a storage\nx : rank-2 array(‘D’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zposv.html
scipy linalg lapack zposv	R	scipy.linalg.lapack.zposv										
scipy linalg.lapack.zposv	R	scipy.linalg.lapack.zposv										
scipy.linalg.lapack.zpotrf	A										<section class="prog__container"><p>Wrapper for zpotrf.</p><pre><code>scipy.linalg.lapack.zpotrf(a[, lower, clean, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>c : rank-2 array(‘D’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zpotrf.html
scipy linalg lapack zpotrf	R	scipy.linalg.lapack.zpotrf										
scipy linalg.lapack.zpotrf	R	scipy.linalg.lapack.zpotrf										
scipy.linalg.lapack.zpotri	A										<section class="prog__container"><p>Wrapper for zpotri.</p><pre><code>scipy.linalg.lapack.zpotri(c[, lower, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_a : rank-2 array(‘D’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zpotri.html
scipy linalg lapack zpotri	R	scipy.linalg.lapack.zpotri										
scipy linalg.lapack.zpotri	R	scipy.linalg.lapack.zpotri										
scipy.linalg.lapack.zpotrs	A										<section class="prog__container"><p>Wrapper for zpotrs.</p><pre><code>scipy.linalg.lapack.zpotrs(c, b[, lower, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘D’) with bounds (n,n)\nb : input rank-2 array(‘D’) with bounds (n,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘D’) with bounds (n,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zpotrs.html
scipy linalg lapack zpotrs	R	scipy.linalg.lapack.zpotrs										
scipy linalg.lapack.zpotrs	R	scipy.linalg.lapack.zpotrs										
scipy.linalg.lapack.zptsv	A										<section class="prog__container"><p>Wrapper for zptsv.</p><pre><code>scipy.linalg.lapack.zptsv(d, e, b[, overwrite_d, overwrite_e, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>d : input rank-1 array(‘d’) with bounds (*)\ne : input rank-1 array(‘D’) with bounds (n - 1)\nb : input rank-2 array(‘D’) with bounds (,)</code></pre><span class="prog__sub">Returns:</span><pre><code>d : rank-1 array(‘d’) with bounds (*)\ndu : rank-1 array(‘D’) with bounds (n - 1) and e storage\nx : rank-2 array(‘D’) with bounds (,) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zptsv.html
scipy linalg lapack zptsv	R	scipy.linalg.lapack.zptsv										
scipy linalg.lapack.zptsv	R	scipy.linalg.lapack.zptsv										
scipy.linalg.lapack.zrot	A										<section class="prog__container"><p>Wrapper for zrot.</p><pre><code>scipy.linalg.lapack.zrot(x, y, c, s[, n, offx, incx, offy, incy, overwrite_x, overwrite_y]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : input rank-1 array(‘D’) with bounds (*)\ny : input rank-1 array(‘D’) with bounds (*)\nc : input float\ns : input complex</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-1 array(‘D’) with bounds (*)\ny : rank-1 array(‘D’) with bounds (*)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zrot.html
scipy linalg lapack zrot	R	scipy.linalg.lapack.zrot										
scipy linalg.lapack.zrot	R	scipy.linalg.lapack.zrot										
scipy.linalg.lapack.ztrsyl	A										<section class="prog__container"><p>Wrapper for ztrsyl.</p><pre><code>scipy.linalg.lapack.ztrsyl(a, b, c[, trana, tranb, isgn, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,m)\nb : input rank-2 array(‘D’) with bounds (n,n)\nc : input rank-2 array(‘D’) with bounds (m,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘D’) with bounds (m,n) and c storage\nscale : float\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ztrsyl.html
scipy linalg lapack ztrsyl	R	scipy.linalg.lapack.ztrsyl										
scipy linalg.lapack.ztrsyl	R	scipy.linalg.lapack.ztrsyl										
scipy.linalg.lapack.ztrtri	A										<section class="prog__container"><p>Wrapper for ztrtri.</p><pre><code>scipy.linalg.lapack.ztrtri(c[, lower, unitdiag, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>c : input rank-2 array(‘D’) with bounds (n,n)</code></pre><span class="prog__sub">Returns:</span><pre><code>inv_c : rank-2 array(‘D’) with bounds (n,n) and c storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ztrtri.html
scipy linalg lapack ztrtri	R	scipy.linalg.lapack.ztrtri										
scipy linalg.lapack.ztrtri	R	scipy.linalg.lapack.ztrtri										
scipy.linalg.lapack.ztrtrs	A										<section class="prog__container"><p>Wrapper for ztrtrs.</p><pre><code>scipy.linalg.lapack.ztrtrs(a, b[, lower, trans, unitdiag, lda, overwrite_b]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (lda,n)\nb : input rank-2 array(‘D’) with bounds (ldb,nrhs)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : rank-2 array(‘D’) with bounds (ldb,nrhs) and b storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.ztrtrs.html
scipy linalg lapack ztrtrs	R	scipy.linalg.lapack.ztrtrs										
scipy linalg.lapack.ztrtrs	R	scipy.linalg.lapack.ztrtrs										
scipy.linalg.lapack.zunghr	A										<section class="prog__container"><p>Wrapper for zunghr.</p><pre><code>scipy.linalg.lapack.zunghr(a, tau[, lo, hi, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (n,n)\ntau : input rank-1 array(‘D’) with bounds (n - 1)</code></pre><span class="prog__sub">Returns:</span><pre><code>ht : rank-2 array(‘D’) with bounds (n,n) and a storage\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zunghr.html
scipy linalg lapack zunghr	R	scipy.linalg.lapack.zunghr										
scipy linalg.lapack.zunghr	R	scipy.linalg.lapack.zunghr										
scipy.linalg.lapack.zungqr	A										<section class="prog__container"><p>Wrapper for zungqr.</p><pre><code>scipy.linalg.lapack.zungqr(a, tau[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)\ntau : input rank-1 array(‘D’) with bounds (k)</code></pre><span class="prog__sub">Returns:</span><pre><code>q : rank-2 array(‘D’) with bounds (m,n) and a storage\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zungqr.html
scipy linalg lapack zungqr	R	scipy.linalg.lapack.zungqr										
scipy linalg.lapack.zungqr	R	scipy.linalg.lapack.zungqr										
scipy.linalg.lapack.zungrq	A										<section class="prog__container"><p>Wrapper for zungrq.</p><pre><code>scipy.linalg.lapack.zungrq(a, tau[, lwork, overwrite_a]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : input rank-2 array(‘D’) with bounds (m,n)\ntau : input rank-1 array(‘D’) with bounds (k)</code></pre><span class="prog__sub">Returns:</span><pre><code>q : rank-2 array(‘D’) with bounds (m,n) and a storage\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zungrq.html
scipy linalg lapack zungrq	R	scipy.linalg.lapack.zungrq										
scipy linalg.lapack.zungrq	R	scipy.linalg.lapack.zungrq										
scipy.linalg.lapack.zunmqr	A										<section class="prog__container"><p>Wrapper for zunmqr.</p><pre><code>scipy.linalg.lapack.zunmqr(side, trans, a, tau, c, lwork[, overwrite_c]) = <fortran object></code></pre><span class="prog__sub">Parameters:</span><pre><code>side : input string(len=1)\ntrans : input string(len=1)\na : input rank-2 array(‘D’) with bounds (lda,k)\ntau : input rank-1 array(‘D’) with bounds (k)\nc : input rank-2 array(‘D’) with bounds (ldc,n)\nlwork : input int</code></pre><span class="prog__sub">Returns:</span><pre><code>cq : rank-2 array(‘D’) with bounds (ldc,n) and c storage\nwork : rank-1 array(‘D’) with bounds (MAX(lwork,1))\ninfo : int</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lapack.zunmqr.html
scipy linalg lapack zunmqr	R	scipy.linalg.lapack.zunmqr										
scipy linalg.lapack.zunmqr	R	scipy.linalg.lapack.zunmqr										
scipy.linalg.leslie	A										<section class="prog__container"><p>Create a Leslie matrix.</p><pre><code>scipy.linalg.leslie(f, s)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : (N,) array_like\n    The “fecundity” coefficients. \ns : (N-1,) array_like\n    The “survival” coefficients, has to be 1-D.  The length of s must be one less than the length of f, and it must be at least 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>L : (N, N) ndarray\n    The array is zero except for the first row, which is f, and the first sub-diagonal, which is s. The data-type of the array will be the data-type of f[0]+s[0].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import leslie\n>>> leslie([0.1, 2.0, 1.0, 0.1], [0.2, 0.8, 0.7])\narray([[ 0.1,  2. ,  1. ,  0.1],\n       [ 0.2,  0. ,  0. ,  0. ],\n       [ 0. ,  0.8,  0. ,  0. ],\n       [ 0. ,  0. ,  0.7,  0. ]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.leslie.html
scipy linalg leslie	R	scipy.linalg.leslie										
scipy linalg.leslie	R	scipy.linalg.leslie										
scipy.linalg.LinAlgError	A										<section class="prog__container"><p>Generic Python-exception-derived object raised by linalg functions.</p><pre><code>exception scipy.linalg.LinAlgError</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import linalg as LA\n>>> LA.inv(np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n  File "...linalg.py", line 350,\n    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))\n  File "...linalg.py", line 249,\n    in solve\n    raise LinAlgError('Singular matrix')\nnumpy.linalg.LinAlgError: Singular matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.LinAlgError.html
scipy linalg LinAlgError	R	scipy.linalg.LinAlgError										
scipy linalg.LinAlgError	R	scipy.linalg.LinAlgError										
scipy.linalg.logm	A										<section class="prog__container"><p>Compute matrix logarithm.</p><pre><code>scipy.linalg.logm(A, disp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Matrix whose logarithm to evaluate \ndisp : bool, optional\n    Print warning if error in the result is estimated large instead of returning estimated error. (Default: True)</code></pre><span class="prog__sub">Returns:</span><pre><code>logm : (N, N) ndarray\n    Matrix logarithm of A \nerrest : float\n    (if disp == False) 1-norm of the estimated error, ||err||_1 / ||A||_1</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import logm, expm\n>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])\n>>> b = logm(a)\n>>> b\narray([[-1.02571087,  2.05142174],\n       [ 0.68380725,  1.02571087]])\n>>> expm(b)         # Verify expm(logm(a)) returns a\narray([[ 1.,  3.],\n       [ 1.,  4.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.logm.html
scipy linalg logm	R	scipy.linalg.logm										
scipy linalg.logm	R	scipy.linalg.logm										
scipy.linalg.lstsq	A										<section class="prog__container"><p>Compute least-squares solution to equation Ax = b.</p><pre><code>scipy.linalg.lstsq(a, b, cond=None, overwrite_a=False, overwrite_b=False, check_finite=True, lapack_driver=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Left hand side matrix (2-D array). \nb : (M,) or (M, K) array_like\n    Right hand side matrix or vector (1-D or 2-D array). \ncond : float, optional\n    Cutoff for ‘small’ singular values; used to determine effective rank of a. Singular values smaller than rcond * largest_singular_value are considered zero. \noverwrite_a : bool, optional\n    Discard data in a (may enhance performance). Default is False. \noverwrite_b : bool, optional\n    Discard data in b (may enhance performance). Default is False. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. \nlapack_driver: str, optional\n    Which LAPACK driver is used to solve the least-squares problem. Options are 'gelsd', 'gelsy', 'gelss'. Default ('gelsd') is a good choice.  However, 'gelsy' can be slightly faster on many problems.  'gelss' was used historically.  It is generally slow but uses less memory.  New in version 0.17.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : (N,) or (N, K) ndarray\n    Least-squares solution.  Return shape matches shape of b. \nresidues : () or (1,) or (K,) ndarray\n    Sums of residues, squared 2-norm for each column in b - a x. If rank of matrix a is < N or > M, or 'gelsy' is used, this is an empty array. If b was 1-D, this is an (1,) shape array, otherwise the shape is (K,). \nrank : int\n    Effective rank of matrix a. \ns : (min(M,N),) ndarray or None\n    Singular values of a. The condition number of a is abs(s[0] / s[-1]). None is returned when 'gelsy' is used.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html
scipy linalg lstsq	R	scipy.linalg.lstsq										
scipy linalg.lstsq	R	scipy.linalg.lstsq										
scipy.linalg.lu	A										<section class="prog__container"><p>Compute pivoted LU decomposition of a matrix.</p><pre><code>scipy.linalg.lu(a, permute_l=False, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Array to decompose \npermute_l : bool, optional\n    Perform the multiplication P*L  (Default: do not permute) \noverwrite_a : bool, optional\n    Whether to overwrite data in a (may improve performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>(If permute_l == False)\np : (M, M) ndarray\n    Permutation matrix \nl : (M, K) ndarray\n    Lower triangular or trapezoidal matrix with unit diagonal. K = min(M, N) \nu : (K, N) ndarray\n    Upper triangular or trapezoidal matrix \n(If permute_l == True)\npl : (M, K) ndarray\n    Permuted L matrix. K = min(M, N) \nu : (K, N) ndarray\n    Upper triangular or trapezoidal matrix</code></pre><span class="prog__sub">Examples:</span><pre><code>A = P L U</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lu.html
scipy.linalg.lu_factor	A										<section class="prog__container"><p>Compute pivoted LU decomposition of a matrix.</p><pre><code>scipy.linalg.lu_factor(a, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    Matrix to decompose \noverwrite_a : bool, optional\n    Whether to overwrite data in A (may increase performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>lu : (N, N) ndarray\n    Matrix containing U in its upper triangle, and L in its lower triangle. The unit diagonal elements of L are not stored. \npiv : (N,) ndarray\n    Pivot indices representing the permutation matrix P: row i of matrix was interchanged with row piv[i].</code></pre><span class="prog__sub">Examples:</span><pre><code>A = P L U</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lu_factor.html
scipy linalg lu_factor	R	scipy.linalg.lu_factor										
scipy linalg.lu_factor	R	scipy.linalg.lu_factor										
scipy linalg lu	R	scipy.linalg.lu										
scipy linalg.lu	R	scipy.linalg.lu										
scipy.linalg.lu_solve	A										<section class="prog__container"><p>Solve an equation system, a x = b, given the LU factorization of a</p><pre><code>scipy.linalg.lu_solve(lu_and_piv, b, trans=0, overwrite_b=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>(lu, piv)\n    Factorization of the coefficient matrix a, as given by lu_factor \nb : array\n    Right-hand side \ntrans : {0, 1, 2}, optional\n    Type of system to solve:       trans system    0 a x   = b  1 a^T x = b  2 a^H x = b    \noverwrite_b : bool, optional\n    Whether to overwrite data in b (may increase performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array\n    Solution to the system</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lu_solve.html
scipy linalg lu_solve	R	scipy.linalg.lu_solve										
scipy linalg.lu_solve	R	scipy.linalg.lu_solve										
scipy.linalg.norm	A										<section class="prog__container"><p>Matrix or vector norm.</p><pre><code>scipy.linalg.norm(a, ord=None, axis=None, keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M,) or (M, N) array_like\n    Input array.  If axis is None, a must be 1-D or 2-D. \nord : {non-zero int, inf, -inf, ‘fro’}, optional\n    Order of the norm (see table under Notes). inf means numpy’s inf object \naxis : {int, 2-tuple of ints, None}, optional\n    If axis is an integer, it specifies the axis of a along which to compute the vector norms.  If axis is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed.  If axis is None then either a vector norm (when a is 1-D) or a matrix norm (when a is 2-D) is returned. \nkeepdims : bool, optional\n    If this is set to True, the axes which are normed over are left in the result as dimensions with size one.  With this option the result will broadcast correctly against the original a.</code></pre><span class="prog__sub">Returns:</span><pre><code>n : float or ndarray\n    Norm of the matrix or vector(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import norm\n>>> a = np.arange(9) - 4.0\n>>> a\narray([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])\n>>> b = a.reshape((3, 3))\n>>> b\narray([[-4., -3., -2.],\n       [-1.,  0.,  1.],\n       [ 2.,  3.,  4.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.norm.html
scipy linalg norm	R	scipy.linalg.norm										
scipy linalg.norm	R	scipy.linalg.norm										
scipy.linalg.ordqz	A					[[scipy.linalg.qz]]					<section class="prog__container"><p>QZ decomposition for a pair of matrices with reordering.</p><pre><code>scipy.linalg.ordqz(A, B, sort='lhp', output='real', overwrite_a=False, overwrite_b=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    2d array to decompose \nB : (N, N) array_like\n    2d array to decompose \nsort : {callable, ‘lhp’, ‘rhp’, ‘iuc’, ‘ouc’}, optional\n    Specifies whether the upper eigenvalues should be sorted.  A callable may be passed that, given a eigenvalue, returns a boolean denoting whether the eigenvalue should be sorted to the top-left (True). For real matrix pairs, the sort function takes three real arguments (alphar, alphai, beta). The eigenvalue x = (alphar + alphai*1j)/beta.  For complex matrix pairs or output=’complex’, the sort function takes two complex arguments (alpha, beta). The eigenvalue x = (alpha/beta). Alternatively, string parameters may be used:   ‘lhp’   Left-hand plane (x.real < 0.0) ‘rhp’   Right-hand plane (x.real > 0.0) ‘iuc’   Inside the unit circle (x*x.conjugate() < 1.0) ‘ouc’   Outside the unit circle (x*x.conjugate() > 1.0)   \noutput : str {‘real’,’complex’}, optional\n    Construct the real or complex QZ decomposition for real matrices. Default is ‘real’. \noverwrite_a : bool, optional\n    If True, the contents of A are overwritten. \noverwrite_b : bool, optional\n    If True, the contents of B are overwritten. \ncheck_finite : bool, optional\n    If true checks the elements of A and B are finite numbers. If false does no checking and passes matrix through to underlying algorithm.</code></pre><span class="prog__sub">Returns:</span><pre><code>AA : (N, N) ndarray\n    Generalized Schur form of A. \nBB : (N, N) ndarray\n    Generalized Schur form of B. \nalpha : (N,) ndarray\n    alpha = alphar + alphai * 1j. See notes. \nbeta : (N,) ndarray\n    See notes. \nQ : (N, N) ndarray\n    The left Schur vectors. \nZ : (N, N) ndarray\n    The right Schur vectors.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.ordqz.html
scipy linalg ordqz	R	scipy.linalg.ordqz										
scipy linalg.ordqz	R	scipy.linalg.ordqz										
scipy.linalg.orth	A										<section class="prog__container"><p>Construct an orthonormal basis for the range of A using SVD</p><pre><code>scipy.linalg.orth(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (M, N) array_like\n    Input array</code></pre><span class="prog__sub">Returns:</span><pre><code>Q : (M, K) ndarray\n    Orthonormal basis for the range of A. K = effective rank of A, as determined by automatic cutoff</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.orth.html
scipy.linalg.orthogonal_procrustes	A										<section class="prog__container"><p>Compute the matrix solution of the orthogonal Procrustes problem.</p><pre><code>scipy.linalg.orthogonal_procrustes(A, B, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (M, N) array_like\n    Matrix to be mapped. \nB : (M, N) array_like\n    Target matrix. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>R : (N, N) ndarray\n    The matrix solution of the orthogonal Procrustes problem. Minimizes the Frobenius norm of dot(A, R) - B, subject to dot(R.T, R) == I. \nscale : float\n    Sum of the singular values of dot(A.T, B).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.orthogonal_procrustes.html
scipy linalg orthogonal_procrustes	R	scipy.linalg.orthogonal_procrustes										
scipy linalg.orthogonal_procrustes	R	scipy.linalg.orthogonal_procrustes										
scipy linalg orth	R	scipy.linalg.orth										
scipy linalg.orth	R	scipy.linalg.orth										
scipy.linalg.pascal	A					[[scipy.linalg.invpascal]]					<section class="prog__container"><p>Returns the n x n Pascal matrix.</p><pre><code>scipy.linalg.pascal(n, kind='symmetric', exact=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    The size of the matrix to create; that is, the result is an n x n matrix. \nkind : str, optional\n    Must be one of ‘symmetric’, ‘lower’, or ‘upper’. Default is ‘symmetric’. \nexact : bool, optional\n    If exact is True, the result is either an array of type numpy.uint64 (if n < 35) or an object array of Python long integers. If exact is False, the coefficients in the matrix are computed using scipy.special.comb with exact=False.  The result will be a floating point array, and the values in the array will not be the exact coefficients, but this version is much faster than exact=True.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : (n, n) ndarray\n    The Pascal matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import pascal\n>>> pascal(4)\narray([[ 1,  1,  1,  1],\n       [ 1,  2,  3,  4],\n       [ 1,  3,  6, 10],\n       [ 1,  4, 10, 20]], dtype=uint64)\n>>> pascal(4, kind='lower')\narray([[1, 0, 0, 0],\n       [1, 1, 0, 0],\n       [1, 2, 1, 0],\n       [1, 3, 3, 1]], dtype=uint64)\n>>> pascal(50)[-1, -1]\n25477612258980856902730428600L\n>>> from scipy.special import comb\n>>> comb(98, 49, exact=True)\n25477612258980856902730428600L</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.pascal.html
scipy linalg pascal	R	scipy.linalg.pascal										
scipy linalg.pascal	R	scipy.linalg.pascal										
scipy.linalg.pinv2	A										<section class="prog__container"><p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p><pre><code>scipy.linalg.pinv2(a, cond=None, rcond=None, return_rank=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Matrix to be pseudo-inverted. \ncond, rcond : float or None\n    Cutoff for ‘small’ singular values. Singular values smaller than rcond*largest_singular_value are considered zero. If None or -1, suitable machine precision is used. \nreturn_rank : bool, optional\n    if True, return the effective rank of the matrix \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>B : (N, M) ndarray\n    The pseudo-inverse of matrix a. \nrank : int\n    The effective rank of the matrix.  Returned if return_rank == True</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import linalg\n>>> a = np.random.randn(9, 6)\n>>> B = linalg.pinv2(a)\n>>> np.allclose(a, np.dot(a, np.dot(B, a)))\nTrue\n>>> np.allclose(B, np.dot(B, np.dot(a, B)))\nTrue</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.pinv2.html
scipy linalg pinv2	R	scipy.linalg.pinv2										
scipy linalg.pinv2	R	scipy.linalg.pinv2										
scipy.linalg.pinv	A										<section class="prog__container"><p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p><pre><code>scipy.linalg.pinv(a, cond=None, rcond=None, return_rank=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Matrix to be pseudo-inverted. \ncond, rcond : float, optional\n    Cutoff for ‘small’ singular values in the least-squares solver. Singular values smaller than rcond * largest_singular_value are considered zero. \nreturn_rank : bool, optional\n    if True, return the effective rank of the matrix \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>B : (N, M) ndarray\n    The pseudo-inverse of matrix a. \nrank : int\n    The effective rank of the matrix.  Returned if return_rank == True</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import linalg\n>>> a = np.random.randn(9, 6)\n>>> B = linalg.pinv(a)\n>>> np.allclose(a, np.dot(a, np.dot(B, a)))\nTrue\n>>> np.allclose(B, np.dot(B, np.dot(a, B)))\nTrue</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.pinv.html
scipy.linalg.pinvh	A										<section class="prog__container"><p>Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</p><pre><code>scipy.linalg.pinvh(a, cond=None, rcond=None, lower=True, return_rank=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (N, N) array_like\n    Real symmetric or complex hermetian matrix to be pseudo-inverted \ncond, rcond : float or None\n    Cutoff for ‘small’ eigenvalues. Singular values smaller than rcond * largest_eigenvalue are considered zero. If None or -1, suitable machine precision is used. \nlower : bool, optional\n    Whether the pertinent array data is taken from the lower or upper triangle of a. (Default: lower) \nreturn_rank : bool, optional\n    if True, return the effective rank of the matrix \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>B : (N, N) ndarray\n    The pseudo-inverse of matrix a. \nrank : int\n    The effective rank of the matrix.  Returned if return_rank == True</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import pinvh\n>>> a = np.random.randn(9, 6)\n>>> a = np.dot(a, a.T)\n>>> B = pinvh(a)\n>>> np.allclose(a, np.dot(a, np.dot(B, a)))\nTrue\n>>> np.allclose(B, np.dot(B, np.dot(a, B)))\nTrue</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.pinvh.html
scipy linalg pinvh	R	scipy.linalg.pinvh										
scipy linalg.pinvh	R	scipy.linalg.pinvh										
scipy linalg pinv	R	scipy.linalg.pinv										
scipy linalg.pinv	R	scipy.linalg.pinv										
scipy.linalg.polar	A										<section class="prog__container"><p>Compute the polar decomposition.</p><pre><code>scipy.linalg.polar(a, side='right')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (m, n) array_like\n    The array to be factored. \nside : {‘left’, ‘right’}, optional\n    Determines whether a right or left polar decomposition is computed. If side is “right”, then a = up.  If side is “left”,  then a = pu.  The default is “right”.</code></pre><span class="prog__sub">Returns:</span><pre><code>u : (m, n) ndarray\n    If a is square, then u is unitary.  If m > n, then the columns of a are orthonormal, and if m < n, then the rows of u are orthonormal. \np : ndarray\n    p is Hermitian positive semidefinite.  If a is nonsingular, p is positive definite.  The shape of p is (n, n) or (m, m), depending on whether side is “right” or “left”, respectively.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import polar\n>>> a = np.array([[1, -1], [2, 4]])\n>>> u, p = polar(a)\n>>> u\narray([[ 0.85749293, -0.51449576],\n       [ 0.51449576,  0.85749293]])\n>>> p\narray([[ 1.88648444,  1.2004901 ],\n       [ 1.2004901 ,  3.94446746]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.polar.html
scipy linalg polar	R	scipy.linalg.polar										
scipy linalg.polar	R	scipy.linalg.polar										
scipy.linalg.qr	A										<section class="prog__container"><p>Compute QR decomposition of a matrix.</p><pre><code>scipy.linalg.qr(a, overwrite_a=False, lwork=None, mode='full', pivoting=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Matrix to be decomposed \noverwrite_a : bool, optional\n    Whether data in a is overwritten (may improve performance) \nlwork : int, optional\n    Work array size, lwork >= a.shape[1]. If None or -1, an optimal size is computed. \nmode : {‘full’, ‘r’, ‘economic’, ‘raw’}, optional\n    Determines what information is to be returned: either both Q and R (‘full’, default), only R (‘r’) or both Q and R but computed in economy-size (‘economic’, see Notes). The final option ‘raw’ (added in Scipy 0.11) makes the function return two matrices (Q, TAU) in the internal format used by LAPACK. \npivoting : bool, optional\n    Whether or not factorization should include pivoting for rank-revealing qr decomposition. If pivoting, compute the decomposition A P = Q R as above, but where P is chosen such that the diagonal of R is non-increasing. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>Q : float or complex ndarray\n    Of shape (M, M), or (M, K) for mode='economic'.  Not returned if mode='r'. \nR : float or complex ndarray\n    Of shape (M, N), or (K, N) for mode='economic'.  K = min(M, N). \nP : int ndarray\n    Of shape (N,) for pivoting=True. Not returned if pivoting=False.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import random, linalg, dot, diag, all, allclose\n>>> a = random.randn(9, 6)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.qr.html
scipy.linalg.qr_delete	A					[[scipy.linalg.qr]]\\n[[scipy.linalg.qr_multiply]]\\n[[scipy.linalg.qr_insert]]\\n[[scipy.linalg.qr_update]]					<section class="prog__container"><p>QR downdate on row or column deletions</p><pre><code>scipy.linalg.qr_delete(Q, R, k, int p=1, which='row', overwrite_qr=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Q : (M, M) or (M, N) array_like\n    Unitary/orthogonal matrix from QR decomposition. \nR : (M, N) or (N, N) array_like\n    Upper triangular matrix from QR decomposition. \nk : int\n    Index of the first row or column to delete. \np : int, optional\n    Number of rows or columns to delete, defaults to 1. \nwhich: {‘row’, ‘col’}, optional\n    Determines if rows or columns will be deleted, defaults to ‘row’ \noverwrite_qr : bool, optional\n    If True, consume Q and R, overwriting their contents with their downdated versions, and returning approriately sized views. Defaults to False. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>Q1 : ndarray\n    Updated unitary/orthogonal factor \nR1 : ndarray\n    Updated upper triangular factor</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import linalg\n>>> a = np.array([[  3.,  -2.,  -2.],\n...               [  6.,  -9.,  -3.],\n...               [ -3.,  10.,   1.],\n...               [  6.,  -7.,   4.],\n...               [  7.,   8.,  -6.]])\n>>> q, r = linalg.qr(a)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.qr_delete.html
scipy linalg qr_delete	R	scipy.linalg.qr_delete										
scipy linalg.qr_delete	R	scipy.linalg.qr_delete										
scipy.linalg.qr_insert	A					[[scipy.linalg.qr]]\\n[[scipy.linalg.qr_multiply]]\\n[[scipy.linalg.qr_delete]]\\n[[scipy.linalg.qr_update]]					<section class="prog__container"><p>QR update on row or column insertions</p><pre><code>scipy.linalg.qr_insert(Q, R, u, k, which='row', rcond=None, overwrite_qru=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Q : (M, M) array_like\n    Unitary/orthogonal matrix from the QR decomposition of A. \nR : (M, N) array_like\n    Upper triangular matrix from the QR decomposition of A. \nu : (N,), (p, N), (M,), or (M, p) array_like\n    Rows or columns to insert \nk : int\n    Index before which u is to be inserted. \nwhich: {‘row’, ‘col’}, optional\n    Determines if rows or columns will be inserted, defaults to ‘row’ \nrcond : float\n    Lower bound on the reciprocal condition number of Q augmented with u/||u|| Only used when updating economic mode (thin, (M,N) (N,N)) decompositions.  If None, machine precision is used.  Defaults to None. \noverwrite_qru : bool, optional\n    If True, consume Q, R, and u, if possible, while performing the update, otherwise make copies as necessary. Defaults to False. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>Q1 : ndarray\n    Updated unitary/orthogonal factor \nR1 : ndarray\n    Updated upper triangular factor</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import linalg\n>>> a = np.array([[  3.,  -2.,  -2.],\n...               [  6.,  -7.,   4.],\n...               [  7.,   8.,  -6.]])\n>>> q, r = linalg.qr(a)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.qr_insert.html
scipy linalg qr_insert	R	scipy.linalg.qr_insert										
scipy linalg.qr_insert	R	scipy.linalg.qr_insert										
scipy.linalg.qr_multiply	A										<section class="prog__container"><p>Calculate the QR decomposition and multiply Q with a matrix.</p><pre><code>scipy.linalg.qr_multiply(a, c, mode='right', pivoting=False, conjugate=False, overwrite_a=False, overwrite_c=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like, shape (M, N)\n    Matrix to be decomposed \nc : array_like, one- or two-dimensional\n    calculate the product of c and q, depending on the mode: \nmode : {‘left’, ‘right’}, optional\n    dot(Q, c) is returned if mode is ‘left’, dot(c, Q) is returned if mode is ‘right’. The shape of c must be appropriate for the matrix multiplications, if mode is ‘left’, min(a.shape) == c.shape[0], if mode is ‘right’, a.shape[0] == c.shape[1]. \npivoting : bool, optional\n    Whether or not factorization should include pivoting for rank-revealing qr decomposition, see the documentation of qr. \nconjugate : bool, optional\n    Whether Q should be complex-conjugated. This might be faster than explicit conjugation. \noverwrite_a : bool, optional\n    Whether data in a is overwritten (may improve performance) \noverwrite_c : bool, optional\n    Whether data in c is overwritten (may improve performance). If this is used, c must be big enough to keep the result, i.e. c.shape[0] = a.shape[0] if mode is ‘left’.</code></pre><span class="prog__sub">Returns:</span><pre><code>CQ : float or complex ndarray\n    the product of Q and c, as defined in mode \nR : float or complex ndarray\n    Of shape (K, N), K = min(M, N). \nP : ndarray of ints\n    Of shape (N,) for pivoting=True. Not returned if pivoting=False.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.qr_multiply.html
scipy linalg qr_multiply	R	scipy.linalg.qr_multiply										
scipy linalg.qr_multiply	R	scipy.linalg.qr_multiply										
scipy linalg qr	R	scipy.linalg.qr										
scipy linalg.qr	R	scipy.linalg.qr										
scipy.linalg.qr_update	A					[[scipy.linalg.qr]]\\n[[scipy.linalg.qr_multiply]]\\n[[scipy.linalg.qr_delete]]\\n[[scipy.linalg.qr_insert]]					<section class="prog__container"><p>Rank-k QR update</p><pre><code>scipy.linalg.qr_update(Q, R, u, v, overwrite_qruv=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Q : (M, M) or (M, N) array_like\n    Unitary/orthogonal matrix from the qr decomposition of A. \nR : (M, N) or (N, N) array_like\n    Upper triangular matrix from the qr decomposition of A. \nu : (M,) or (M, k) array_like\n    Left update vector \nv : (N,) or (N, k) array_like\n    Right update vector \noverwrite_qruv : bool, optional\n    If True, consume Q, R, u, and v, if possible, while performing the update, otherwise make copies as necessary. Defaults to False. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>Q1 : ndarray\n    Updated unitary/orthogonal factor \nR1 : ndarray\n    Updated upper triangular factor</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import linalg\n>>> a = np.array([[  3.,  -2.,  -2.],\n...               [  6.,  -9.,  -3.],\n...               [ -3.,  10.,   1.],\n...               [  6.,  -7.,   4.],\n...               [  7.,   8.,  -6.]])\n>>> q, r = linalg.qr(a)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.qr_update.html
scipy linalg qr_update	R	scipy.linalg.qr_update										
scipy linalg.qr_update	R	scipy.linalg.qr_update										
scipy.linalg.qz	A					[[scipy.linalg.ordqz]]					<section class="prog__container"><p>QZ decomposition for generalized eigenvalues of a pair of matrices.</p><pre><code>scipy.linalg.qz(A, B, output='real', lwork=None, sort=None, overwrite_a=False, overwrite_b=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    2d array to decompose \nB : (N, N) array_like\n    2d array to decompose \noutput : {‘real’, ‘complex’}, optional\n    Construct the real or complex QZ decomposition for real matrices. Default is ‘real’. \nlwork : int, optional\n    Work array size.  If None or -1, it is automatically computed. \nsort : {None, callable, ‘lhp’, ‘rhp’, ‘iuc’, ‘ouc’}, optional\n    NOTE: THIS INPUT IS DISABLED FOR NOW. Use ordqz instead. Specifies whether the upper eigenvalues should be sorted.  A callable may be passed that, given a eigenvalue, returns a boolean denoting whether the eigenvalue should be sorted to the top-left (True). For real matrix pairs, the sort function takes three real arguments (alphar, alphai, beta). The eigenvalue x = (alphar + alphai*1j)/beta.  For complex matrix pairs or output=’complex’, the sort function takes two complex arguments (alpha, beta). The eigenvalue x = (alpha/beta).  Alternatively, string parameters may be used:   ‘lhp’   Left-hand plane (x.real < 0.0) ‘rhp’   Right-hand plane (x.real > 0.0) ‘iuc’   Inside the unit circle (x*x.conjugate() < 1.0) ‘ouc’   Outside the unit circle (x*x.conjugate() > 1.0)   Defaults to None (no sorting). \noverwrite_a : bool, optional\n    Whether to overwrite data in a (may improve performance) \noverwrite_b : bool, optional\n    Whether to overwrite data in b (may improve performance) \ncheck_finite : bool, optional\n    If true checks the elements of A and B are finite numbers. If false does no checking and passes matrix through to underlying algorithm.</code></pre><span class="prog__sub">Returns:</span><pre><code>AA : (N, N) ndarray\n    Generalized Schur form of A. \nBB : (N, N) ndarray\n    Generalized Schur form of B. \nQ : (N, N) ndarray\n    The left Schur vectors. \nZ : (N, N) ndarray\n    The right Schur vectors.</code></pre><span class="prog__sub">Examples:</span><pre><code>(A,B) = (Q*AA*Z', Q*BB*Z')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.qz.html
scipy linalg qz	R	scipy.linalg.qz										
scipy linalg.qz	R	scipy.linalg.qz										
scipy.linalg.rq	A										<section class="prog__container"><p>Compute RQ decomposition of a matrix.</p><pre><code>scipy.linalg.rq(a, overwrite_a=False, lwork=None, mode='full', check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Matrix to be decomposed \noverwrite_a : bool, optional\n    Whether data in a is overwritten (may improve performance) \nlwork : int, optional\n    Work array size, lwork >= a.shape[1]. If None or -1, an optimal size is computed. \nmode : {‘full’, ‘r’, ‘economic’}, optional\n    Determines what information is to be returned: either both Q and R (‘full’, default), only R (‘r’) or both Q and R but computed in economy-size (‘economic’, see Notes). \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>R : float or complex ndarray\n    Of shape (M, N) or (M, K) for mode='economic'.  K = min(M, N). \nQ : float or complex ndarray\n    Of shape (N, N) or (K, N) for mode='economic'.  Not returned if mode='r'.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import linalg\n>>> from numpy import random, dot, allclose\n>>> a = random.randn(6, 9)\n>>> r, q = linalg.rq(a)\n>>> allclose(a, dot(r, q))\nTrue\n>>> r.shape, q.shape\n((6, 9), (9, 9))\n>>> r2 = linalg.rq(a, mode='r')\n>>> allclose(r, r2)\nTrue\n>>> r3, q3 = linalg.rq(a, mode='economic')\n>>> r3.shape, q3.shape\n((6, 6), (6, 9))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.rq.html
scipy linalg rq	R	scipy.linalg.rq										
scipy linalg.rq	R	scipy.linalg.rq										
scipy.linalg.rsf2csf	A										<section class="prog__container"><p>Convert real Schur form to complex Schur form.</p><pre><code>scipy.linalg.rsf2csf(T, Z, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>T : (M, M) array_like\n    Real Schur form of the original matrix \nZ : (M, M) array_like\n    Schur transformation matrix \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>T : (M, M) ndarray\n    Complex Schur form of the original matrix \nZ : (M, M) ndarray\n    Schur transformation matrix corresponding to the complex form</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.rsf2csf.html
scipy linalg rsf2csf	R	scipy.linalg.rsf2csf										
scipy linalg.rsf2csf	R	scipy.linalg.rsf2csf										
scipy.linalg.schur	A										<section class="prog__container"><p>Compute Schur decomposition of a matrix.</p><pre><code>scipy.linalg.schur(a, output='real', lwork=None, overwrite_a=False, sort=None, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    Matrix to decompose \noutput : {‘real’, ‘complex’}, optional\n    Construct the real or complex Schur decomposition (for real matrices). \nlwork : int, optional\n    Work array size. If None or -1, it is automatically computed. \noverwrite_a : bool, optional\n    Whether to overwrite data in a (may improve performance). \nsort : {None, callable, ‘lhp’, ‘rhp’, ‘iuc’, ‘ouc’}, optional\n    Specifies whether the upper eigenvalues should be sorted.  A callable may be passed that, given a eigenvalue, returns a boolean denoting whether the eigenvalue should be sorted to the top-left (True). Alternatively, string parameters may be used: 'lhp'   Left-hand plane (x.real < 0.0) 'rhp'   Right-hand plane (x.real > 0.0) 'iuc'   Inside the unit circle (x*x.conjugate() <= 1.0) 'ouc'   Outside the unit circle (x*x.conjugate() > 1.0)   Defaults to None (no sorting). \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>T : (M, M) ndarray\n    Schur form of A. It is real-valued for the real Schur decomposition. \nZ : (M, M) ndarray\n    An unitary Schur transformation matrix for A. It is real-valued for the real Schur decomposition. \nsdim : int\n    If and only if sorting was requested, a third return value will contain the number of eigenvalues satisfying the sort condition.</code></pre><span class="prog__sub">Examples:</span><pre><code>A = Z T Z^H</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.schur.html
scipy linalg schur	R	scipy.linalg.schur										
scipy linalg.schur	R	scipy.linalg.schur										
scipy.linalg.signm	A										<section class="prog__container"><p>Matrix sign function.</p><pre><code>scipy.linalg.signm(A, disp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Matrix at which to evaluate the sign function \ndisp : bool, optional\n    Print warning if error in the result is estimated large instead of returning estimated error. (Default: True)</code></pre><span class="prog__sub">Returns:</span><pre><code>signm : (N, N) ndarray\n    Value of the sign function at A \nerrest : float\n    (if disp == False) 1-norm of the estimated error, ||err||_1 / ||A||_1</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import signm, eigvals\n>>> a = [[1,2,3], [1,2,1], [1,1,1]]\n>>> eigvals(a)\narray([ 4.12488542+0.j, -0.76155718+0.j,  0.63667176+0.j])\n>>> eigvals(signm(a))\narray([-1.+0.j,  1.+0.j,  1.+0.j])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.signm.html
scipy linalg signm	R	scipy.linalg.signm										
scipy linalg.signm	R	scipy.linalg.signm										
scipy.linalg.sinhm	A										<section class="prog__container"><p>Compute the hyperbolic matrix sine.</p><pre><code>scipy.linalg.sinhm(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>sinhm : (N, N) ndarray\n    Hyperbolic matrix sine of A</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import tanhm, sinhm, coshm\n>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])\n>>> s = sinhm(a)\n>>> s\narray([[ 10.57300653,  39.28826594],\n       [ 13.09608865,  49.86127247]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.sinhm.html
scipy linalg sinhm	R	scipy.linalg.sinhm										
scipy linalg.sinhm	R	scipy.linalg.sinhm										
scipy.linalg.sinm	A										<section class="prog__container"><p>Compute the matrix sine.</p><pre><code>scipy.linalg.sinm(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>sinm : (N, N) ndarray\n    Matrix cosine of A</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import expm, sinm, cosm</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.sinm.html
scipy linalg sinm	R	scipy.linalg.sinm										
scipy linalg.sinm	R	scipy.linalg.sinm										
scipy.linalg.solve	A										<section class="prog__container"><p>Solve the equation a x = b for x.</p><pre><code>scipy.linalg.solve(a, b, sym_pos=False, lower=False, overwrite_a=False, overwrite_b=False, debug=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    A square matrix. \nb : (M,) or (M, N) array_like\n    Right-hand side matrix in a x = b. \nsym_pos : bool, optional\n    Assume a is symmetric and positive definite. \nlower : bool, optional\n    Use only data contained in the lower triangle of a, if sym_pos is true.  Default is to use upper triangle. \noverwrite_a : bool, optional\n    Allow overwriting data in a (may enhance performance). Default is False. \noverwrite_b : bool, optional\n    Allow overwriting data in b (may enhance performance). Default is False. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : (M,) or (M, N) ndarray\n    Solution to the system a x = b.  Shape of the return matches the shape of b.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])\n>>> b = np.array([2, 4, -1])\n>>> from scipy import linalg\n>>> x = linalg.solve(a, b)\n>>> x\narray([ 2., -2.,  9.])\n>>> np.dot(a, x) == b\narray([ True,  True,  True], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html
scipy.linalg.solve_banded	A										<section class="prog__container"><p>Solve the equation a x = b for x, assuming a is banded matrix.</p><pre><code>scipy.linalg.solve_banded(l_and_u, ab, b, overwrite_ab=False, overwrite_b=False, debug=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>(l, u) : (integer, integer)\n    Number of non-zero lower and upper diagonals \nab : (l + u + 1, M) array_like\n    Banded matrix \nb : (M,) or (M, K) array_like\n    Right-hand side \noverwrite_ab : bool, optional\n    Discard data in ab (may enhance performance) \noverwrite_b : bool, optional\n    Discard data in b (may enhance performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : (M,) or (M, K) ndarray\n    The solution to the system a x = b.  Returned shape depends on the shape of b.</code></pre><span class="prog__sub">Examples:</span><pre><code>ab[u + i - j, j] == a[i,j]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_banded.html
scipy linalg solve_banded	R	scipy.linalg.solve_banded										
scipy linalg.solve_banded	R	scipy.linalg.solve_banded										
scipy.linalg.solve_circulant	A					[[scipy.linalg.circulant]]					<section class="prog__container"><p>Solve C x = b for x, where C is a circulant matrix.</p><pre><code>scipy.linalg.solve_circulant(c, b, singular='raise', tol=None, caxis=-1, baxis=0, outaxis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    The coefficients of the circulant matrix. \nb : array_like\n    Right-hand side matrix in a x = b. \nsingular : str, optional\n    This argument controls how a near singular circulant matrix is handled.  If singular is “raise” and the circulant matrix is near singular, a LinAlgError is raised.  If singular is “lstsq”, the least squares solution is returned.  Default is “raise”. \ntol : float, optional\n    If any eigenvalue of the circulant matrix has an absolute value that is less than or equal to tol, the matrix is considered to be near singular.  If not given, tol is set to: tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps   where abs_eigs is the array of absolute values of the eigenvalues of the circulant matrix. \ncaxis : int\n    When c has dimension greater than 1, it is viewed as a collection of circulant vectors.  In this case, caxis is the axis of c that holds the vectors of circulant coefficients. \nbaxis : int\n    When b has dimension greater than 1, it is viewed as a collection of vectors.  In this case, baxis is the axis of b that holds the right-hand side vectors. \noutaxis : int\n    When c or b are multidimensional, the value returned by solve_circulant is multidimensional.  In this case, outaxis is the axis of the result that holds the solution vectors.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Solution to the system C x = b.</code></pre><span class="prog__sub">Examples:</span><pre><code>x = ifft(fft(b) / fft(c))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_circulant.html
scipy linalg solve_circulant	R	scipy.linalg.solve_circulant										
scipy linalg.solve_circulant	R	scipy.linalg.solve_circulant										
scipy.linalg.solve_continuous_are	A										<section class="prog__container"><p>Solves the continuous algebraic Riccati equation (CARE).</p><pre><code>scipy.linalg.solve_continuous_are(a, b, q, r)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    Input \nb : (M, N) array_like\n    Input \nq : (M, M) array_like\n    Input \nr : (N, N) array_like\n    Non-singular, square matrix</code></pre><span class="prog__sub">Returns:</span><pre><code>x : (M, M) ndarray\n    Solution to the continuous algebraic Riccati equation</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_continuous_are.html
scipy linalg solve_continuous_are	R	scipy.linalg.solve_continuous_are										
scipy linalg.solve_continuous_are	R	scipy.linalg.solve_continuous_are										
scipy.linalg.solve_discrete_are	A										<section class="prog__container"><p>Solves the discrete algebraic Riccati equation (DARE).</p><pre><code>scipy.linalg.solve_discrete_are(a, b, q, r)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    Non-singular, square matrix \nb : (M, N) array_like\n    Input \nq : (M, M) array_like\n    Input \nr : (N, N) array_like\n    Non-singular, square matrix</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Solution to the continuous Lyapunov equation</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_discrete_are.html
scipy linalg solve_discrete_are	R	scipy.linalg.solve_discrete_are										
scipy linalg.solve_discrete_are	R	scipy.linalg.solve_discrete_are										
scipy.linalg.solve_discrete_lyapunov	A										<section class="prog__container"><p>Solves the discrete Lyapunov equation \(AXA^H - X + Q = 0\).</p><pre><code>scipy.linalg.solve_discrete_lyapunov(a, q, method=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, q : (M, M) array_like\n    Square matrices corresponding to A and Q in the equation above respectively. Must have the same shape. \nmethod : {‘direct’, ‘bilinear’}, optional\n    Type of solver. If not given, chosen to be direct if M is less than 10 and bilinear otherwise.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Solution to the discrete Lyapunov equation</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_discrete_lyapunov.html
scipy linalg solve_discrete_lyapunov	R	scipy.linalg.solve_discrete_lyapunov										
scipy linalg.solve_discrete_lyapunov	R	scipy.linalg.solve_discrete_lyapunov										
scipy.linalg.solveh_banded	A										<section class="prog__container"><p>Solve equation a x = b. a is Hermitian positive-definite banded matrix.</p><pre><code>scipy.linalg.solveh_banded(ab, b, overwrite_ab=False, overwrite_b=False, lower=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ab : (u + 1, M) array_like\n    Banded matrix \nb : (M,) or (M, K) array_like\n    Right-hand side \noverwrite_ab : bool, optional\n    Discard data in ab (may enhance performance) \noverwrite_b : bool, optional\n    Discard data in b (may enhance performance) \nlower : bool, optional\n    Is the matrix in the lower form. (Default is upper form) \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : (M,) or (M, K) ndarray\n    The solution to the system a x = b.  Shape of return matches shape of b.</code></pre><span class="prog__sub">Examples:</span><pre><code>upper form:\n*   *   a02 a13 a24 a35\n*   a01 a12 a23 a34 a45\na00 a11 a22 a33 a44 a55\n\nlower form:\na00 a11 a22 a33 a44 a55\na10 a21 a32 a43 a54 *\na20 a31 a42 a53 *   *</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solveh_banded.html
scipy linalg solveh_banded	R	scipy.linalg.solveh_banded										
scipy linalg.solveh_banded	R	scipy.linalg.solveh_banded										
scipy.linalg.solve_lyapunov	A										<section class="prog__container"><p>Solves the continuous Lyapunov equation \(AX + XA^H = Q\).</p><pre><code>scipy.linalg.solve_lyapunov(a, q)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    A square matrix \nq : array_like\n    Right-hand side square matrix</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array_like\n    Solution to the continuous Lyapunov equation</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_lyapunov.html
scipy linalg solve_lyapunov	R	scipy.linalg.solve_lyapunov										
scipy linalg.solve_lyapunov	R	scipy.linalg.solve_lyapunov										
scipy linalg solve	R	scipy.linalg.solve										
scipy linalg.solve	R	scipy.linalg.solve										
scipy.linalg.solve_sylvester	A										<section class="prog__container"><p>Computes a solution (X) to the Sylvester equation \(AX + XB = Q\).</p><pre><code>scipy.linalg.solve_sylvester(a, b, q)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    Leading matrix of the Sylvester equation \nb : (N, N) array_like\n    Trailing matrix of the Sylvester equation \nq : (M, N) array_like\n    Right-hand side</code></pre><span class="prog__sub">Returns:</span><pre><code>x : (M, N) ndarray\n    The solution to the Sylvester equation.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_sylvester.html
scipy linalg solve_sylvester	R	scipy.linalg.solve_sylvester										
scipy linalg.solve_sylvester	R	scipy.linalg.solve_sylvester										
scipy.linalg.solve_toeplitz	A										<section class="prog__container"><p>Solve a Toeplitz system using Levinson Recursion</p><pre><code>scipy.linalg.solve_toeplitz(c_or_cr, b, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c_or_cr : array_like or tuple of (array_like, array_like)\n    The vector c, or a tuple of arrays (c, r). Whatever the actual shape of c, it will be converted to a 1-D array. If not supplied, r = conjugate(c) is assumed; in this case, if c[0] is real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row of the Toeplitz matrix is [c[0], r[1:]].  Whatever the actual shape of r, it will be converted to a 1-D array. \nb : (M,) or (M, K) array_like\n    Right-hand side in T x = b. \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (result entirely NaNs) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : (M,) or (M, K) ndarray\n    The solution to the system T x = b.  Shape of return matches shape of b.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_toeplitz.html
scipy linalg solve_toeplitz	R	scipy.linalg.solve_toeplitz										
scipy linalg.solve_toeplitz	R	scipy.linalg.solve_toeplitz										
scipy.linalg.solve_triangular	A										<section class="prog__container"><p>Solve the equation a x = b for x, assuming a is a triangular matrix.</p><pre><code>scipy.linalg.solve_triangular(a, b, trans=0, lower=False, unit_diagonal=False, overwrite_b=False, debug=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, M) array_like\n    A triangular matrix \nb : (M,) or (M, N) array_like\n    Right-hand side matrix in a x = b \nlower : bool, optional\n    Use only data contained in the lower triangle of a. Default is to use upper triangle. \ntrans : {0, 1, 2, ‘N’, ‘T’, ‘C’}, optional\n    Type of system to solve:       trans system    0 or ‘N’ a x  = b  1 or ‘T’ a^T x = b  2 or ‘C’ a^H x = b    \nunit_diagonal : bool, optional\n    If True, diagonal elements of a are assumed to be 1 and will not be referenced. \noverwrite_b : bool, optional\n    Allow overwriting data in b (may enhance performance) \ncheck_finite : bool, optional\n    Whether to check that the input matrices contain only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : (M,) or (M, N) ndarray\n    Solution to the system a x = b.  Shape of return matches b.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_triangular.html
scipy linalg solve_triangular	R	scipy.linalg.solve_triangular										
scipy linalg.solve_triangular	R	scipy.linalg.solve_triangular										
scipy.linalg.sqrtm	A										<section class="prog__container"><p>Matrix square root.</p><pre><code>scipy.linalg.sqrtm(A, disp=True, blocksize=64)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Matrix whose square root to evaluate \ndisp : bool, optional\n    Print warning if error in the result is estimated large instead of returning estimated error. (Default: True) \nblocksize : integer, optional\n    If the blocksize is not degenerate with respect to the size of the input array, then use a blocked algorithm. (Default: 64)</code></pre><span class="prog__sub">Returns:</span><pre><code>sqrtm : (N, N) ndarray\n    Value of the sqrt function at A \nerrest : float\n    (if disp == False) Frobenius norm of the estimated error, ||err||_F / ||A||_F</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import sqrtm\n>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])\n>>> r = sqrtm(a)\n>>> r\narray([[ 0.75592895,  1.13389342],\n       [ 0.37796447,  1.88982237]])\n>>> r.dot(r)\narray([[ 1.,  3.],\n       [ 1.,  4.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.sqrtm.html
scipy linalg sqrtm	R	scipy.linalg.sqrtm										
scipy linalg.sqrtm	R	scipy.linalg.sqrtm										
scipy.linalg.svd	A										<section class="prog__container"><p>Singular Value Decomposition.</p><pre><code>scipy.linalg.svd(a, full_matrices=True, compute_uv=True, overwrite_a=False, check_finite=True, lapack_driver='gesdd')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Matrix to decompose. \nfull_matrices : bool, optional\n    If True, U and Vh are of shape (M,M), (N,N). If False, the shapes are (M,K) and (K,N), where K = min(M,N). \ncompute_uv : bool, optional\n    Whether to compute also U and Vh in addition to s. Default is True. \noverwrite_a : bool, optional\n    Whether to overwrite a; may improve performance. Default is False. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs. \nlapack_driver : {‘gesdd’, ‘gesvd’}, optional\n    Whether to use the more efficient divide-and-conquer approach ('gesdd') or general rectangular approach ('gesvd') to compute the SVD. MATLAB and Octave use the 'gesvd' approach. Default is 'gesdd'.  New in version 0.18.</code></pre><span class="prog__sub">Returns:</span><pre><code>U : ndarray\n    Unitary matrix having left singular vectors as columns. Of shape (M,M) or (M,K), depending on full_matrices. \ns : ndarray\n    The singular values, sorted in non-increasing order. Of shape (K,), with K = min(M, N). \nVh : ndarray\n    Unitary matrix having right singular vectors as rows. Of shape (N,N) or (K,N) depending on full_matrices. \nFor compute_uv=False, only s is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import linalg\n>>> a = np.random.randn(9, 6) + 1.j*np.random.randn(9, 6)\n>>> U, s, Vh = linalg.svd(a)\n>>> U.shape, Vh.shape, s.shape\n((9, 9), (6, 6), (6,))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.svd.html
scipy linalg svd	R	scipy.linalg.svd										
scipy linalg.svd	R	scipy.linalg.svd										
scipy.linalg.svdvals	A										<section class="prog__container"><p>Compute singular values of a matrix.</p><pre><code>scipy.linalg.svdvals(a, overwrite_a=False, check_finite=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (M, N) array_like\n    Matrix to decompose. \noverwrite_a : bool, optional\n    Whether to overwrite a; may improve performance. Default is False. \ncheck_finite : bool, optional\n    Whether to check that the input matrix contains only finite numbers. Disabling may give a performance gain, but may result in problems (crashes, non-termination) if the inputs do contain infinities or NaNs.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : (min(M, N),) ndarray\n    The singular values, sorted in decreasing order.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.empty((0, 2))\n>>> from scipy.linalg import svdvals\n>>> svdvals(a)\narray([], dtype=float64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.svdvals.html
scipy linalg svdvals	R	scipy.linalg.svdvals										
scipy linalg.svdvals	R	scipy.linalg.svdvals										
scipy.linalg.tanhm	A										<section class="prog__container"><p>Compute the hyperbolic matrix tangent.</p><pre><code>scipy.linalg.tanhm(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Input array</code></pre><span class="prog__sub">Returns:</span><pre><code>tanhm : (N, N) ndarray\n    Hyperbolic matrix tangent of A</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import tanhm, sinhm, coshm\n>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])\n>>> t = tanhm(a)\n>>> t\narray([[ 0.3428582 ,  0.51987926],\n       [ 0.17329309,  0.86273746]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.tanhm.html
scipy linalg tanhm	R	scipy.linalg.tanhm										
scipy linalg.tanhm	R	scipy.linalg.tanhm										
scipy.linalg.tanm	A										<section class="prog__container"><p>Compute the matrix tangent.</p><pre><code>scipy.linalg.tanm(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>tanm : (N, N) ndarray\n    Matrix tangent of A</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import tanm, sinm, cosm\n>>> a = np.array([[1.0, 3.0], [1.0, 4.0]])\n>>> t = tanm(a)\n>>> t\narray([[ -2.00876993,  -8.41880636],\n       [ -2.80626879, -10.42757629]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.tanm.html
scipy linalg tanm	R	scipy.linalg.tanm										
scipy linalg.tanm	R	scipy.linalg.tanm										
scipy.linalg.toeplitz	A										<section class="prog__container"><p>Construct a Toeplitz matrix.</p><pre><code>scipy.linalg.toeplitz(c, r=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    First column of the matrix.  Whatever the actual shape of c, it will be converted to a 1-D array. \nr : array_like, optional\n    First row of the matrix. If None, r = conjugate(c) is assumed; in this case, if c[0] is real, the result is a Hermitian matrix. r[0] is ignored; the first row of the returned matrix is [c[0], r[1:]].  Whatever the actual shape of r, it will be converted to a 1-D array.</code></pre><span class="prog__sub">Returns:</span><pre><code>A : (len(c), len(r)) ndarray\n    The Toeplitz matrix. Dtype is the same as (c[0] + r[0]).dtype.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import toeplitz\n>>> toeplitz([1,2,3], [1,4,5,6])\narray([[1, 4, 5, 6],\n       [2, 1, 4, 5],\n       [3, 2, 1, 4]])\n>>> toeplitz([1.0, 2+3j, 4-1j])\narray([[ 1.+0.j,  2.-3.j,  4.+1.j],\n       [ 2.+3.j,  1.+0.j,  2.-3.j],\n       [ 4.-1.j,  2.+3.j,  1.+0.j]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.toeplitz.html
scipy linalg toeplitz	R	scipy.linalg.toeplitz										
scipy linalg.toeplitz	R	scipy.linalg.toeplitz										
scipy.linalg.tri	A										<section class="prog__container"><p>Construct (N, M) matrix filled with ones at and below the k-th diagonal.</p><pre><code>scipy.linalg.tri(N, M=None, k=0, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    The size of the first dimension of the matrix. \nM : int or None, optional\n    The size of the second dimension of the matrix. If M is None, M = N is assumed. \nk : int, optional\n    Number of subdiagonal below which matrix is filled with ones. k = 0 is the main diagonal, k < 0 subdiagonal and k > 0 superdiagonal. \ndtype : dtype, optional\n    Data type of the matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>tri : (N, M) ndarray\n    Tri matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import tri\n>>> tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])\n>>> tri(3, 5, -1, dtype=int)\narray([[0, 0, 0, 0, 0],\n       [1, 0, 0, 0, 0],\n       [1, 1, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.tri.html
scipy.linalg.tril	A										<section class="prog__container"><p>Make a copy of a matrix with elements above the k-th diagonal zeroed.</p><pre><code>scipy.linalg.tril(m, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Matrix whose elements to return \nk : int, optional\n    Diagonal above which to zero elements. k == 0 is the main diagonal, k < 0 subdiagonal and k > 0 superdiagonal.</code></pre><span class="prog__sub">Returns:</span><pre><code>tril : ndarray\n    Return is the same shape and type as m.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import tril\n>>> tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 0,  0,  0],\n       [ 4,  0,  0],\n       [ 7,  8,  0],\n       [10, 11, 12]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.tril.html
scipy linalg tril	R	scipy.linalg.tril										
scipy linalg.tril	R	scipy.linalg.tril										
scipy linalg tri	R	scipy.linalg.tri										
scipy linalg.tri	R	scipy.linalg.tri										
scipy.linalg.triu	A										<section class="prog__container"><p>Make a copy of a matrix with elements below the k-th diagonal zeroed.</p><pre><code>scipy.linalg.triu(m, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Matrix whose elements to return \nk : int, optional\n    Diagonal below which to zero elements. k == 0 is the main diagonal, k < 0 subdiagonal and k > 0 superdiagonal.</code></pre><span class="prog__sub">Returns:</span><pre><code>triu : ndarray\n    Return matrix with zeroed elements below the k-th diagonal and has same shape and type as m.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.linalg import triu\n>>> triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 0,  8,  9],\n       [ 0,  0, 12]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.triu.html
scipy linalg triu	R	scipy.linalg.triu										
scipy linalg.triu	R	scipy.linalg.triu										
scipy.misc.ascent	A										<section class="prog__container"><p>Get an 8-bit grayscale bit-depth, 512 x 512 derived image for easy use in demos</p><pre><code>scipy.misc.ascent()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>ascent : ndarray\n    convenient image to use for testing and demonstration</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import scipy.misc\n>>> ascent = scipy.misc.ascent()\n>>> ascent.shape\n(512, 512)\n>>> ascent.max()\n255</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.ascent.html
scipy misc ascent	R	scipy.misc.ascent										
scipy misc.ascent	R	scipy.misc.ascent										
scipy.misc.bytescale	A										<section class="prog__container"><p>Byte scales an array (image).</p><pre><code>scipy.misc.bytescale(data, cmin=None, cmax=None, high=255, low=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    PIL image data array. \ncmin : scalar, optional\n    Bias scaling of small values. Default is data.min(). \ncmax : scalar, optional\n    Bias scaling of large values. Default is data.max(). \nhigh : scalar, optional\n    Scale max value to high.  Default is 255. \nlow : scalar, optional\n    Scale min value to low.  Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>img_array : uint8 ndarray\n    The byte-scaled array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.misc import bytescale\n>>> img = np.array([[ 91.06794177,   3.39058326,  84.4221549 ],\n...                 [ 73.88003259,  80.91433048,   4.88878881],\n...                 [ 51.53875334,  34.45808177,  27.5873488 ]])\n>>> bytescale(img)\narray([[255,   0, 236],\n       [205, 225,   4],\n       [140,  90,  70]], dtype=uint8)\n>>> bytescale(img, high=200, low=100)\narray([[200, 100, 192],\n       [180, 188, 102],\n       [155, 135, 128]], dtype=uint8)\n>>> bytescale(img, cmin=0, cmax=255)\narray([[91,  3, 84],\n       [74, 81,  5],\n       [52, 34, 28]], dtype=uint8)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.bytescale.html
scipy misc bytescale	R	scipy.misc.bytescale										
scipy misc.bytescale	R	scipy.misc.bytescale										
scipy.misc.central_diff_weights	A										<section class="prog__container"><p>Return weights for an Np-point central derivative.</p><pre><code>scipy.misc.central_diff_weights(Np, ndiv=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Np : int\n    Number of points for the central derivative. \nndiv : int, optional\n    Number of divisions.  Default is 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.central_diff_weights.html
scipy misc central_diff_weights	R	scipy.misc.central_diff_weights										
scipy misc.central_diff_weights	R	scipy.misc.central_diff_weights										
scipy.misc.comb	A										<section class="prog__container"><p>The number of combinations of N things taken k at a time.</p><pre><code>scipy.misc.comb(N, k, exact=False, repetition=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int, ndarray\n    Number of things. \nk : int, ndarray\n    Number of elements taken. \nexact : bool, optional\n    If exact is False, then floating point precision is used, otherwise exact long integer is computed. \nrepetition : bool, optional\n    If repetition is True, then the number of combinations with repetition is computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : int, ndarray\n    The total number of combinations.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import comb\n>>> k = np.array([3, 4])\n>>> n = np.array([10, 10])\n>>> comb(n, k, exact=False)\narray([ 120.,  210.])\n>>> comb(10, 3, exact=True)\n120L\n>>> comb(10, 3, exact=True, repetition=True)\n220L</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.comb.html
scipy misc comb	R	scipy.misc.comb										
scipy misc.comb	R	scipy.misc.comb										
scipy.misc.derivative	A										<section class="prog__container"><p>Find the n-th derivative of a function at a point.</p><pre><code>scipy.misc.derivative(func, x0, dx=1.0, n=1, args=(), order=3)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    Input function. \nx0 : float\n    The point at which n-th derivative is found. \ndx : float, optional\n    Spacing. \nn : int, optional\n    Order of the derivative. Default is 1. \nargs : tuple, optional\n    Arguments \norder : int, optional\n    Number of points to use, must be odd.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.misc import derivative\n>>> def f(x):\n...     return x**3 + x**2\n>>> derivative(f, 1.0, dx=1e-6)\n4.9999999999217337</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.derivative.html
scipy misc derivative	R	scipy.misc.derivative										
scipy misc.derivative	R	scipy.misc.derivative										
scipy.misc.face	A										<section class="prog__container"><p>Get a 1024 x 768, color image of a raccoon face.</p><pre><code>scipy.misc.face(gray=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>gray : bool, optional\n    If True return 8-bit grey-scale image, otherwise return a color image</code></pre><span class="prog__sub">Returns:</span><pre><code>face : ndarray\n    image of a racoon face</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import scipy.misc\n>>> face = scipy.misc.face()\n>>> face.shape\n(768, 1024, 3)\n>>> face.max()\n255\n>>> face.dtype\ndtype('uint8')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.face.html
scipy misc face	R	scipy.misc.face										
scipy misc.face	R	scipy.misc.face										
scipy.misc.factorial2	A										<section class="prog__container"><p>Double factorial.</p><pre><code>scipy.misc.factorial2(n, exact=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like\n    Calculate n!!.  Arrays are only supported with exact set to False.  If n < 0, the return value is 0. \nexact : bool, optional\n    The result can be approximated rapidly using the gamma-formula above (default).  If exact is set to True, calculate the answer exactly using integer arithmetic.</code></pre><span class="prog__sub">Returns:</span><pre><code>nff : float or int\n    Double factorial of n, as an int or a float depending on exact.</code></pre><span class="prog__sub">Examples:</span><pre><code>n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd\n    = 2**(n/2) * (n/2)!                           n even</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.factorial2.html
scipy misc factorial2	R	scipy.misc.factorial2										
scipy misc.factorial2	R	scipy.misc.factorial2										
scipy.misc.factorial	A										<section class="prog__container"><p>The factorial of a number or array of numbers.</p><pre><code>scipy.misc.factorial(n, exact=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Input values.  If n < 0, the return value is 0. \nexact : bool, optional\n    If True, calculate the answer exactly using long integer arithmetic. If False, result is approximated in floating point rapidly using the gamma function. Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>nf : float or int or ndarray\n    Factorial of n, as integer or float depending on exact.</code></pre><span class="prog__sub">Examples:</span><pre><code>n! = n * (n - 1) * (n - 2) * ... * 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.factorial.html
scipy.misc.factorialk	A										<section class="prog__container"><p>Multifactorial of n of order k, n(!!...!).</p><pre><code>scipy.misc.factorialk(n, k, exact=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Calculate multifactorial. If n < 0, the return value is 0. \nk : int\n    Order of multifactorial. \nexact : bool, optional\n    If exact is set to True, calculate the answer exactly using integer arithmetic.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : int\n    Multifactorial of n.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import factorialk\n>>> factorialk(5, 1, exact=True)\n120L\n>>> factorialk(5, 3, exact=True)\n10L</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.factorialk.html
scipy misc factorialk	R	scipy.misc.factorialk										
scipy misc.factorialk	R	scipy.misc.factorialk										
scipy misc factorial	R	scipy.misc.factorial										
scipy misc.factorial	R	scipy.misc.factorial										
scipy.misc.fromimage	A										<section class="prog__container"><p>Return a copy of a PIL image as a numpy array.</p><pre><code>scipy.misc.fromimage(im, flatten=False, mode=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>im : PIL image\n    Input image. \nflatten : bool\n    If true, convert the output to grey-scale. \nmode : str, optional\n    Mode to convert image to, e.g. 'RGB'.  See the Notes of the imread docstring for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>fromimage : ndarray\n    The different colour bands/channels are stored in the third dimension, such that a grey-image is MxN, an RGB-image MxNx3 and an RGBA-image MxNx4.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.fromimage.html
scipy misc fromimage	R	scipy.misc.fromimage										
scipy misc.fromimage	R	scipy.misc.fromimage										
scipy.misc.imfilter	A										<section class="prog__container"><p>Simple filtering of an image.</p><pre><code>scipy.misc.imfilter(arr, ftype)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    The array of Image in which the filter is to be applied. \nftype : str\n    The filter that has to be applied. Legal values are: ‘blur’, ‘contour’, ‘detail’, ‘edge_enhance’, ‘edge_enhance_more’, ‘emboss’, ‘find_edges’, ‘smooth’, ‘smooth_more’, ‘sharpen’.</code></pre><span class="prog__sub">Returns:</span><pre><code>imfilter : ndarray\n    The array with filter applied.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.imfilter.html
scipy misc imfilter	R	scipy.misc.imfilter										
scipy misc.imfilter	R	scipy.misc.imfilter										
scipy.misc.imread	A										<section class="prog__container"><p>Read an image from a file as an array.</p><pre><code>scipy.misc.imread(name, flatten=False, mode=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>name : str or file object\n    The file name or file object to be read. \nflatten : bool, optional\n    If True, flattens the color layers into a single gray-scale layer. \nmode : str, optional\n    Mode to convert image to, e.g. 'RGB'.  See the Notes for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>imread : ndarray\n    The array obtained by reading the image.</code></pre><span class="prog__sub">Examples:</span><pre><code>L = R * 299/1000 + G * 587/1000 + B * 114/1000</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.imread.html
scipy misc imread	R	scipy.misc.imread										
scipy misc.imread	R	scipy.misc.imread										
scipy.misc.imresize	A										<section class="prog__container"><p>Resize an image.</p><pre><code>scipy.misc.imresize(arr, size, interp='bilinear', mode=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    The array of image to be resized. \nsize : int, float or tuple\n    int   - Percentage of current size. float - Fraction of current size. tuple - Size of the output image.  \ninterp : str, optional\n    Interpolation to use for re-sizing (‘nearest’, ‘lanczos’, ‘bilinear’, ‘bicubic’ or ‘cubic’). \nmode : str, optional\n    The PIL image mode (‘P’, ‘L’, etc.) to convert arr before resizing.</code></pre><span class="prog__sub">Returns:</span><pre><code>imresize : ndarray\n    The resized array of image.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.imresize.html
scipy misc imresize	R	scipy.misc.imresize										
scipy misc.imresize	R	scipy.misc.imresize										
scipy.misc.imrotate	A										<section class="prog__container"><p>Rotate an image counter-clockwise by angle degrees.</p><pre><code>scipy.misc.imrotate(arr, angle, interp='bilinear')</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    Input array of image to be rotated. \nangle : float\n    The angle of rotation. \ninterp : str, optional\n    Interpolation  ‘nearest’ :  for nearest neighbor ‘bilinear’ : for bilinear ‘lanczos’ : for lanczos ‘cubic’ : for bicubic ‘bicubic’ : for bicubic</code></pre><span class="prog__sub">Returns:</span><pre><code>imrotate : ndarray\n    The rotated array of image.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.imrotate.html
scipy misc imrotate	R	scipy.misc.imrotate										
scipy misc.imrotate	R	scipy.misc.imrotate										
scipy.misc.imsave	A										<section class="prog__container"><p>Save an array as an image.</p><pre><code>scipy.misc.imsave(name, arr, format=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>name : str or file object\n    Output file name or file object. \narr : ndarray, MxN or MxNx3 or MxNx4\n    Array containing image values.  If the shape is MxN, the array represents a grey-level image.  Shape MxNx3 stores the red, green and blue bands along the last dimension.  An alpha layer may be included, specified as the last colour band of an MxNx4 array. \nformat : str\n    Image format. If omitted, the format to use is determined from the file name extension. If a file object was used instead of a file name, this parameter should always be used.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.misc import imsave\n>>> x = np.zeros((255, 255))\n>>> x = np.zeros((255, 255), dtype=np.uint8)\n>>> x[:] = np.arange(255)\n>>> imsave('gradient.png', x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.imsave.html
scipy misc imsave	R	scipy.misc.imsave										
scipy misc.imsave	R	scipy.misc.imsave										
scipy.misc.imshow	A										<section class="prog__container"><p>Simple showing of an image through an external viewer.</p><pre><code>scipy.misc.imshow(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray\n    Array of image data to show.</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.tile(np.arange(255), (255,1))\n>>> from scipy import misc\n>>> misc.imshow(a)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.imshow.html
scipy misc imshow	R	scipy.misc.imshow										
scipy misc.imshow	R	scipy.misc.imshow										
scipy.misc.info	A					[[scipy.misc.source]]					<section class="prog__container"><p>Get help information for a function, class, or module.</p><pre><code>scipy.misc.info(object=None, maxwidth=76, output=<open file '<stdout>', mode 'w' at 0x2aba830f0150>, toplevel='scipy')</code></pre><span class="prog__sub">Parameters:</span><pre><code>object : object or str, optional\n    Input object or name to get information about. If object is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects.  If None, information about info itself is returned. \nmaxwidth : int, optional\n    Printing width. \noutput : file like object, optional\n    File like object that the output is written to, default is stdout.  The object has to be opened in ‘w’ or ‘a’ mode. \ntoplevel : str, optional\n    Start search at this level.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.info(np.polyval) \n   polyval(p, x)\n     Evaluate the polynomial p at x.\n     ...</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.info.html
scipy misc info	R	scipy.misc.info										
scipy misc.info	R	scipy.misc.info										
scipy.misc.lena	A					[[scipy.misc.face]]\\n[[scipy.misc.ascent]]					<section class="prog__container"><p>Function that previously returned an example image</p><pre><code>scipy.misc.lena()</code></pre><span class="prog__sub">Parameters:</span><pre><code>None</code></pre><span class="prog__sub">Returns:</span><pre><code>None</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.lena.html
scipy misc lena	R	scipy.misc.lena										
scipy misc.lena	R	scipy.misc.lena										
scipy.misc.logsumexp	A					[[(in NumPy v1.11)]]\\n[[(in NumPy v1.11)]]					<section class="prog__container"><p>Compute the log of the sum of exponentials of input elements.</p><pre><code>scipy.misc.logsumexp(a, axis=None, b=None, keepdims=False, return_sign=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : None or int or tuple of ints, optional\n    Axis or axes over which the sum is taken. By default axis is None, and all elements are summed. Tuple of ints is not accepted if NumPy version is lower than 1.7.0.  New in version 0.11.0.  \nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array.  New in version 0.15.0.  \nb : array-like, optional\n    Scaling factor for exp(a) must be of the same shape as a or broadcastable to a. These values may be negative in order to implement subtraction.  New in version 0.12.0.  \nreturn_sign : bool, optional\n    If this is set to True, the result will be a pair containing sign information; if False, results that are negative will be returned as NaN. Default is False (no sign information).  New in version 0.16.0.  \nReturns\n——-\nres : ndarray\n    The result, np.log(np.sum(np.exp(a))) calculated in a numerically more stable way. If b is given then np.log(np.sum(b*np.exp(a))) is returned. \nsgn : ndarray\n    If return_sign is True, this will be an array of floating-point numbers matching res and +1, 0, or -1 depending on the sign of the result. If False, only one result is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.misc import logsumexp\n>>> a = np.arange(10)\n>>> np.log(np.sum(np.exp(a)))\n9.4586297444267107\n>>> logsumexp(a)\n9.4586297444267107</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.logsumexp.html
scipy misc logsumexp	R	scipy.misc.logsumexp										
scipy misc.logsumexp	R	scipy.misc.logsumexp										
scipy.misc.pade	A										<section class="prog__container"><p>Return Pade approximation to a polynomial as the ratio of two polynomials.</p><pre><code>scipy.misc.pade(an, m)</code></pre><span class="prog__sub">Parameters:</span><pre><code>an : (N,) array_like\n    Taylor series coefficients. \nm : int\n    The order of the returned approximating polynomials.</code></pre><span class="prog__sub">Returns:</span><pre><code>p, q : Polynomial class\n    The pade approximation of the polynomial defined by an is p(x)/q(x).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import misc\n>>> e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0]\n>>> p, q = misc.pade(e_exp, 2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.pade.html
scipy misc pade	R	scipy.misc.pade										
scipy misc.pade	R	scipy.misc.pade										
scipy.misc.source	A					[[scipy.misc.info]]					<section class="prog__container"><p>Print or write to a file the source code for a Numpy object.</p><pre><code>scipy.misc.source(object, output=<open file '<stdout>', mode 'w' at 0x2aba830f0150>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>object : numpy object\n    Input object. This can be any object (function, class, module, ...). \noutput : file object, optional\n    If output not supplied then source code is printed to screen (sys.stdout).  File object must be created with either write ‘w’ or append ‘a’ modes.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> np.source(np.interp)                        \nIn file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\ndef interp(x, xp, fp, left=None, right=None):\n    """.... (full docstring printed)"""\n    if isinstance(x, (float, int, number)):\n        return compiled_interp([x], xp, fp, left, right).item()\n    else:\n        return compiled_interp(x, xp, fp, left, right)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.source.html
scipy misc source	R	scipy.misc.source										
scipy misc.source	R	scipy.misc.source										
scipy.misc.toimage	A										<section class="prog__container"><p>Takes a numpy array and returns a PIL image.</p><pre><code>scipy.misc.toimage(arr, high=255, low=0, cmin=None, cmax=None, pal=None, mode=None, channel_axis=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.toimage.html
scipy misc toimage	R	scipy.misc.toimage										
scipy misc.toimage	R	scipy.misc.toimage										
scipy.misc.who	A										<section class="prog__container"><p>Print the Numpy arrays in the given dictionary.</p><pre><code>scipy.misc.who(vardict=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>vardict : dict, optional\n    A dictionary possibly containing ndarrays.  Default is globals().</code></pre><span class="prog__sub">Returns:</span><pre><code>out : None\n    Returns ‘None’.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(10)\n>>> b = np.ones(20)\n>>> np.who()\nName            Shape            Bytes            Type\n===========================================================\na               10               40               int32\nb               20               160              float64\nUpper bound on total bytes  =       200</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.who.html
scipy misc who	R	scipy.misc.who										
scipy misc.who	R	scipy.misc.who										
scipy.ndimage.affine_transform	A										<section class="prog__container"><p>Apply an affine transformation.</p><pre><code>scipy.ndimage.affine_transform(input, matrix, offset=0.0, output_shape=None, output=None, order=3, mode='constant', cval=0.0, prefilter=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    The input array. \nmatrix : ndarray\n    The matrix must be two-dimensional or can also be given as a one-dimensional sequence or array. In the latter case, it is assumed that the matrix is diagonal. A more efficient algorithms is then applied that exploits the separability of the problem. \noffset : float or sequence, optional\n    The offset into the array where the transform is applied. If a float, offset is the same for each axis. If a sequence, offset should contain one value for each axis. \noutput_shape : tuple of ints, optional\n    Shape tuple. \noutput : ndarray or dtype, optional\n    The array in which to place the output, or the dtype of the returned array. \norder : int, optional\n    The order of the spline interpolation, default is 3. The order has to be in the range 0-5. \nmode : str, optional\n    Points outside the boundaries of the input are filled according to the given mode (‘constant’, ‘nearest’, ‘reflect’ or ‘wrap’). Default is ‘constant’. \ncval : scalar, optional\n    Value used for points outside the boundaries of the input if mode='constant'. Default is 0.0 \nprefilter : bool, optional\n    The parameter prefilter determines if the input is pre-filtered with spline_filter before interpolation (necessary for spline interpolation of order > 1).  If False, it is assumed that the input is already filtered. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>affine_transform : ndarray or None\n    The transformed input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.affine_transform.html
scipy ndimage affine_transform	R	scipy.ndimage.affine_transform										
scipy ndimage.affine_transform	R	scipy.ndimage.affine_transform										
scipy.ndimage.binary_closing	A					[[scipy.ndimage.grey_closing]]\\n[[scipy.ndimage.binary_opening]]\\n[[scipy.ndimage.binary_dilation]]\\n[[scipy.ndimage.binary_erosion]]\\n[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Multi-dimensional binary closing with the given structuring element.</p><pre><code>scipy.ndimage.binary_closing(input, structure=None, iterations=1, output=None, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Binary array_like to be closed. Non-zero (True) elements form the subset to be closed. \nstructure : array_like, optional\n    Structuring element used for the closing. Non-zero elements are considered True. If no structuring element is provided an element is generated with a square connectivity equal to one (i.e., only nearest neighbors are connected to the center, diagonally-connected elements are not considered neighbors). \niterations : {int, float}, optional\n    The dilation step of the closing, then the erosion step are each repeated iterations times (one, by default). If iterations is less than 1, each operations is repeated until the result does not change anymore. \noutput : ndarray, optional\n    Array of the same shape as input, into which the output is placed. By default, a new array is created. \norigin : int or tuple of ints, optional\n    Placement of the filter, by default 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>binary_closing : ndarray of bools\n    Closing of the input by the structuring element.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((5,5), dtype=int)\n>>> a[1:-1, 1:-1] = 1; a[2,2] = 0\n>>> a\narray([[0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 0, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0]])\n>>> # Closing removes small holes\n>>> ndimage.binary_closing(a).astype(int)\narray([[0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0]])\n>>> # Closing is the erosion of the dilation of the input\n>>> ndimage.binary_dilation(a).astype(int)\narray([[0, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [0, 1, 1, 1, 0]])\n>>> ndimage.binary_erosion(ndimage.binary_dilation(a)).astype(int)\narray([[0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.binary_closing.html
scipy ndimage binary_closing	R	scipy.ndimage.binary_closing										
scipy ndimage.binary_closing	R	scipy.ndimage.binary_closing										
scipy.ndimage.binary_dilation	A					[[scipy.ndimage.grey_dilation]]\\n[[scipy.ndimage.binary_erosion]]\\n[[scipy.ndimage.binary_closing]]\\n[[scipy.ndimage.binary_opening]]\\n[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Multi-dimensional binary dilation with the given structuring element.</p><pre><code>scipy.ndimage.binary_dilation(input, structure=None, iterations=1, mask=None, output=None, border_value=0, origin=0, brute_force=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Binary array_like to be dilated. Non-zero (True) elements form the subset to be dilated. \nstructure : array_like, optional\n    Structuring element used for the dilation. Non-zero elements are considered True. If no structuring element is provided an element is generated with a square connectivity equal to one. \niterations : {int, float}, optional\n    The dilation is repeated iterations times (one, by default). If iterations is less than 1, the dilation is repeated until the result does not change anymore. \nmask : array_like, optional\n    If a mask is given, only those elements with a True value at the corresponding mask element are modified at each iteration. \noutput : ndarray, optional\n    Array of the same shape as input, into which the output is placed. By default, a new array is created. \norigin : int or tuple of ints, optional\n    Placement of the filter, by default 0. \nborder_value : int (cast to 0 or 1), optional\n    Value at the border in the output array.</code></pre><span class="prog__sub">Returns:</span><pre><code>binary_dilation : ndarray of bools\n    Dilation of the input by the structuring element.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((5, 5))\n>>> a[2, 2] = 1\n>>> a\narray([[ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.]])\n>>> ndimage.binary_dilation(a)\narray([[False, False, False, False, False],\n       [False, False,  True, False, False],\n       [False,  True,  True,  True, False],\n       [False, False,  True, False, False],\n       [False, False, False, False, False]], dtype=bool)\n>>> ndimage.binary_dilation(a).astype(a.dtype)\narray([[ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.]])\n>>> # 3x3 structuring element with connectivity 1, used by default\n>>> struct1 = ndimage.generate_binary_structure(2, 1)\n>>> struct1\narray([[False,  True, False],\n       [ True,  True,  True],\n       [False,  True, False]], dtype=bool)\n>>> # 3x3 structuring element with connectivity 2\n>>> struct2 = ndimage.generate_binary_structure(2, 2)\n>>> struct2\narray([[ True,  True,  True],\n       [ True,  True,  True],\n       [ True,  True,  True]], dtype=bool)\n>>> ndimage.binary_dilation(a, structure=struct1).astype(a.dtype)\narray([[ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.]])\n>>> ndimage.binary_dilation(a, structure=struct2).astype(a.dtype)\narray([[ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.]])\n>>> ndimage.binary_dilation(a, structure=struct1,\\n... iterations=2).astype(a.dtype)\narray([[ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 1.,  1.,  1.,  1.,  1.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.binary_dilation.html
scipy ndimage binary_dilation	R	scipy.ndimage.binary_dilation										
scipy ndimage.binary_dilation	R	scipy.ndimage.binary_dilation										
scipy.ndimage.binary_erosion	A					[[scipy.ndimage.grey_erosion]]\\n[[scipy.ndimage.binary_dilation]]\\n[[scipy.ndimage.binary_closing]]\\n[[scipy.ndimage.binary_opening]]\\n[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Multi-dimensional binary erosion with a given structuring element.</p><pre><code>scipy.ndimage.binary_erosion(input, structure=None, iterations=1, mask=None, output=None, border_value=0, origin=0, brute_force=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Binary image to be eroded. Non-zero (True) elements form the subset to be eroded. \nstructure : array_like, optional\n    Structuring element used for the erosion. Non-zero elements are considered True. If no structuring element is provided, an element is generated with a square connectivity equal to one. \niterations : {int, float}, optional\n    The erosion is repeated iterations times (one, by default). If iterations is less than 1, the erosion is repeated until the result does not change anymore. \nmask : array_like, optional\n    If a mask is given, only those elements with a True value at the corresponding mask element are modified at each iteration. \noutput : ndarray, optional\n    Array of the same shape as input, into which the output is placed. By default, a new array is created. \norigin : int or tuple of ints, optional\n    Placement of the filter, by default 0. \nborder_value : int (cast to 0 or 1), optional\n    Value at the border in the output array.</code></pre><span class="prog__sub">Returns:</span><pre><code>binary_erosion : ndarray of bools\n    Erosion of the input by the structuring element.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((7,7), dtype=int)\n>>> a[1:6, 2:5] = 1\n>>> a\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> ndimage.binary_erosion(a).astype(a.dtype)\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> #Erosion removes objects smaller than the structure\n>>> ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.binary_erosion.html
scipy ndimage binary_erosion	R	scipy.ndimage.binary_erosion										
scipy ndimage.binary_erosion	R	scipy.ndimage.binary_erosion										
scipy.ndimage.binary_fill_holes	A					[[scipy.ndimage.binary_dilation]]\\n[[scipy.ndimage.binary_propagation]]\\n[[scipy.ndimage.label]]					<section class="prog__container"><p>Fill the holes in binary objects.</p><pre><code>scipy.ndimage.binary_fill_holes(input, structure=None, output=None, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    n-dimensional binary array with holes to be filled \nstructure : array_like, optional\n    Structuring element used in the computation; large-size elements make computations faster but may miss holes separated from the background by thin regions. The default element (with a square connectivity equal to one) yields the intuitive result where all holes in the input have been filled. \noutput : ndarray, optional\n    Array of the same shape as input, into which the output is placed. By default, a new array is created. \norigin : int, tuple of ints, optional\n    Position of the structuring element.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Transformation of the initial image input where holes have been filled.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((5, 5), dtype=int)\n>>> a[1:4, 1:4] = 1\n>>> a[2,2] = 0\n>>> a\narray([[0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 0, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0]])\n>>> ndimage.binary_fill_holes(a).astype(int)\narray([[0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0]])\n>>> # Too big structuring element\n>>> ndimage.binary_fill_holes(a, structure=np.ones((5,5))).astype(int)\narray([[0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 0, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.binary_fill_holes.html
scipy ndimage binary_fill_holes	R	scipy.ndimage.binary_fill_holes										
scipy ndimage.binary_fill_holes	R	scipy.ndimage.binary_fill_holes										
scipy.ndimage.binary_hit_or_miss	A					[[scipy.ndimage.binary_erosion]]					<section class="prog__container"><p>Multi-dimensional binary hit-or-miss transform.</p><pre><code>scipy.ndimage.binary_hit_or_miss(input, structure1=None, structure2=None, output=None, origin1=0, origin2=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like (cast to booleans)\n    Binary image where a pattern is to be detected. \nstructure1 : array_like (cast to booleans), optional\n    Part of the structuring element to be fitted to the foreground (non-zero elements) of input. If no value is provided, a structure of square connectivity 1 is chosen. \nstructure2 : array_like (cast to booleans), optional\n    Second part of the structuring element that has to miss completely the foreground. If no value is provided, the complementary of structure1 is taken. \noutput : ndarray, optional\n    Array of the same shape as input, into which the output is placed. By default, a new array is created. \norigin1 : int or tuple of ints, optional\n    Placement of the first part of the structuring element structure1, by default 0 for a centered structure. \norigin2 : int or tuple of ints, optional\n    Placement of the second part of the structuring element structure2, by default 0 for a centered structure. If a value is provided for origin1 and not for origin2, then origin2 is set to origin1.</code></pre><span class="prog__sub">Returns:</span><pre><code>binary_hit_or_miss : ndarray\n    Hit-or-miss transform of input with the given structuring element (structure1, structure2).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((7,7), dtype=int)\n>>> a[1, 1] = 1; a[2:4, 2:4] = 1; a[4:6, 4:6] = 1\n>>> a\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 1, 1, 0, 0, 0],\n       [0, 0, 1, 1, 0, 0, 0],\n       [0, 0, 0, 0, 1, 1, 0],\n       [0, 0, 0, 0, 1, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> structure1 = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]])\n>>> structure1\narray([[1, 0, 0],\n       [0, 1, 1],\n       [0, 1, 1]])\n>>> # Find the matches of structure1 in the array a\n>>> ndimage.binary_hit_or_miss(a, structure1=structure1).astype(int)\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> # Change the origin of the filter\n>>> # origin1=1 is equivalent to origin1=(1,1) here\n>>> ndimage.binary_hit_or_miss(a, structure1=structure1,\\n... origin1=1).astype(int)\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.binary_hit_or_miss.html
scipy ndimage binary_hit_or_miss	R	scipy.ndimage.binary_hit_or_miss										
scipy ndimage.binary_hit_or_miss	R	scipy.ndimage.binary_hit_or_miss										
scipy.ndimage.binary_opening	A					[[scipy.ndimage.grey_opening]]\\n[[scipy.ndimage.binary_closing]]\\n[[scipy.ndimage.binary_erosion]]\\n[[scipy.ndimage.binary_dilation]]\\n[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Multi-dimensional binary opening with the given structuring element.</p><pre><code>scipy.ndimage.binary_opening(input, structure=None, iterations=1, output=None, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Binary array_like to be opened. Non-zero (True) elements form the subset to be opened. \nstructure : array_like, optional\n    Structuring element used for the opening. Non-zero elements are considered True. If no structuring element is provided an element is generated with a square connectivity equal to one (i.e., only nearest neighbors are connected to the center, diagonally-connected elements are not considered neighbors). \niterations : {int, float}, optional\n    The erosion step of the opening, then the dilation step are each repeated iterations times (one, by default). If iterations is less than 1, each operation is repeated until the result does not change anymore. \noutput : ndarray, optional\n    Array of the same shape as input, into which the output is placed. By default, a new array is created. \norigin : int or tuple of ints, optional\n    Placement of the filter, by default 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>binary_opening : ndarray of bools\n    Opening of the input by the structuring element.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((5,5), dtype=int)\n>>> a[1:4, 1:4] = 1; a[4, 4] = 1\n>>> a\narray([[0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 0, 1]])\n>>> # Opening removes small objects\n>>> ndimage.binary_opening(a, structure=np.ones((3,3))).astype(int)\narray([[0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0]])\n>>> # Opening can also smooth corners\n>>> ndimage.binary_opening(a).astype(int)\narray([[0, 0, 0, 0, 0],\n       [0, 0, 1, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 1, 0, 0],\n       [0, 0, 0, 0, 0]])\n>>> # Opening is the dilation of the erosion of the input\n>>> ndimage.binary_erosion(a).astype(int)\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 1, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0]])\n>>> ndimage.binary_dilation(ndimage.binary_erosion(a)).astype(int)\narray([[0, 0, 0, 0, 0],\n       [0, 0, 1, 0, 0],\n       [0, 1, 1, 1, 0],\n       [0, 0, 1, 0, 0],\n       [0, 0, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.binary_opening.html
scipy ndimage binary_opening	R	scipy.ndimage.binary_opening										
scipy ndimage.binary_opening	R	scipy.ndimage.binary_opening										
scipy.ndimage.binary_propagation	A										<section class="prog__container"><p>Multi-dimensional binary propagation with the given structuring element.</p><pre><code>scipy.ndimage.binary_propagation(input, structure=None, mask=None, output=None, border_value=0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Binary image to be propagated inside mask. \nstructure : array_like, optional\n    Structuring element used in the successive dilations. The output may depend on the structuring element, especially if mask has several connex components. If no structuring element is provided, an element is generated with a squared connectivity equal to one. \nmask : array_like, optional\n    Binary mask defining the region into which input is allowed to propagate. \noutput : ndarray, optional\n    Array of the same shape as input, into which the output is placed. By default, a new array is created. \nborder_value : int (cast to 0 or 1), optional\n    Value at the border in the output array. \norigin : int or tuple of ints, optional\n    Placement of the filter, by default 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>binary_propagation : ndarray\n    Binary propagation of input inside mask.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> input = np.zeros((8, 8), dtype=int)\n>>> input[2, 2] = 1\n>>> mask = np.zeros((8, 8), dtype=int)\n>>> mask[1:4, 1:4] = mask[4, 4]  = mask[6:8, 6:8] = 1\n>>> input\narray([[0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0]])\n>>> mask\narray([[0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 1],\n       [0, 0, 0, 0, 0, 0, 1, 1]])\n>>> ndimage.binary_propagation(input, mask=mask).astype(int)\narray([[0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0]])\n>>> ndimage.binary_propagation(input, mask=mask,\\n... structure=np.ones((3,3))).astype(int)\narray([[0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 1, 1, 1, 0, 0, 0, 0],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.binary_propagation.html
scipy ndimage binary_propagation	R	scipy.ndimage.binary_propagation										
scipy ndimage.binary_propagation	R	scipy.ndimage.binary_propagation										
scipy.ndimage.black_tophat	A					[[scipy.ndimage.white_tophat]]\\n[[scipy.ndimage.grey_opening]]\\n[[scipy.ndimage.grey_closing]]					<section class="prog__container"><p>Multi-dimensional black tophat filter.</p><pre><code>scipy.ndimage.black_tophat(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input. \nsize : tuple of ints, optional\n    Shape of a flat and full structuring element used for the filter. Optional if footprint or structure is provided. \nfootprint : array of ints, optional\n    Positions of non-infinite elements of a flat structuring element used for the black tophat filter. \nstructure : array of ints, optional\n    Structuring element used for the filter. structure may be a non-flat structuring element. \noutput : array, optional\n    An array used for storing the output of the filter may be provided. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0. \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0</code></pre><span class="prog__sub">Returns:</span><pre><code>black_tophat : ndarray\n    Result of the filter of input with structure.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.black_tophat.html
scipy ndimage black_tophat	R	scipy.ndimage.black_tophat										
scipy ndimage.black_tophat	R	scipy.ndimage.black_tophat										
scipy.ndimage.center_of_mass	A										<section class="prog__container"><p>Calculate the center of mass of the values of an array at labels.</p><pre><code>scipy.ndimage.center_of_mass(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    Data from which to calculate center-of-mass. \nlabels : ndarray, optional\n    Labels for objects in input, as generated by ndimage.label. Only used with index.  Dimensions must be the same as input. \nindex : int or sequence of ints, optional\n    Labels for which to calculate centers-of-mass. If not specified, all labels greater than zero are used.  Only used with labels.</code></pre><span class="prog__sub">Returns:</span><pre><code>center_of_mass : tuple, or list of tuples\n    Coordinates of centers-of-mass.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array(([0,0,0,0],\n...               [0,1,1,0],\n...               [0,1,1,0],\n...               [0,1,1,0]))\n>>> from scipy import ndimage\n>>> ndimage.measurements.center_of_mass(a)\n(2.0, 1.5)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.center_of_mass.html
scipy ndimage center_of_mass	R	scipy.ndimage.center_of_mass										
scipy ndimage.center_of_mass	R	scipy.ndimage.center_of_mass										
scipy.ndimage.convolve1d	A										<section class="prog__container"><p>Calculate a one-dimensional convolution along the given axis.</p><pre><code>scipy.ndimage.convolve1d(input, weights, axis=-1, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nweights : ndarray\n    One-dimensional sequence of numbers. \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>convolve1d : ndarray\n    Convolved array with same shape as input</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve1d.html
scipy ndimage convolve1d	R	scipy.ndimage.convolve1d										
scipy ndimage.convolve1d	R	scipy.ndimage.convolve1d										
scipy.ndimage.convolve	A										<section class="prog__container"><p>Multidimensional convolution.</p><pre><code>scipy.ndimage.convolve(input, weights, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nweights : array_like\n    Array of weights, same number of dimensions as input \noutput : ndarray, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’,’constant’,’nearest’,’mirror’, ‘wrap’}, optional\n    the mode parameter determines how the array borders are handled. For ‘constant’ mode, values beyond borders are set to be cval. Default is ‘reflect’. \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : array_like, optional\n    The origin parameter controls the placement of the filter,  relative to the centre of the current element of the input.   Default of 0 is equivalent to (0,)*input.ndim.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    The result of convolution of input with weights.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2, 0, 0],\n...               [5, 3, 0, 4],\n...               [0, 0, 0, 7],\n...               [9, 3, 0, 0]])\n>>> k = np.array([[1,1,1],[1,1,0],[1,0,0]])\n>>> from scipy import ndimage\n>>> ndimage.convolve(a, k, mode='constant', cval=0.0)\narray([[11, 10,  7,  4],\n       [10,  3, 11, 11],\n       [15, 12, 14,  7],\n       [12,  3,  7,  0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html
scipy ndimage convolve	R	scipy.ndimage.convolve										
scipy ndimage.convolve	R	scipy.ndimage.convolve										
scipy.ndimage.correlate1d	A										<section class="prog__container"><p>Calculate a one-dimensional correlation along the given axis.</p><pre><code>scipy.ndimage.correlate1d(input, weights, axis=-1, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nweights : array\n    One-dimensional sequence of numbers. \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.correlate1d.html
scipy ndimage correlate1d	R	scipy.ndimage.correlate1d										
scipy ndimage.correlate1d	R	scipy.ndimage.correlate1d										
scipy.ndimage.correlate	A										<section class="prog__container"><p>Multi-dimensional correlation.</p><pre><code>scipy.ndimage.correlate(input, weights, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array-like\n    input array to filter \nweights : ndarray\n    array of weights, same number of dimensions as input \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’,’constant’,’nearest’,’mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.correlate.html
scipy ndimage correlate	R	scipy.ndimage.correlate										
scipy ndimage.correlate	R	scipy.ndimage.correlate										
scipy.ndimage.distance_transform_bf	A										<section class="prog__container"><p>Distance transform function by a brute force algorithm.</p><pre><code>scipy.ndimage.distance_transform_bf(input, metric='euclidean', sampling=None, return_distances=True, return_indices=False, distances=None, indices=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input \nmetric : str, optional\n    Three types of distance metric are supported: ‘euclidean’, ‘taxicab’ and ‘chessboard’. \nsampling : {int, sequence of ints}, optional\n    This parameter is only used in the case of the euclidean metric distance transform. The sampling along each axis can be given by the sampling parameter which should be a sequence of length equal to the input rank, or a single number in which the sampling is assumed to be equal along all axes. \nreturn_distances : bool, optional\n    The return_distances flag can be used to indicate if the distance transform is returned. The default is True. \nreturn_indices : bool, optional\n    The return_indices flags can be used to indicate if the feature transform is returned. The default is False. \ndistances : float64 ndarray, optional\n    Optional output array to hold distances (if return_distances is True). \nindices : int64 ndarray, optional\n    Optional output array to hold indices (if return_indices is True).</code></pre><span class="prog__sub">Returns:</span><pre><code>distances : ndarray\n    Distance array if return_distances is True. \nindices : ndarray\n    Indices array if return_indices is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.distance_transform_bf.html
scipy ndimage distance_transform_bf	R	scipy.ndimage.distance_transform_bf										
scipy ndimage.distance_transform_bf	R	scipy.ndimage.distance_transform_bf										
scipy.ndimage.distance_transform_cdt	A										<section class="prog__container"><p>Distance transform for chamfer type of transforms.</p><pre><code>scipy.ndimage.distance_transform_cdt(input, metric='chessboard', return_distances=True, return_indices=False, distances=None, indices=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input \nmetric : {‘chessboard’, ‘taxicab’}, optional\n    The metric determines the type of chamfering that is done. If the metric is equal to ‘taxicab’ a structure is generated using generate_binary_structure with a squared distance equal to 1. If the metric is equal to ‘chessboard’, a metric is generated using generate_binary_structure with a squared distance equal to the dimensionality of the array. These choices correspond to the common interpretations of the ‘taxicab’ and the ‘chessboard’ distance metrics in two dimensions. The default for metric is ‘chessboard’. \nreturn_distances, return_indices : bool, optional\n    The return_distances, and return_indices flags can be used to indicate if the distance transform, the feature transform, or both must be returned. If the feature transform is returned (return_indices=True), the index of the closest background element is returned along the first axis of the result. The return_distances default is True, and the return_indices default is False. \ndistances, indices : ndarrays of int32, optional\n    The distances and indices arguments can be used to give optional output arrays that must be the same shape as input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.distance_transform_cdt.html
scipy ndimage distance_transform_cdt	R	scipy.ndimage.distance_transform_cdt										
scipy ndimage.distance_transform_cdt	R	scipy.ndimage.distance_transform_cdt										
scipy.ndimage.distance_transform_edt	A										<section class="prog__container"><p>Exact euclidean distance transform.</p><pre><code>scipy.ndimage.distance_transform_edt(input, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input data to transform. Can be any type but will be converted into binary: 1 wherever input equates to True, 0 elsewhere. \nsampling : float or int, or sequence of same, optional\n    Spacing of elements along each dimension. If a sequence, must be of length equal to the input rank; if a single number, this is used for all axes. If not specified, a grid spacing of unity is implied. \nreturn_distances : bool, optional\n    Whether to return distance matrix. At least one of return_distances/return_indices must be True. Default is True. \nreturn_indices : bool, optional\n    Whether to return indices matrix. Default is False. \ndistances : ndarray, optional\n    Used for output of distance array, must be of type float64. \nindices : ndarray, optional\n    Used for output of indices, must be of type int32.</code></pre><span class="prog__sub">Returns:</span><pre><code>distance_transform_edt : ndarray or list of ndarrays\n    Either distance matrix, index matrix, or a list of the two, depending on return_x flags and distance and indices input parameters.</code></pre><span class="prog__sub">Examples:</span><pre><code>n\ny_i = sqrt(sum (x[i]-b[i])**2)\n              i</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.distance_transform_edt.html
scipy ndimage distance_transform_edt	R	scipy.ndimage.distance_transform_edt										
scipy ndimage.distance_transform_edt	R	scipy.ndimage.distance_transform_edt										
scipy.ndimage.extrema	A					[[scipy.ndimage.maximum]]\\n[[scipy.ndimage.minimum]]\\n[[scipy.ndimage.maximum_position]]\\n[[scipy.ndimage.minimum_position]]\\n[[scipy.ndimage.center_of_mass]]					<section class="prog__container"><p>Calculate the minimums and maximums of the values of an array\nat labels, along with their positions.</p><pre><code>scipy.ndimage.extrema(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    Nd-image data to process. \nlabels : ndarray, optional\n    Labels of features in input. If not None, must be same shape as input. \nindex : int or sequence of ints, optional\n    Labels to include in output.  If None (default), all values where non-zero labels are used.</code></pre><span class="prog__sub">Returns:</span><pre><code>minimums, maximums : int or ndarray\n    Values of minimums and maximums in each feature. \nmin_positions, max_positions : tuple or list of tuples\n    Each tuple gives the n-D coordinates of the corresponding minimum or maximum.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2, 0, 0],\n...               [5, 3, 0, 4],\n...               [0, 0, 0, 7],\n...               [9, 3, 0, 0]])\n>>> from scipy import ndimage\n>>> ndimage.extrema(a)\n(0, 9, (0, 2), (3, 0))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.extrema.html
scipy ndimage extrema	R	scipy.ndimage.extrema										
scipy ndimage.extrema	R	scipy.ndimage.extrema										
scipy.ndimage.find_objects	A					[[scipy.ndimage.label]]\\n[[scipy.ndimage.center_of_mass]]					<section class="prog__container"><p>Find objects in a labeled array.</p><pre><code>scipy.ndimage.find_objects(input, max_label=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray of ints\n    Array containing objects defined by different labels. Labels with value 0 are ignored. \nmax_label : int, optional\n    Maximum label to be searched for in input. If max_label is not given, the positions of all objects are returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>object_slices : list of tuples\n    A list of tuples, with each tuple containing N slices (with N the dimension of the input array).  Slices correspond to the minimal parallelepiped that contains the object. If a number is missing, None is returned instead of a slice.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((6,6), dtype=int)\n>>> a[2:4, 2:4] = 1\n>>> a[4, 4] = 1\n>>> a[:2, :3] = 2\n>>> a[0, 5] = 3\n>>> a\narray([[2, 2, 2, 0, 0, 3],\n       [2, 2, 2, 0, 0, 0],\n       [0, 0, 1, 1, 0, 0],\n       [0, 0, 1, 1, 0, 0],\n       [0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0]])\n>>> ndimage.find_objects(a)\n[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None)), (slice(0, 1, None), slice(5, 6, None))]\n>>> ndimage.find_objects(a, max_label=2)\n[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None))]\n>>> ndimage.find_objects(a == 1, max_label=2)\n[(slice(2, 5, None), slice(2, 5, None)), None]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.find_objects.html
scipy ndimage find_objects	R	scipy.ndimage.find_objects										
scipy ndimage.find_objects	R	scipy.ndimage.find_objects										
scipy.ndimage.fourier_ellipsoid	A										<section class="prog__container"><p>Multi-dimensional ellipsoid fourier filter.</p><pre><code>scipy.ndimage.fourier_ellipsoid(input, size, n=-1, axis=-1, output=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    The input array. \nsize : float or sequence\n    The size of the box used for filtering. If a float, size is the same for all axes. If a sequence, size has to contain one value for each axis. \nn : int, optional\n    If n is negative (default), then the input is assumed to be the result of a complex fft. If n is larger than or equal to zero, the input is assumed to be the result of a real fft, and n gives the length of the array before transformation along the real transform direction. \naxis : int, optional\n    The axis of the real transform. \noutput : ndarray, optional\n    If given, the result of filtering the input is placed in this array. None is returned in this case.</code></pre><span class="prog__sub">Returns:</span><pre><code>fourier_ellipsoid : ndarray or None\n    The filtered input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.fourier_ellipsoid.html
scipy ndimage fourier_ellipsoid	R	scipy.ndimage.fourier_ellipsoid										
scipy ndimage.fourier_ellipsoid	R	scipy.ndimage.fourier_ellipsoid										
scipy.ndimage.fourier_gaussian	A										<section class="prog__container"><p>Multi-dimensional Gaussian fourier filter.</p><pre><code>scipy.ndimage.fourier_gaussian(input, sigma, n=-1, axis=-1, output=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    The input array. \nsigma : float or sequence\n    The sigma of the Gaussian kernel. If a float, sigma is the same for all axes. If a sequence, sigma has to contain one value for each axis. \nn : int, optional\n    If n is negative (default), then the input is assumed to be the result of a complex fft. If n is larger than or equal to zero, the input is assumed to be the result of a real fft, and n gives the length of the array before transformation along the real transform direction. \naxis : int, optional\n    The axis of the real transform. \noutput : ndarray, optional\n    If given, the result of filtering the input is placed in this array. None is returned in this case.</code></pre><span class="prog__sub">Returns:</span><pre><code>fourier_gaussian : ndarray or None\n    The filtered input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.fourier_gaussian.html
scipy ndimage fourier_gaussian	R	scipy.ndimage.fourier_gaussian										
scipy ndimage.fourier_gaussian	R	scipy.ndimage.fourier_gaussian										
scipy.ndimage.fourier_shift	A										<section class="prog__container"><p>Multi-dimensional fourier shift filter.</p><pre><code>scipy.ndimage.fourier_shift(input, shift, n=-1, axis=-1, output=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    The input array. \nshift : float or sequence\n    The size of the box used for filtering. If a float, shift is the same for all axes. If a sequence, shift has to contain one value for each axis. \nn : int, optional\n    If n is negative (default), then the input is assumed to be the result of a complex fft. If n is larger than or equal to zero, the input is assumed to be the result of a real fft, and n gives the length of the array before transformation along the real transform direction. \naxis : int, optional\n    The axis of the real transform. \noutput : ndarray, optional\n    If given, the result of shifting the input is placed in this array. None is returned in this case.</code></pre><span class="prog__sub">Returns:</span><pre><code>fourier_shift : ndarray or None\n    The shifted input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.fourier_shift.html
scipy ndimage fourier_shift	R	scipy.ndimage.fourier_shift										
scipy ndimage.fourier_shift	R	scipy.ndimage.fourier_shift										
scipy.ndimage.fourier_uniform	A										<section class="prog__container"><p>Multi-dimensional uniform fourier filter.</p><pre><code>scipy.ndimage.fourier_uniform(input, size, n=-1, axis=-1, output=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    The input array. \nsize : float or sequence\n    The size of the box used for filtering. If a float, size is the same for all axes. If a sequence, size has to contain one value for each axis. \nn : int, optional\n    If n is negative (default), then the input is assumed to be the result of a complex fft. If n is larger than or equal to zero, the input is assumed to be the result of a real fft, and n gives the length of the array before transformation along the real transform direction. \naxis : int, optional\n    The axis of the real transform. \noutput : ndarray, optional\n    If given, the result of filtering the input is placed in this array. None is returned in this case.</code></pre><span class="prog__sub">Returns:</span><pre><code>fourier_uniform : ndarray or None\n    The filtered input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.fourier_uniform.html
scipy ndimage fourier_uniform	R	scipy.ndimage.fourier_uniform										
scipy ndimage.fourier_uniform	R	scipy.ndimage.fourier_uniform										
scipy.ndimage.gaussian_filter1d	A										<section class="prog__container"><p>One-dimensional Gaussian filter.</p><pre><code>scipy.ndimage.gaussian_filter1d(input, sigma, axis=-1, order=0, output=None, mode='reflect', cval=0.0, truncate=4.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsigma : scalar\n    standard deviation for Gaussian kernel \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \norder : {0, 1, 2, 3}, optional\n    An order of 0 corresponds to convolution with a Gaussian kernel. An order of 1, 2, or 3 corresponds to convolution with the first, second or third derivatives of a Gaussian. Higher order derivatives are not implemented \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \ntruncate : float, optional\n    Truncate the filter at this many standard deviations. Default is 4.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>gaussian_filter1d : ndarray</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_filter1d.html
scipy ndimage gaussian_filter1d	R	scipy.ndimage.gaussian_filter1d										
scipy ndimage.gaussian_filter1d	R	scipy.ndimage.gaussian_filter1d										
scipy.ndimage.gaussian_filter	A										<section class="prog__container"><p>Multidimensional Gaussian filter.</p><pre><code>scipy.ndimage.gaussian_filter(input, sigma, order=0, output=None, mode='reflect', cval=0.0, truncate=4.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsigma : scalar or sequence of scalars\n    Standard deviation for Gaussian kernel. The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes. \norder : {0, 1, 2, 3} or sequence from same set, optional\n    The order of the filter along each axis is given as a sequence of integers, or as a single number.  An order of 0 corresponds to convolution with a Gaussian kernel. An order of 1, 2, or 3 corresponds to convolution with the first, second or third derivatives of a Gaussian. Higher order derivatives are not implemented \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \ntruncate : float\n    Truncate the filter at this many standard deviations. Default is 4.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>gaussian_filter : ndarray\n    Returned array of same shape as input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.ndimage import gaussian_filter\n>>> a = np.arange(50, step=2).reshape((5,5))\n>>> a\narray([[ 0,  2,  4,  6,  8],\n       [10, 12, 14, 16, 18],\n       [20, 22, 24, 26, 28],\n       [30, 32, 34, 36, 38],\n       [40, 42, 44, 46, 48]])\n>>> gaussian_filter(a, sigma=1)\narray([[ 4,  6,  8,  9, 11],\n       [10, 12, 14, 15, 17],\n       [20, 22, 24, 25, 27],\n       [29, 31, 33, 34, 36],\n       [35, 37, 39, 40, 42]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_filter.html
scipy ndimage gaussian_filter	R	scipy.ndimage.gaussian_filter										
scipy ndimage.gaussian_filter	R	scipy.ndimage.gaussian_filter										
scipy.ndimage.gaussian_gradient_magnitude	A										<section class="prog__container"><p>Multidimensional gradient magnitude using Gaussian derivatives.</p><pre><code>scipy.ndimage.gaussian_gradient_magnitude(input, sigma, output=None, mode='reflect', cval=0.0, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsigma : scalar or sequence of scalars\n    The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes.. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \nExtra keyword arguments will be passed to gaussian_filter().</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_gradient_magnitude.html
scipy ndimage gaussian_gradient_magnitude	R	scipy.ndimage.gaussian_gradient_magnitude										
scipy ndimage.gaussian_gradient_magnitude	R	scipy.ndimage.gaussian_gradient_magnitude										
scipy.ndimage.gaussian_laplace	A										<section class="prog__container"><p>Multidimensional Laplace filter using gaussian second derivatives.</p><pre><code>scipy.ndimage.gaussian_laplace(input, sigma, output=None, mode='reflect', cval=0.0, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsigma : scalar or sequence of scalars\n    The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \nExtra keyword arguments will be passed to gaussian_filter().</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage, misc\n>>> import matplotlib.pyplot as plt\n>>> ascent = misc.ascent()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_laplace.html
scipy ndimage gaussian_laplace	R	scipy.ndimage.gaussian_laplace										
scipy ndimage.gaussian_laplace	R	scipy.ndimage.gaussian_laplace										
scipy.ndimage.generate_binary_structure	A					[[scipy.ndimage.iterate_structure]]\\n[[scipy.ndimage.binary_dilation]]\\n[[scipy.ndimage.binary_erosion]]					<section class="prog__container"><p>Generate a binary structure for binary morphological operations.</p><pre><code>scipy.ndimage.generate_binary_structure(rank, connectivity)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rank : int\n    Number of dimensions of the array to which the structuring element will be applied, as returned by np.ndim. \nconnectivity : int\n    connectivity determines which elements of the output array belong to the structure, i.e. are considered as neighbors of the central element. Elements up to a squared distance of connectivity from the center are considered neighbors. connectivity may range from 1 (no diagonal elements are neighbors) to rank (all elements are neighbors).</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray of bools\n    Structuring element which may be used for binary morphological operations, with rank dimensions and all dimensions equal to 3.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> struct = ndimage.generate_binary_structure(2, 1)\n>>> struct\narray([[False,  True, False],\n       [ True,  True,  True],\n       [False,  True, False]], dtype=bool)\n>>> a = np.zeros((5,5))\n>>> a[2, 2] = 1\n>>> a\narray([[ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.]])\n>>> b = ndimage.binary_dilation(a, structure=struct).astype(a.dtype)\n>>> b\narray([[ 0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.]])\n>>> ndimage.binary_dilation(b, structure=struct).astype(a.dtype)\narray([[ 0.,  0.,  1.,  0.,  0.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 1.,  1.,  1.,  1.,  1.],\n       [ 0.,  1.,  1.,  1.,  0.],\n       [ 0.,  0.,  1.,  0.,  0.]])\n>>> struct = ndimage.generate_binary_structure(2, 2)\n>>> struct\narray([[ True,  True,  True],\n       [ True,  True,  True],\n       [ True,  True,  True]], dtype=bool)\n>>> struct = ndimage.generate_binary_structure(3, 1)\n>>> struct # no diagonal elements\narray([[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n       [[False,  True, False],\n        [ True,  True,  True],\n        [False,  True, False]],\n       [[False, False, False],\n        [False,  True, False],\n        [False, False, False]]], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.generate_binary_structure.html
scipy ndimage generate_binary_structure	R	scipy.ndimage.generate_binary_structure										
scipy ndimage.generate_binary_structure	R	scipy.ndimage.generate_binary_structure										
scipy.ndimage.generic_filter1d	A										<section class="prog__container"><p>Calculate a one-dimensional filter along the given axis.</p><pre><code>scipy.ndimage.generic_filter1d(input, function, filter_size, axis=-1, output=None, mode='reflect', cval=0.0, origin=0, extra_arguments=(), extra_keywords=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nfunction : callable\n    Function to apply along given axis. \nfilter_size : scalar\n    Length of the filter. \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0. \nextra_arguments : sequence, optional\n    Sequence of extra positional arguments to pass to passed function \nextra_keywords : dict, optional\n    dict of extra keyword arguments to pass to passed function</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.generic_filter1d.html
scipy ndimage generic_filter1d	R	scipy.ndimage.generic_filter1d										
scipy ndimage.generic_filter1d	R	scipy.ndimage.generic_filter1d										
scipy.ndimage.generic_filter	A										<section class="prog__container"><p>Calculates a multi-dimensional filter using the given function.</p><pre><code>scipy.ndimage.generic_filter(input, function, size=None, footprint=None, output=None, mode='reflect', cval=0.0, origin=0, extra_arguments=(), extra_keywords=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nfunction : callable\n    Function to apply at each element. \nsize : scalar or tuple, optional\n    See footprint, below \nfootprint : array, optional\n    Either size or footprint must be defined.  size gives the shape that is taken from the input array, at every element position, to define the input to the filter function. footprint is a boolean array that specifies (implicitly) a shape, but also which of the elements within this shape will get passed to the filter function.  Thus size=(n,m) is equivalent to footprint=np.ones((n,m)).  We adjust size to the number of dimensions of the input array, so that, if the input array is shape (10,10,10), and size is 2, then the actual size used is (2,2,2). \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0. \nextra_arguments : sequence, optional\n    Sequence of extra positional arguments to pass to passed function \nextra_keywords : dict, optional\n    dict of extra keyword arguments to pass to passed function</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.generic_filter.html
scipy ndimage generic_filter	R	scipy.ndimage.generic_filter										
scipy ndimage.generic_filter	R	scipy.ndimage.generic_filter										
scipy.ndimage.generic_gradient_magnitude	A										<section class="prog__container"><p>Gradient magnitude using a provided gradient function.</p><pre><code>scipy.ndimage.generic_gradient_magnitude(input, derivative, output=None, mode='reflect', cval=0.0, extra_arguments=(), extra_keywords=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nderivative : callable\n    Callable with the following signature: derivative(input, axis, output, mode, cval,            *extra_arguments, **extra_keywords)   See extra_arguments, extra_keywords below. derivative can assume that input and output are ndarrays. Note that the output from derivative is modified inplace; be careful to copy important inputs before returning them. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \nextra_keywords : dict, optional\n    dict of extra keyword arguments to pass to passed function \nextra_arguments : sequence, optional\n    Sequence of extra positional arguments to pass to passed function</code></pre><span class="prog__sub">Examples:</span><pre><code>derivative(input, axis, output, mode, cval,\n           *extra_arguments, **extra_keywords)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.generic_gradient_magnitude.html
scipy ndimage generic_gradient_magnitude	R	scipy.ndimage.generic_gradient_magnitude										
scipy ndimage.generic_gradient_magnitude	R	scipy.ndimage.generic_gradient_magnitude										
scipy.ndimage.generic_laplace	A										<section class="prog__container"><p>N-dimensional Laplace filter using a provided second derivative function</p><pre><code>scipy.ndimage.generic_laplace(input, derivative2, output=None, mode='reflect', cval=0.0, extra_arguments=(), extra_keywords=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nderivative2 : callable\n    Callable with the following signature: derivative2(input, axis, output, mode, cval,             *extra_arguments, **extra_keywords)   See extra_arguments, extra_keywords below. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \nextra_keywords : dict, optional\n    dict of extra keyword arguments to pass to passed function \nextra_arguments : sequence, optional\n    Sequence of extra positional arguments to pass to passed function</code></pre><span class="prog__sub">Examples:</span><pre><code>derivative2(input, axis, output, mode, cval,\n            *extra_arguments, **extra_keywords)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.generic_laplace.html
scipy ndimage generic_laplace	R	scipy.ndimage.generic_laplace										
scipy ndimage.generic_laplace	R	scipy.ndimage.generic_laplace										
scipy.ndimage.geometric_transform	A					[[scipy.ndimage.map_coordinates]]\\n[[scipy.ndimage.affine_transform]]\\n[[scipy.ndimage.spline_filter1d]]					<section class="prog__container"><p>Apply an arbritrary geometric transform.</p><pre><code>scipy.ndimage.geometric_transform(input, mapping, output_shape=None, output=None, order=3, mode='constant', cval=0.0, prefilter=True, extra_arguments=(), extra_keywords={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    The input array. \nmapping : callable\n    A callable object that accepts a tuple of length equal to the output array rank, and returns the corresponding input coordinates as a tuple of length equal to the input array rank. \noutput_shape : tuple of ints, optional\n    Shape tuple. \noutput : ndarray or dtype, optional\n    The array in which to place the output, or the dtype of the returned array. \norder : int, optional\n    The order of the spline interpolation, default is 3. The order has to be in the range 0-5. \nmode : str, optional\n    Points outside the boundaries of the input are filled according to the given mode (‘constant’, ‘nearest’, ‘reflect’ or ‘wrap’). Default is ‘constant’. \ncval : scalar, optional\n    Value used for points outside the boundaries of the input if mode='constant'. Default is 0.0 \nprefilter : bool, optional\n    The parameter prefilter determines if the input is pre-filtered with spline_filter before interpolation (necessary for spline interpolation of order > 1).  If False, it is assumed that the input is already filtered. Default is True. \nextra_arguments : tuple, optional\n    Extra arguments passed to mapping. \nextra_keywords : dict, optional\n    Extra keywords passed to mapping.</code></pre><span class="prog__sub">Returns:</span><pre><code>return_value : ndarray or None\n    The filtered input. If output is given as a parameter, None is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.arange(12.).reshape((4, 3))\n>>> def shift_func(output_coords):\n...     return (output_coords[0] - 0.5, output_coords[1] - 0.5)\n...\n>>> ndimage.geometric_transform(a, shift_func)\narray([[ 0.   ,  0.   ,  0.   ],\n       [ 0.   ,  1.362,  2.738],\n       [ 0.   ,  4.812,  6.187],\n       [ 0.   ,  8.263,  9.637]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.geometric_transform.html
scipy ndimage geometric_transform	R	scipy.ndimage.geometric_transform										
scipy ndimage.geometric_transform	R	scipy.ndimage.geometric_transform										
scipy.ndimage.grey_closing	A					[[scipy.ndimage.binary_closing]]\\n[[scipy.ndimage.grey_dilation]]\\n[[scipy.ndimage.grey_erosion]]\\n[[scipy.ndimage.grey_opening]]\\n[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Multi-dimensional greyscale closing.</p><pre><code>scipy.ndimage.grey_closing(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array over which the grayscale closing is to be computed. \nsize : tuple of ints\n    Shape of a flat and full structuring element used for the grayscale closing. Optional if footprint or structure is provided. \nfootprint : array of ints, optional\n    Positions of non-infinite elements of a flat structuring element used for the grayscale closing. \nstructure : array of ints, optional\n    Structuring element used for the grayscale closing. structure may be a non-flat structuring element. \noutput : array, optional\n    An array used for storing the ouput of the closing may be provided. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0. \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0</code></pre><span class="prog__sub">Returns:</span><pre><code>grey_closing : ndarray\n    Result of the grayscale closing of input with structure.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.arange(36).reshape((6,6))\n>>> a[3,3] = 0\n>>> a\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20,  0, 22, 23],\n       [24, 25, 26, 27, 28, 29],\n       [30, 31, 32, 33, 34, 35]])\n>>> ndimage.grey_closing(a, size=(3,3))\narray([[ 7,  7,  8,  9, 10, 11],\n       [ 7,  7,  8,  9, 10, 11],\n       [13, 13, 14, 15, 16, 17],\n       [19, 19, 20, 20, 22, 23],\n       [25, 25, 26, 27, 28, 29],\n       [31, 31, 32, 33, 34, 35]])\n>>> # Note that the local minimum a[3,3] has disappeared</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.grey_closing.html
scipy ndimage grey_closing	R	scipy.ndimage.grey_closing										
scipy ndimage.grey_closing	R	scipy.ndimage.grey_closing										
scipy.ndimage.grey_dilation	A					[[scipy.ndimage.binary_dilation]]\\n[[scipy.ndimage.grey_erosion]]\\n[[scipy.ndimage.grey_closing]]\\n[[scipy.ndimage.grey_opening]]\\n[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Calculate a greyscale dilation, using either a structuring element,\nor a footprint corresponding to a flat structuring element.</p><pre><code>scipy.ndimage.grey_dilation(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array over which the grayscale dilation is to be computed. \nsize : tuple of ints\n    Shape of a flat and full structuring element used for the grayscale dilation. Optional if footprint or structure is provided. \nfootprint : array of ints, optional\n    Positions of non-infinite elements of a flat structuring element used for the grayscale dilation. Non-zero values give the set of neighbors of the center over which the maximum is chosen. \nstructure : array of ints, optional\n    Structuring element used for the grayscale dilation. structure may be a non-flat structuring element. \noutput : array, optional\n    An array used for storing the ouput of the dilation may be provided. \nmode : {‘reflect’,’constant’,’nearest’,’mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0. \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0</code></pre><span class="prog__sub">Returns:</span><pre><code>grey_dilation : ndarray\n    Grayscale dilation of input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((7,7), dtype=int)\n>>> a[2:5, 2:5] = 1\n>>> a[4,4] = 2; a[2,3] = 3\n>>> a\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 1, 3, 1, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 1, 1, 2, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> ndimage.grey_dilation(a, size=(3,3))\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 3, 3, 3, 1, 0],\n       [0, 1, 3, 3, 3, 1, 0],\n       [0, 1, 3, 3, 3, 2, 0],\n       [0, 1, 1, 2, 2, 2, 0],\n       [0, 1, 1, 2, 2, 2, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> ndimage.grey_dilation(a, footprint=np.ones((3,3)))\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 3, 3, 3, 1, 0],\n       [0, 1, 3, 3, 3, 1, 0],\n       [0, 1, 3, 3, 3, 2, 0],\n       [0, 1, 1, 2, 2, 2, 0],\n       [0, 1, 1, 2, 2, 2, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> s = ndimage.generate_binary_structure(2,1)\n>>> s\narray([[False,  True, False],\n       [ True,  True,  True],\n       [False,  True, False]], dtype=bool)\n>>> ndimage.grey_dilation(a, footprint=s)\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 1, 3, 1, 0, 0],\n       [0, 1, 3, 3, 3, 1, 0],\n       [0, 1, 1, 3, 2, 1, 0],\n       [0, 1, 1, 2, 2, 2, 0],\n       [0, 0, 1, 1, 2, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> ndimage.grey_dilation(a, size=(3,3), structure=np.ones((3,3)))\narray([[1, 1, 1, 1, 1, 1, 1],\n       [1, 2, 4, 4, 4, 2, 1],\n       [1, 2, 4, 4, 4, 2, 1],\n       [1, 2, 4, 4, 4, 3, 1],\n       [1, 2, 2, 3, 3, 3, 1],\n       [1, 2, 2, 3, 3, 3, 1],\n       [1, 1, 1, 1, 1, 1, 1]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.grey_dilation.html
scipy ndimage grey_dilation	R	scipy.ndimage.grey_dilation										
scipy ndimage.grey_dilation	R	scipy.ndimage.grey_dilation										
scipy.ndimage.grey_erosion	A					[[scipy.ndimage.binary_erosion]]\\n[[scipy.ndimage.grey_dilation]]\\n[[scipy.ndimage.grey_opening]]\\n[[scipy.ndimage.grey_closing]]\\n[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Calculate a greyscale erosion, using either a structuring element,\nor a footprint corresponding to a flat structuring element.</p><pre><code>scipy.ndimage.grey_erosion(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array over which the grayscale erosion is to be computed. \nsize : tuple of ints\n    Shape of a flat and full structuring element used for the grayscale erosion. Optional if footprint or structure is provided. \nfootprint : array of ints, optional\n    Positions of non-infinite elements of a flat structuring element used for the grayscale erosion. Non-zero values give the set of neighbors of the center over which the minimum is chosen. \nstructure : array of ints, optional\n    Structuring element used for the grayscale erosion. structure may be a non-flat structuring element. \noutput : array, optional\n    An array used for storing the ouput of the erosion may be provided. \nmode : {‘reflect’,’constant’,’nearest’,’mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0. \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    Grayscale erosion of input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((7,7), dtype=int)\n>>> a[1:6, 1:6] = 3\n>>> a[4,4] = 2; a[2,3] = 1\n>>> a\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 3, 3, 3, 3, 3, 0],\n       [0, 3, 3, 1, 3, 3, 0],\n       [0, 3, 3, 3, 3, 3, 0],\n       [0, 3, 3, 3, 2, 3, 0],\n       [0, 3, 3, 3, 3, 3, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> ndimage.grey_erosion(a, size=(3,3))\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 3, 2, 2, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> footprint = ndimage.generate_binary_structure(2, 1)\n>>> footprint\narray([[False,  True, False],\n       [ True,  True,  True],\n       [False,  True, False]], dtype=bool)\n>>> # Diagonally-connected elements are not considered neighbors\n>>> ndimage.grey_erosion(a, size=(3,3), footprint=footprint)\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 3, 1, 2, 0, 0],\n       [0, 0, 3, 2, 2, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.grey_erosion.html
scipy ndimage grey_erosion	R	scipy.ndimage.grey_erosion										
scipy ndimage.grey_erosion	R	scipy.ndimage.grey_erosion										
scipy.ndimage.grey_opening	A					[[scipy.ndimage.binary_opening]]\\n[[scipy.ndimage.grey_dilation]]\\n[[scipy.ndimage.grey_erosion]]\\n[[scipy.ndimage.grey_closing]]\\n[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Multi-dimensional greyscale opening.</p><pre><code>scipy.ndimage.grey_opening(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array over which the grayscale opening is to be computed. \nsize : tuple of ints\n    Shape of a flat and full structuring element used for the grayscale opening. Optional if footprint or structure is provided. \nfootprint : array of ints, optional\n    Positions of non-infinite elements of a flat structuring element used for the grayscale opening. \nstructure : array of ints, optional\n    Structuring element used for the grayscale opening. structure may be a non-flat structuring element. \noutput : array, optional\n    An array used for storing the ouput of the opening may be provided. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0. \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0</code></pre><span class="prog__sub">Returns:</span><pre><code>grey_opening : ndarray\n    Result of the grayscale opening of input with structure.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.arange(36).reshape((6,6))\n>>> a[3, 3] = 50\n>>> a\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 50, 22, 23],\n       [24, 25, 26, 27, 28, 29],\n       [30, 31, 32, 33, 34, 35]])\n>>> ndimage.grey_opening(a, size=(3,3))\narray([[ 0,  1,  2,  3,  4,  4],\n       [ 6,  7,  8,  9, 10, 10],\n       [12, 13, 14, 15, 16, 16],\n       [18, 19, 20, 22, 22, 22],\n       [24, 25, 26, 27, 28, 28],\n       [24, 25, 26, 27, 28, 28]])\n>>> # Note that the local maximum a[3,3] has disappeared</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.grey_opening.html
scipy ndimage grey_opening	R	scipy.ndimage.grey_opening										
scipy ndimage.grey_opening	R	scipy.ndimage.grey_opening										
scipy.ndimage.histogram	A										<section class="prog__container"><p>Calculate the histogram of the values of an array, optionally at labels.</p><pre><code>scipy.ndimage.histogram(input, min, max, bins, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Data for which to calculate histogram. \nmin, max : int\n    Minimum and maximum values of range of histogram bins. \nbins : int\n    Number of bins. \nlabels : array_like, optional\n    Labels for objects in input. If not None, must be same shape as input. \nindex : int or sequence of ints, optional\n    Label or labels for which to calculate histogram. If None, all values where label is greater than zero are used</code></pre><span class="prog__sub">Returns:</span><pre><code>hist : ndarray\n    Histogram counts.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[ 0.    ,  0.2146,  0.5962,  0.    ],\n...               [ 0.    ,  0.7778,  0.    ,  0.    ],\n...               [ 0.    ,  0.    ,  0.    ,  0.    ],\n...               [ 0.    ,  0.    ,  0.7181,  0.2787],\n...               [ 0.    ,  0.    ,  0.6573,  0.3094]])\n>>> from scipy import ndimage\n>>> ndimage.measurements.histogram(a, 0, 1, 10)\narray([13,  0,  2,  1,  0,  1,  1,  2,  0,  0])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.histogram.html
scipy ndimage histogram	R	scipy.ndimage.histogram										
scipy ndimage.histogram	R	scipy.ndimage.histogram										
scipy.ndimage.imread	A										<section class="prog__container"><p>Read an image from a file as an array.</p><pre><code>scipy.ndimage.imread(fname, flatten=False, mode=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fname : str or file object\n    The file name or file object to be read. \nflatten : bool, optional\n    If True, flattens the color layers into a single gray-scale layer. \nmode : str, optional\n    Mode to convert image to, e.g. 'RGB'.  See the Notes for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>imread : ndarray\n    The array obtained by reading the image.</code></pre><span class="prog__sub">Examples:</span><pre><code>L = R * 299/1000 + G * 587/1000 + B * 114/1000</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.imread.html
scipy ndimage imread	R	scipy.ndimage.imread										
scipy ndimage.imread	R	scipy.ndimage.imread										
scipy.ndimage.iterate_structure	A					[[scipy.ndimage.generate_binary_structure]]					<section class="prog__container"><p>Iterate a structure by dilating it with itself.</p><pre><code>scipy.ndimage.iterate_structure(structure, iterations, origin=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>structure : array_like\n    Structuring element (an array of bools, for example), to be dilated with itself. \niterations : int\n    number of dilations performed on the structure with itself \norigin : optional\n    If origin is None, only the iterated structure is returned. If not, a tuple of the iterated structure and the modified origin is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>iterate_structure : ndarray of bools\n    A new structuring element obtained by dilating structure (iterations - 1) times with itself.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> struct = ndimage.generate_binary_structure(2, 1)\n>>> struct.astype(int)\narray([[0, 1, 0],\n       [1, 1, 1],\n       [0, 1, 0]])\n>>> ndimage.iterate_structure(struct, 2).astype(int)\narray([[0, 0, 1, 0, 0],\n       [0, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1],\n       [0, 1, 1, 1, 0],\n       [0, 0, 1, 0, 0]])\n>>> ndimage.iterate_structure(struct, 3).astype(int)\narray([[0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1, 1, 1],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.iterate_structure.html
scipy ndimage iterate_structure	R	scipy.ndimage.iterate_structure										
scipy ndimage.iterate_structure	R	scipy.ndimage.iterate_structure										
scipy.ndimage.label	A										<section class="prog__container"><p>Label features in an array.</p><pre><code>scipy.ndimage.label(input, structure=None, output=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    An array-like object to be labeled.  Any non-zero values in input are counted as features and zero values are considered the background. \nstructure : array_like, optional\n    A structuring element that defines feature connections. structure must be symmetric.  If no structuring element is provided, one is automatically generated with a squared connectivity equal to one.  That is, for a 2-D input array, the default structuring element is: [[0,1,0],  [1,1,1],  [0,1,0]]   \noutput : (None, data-type, array_like), optional\n    If output is a data type, it specifies the type of the resulting labeled feature array If output is an array-like object, then output will be updated with the labeled features from this function.  This function can operate in-place, by passing output=input. Note that the output must be able to store the largest label, or this function will raise an Exception.</code></pre><span class="prog__sub">Returns:</span><pre><code>label : ndarray or int\n    An integer ndarray where each unique feature in input has a unique label in the returned array. \nnum_features : int\n    How many objects were found. If output is None, this function returns a tuple of (labeled_array, num_features). If output is a ndarray, then it will be updated with values in labeled_array and only num_features will be returned by this function.</code></pre><span class="prog__sub">Examples:</span><pre><code>[[0,1,0],\n [1,1,1],\n [0,1,0]]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.label.html
scipy.ndimage.labeled_comprehension	A										<section class="prog__container"><p>Roughly equivalent to [func(input[labels == i]) for i in index].</p><pre><code>scipy.ndimage.labeled_comprehension(input, labels, index, func, out_dtype, default, pass_positions=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Data from which to select labels to process. \nlabels : array_like or None\n    Labels to objects in input. If not None, array must be same shape as input. If None, func is applied to raveled input. \nindex : int, sequence of ints or None\n    Subset of labels to which to apply func. If a scalar, a single value is returned. If None, func is applied to all non-zero values of labels. \nfunc : callable\n    Python function to apply to labels from input. \nout_dtype : dtype\n    Dtype to use for result. \ndefault : int, float or None\n    Default return value when a element of index does not exist in labels. \npass_positions : bool, optional\n    If True, pass linear indices to func as a second argument. Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : ndarray\n    Result of applying func to each of labels to input in index.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2, 0, 0],\n...               [5, 3, 0, 4],\n...               [0, 0, 0, 7],\n...               [9, 3, 0, 0]])\n>>> from scipy import ndimage\n>>> lbl, nlbl = ndimage.label(a)\n>>> lbls = np.arange(1, nlbl+1)\n>>> ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, 0)\narray([ 2.75,  5.5 ,  6.  ])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.labeled_comprehension.html
scipy ndimage labeled_comprehension	R	scipy.ndimage.labeled_comprehension										
scipy ndimage.labeled_comprehension	R	scipy.ndimage.labeled_comprehension										
scipy ndimage label	R	scipy.ndimage.label										
scipy ndimage.label	R	scipy.ndimage.label										
scipy.ndimage.laplace	A										<section class="prog__container"><p>N-dimensional Laplace filter based on approximate second derivatives.</p><pre><code>scipy.ndimage.laplace(input, output=None, mode='reflect', cval=0.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage, misc\n>>> import matplotlib.pyplot as plt\n>>> ascent = misc.ascent()\n>>> result = ndimage.laplace(ascent)\n>>> plt.gray()  # show the filtered result in grayscale\n>>> plt.imshow(result)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.laplace.html
scipy ndimage laplace	R	scipy.ndimage.laplace										
scipy ndimage.laplace	R	scipy.ndimage.laplace										
scipy.ndimage.map_coordinates	A					[[scipy.ndimage.spline_filter]]\\n[[scipy.ndimage.geometric_transform]]\\n[[scipy.interpolate]]					<section class="prog__container"><p>Map the input array to new coordinates by interpolation.</p><pre><code>scipy.ndimage.map_coordinates(input, coordinates, output=None, order=3, mode='constant', cval=0.0, prefilter=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    The input array. \ncoordinates : array_like\n    The coordinates at which input is evaluated. \noutput : ndarray or dtype, optional\n    The array in which to place the output, or the dtype of the returned array. \norder : int, optional\n    The order of the spline interpolation, default is 3. The order has to be in the range 0-5. \nmode : str, optional\n    Points outside the boundaries of the input are filled according to the given mode (‘constant’, ‘nearest’, ‘reflect’ or ‘wrap’). Default is ‘constant’. \ncval : scalar, optional\n    Value used for points outside the boundaries of the input if mode='constant'. Default is 0.0 \nprefilter : bool, optional\n    The parameter prefilter determines if the input is pre-filtered with spline_filter before interpolation (necessary for spline interpolation of order > 1).  If False, it is assumed that the input is already filtered. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>map_coordinates : ndarray\n    The result of transforming the input. The shape of the output is derived from that of coordinates by dropping the first axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.arange(12.).reshape((4, 3))\n>>> a\narray([[  0.,   1.,   2.],\n       [  3.,   4.,   5.],\n       [  6.,   7.,   8.],\n       [  9.,  10.,  11.]])\n>>> ndimage.map_coordinates(a, [[0.5, 2], [0.5, 1]], order=1)\narray([ 2.,  7.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html
scipy ndimage map_coordinates	R	scipy.ndimage.map_coordinates										
scipy ndimage.map_coordinates	R	scipy.ndimage.map_coordinates										
scipy.ndimage.maximum	A					[[scipy.ndimage.label]]\\n[[scipy.ndimage.minimum]]\\n[[scipy.ndimage.median]]\\n[[scipy.ndimage.maximum_position]]\\n[[scipy.ndimage.extrema]]\\n[[scipy.ndimage.sum]]\\n[[scipy.ndimage.mean]]\\n[[scipy.ndimage.variance]]\\n[[scipy.ndimage.standard_deviation]]					<section class="prog__container"><p>Calculate the maximum of the values of an array over labeled regions.</p><pre><code>scipy.ndimage.maximum(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array_like of values. For each region specified by labels, the maximal values of input over the region is computed. \nlabels : array_like, optional\n    An array of integers marking different regions over which the maximum value of input is to be computed. labels must have the same shape as input. If labels is not specified, the maximum over the whole array is returned. \nindex : array_like, optional\n    A list of region labels that are taken into account for computing the maxima. If index is None, the maximum over all elements where labels is non-zero is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : float or list of floats\n    List of maxima of input over the regions determined by labels and whose index is in index. If index or labels are not specified, a float is returned: the maximal value of input if labels is None, and the maximal value of elements where labels is greater than zero if index is None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(16).reshape((4,4))\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n>>> labels = np.zeros_like(a)\n>>> labels[:2,:2] = 1\n>>> labels[2:, 1:3] = 2\n>>> labels\narray([[1, 1, 0, 0],\n       [1, 1, 0, 0],\n       [0, 2, 2, 0],\n       [0, 2, 2, 0]])\n>>> from scipy import ndimage\n>>> ndimage.maximum(a)\n15.0\n>>> ndimage.maximum(a, labels=labels, index=[1,2])\n[5.0, 14.0]\n>>> ndimage.maximum(a, labels=labels)\n14.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.maximum.html
scipy.ndimage.maximum_filter1d	A										<section class="prog__container"><p>Calculate a one-dimensional maximum filter along the given axis.</p><pre><code>scipy.ndimage.maximum_filter1d(input, size, axis=-1, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsize : int\n    Length along which to calculate the 1-D maximum. \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>maximum1d : ndarray, None\n    Maximum-filtered array with same shape as input. None if output is not None</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.maximum_filter1d.html
scipy ndimage maximum_filter1d	R	scipy.ndimage.maximum_filter1d										
scipy ndimage.maximum_filter1d	R	scipy.ndimage.maximum_filter1d										
scipy.ndimage.maximum_filter	A										<section class="prog__container"><p>Calculates a multi-dimensional maximum filter.</p><pre><code>scipy.ndimage.maximum_filter(input, size=None, footprint=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsize : scalar or tuple, optional\n    See footprint, below \nfootprint : array, optional\n    Either size or footprint must be defined.  size gives the shape that is taken from the input array, at every element position, to define the input to the filter function. footprint is a boolean array that specifies (implicitly) a shape, but also which of the elements within this shape will get passed to the filter function.  Thus size=(n,m) is equivalent to footprint=np.ones((n,m)).  We adjust size to the number of dimensions of the input array, so that, if the input array is shape (10,10,10), and size is 2, then the actual size used is (2,2,2). \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.maximum_filter.html
scipy ndimage maximum_filter	R	scipy.ndimage.maximum_filter										
scipy ndimage.maximum_filter	R	scipy.ndimage.maximum_filter										
scipy.ndimage.maximum_position	A					[[scipy.ndimage.label]]\\n[[scipy.ndimage.minimum]]\\n[[scipy.ndimage.median]]\\n[[scipy.ndimage.maximum_position]]\\n[[scipy.ndimage.extrema]]\\n[[scipy.ndimage.sum]]\\n[[scipy.ndimage.mean]]\\n[[scipy.ndimage.variance]]\\n[[scipy.ndimage.standard_deviation]]					<section class="prog__container"><p>Find the positions of the maximums of the values of an array at labels.</p><pre><code>scipy.ndimage.maximum_position(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array_like of values. \nlabels : array_like, optional\n    An array of integers marking different regions over which the position of the maximum value of input is to be computed. labels must have the same shape as input. If labels is not specified, the location of the first maximum over the whole array is returned. The labels argument only works when index is specified. \nindex : array_like, optional\n    A list of region labels that are taken into account for finding the location of the maxima.  If index is None, the first maximum over all elements where labels is non-zero is returned. The index argument only works when labels is specified.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : list of tuples of ints\n    List of tuples of ints that specify the location of maxima of input over the regions determined by labels and whose index is in index. If index or labels are not specified, a tuple of ints is returned specifying the location of the first maximal value of input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.maximum_position.html
scipy ndimage maximum_position	R	scipy.ndimage.maximum_position										
scipy ndimage.maximum_position	R	scipy.ndimage.maximum_position										
scipy ndimage maximum	R	scipy.ndimage.maximum										
scipy ndimage.maximum	R	scipy.ndimage.maximum										
scipy.ndimage.mean	A										<section class="prog__container"><p>Calculate the mean of the values of an array at labels.</p><pre><code>scipy.ndimage.mean(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array on which to compute the mean of elements over distinct regions. \nlabels : array_like, optional\n    Array of labels of same shape, or broadcastable to the same shape as input. All elements sharing the same label form one region over which the mean of the elements is computed. \nindex : int or sequence of ints, optional\n    Labels of the objects over which the mean is to be computed. Default is None, in which case the mean for all values where label is greater than 0 is calculated.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : list\n    Sequence of same length as index, with the mean of the different regions labeled by the labels in index.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.arange(25).reshape((5,5))\n>>> labels = np.zeros_like(a)\n>>> labels[3:5,3:5] = 1\n>>> index = np.unique(labels)\n>>> labels\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 1],\n       [0, 0, 0, 1, 1]])\n>>> index\narray([0, 1])\n>>> ndimage.mean(a, labels=labels, index=index)\n[10.285714285714286, 21.0]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.mean.html
scipy ndimage mean	R	scipy.ndimage.mean										
scipy ndimage.mean	R	scipy.ndimage.mean										
scipy.ndimage.median	A					[[scipy.ndimage.label]]\\n[[scipy.ndimage.minimum]]\\n[[scipy.ndimage.maximum]]\\n[[scipy.ndimage.extrema]]\\n[[scipy.ndimage.sum]]\\n[[scipy.ndimage.mean]]\\n[[scipy.ndimage.variance]]\\n[[scipy.ndimage.standard_deviation]]					<section class="prog__container"><p>Calculate the median of the values of an array over labeled regions.</p><pre><code>scipy.ndimage.median(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array_like of values. For each region specified by labels, the median value of input over the region is computed. \nlabels : array_like, optional\n    An array_like of integers marking different regions over which the median value of input is to be computed. labels must have the same shape as input. If labels is not specified, the median over the whole array is returned. \nindex : array_like, optional\n    A list of region labels that are taken into account for computing the medians. If index is None, the median over all elements where labels is non-zero is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : float or list of floats\n    List of medians of input over the regions determined by labels and whose index is in index. If index or labels are not specified, a float is returned: the median value of input if labels is None, and the median value of elements where labels is greater than zero if index is None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.array([[1, 2, 0, 1],\n...               [5, 3, 0, 4],\n...               [0, 0, 0, 7],\n...               [9, 3, 0, 0]])\n>>> labels, labels_nb = ndimage.label(a)\n>>> labels\narray([[1, 1, 0, 2],\n       [1, 1, 0, 2],\n       [0, 0, 0, 2],\n       [3, 3, 0, 0]])\n>>> ndimage.median(a, labels=labels, index=np.arange(1, labels_nb + 1))\n[2.5, 4.0, 6.0]\n>>> ndimage.median(a)\n1.0\n>>> ndimage.median(a, labels=labels)\n3.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.median.html
scipy.ndimage.median_filter	A										<section class="prog__container"><p>Calculates a multidimensional median filter.</p><pre><code>scipy.ndimage.median_filter(input, size=None, footprint=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsize : scalar or tuple, optional\n    See footprint, below \nfootprint : array, optional\n    Either size or footprint must be defined.  size gives the shape that is taken from the input array, at every element position, to define the input to the filter function. footprint is a boolean array that specifies (implicitly) a shape, but also which of the elements within this shape will get passed to the filter function.  Thus size=(n,m) is equivalent to footprint=np.ones((n,m)).  We adjust size to the number of dimensions of the input array, so that, if the input array is shape (10,10,10), and size is 2, then the actual size used is (2,2,2). \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>median_filter : ndarray\n    Return of same shape as input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.median_filter.html
scipy ndimage median_filter	R	scipy.ndimage.median_filter										
scipy ndimage.median_filter	R	scipy.ndimage.median_filter										
scipy ndimage median	R	scipy.ndimage.median										
scipy ndimage.median	R	scipy.ndimage.median										
scipy.ndimage.minimum	A					[[scipy.ndimage.label]]\\n[[scipy.ndimage.maximum]]\\n[[scipy.ndimage.median]]\\n[[scipy.ndimage.minimum_position]]\\n[[scipy.ndimage.extrema]]\\n[[scipy.ndimage.sum]]\\n[[scipy.ndimage.mean]]\\n[[scipy.ndimage.variance]]\\n[[scipy.ndimage.standard_deviation]]					<section class="prog__container"><p>Calculate the minimum of the values of an array over labeled regions.</p><pre><code>scipy.ndimage.minimum(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array_like of values. For each region specified by labels, the minimal values of input over the region is computed. \nlabels : array_like, optional\n    An array_like of integers marking different regions over which the minimum value of input is to be computed. labels must have the same shape as input. If labels is not specified, the minimum over the whole array is returned. \nindex : array_like, optional\n    A list of region labels that are taken into account for computing the minima. If index is None, the minimum over all elements where labels is non-zero is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>minimum : float or list of floats\n    List of minima of input over the regions determined by labels and whose index is in index. If index or labels are not specified, a float is returned: the minimal value of input if labels is None, and the minimal value of elements where labels is greater than zero if index is None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.array([[1, 2, 0, 0],\n...               [5, 3, 0, 4],\n...               [0, 0, 0, 7],\n...               [9, 3, 0, 0]])\n>>> labels, labels_nb = ndimage.label(a)\n>>> labels\narray([[1, 1, 0, 0],\n       [1, 1, 0, 2],\n       [0, 0, 0, 2],\n       [3, 3, 0, 0]])\n>>> ndimage.minimum(a, labels=labels, index=np.arange(1, labels_nb + 1))\n[1.0, 4.0, 3.0]\n>>> ndimage.minimum(a)\n0.0\n>>> ndimage.minimum(a, labels=labels)\n1.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.minimum.html
scipy.ndimage.minimum_filter1d	A										<section class="prog__container"><p>Calculate a one-dimensional minimum filter along the given axis.</p><pre><code>scipy.ndimage.minimum_filter1d(input, size, axis=-1, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsize : int\n    length along which to calculate 1D minimum \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.minimum_filter1d.html
scipy ndimage minimum_filter1d	R	scipy.ndimage.minimum_filter1d										
scipy ndimage.minimum_filter1d	R	scipy.ndimage.minimum_filter1d										
scipy.ndimage.minimum_filter	A										<section class="prog__container"><p>Calculates a multi-dimensional minimum filter.</p><pre><code>scipy.ndimage.minimum_filter(input, size=None, footprint=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsize : scalar or tuple, optional\n    See footprint, below \nfootprint : array, optional\n    Either size or footprint must be defined.  size gives the shape that is taken from the input array, at every element position, to define the input to the filter function. footprint is a boolean array that specifies (implicitly) a shape, but also which of the elements within this shape will get passed to the filter function.  Thus size=(n,m) is equivalent to footprint=np.ones((n,m)).  We adjust size to the number of dimensions of the input array, so that, if the input array is shape (10,10,10), and size is 2, then the actual size used is (2,2,2). \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.minimum_filter.html
scipy ndimage minimum_filter	R	scipy.ndimage.minimum_filter										
scipy ndimage.minimum_filter	R	scipy.ndimage.minimum_filter										
scipy.ndimage.minimum_position	A					[[scipy.ndimage.label]]\\n[[scipy.ndimage.minimum]]\\n[[scipy.ndimage.median]]\\n[[scipy.ndimage.maximum_position]]\\n[[scipy.ndimage.extrema]]\\n[[scipy.ndimage.sum]]\\n[[scipy.ndimage.mean]]\\n[[scipy.ndimage.variance]]\\n[[scipy.ndimage.standard_deviation]]					<section class="prog__container"><p>Find the positions of the minimums of the values of an array at labels.</p><pre><code>scipy.ndimage.minimum_position(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array_like of values. \nlabels : array_like, optional\n    An array of integers marking different regions over which the position of the minimum value of input is to be computed. labels must have the same shape as input. If labels is not specified, the location of the first minimum over the whole array is returned. The labels argument only works when index is specified. \nindex : array_like, optional\n    A list of region labels that are taken into account for finding the location of the minima. If index is None, the first minimum over all elements where labels is non-zero is returned. The index argument only works when labels is specified.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : list of tuples of ints\n    Tuple of ints or list of tuples of ints that specify the location of minima of input over the regions determined by labels and whose index is in index. If index or labels are not specified, a tuple of ints is returned specifying the location of the first minimal value of input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.minimum_position.html
scipy ndimage minimum_position	R	scipy.ndimage.minimum_position										
scipy ndimage.minimum_position	R	scipy.ndimage.minimum_position										
scipy ndimage minimum	R	scipy.ndimage.minimum										
scipy ndimage.minimum	R	scipy.ndimage.minimum										
scipy.ndimage.morphological_gradient	A					[[scipy.ndimage.grey_dilation]]\\n[[scipy.ndimage.grey_erosion]]					<section class="prog__container"><p>Multi-dimensional morphological gradient.</p><pre><code>scipy.ndimage.morphological_gradient(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Array over which to compute the morphlogical gradient. \nsize : tuple of ints\n    Shape of a flat and full structuring element used for the mathematical morphology operations. Optional if footprint or structure is provided. A larger size yields a more blurred gradient. \nfootprint : array of ints, optional\n    Positions of non-infinite elements of a flat structuring element used for the morphology operations. Larger footprints give a more blurred morphological gradient. \nstructure : array of ints, optional\n    Structuring element used for the morphology operations. structure may be a non-flat structuring element. \noutput : array, optional\n    An array used for storing the ouput of the morphological gradient may be provided. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0. \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0</code></pre><span class="prog__sub">Returns:</span><pre><code>morphological_gradient : ndarray\n    Morphological gradient of input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> a = np.zeros((7,7), dtype=int)\n>>> a[2:5, 2:5] = 1\n>>> ndimage.morphological_gradient(a, size=(3,3))\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 1, 1, 0, 1, 1, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> # The morphological gradient is computed as the difference\n>>> # between a dilation and an erosion\n>>> ndimage.grey_dilation(a, size=(3,3)) -\\n...  ndimage.grey_erosion(a, size=(3,3))\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 1, 1, 0, 1, 1, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 1, 1, 1, 1, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> a = np.zeros((7,7), dtype=int)\n>>> a[2:5, 2:5] = 1\n>>> a[4,4] = 2; a[2,3] = 3\n>>> a\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 1, 3, 1, 0, 0],\n       [0, 0, 1, 1, 1, 0, 0],\n       [0, 0, 1, 1, 2, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0]])\n>>> ndimage.morphological_gradient(a, size=(3,3))\narray([[0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 3, 3, 3, 1, 0],\n       [0, 1, 3, 3, 3, 1, 0],\n       [0, 1, 3, 2, 3, 2, 0],\n       [0, 1, 1, 2, 2, 2, 0],\n       [0, 1, 1, 2, 2, 2, 0],\n       [0, 0, 0, 0, 0, 0, 0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.morphological_gradient.html
scipy ndimage morphological_gradient	R	scipy.ndimage.morphological_gradient										
scipy ndimage.morphological_gradient	R	scipy.ndimage.morphological_gradient										
scipy.ndimage.morphological_laplace	A										<section class="prog__container"><p>Multi-dimensional morphological laplace.</p><pre><code>scipy.ndimage.morphological_laplace(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input. \nsize : int or sequence of ints, optional\n    See structure. \nfootprint : bool or ndarray, optional\n    See structure. \nstructure : structure, optional\n    Either size, footprint, or the structure must be provided. \noutput : ndarray, optional\n    An output array can optionally be provided. \nmode : {‘reflect’,’constant’,’nearest’,’mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled. For ‘constant’ mode, values beyond borders are set to be cval. Default is ‘reflect’. \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : origin, optional\n    The origin parameter controls the placement of the filter.</code></pre><span class="prog__sub">Returns:</span><pre><code>morphological_laplace : ndarray\n    Output</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.morphological_laplace.html
scipy ndimage morphological_laplace	R	scipy.ndimage.morphological_laplace										
scipy ndimage.morphological_laplace	R	scipy.ndimage.morphological_laplace										
scipy.ndimage.percentile_filter	A										<section class="prog__container"><p>Calculates a multi-dimensional percentile filter.</p><pre><code>scipy.ndimage.percentile_filter(input, percentile, size=None, footprint=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \npercentile : scalar\n    The percentile parameter may be less then zero, i.e., percentile = -20 equals percentile = 80 \nsize : scalar or tuple, optional\n    See footprint, below \nfootprint : array, optional\n    Either size or footprint must be defined.  size gives the shape that is taken from the input array, at every element position, to define the input to the filter function. footprint is a boolean array that specifies (implicitly) a shape, but also which of the elements within this shape will get passed to the filter function.  Thus size=(n,m) is equivalent to footprint=np.ones((n,m)).  We adjust size to the number of dimensions of the input array, so that, if the input array is shape (10,10,10), and size is 2, then the actual size used is (2,2,2). \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.percentile_filter.html
scipy ndimage percentile_filter	R	scipy.ndimage.percentile_filter										
scipy ndimage.percentile_filter	R	scipy.ndimage.percentile_filter										
scipy.ndimage.prewitt	A										<section class="prog__container"><p>Calculate a Prewitt filter.</p><pre><code>scipy.ndimage.prewitt(input, axis=-1, output=None, mode='reflect', cval=0.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage, misc\n>>> import matplotlib.pyplot as plt\n>>> ascent = misc.ascent()\n>>> result = ndimage.prewitt(ascent)\n>>> plt.gray()  # show the filtered result in grayscale\n>>> plt.imshow(result)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.prewitt.html
scipy ndimage prewitt	R	scipy.ndimage.prewitt										
scipy ndimage.prewitt	R	scipy.ndimage.prewitt										
scipy.ndimage.rank_filter	A										<section class="prog__container"><p>Calculates a multi-dimensional rank filter.</p><pre><code>scipy.ndimage.rank_filter(input, rank, size=None, footprint=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nrank : int\n    The rank parameter may be less then zero, i.e., rank = -1 indicates the largest element. \nsize : scalar or tuple, optional\n    See footprint, below \nfootprint : array, optional\n    Either size or footprint must be defined.  size gives the shape that is taken from the input array, at every element position, to define the input to the filter function. footprint is a boolean array that specifies (implicitly) a shape, but also which of the elements within this shape will get passed to the filter function.  Thus size=(n,m) is equivalent to footprint=np.ones((n,m)).  We adjust size to the number of dimensions of the input array, so that, if the input array is shape (10,10,10), and size is 2, then the actual size used is (2,2,2). \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.rank_filter.html
scipy ndimage rank_filter	R	scipy.ndimage.rank_filter										
scipy ndimage.rank_filter	R	scipy.ndimage.rank_filter										
scipy.ndimage.rotate	A										<section class="prog__container"><p>Rotate an array.</p><pre><code>scipy.ndimage.rotate(input, angle, axes=(1, 0), reshape=True, output=None, order=3, mode='constant', cval=0.0, prefilter=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    The input array. \nangle : float\n    The rotation angle in degrees. \naxes : tuple of 2 ints, optional\n    The two axes that define the plane of rotation. Default is the first two axes. \nreshape : bool, optional\n    If reshape is true, the output shape is adapted so that the input array is contained completely in the output. Default is True. \noutput : ndarray or dtype, optional\n    The array in which to place the output, or the dtype of the returned array. \norder : int, optional\n    The order of the spline interpolation, default is 3. The order has to be in the range 0-5. \nmode : str, optional\n    Points outside the boundaries of the input are filled according to the given mode (‘constant’, ‘nearest’, ‘reflect’ or ‘wrap’). Default is ‘constant’. \ncval : scalar, optional\n    Value used for points outside the boundaries of the input if mode='constant'. Default is 0.0 \nprefilter : bool, optional\n    The parameter prefilter determines if the input is pre-filtered with spline_filter before interpolation (necessary for spline interpolation of order > 1).  If False, it is assumed that the input is already filtered. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>rotate : ndarray or None\n    The rotated input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.rotate.html
scipy ndimage rotate	R	scipy.ndimage.rotate										
scipy ndimage.rotate	R	scipy.ndimage.rotate										
scipy.ndimage.shift	A										<section class="prog__container"><p>Shift an array.</p><pre><code>scipy.ndimage.shift(input, shift, output=None, order=3, mode='constant', cval=0.0, prefilter=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    The input array. \nshift : float or sequence, optional\n    The shift along the axes. If a float, shift is the same for each axis. If a sequence, shift should contain one value for each axis. \noutput : ndarray or dtype, optional\n    The array in which to place the output, or the dtype of the returned array. \norder : int, optional\n    The order of the spline interpolation, default is 3. The order has to be in the range 0-5. \nmode : str, optional\n    Points outside the boundaries of the input are filled according to the given mode (‘constant’, ‘nearest’, ‘reflect’ or ‘wrap’). Default is ‘constant’. \ncval : scalar, optional\n    Value used for points outside the boundaries of the input if mode='constant'. Default is 0.0 \nprefilter : bool, optional\n    The parameter prefilter determines if the input is pre-filtered with spline_filter before interpolation (necessary for spline interpolation of order > 1).  If False, it is assumed that the input is already filtered. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>shift : ndarray or None\n    The shifted input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.shift.html
scipy ndimage shift	R	scipy.ndimage.shift										
scipy ndimage.shift	R	scipy.ndimage.shift										
scipy.ndimage.sobel	A										<section class="prog__container"><p>Calculate a Sobel filter.</p><pre><code>scipy.ndimage.sobel(input, axis=-1, output=None, mode='reflect', cval=0.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage, misc\n>>> import matplotlib.pyplot as plt\n>>> ascent = misc.ascent()\n>>> result = ndimage.sobel(ascent)\n>>> plt.gray()  # show the filtered result in grayscale\n>>> plt.imshow(result)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.sobel.html
scipy ndimage sobel	R	scipy.ndimage.sobel										
scipy ndimage.sobel	R	scipy.ndimage.sobel										
scipy.ndimage.spline_filter1d	A										<section class="prog__container"><p>Calculates a one-dimensional spline filter along the given axis.</p><pre><code>scipy.ndimage.spline_filter1d(input, order=3, axis=-1, output=<type 'numpy.float64'>)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    The input array. \norder : int, optional\n    The order of the spline, default is 3. \naxis : int, optional\n    The axis along which the spline filter is applied. Default is the last axis. \noutput : ndarray or dtype, optional\n    The array in which to place the output, or the dtype of the returned array. Default is numpy.float64.</code></pre><span class="prog__sub">Returns:</span><pre><code>spline_filter1d : ndarray or None\n    The filtered input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.spline_filter1d.html
scipy ndimage spline_filter1d	R	scipy.ndimage.spline_filter1d										
scipy ndimage.spline_filter1d	R	scipy.ndimage.spline_filter1d										
scipy.ndimage.spline_filter	A					[[scipy.ndimage.spline_filter1d]]					<section class="prog__container"><p>Multi-dimensional spline filter.</p><pre><code>scipy.ndimage.spline_filter(input, order=3, output=<type 'numpy.float64'>)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.spline_filter.html
scipy ndimage spline_filter	R	scipy.ndimage.spline_filter										
scipy ndimage.spline_filter	R	scipy.ndimage.spline_filter										
scipy.ndimage.standard_deviation	A					[[scipy.ndimage.label]]\\n[[scipy.ndimage.variance]]\\n[[scipy.ndimage.maximum]]\\n[[scipy.ndimage.minimum]]\\n[[scipy.ndimage.extrema]]					<section class="prog__container"><p>Calculate the standard deviation of the values of an n-D image array,\noptionally at specified sub-regions.</p><pre><code>scipy.ndimage.standard_deviation(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Nd-image data to process. \nlabels : array_like, optional\n    Labels to identify sub-regions in input. If not None, must be same shape as input. \nindex : int or sequence of ints, optional\n    labels to include in output.  If None (default), all values where labels is non-zero are used.</code></pre><span class="prog__sub">Returns:</span><pre><code>standard_deviation : float or ndarray\n    Values of standard deviation, for each sub-region if labels and index are specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2, 0, 0],\n...               [5, 3, 0, 4],\n...               [0, 0, 0, 7],\n...               [9, 3, 0, 0]])\n>>> from scipy import ndimage\n>>> ndimage.standard_deviation(a)\n2.7585095613392387</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.standard_deviation.html
scipy ndimage standard_deviation	R	scipy.ndimage.standard_deviation										
scipy ndimage.standard_deviation	R	scipy.ndimage.standard_deviation										
scipy.ndimage.sum	A					[[scipy.ndimage.mean]]\\n[[scipy.ndimage.median]]					<section class="prog__container"><p>Calculate the sum of the values of the array.</p><pre><code>scipy.ndimage.sum(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Values of input inside the regions defined by labels are summed together. \nlabels : array_like of ints, optional\n    Assign labels to the values of the array. Has to have the same shape as input. \nindex : array_like, optional\n    A single label number or a sequence of label numbers of the objects to be measured.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum : ndarray or scalar\n    An array of the sums of values of input inside the regions defined by labels with the same shape as index. If ‘index’ is None or scalar, a scalar is returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import ndimage\n>>> input =  [0,1,2,3]\n>>> labels = [1,1,2,2]\n>>> ndimage.sum(input, labels, index=[1,2])\n[1.0, 5.0]\n>>> ndimage.sum(input, labels, index=1)\n1\n>>> ndimage.sum(input, labels)\n6</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.sum.html
scipy ndimage sum	R	scipy.ndimage.sum										
scipy ndimage.sum	R	scipy.ndimage.sum										
scipy.ndimage.uniform_filter1d	A										<section class="prog__container"><p>Calculate a one-dimensional uniform filter along the given axis.</p><pre><code>scipy.ndimage.uniform_filter1d(input, size, axis=-1, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsize : int\n    length of uniform filter \naxis : int, optional\n    The axis of input along which to calculate. Default is -1. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.uniform_filter1d.html
scipy ndimage uniform_filter1d	R	scipy.ndimage.uniform_filter1d										
scipy ndimage.uniform_filter1d	R	scipy.ndimage.uniform_filter1d										
scipy.ndimage.uniform_filter	A										<section class="prog__container"><p>Multi-dimensional uniform filter.</p><pre><code>scipy.ndimage.uniform_filter(input, size=3, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input array to filter. \nsize : int or sequence of ints, optional\n    The sizes of the uniform filter are given for each axis as a sequence, or as a single number, in which case the size is equal for all axes. \noutput : array, optional\n    The output parameter passes an array in which to store the filter output. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0 \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default 0.0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.uniform_filter.html
scipy ndimage uniform_filter	R	scipy.ndimage.uniform_filter										
scipy ndimage.uniform_filter	R	scipy.ndimage.uniform_filter										
scipy.ndimage.variance	A					[[scipy.ndimage.label]]\\n[[scipy.ndimage.standard_deviation]]\\n[[scipy.ndimage.maximum]]\\n[[scipy.ndimage.minimum]]\\n[[scipy.ndimage.extrema]]					<section class="prog__container"><p>Calculate the variance of the values of an n-D image array, optionally at\nspecified sub-regions.</p><pre><code>scipy.ndimage.variance(input, labels=None, index=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Nd-image data to process. \nlabels : array_like, optional\n    Labels defining sub-regions in input. If not None, must be same shape as input. \nindex : int or sequence of ints, optional\n    labels to include in output.  If None (default), all values where labels is non-zero are used.</code></pre><span class="prog__sub">Returns:</span><pre><code>variance : float or ndarray\n    Values of variance, for each sub-region if labels and index are specified.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[1, 2, 0, 0],\n...               [5, 3, 0, 4],\n...               [0, 0, 0, 7],\n...               [9, 3, 0, 0]])\n>>> from scipy import ndimage\n>>> ndimage.variance(a)\n7.609375</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.variance.html
scipy ndimage variance	R	scipy.ndimage.variance										
scipy ndimage.variance	R	scipy.ndimage.variance										
scipy.ndimage.watershed_ift	A										<section class="prog__container"><p>Apply watershed from markers using image foresting transform algorithm.</p><pre><code>scipy.ndimage.watershed_ift(input, markers, structure=None, output=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input. \nmarkers : array_like\n    Markers are points within each watershed that form the beginning of the process.  Negative markers are considered background markers which are processed after the other markers. \nstructure : structure element, optional\n    A structuring element defining the connectivity of the object can be provided. If None, an element is generated with a squared connectivity equal to one. \noutput : ndarray, optional\n    An output array can optionally be provided.  The same shape as input.</code></pre><span class="prog__sub">Returns:</span><pre><code>watershed_ift : ndarray\n    Output.  Same shape as input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.watershed_ift.html
scipy ndimage watershed_ift	R	scipy.ndimage.watershed_ift										
scipy ndimage.watershed_ift	R	scipy.ndimage.watershed_ift										
scipy.ndimage.white_tophat	A					[[scipy.ndimage.black_tophat]]					<section class="prog__container"><p>Multi-dimensional white tophat filter.</p><pre><code>scipy.ndimage.white_tophat(input, size=None, footprint=None, structure=None, output=None, mode='reflect', cval=0.0, origin=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    Input. \nsize : tuple of ints\n    Shape of a flat and full structuring element used for the filter. Optional if footprint or structure is provided. \nfootprint : array of ints, optional\n    Positions of elements of a flat structuring element used for the white tophat filter. \nstructure : array of ints, optional\n    Structuring element used for the filter. structure may be a non-flat structuring element. \noutput : array, optional\n    An array used for storing the output of the filter may be provided. \nmode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional\n    The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’ \ncval : scalar, optional\n    Value to fill past edges of input if mode is ‘constant’. Default is 0.0. \norigin : scalar, optional\n    The origin parameter controls the placement of the filter. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    Result of the filter of input with structure.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.white_tophat.html
scipy ndimage white_tophat	R	scipy.ndimage.white_tophat										
scipy ndimage.white_tophat	R	scipy.ndimage.white_tophat										
scipy.ndimage.zoom	A										<section class="prog__container"><p>Zoom an array.</p><pre><code>scipy.ndimage.zoom(input, zoom, output=None, order=3, mode='constant', cval=0.0, prefilter=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    The input array. \nzoom : float or sequence, optional\n    The zoom factor along the axes. If a float, zoom is the same for each axis. If a sequence, zoom should contain one value for each axis. \noutput : ndarray or dtype, optional\n    The array in which to place the output, or the dtype of the returned array. \norder : int, optional\n    The order of the spline interpolation, default is 3. The order has to be in the range 0-5. \nmode : str, optional\n    Points outside the boundaries of the input are filled according to the given mode (‘constant’, ‘nearest’, ‘reflect’ or ‘wrap’). Default is ‘constant’. \ncval : scalar, optional\n    Value used for points outside the boundaries of the input if mode='constant'. Default is 0.0 \nprefilter : bool, optional\n    The parameter prefilter determines if the input is pre-filtered with spline_filter before interpolation (necessary for spline interpolation of order > 1).  If False, it is assumed that the input is already filtered. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>zoom : ndarray or None\n    The zoomed input. If output is given as a parameter, None is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.zoom.html
scipy ndimage zoom	R	scipy.ndimage.zoom										
scipy ndimage.zoom	R	scipy.ndimage.zoom										
scipy.odr.Data	A										<section class="prog__container"><p>The data to fit.</p><pre><code>class scipy.odr.Data(x, y=None, we=None, wd=None, fix=None, meta={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Observed data for the independent variable of the regression \ny : array_like, optional\n    If array-like, observed data for the dependent variable of the regression. A scalar input implies that the model to be used on the data is implicit. \nwe : array_like, optional\n    If we is a scalar, then that value is used for all data points (and all dimensions of the response variable). If we is a rank-1 array of length q (the dimensionality of the response variable), then this vector is the diagonal of the covariant weighting matrix for all data points. If we is a rank-1 array of length n (the number of data points), then the i’th element is the weight for the i’th response variable observation (single-dimensional only). If we is a rank-2 array of shape (q, q), then this is the full covariant weighting matrix broadcast to each observation. If we is a rank-2 array of shape (q, n), then we[:,i] is the diagonal of the covariant weighting matrix for the i’th observation. If we is a rank-3 array of shape (q, q, n), then we[:,:,i] is the full specification of the covariant weighting matrix for each observation. If the fit is implicit, then only a positive scalar value is used. \nwd : array_like, optional\n    If wd is a scalar, then that value is used for all data points (and all dimensions of the input variable). If wd = 0, then the covariant weighting matrix for each observation is set to the identity matrix (so each dimension of each observation has the same weight). If wd is a rank-1 array of length m (the dimensionality of the input variable), then this vector is the diagonal of the covariant weighting matrix for all data points. If wd is a rank-1 array of length n (the number of data points), then the i’th element is the weight for the i’th input variable observation (single-dimensional only). If wd is a rank-2 array of shape (m, m), then this is the full covariant weighting matrix broadcast to each observation. If wd is a rank-2 array of shape (m, n), then wd[:,i] is the diagonal of the covariant weighting matrix for the i’th observation. If wd is a rank-3 array of shape (m, m, n), then wd[:,:,i] is the full specification of the covariant weighting matrix for each observation. \nfix : array_like of ints, optional\n    The fix argument is the same as ifixx in the class ODR. It is an array of integers with the same shape as data.x that determines which input observations are treated as fixed. One can use a sequence of length m (the dimensionality of the input observations) to fix some dimensions for all observations. A value of 0 fixes the observation, a value > 0 makes it free. \nmeta : dict, optional\n    Free-form dictionary for metadata.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Data.html
scipy odr Data	R	scipy.odr.Data										
scipy odr.Data	R	scipy.odr.Data										
scipy.odr.Data.set_meta	A										<section class="prog__container"><p>Update the metadata dictionary with the keywords and data provided\nby keywords.</p><pre><code>Data.set_meta(**kwds)</code></pre><span class="prog__sub">Examples:</span><pre><code>data.set_meta(lab="Ph 7; Lab 26", title="Ag110 + Ag108 Decay")</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Data.set_meta.html
scipy odr Data set_meta	R	scipy.odr.Data.set_meta										
scipy odr.Data.set_meta	R	scipy.odr.Data.set_meta										
scipy.odr.Model	A										<section class="prog__container"><p>The Model class stores information about the function you wish to fit.</p><pre><code>class scipy.odr.Model(fcn, fjacb=None, fjacd=None, extra_args=None, estimate=None, implicit=0, meta=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fcn : function\n    fcn(beta, x) –> y \nfjacb : function\n    Jacobian of fcn wrt the fit parameters beta. fjacb(beta, x) –> @f_i(x,B)/@B_j \nfjacd : function\n    Jacobian of fcn wrt the (possibly multidimensional) input variable. fjacd(beta, x) –> @f_i(x,B)/@x_j \nextra_args : tuple, optional\n    If specified, extra_args should be a tuple of extra arguments to pass to fcn, fjacb, and fjacd. Each will be called by apply(fcn, (beta, x) + extra_args) \nestimate : array_like of rank-1\n    Provides estimates of the fit parameters from the data estimate(data) –> estbeta \nimplicit : boolean\n    If TRUE, specifies that the model is implicit; i.e fcn(beta, x) ~= 0 and there is no y data to fit against \nmeta : dict, optional\n    freeform dictionary of metadata for the model</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Model.html
scipy odr Model	R	scipy.odr.Model										
scipy odr.Model	R	scipy.odr.Model										
scipy.odr.Model.set_meta	A										<section class="prog__container"><p>Update the metadata dictionary with the keywords and data provided\nhere.</p><pre><code>Model.set_meta(**kwds)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Model.set_meta.html
scipy odr Model set_meta	R	scipy.odr.Model.set_meta										
scipy odr.Model.set_meta	R	scipy.odr.Model.set_meta										
scipy.odr.odr	A					[[scipy.odr.ODR]]\\n[[scipy.odr.Model]]\\n[[scipy.odr.Data]]\\n[[scipy.odr.RealData]]					<section class="prog__container"><p>Low-level function for ODR.</p><pre><code>scipy.odr.odr(fcn, beta0, y, x, we=None, wd=None, fjacb=None, fjacd=None, extra_args=None, ifixx=None, ifixb=None, job=0, iprint=0, errfile=None, rptfile=None, ndigit=0, taufac=0.0, sstol=-1.0, partol=-1.0, maxit=-1, stpb=None, stpd=None, sclb=None, scld=None, work=None, iwork=None, full_output=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.odr.html
scipy.odr.ODR	A										<section class="prog__container"><p>The ODR class gathers all information and coordinates the running of the\nmain fitting routine.</p><pre><code>class scipy.odr.ODR(data, model, beta0=None, delta0=None, ifixb=None, ifixx=None, job=None, iprint=None, errfile=None, rptfile=None, ndigit=None, taufac=None, sstol=None, partol=None, maxit=None, stpb=None, stpd=None, sclb=None, scld=None, work=None, iwork=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : Data class instance\n    instance of the Data class \nmodel : Model class instance\n    instance of the Model class</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.ODR.html
scipy.odr.odr_error	A										<section class="prog__container"><p>alias of OdrError</p><pre><code>scipy.odr.odr_error</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.odr_error.html
scipy.odr.OdrError	A										<section class="prog__container"><p>Exception indicating an error in fitting.</p><pre><code>exception scipy.odr.OdrError</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.OdrError.html
scipy odr odr_error	R	scipy.odr.odr_error										
scipy odr.odr_error	R	scipy.odr.odr_error										
scipy odr OdrError	R	scipy.odr.OdrError										
scipy odr.OdrError	R	scipy.odr.OdrError										
scipy.odr.ODR.restart	A										<section class="prog__container"><p>Restarts the run with iter more iterations.</p><pre><code>ODR.restart(iter=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>iter : int, optional\n    ODRPACK’s default for the number of new iterations is 10.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : Output instance\n    This object is also assigned to the attribute .output .</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.ODR.restart.html
scipy odr ODR restart	R	scipy.odr.ODR.restart										
scipy odr.ODR.restart	R	scipy.odr.ODR.restart										
scipy odr odr	R	scipy.odr.odr										
scipy odr.odr	R	scipy.odr.odr										
scipy odr ODR	R	scipy.odr.ODR										
scipy odr.ODR	R	scipy.odr.ODR										
scipy.odr.ODR.run	A										<section class="prog__container"><p>Run the fitting routine with all of the information given.</p><pre><code>ODR.run()</code></pre><span class="prog__sub">Parameters:</span><pre><code>output : Output instance\n    This object is also assigned to the attribute .output .</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.ODR.run.html
scipy odr ODR run	R	scipy.odr.ODR.run										
scipy odr.ODR.run	R	scipy.odr.ODR.run										
scipy.odr.ODR.set_iprint	A										<section class="prog__container"><p>Set the iprint parameter for the printing of computation reports.</p><pre><code>ODR.set_iprint(init=None, so_init=None, iter=None, so_iter=None, iter_step=None, final=None, so_final=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.ODR.set_iprint.html
scipy odr ODR set_iprint	R	scipy.odr.ODR.set_iprint										
scipy odr.ODR.set_iprint	R	scipy.odr.ODR.set_iprint										
scipy.odr.ODR.set_job	A										<section class="prog__container"><p>Sets the “job” parameter is a hopefully comprehensible way.</p><pre><code>ODR.set_job(fit_type=None, deriv=None, var_calc=None, del_init=None, restart=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fit_type : {0, 1, 2} int\n    0 -> explicit ODR 1 -> implicit ODR 2 -> ordinary least-squares \nderiv : {0, 1, 2, 3} int\n    0 -> forward finite differences 1 -> central finite differences  2 -> user-supplied derivatives (Jacobians) with results checked by ODRPACK   3 -> user-supplied derivatives, no checking \nvar_calc : {0, 1, 2} int\n    0 -> calculate asymptotic covariance matrix and fit parameter uncertainties (V_B, s_B) using derivatives recomputed at the final solution   1 -> calculate V_B and s_B using derivatives from last iteration 2 -> do not calculate V_B and s_B \ndel_init : {0, 1} int\n    0 -> initial input variable offsets set to 0 1 -> initial offsets provided by user in variable “work” \nrestart : {0, 1} int\n    0 -> fit is not a restart 1 -> fit is a restart</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.ODR.set_job.html
scipy odr ODR set_job	R	scipy.odr.ODR.set_job										
scipy odr.ODR.set_job	R	scipy.odr.ODR.set_job										
scipy.odr.odr_stop	A										<section class="prog__container"><p>alias of OdrStop</p><pre><code>scipy.odr.odr_stop</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.odr_stop.html
scipy.odr.OdrStop	A										<section class="prog__container"><p>Exception stopping fitting.</p><pre><code>exception scipy.odr.OdrStop</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.OdrStop.html
scipy odr odr_stop	R	scipy.odr.odr_stop										
scipy odr.odr_stop	R	scipy.odr.odr_stop										
scipy odr OdrStop	R	scipy.odr.OdrStop										
scipy odr.OdrStop	R	scipy.odr.OdrStop										
scipy.odr.OdrWarning	A										<section class="prog__container"><p>Warning indicating that the data passed into\nODR will cause problems when passed into ‘odr’\nthat the user should be aware of.</p><pre><code>exception scipy.odr.OdrWarning</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.OdrWarning.html
scipy odr OdrWarning	R	scipy.odr.OdrWarning										
scipy odr.OdrWarning	R	scipy.odr.OdrWarning										
scipy.odr.Output	A										<section class="prog__container"><p>The Output class stores the output of an ODR run.</p><pre><code>class scipy.odr.Output(output)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Output.html
scipy.odr.Output.pprint	A										<section class="prog__container"><p>Pretty-print important results.</p><pre><code>Output.pprint()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Output.pprint.html
scipy odr Output pprint	R	scipy.odr.Output.pprint										
scipy odr.Output.pprint	R	scipy.odr.Output.pprint										
scipy odr Output	R	scipy.odr.Output										
scipy odr.Output	R	scipy.odr.Output										
scipy.odr.polynomial	A										<section class="prog__container"><p>Factory function for a general polynomial model.</p><pre><code>scipy.odr.polynomial(order)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : int or sequence\n    If an integer, it becomes the order of the polynomial to fit. If a sequence of numbers, then these are the explicit powers in the polynomial. A constant term (power 0) is always included, so don’t include 0. Thus, polynomial(n) is equivalent to polynomial(range(1, n+1)).</code></pre><span class="prog__sub">Returns:</span><pre><code>polynomial : Model instance\n    Model instance.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.polynomial.html
scipy odr polynomial	R	scipy.odr.polynomial										
scipy odr.polynomial	R	scipy.odr.polynomial										
scipy.odr.RealData	A										<section class="prog__container"><p>The data, with weightings as actual standard deviations and/or\ncovariances.</p><pre><code>class scipy.odr.RealData(x, y=None, sx=None, sy=None, covx=None, covy=None, fix=None, meta={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Observed data for the independent variable of the regression \ny : array_like, optional\n    If array-like, observed data for the dependent variable of the regression. A scalar input implies that the model to be used on the data is implicit. \nsx, sy : array_like, optional\n    Standard deviations of x. sx are standard deviations of x and are converted to weights by dividing 1.0 by their squares. \nsy : array_like, optional\n    Standard deviations of y. sy are standard deviations of y and are converted to weights by dividing 1.0 by their squares. \ncovx : array_like, optional\n    Covariance of x covx is an array of covariance matrices of x and are converted to weights by performing a matrix inversion on each observation’s covariance matrix. \ncovy : array_like, optional\n    Covariance of y covy is an array of covariance matrices and are converted to weights by performing a matrix inversion on each observation’s covariance matrix. \nfix : array_like, optional\n    The argument and member fix is the same as Data.fix and ODR.ifixx: It is an array of integers with the same shape as x that determines which input observations are treated as fixed. One can use a sequence of length m (the dimensionality of the input observations) to fix some dimensions for all observations. A value of 0 fixes the observation, a value > 0 makes it free. \nmeta : dict, optional\n    Free-form dictionary for metadata.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.RealData.html
scipy odr RealData	R	scipy.odr.RealData										
scipy odr.RealData	R	scipy.odr.RealData										
scipy.odr.RealData.set_meta	A										<section class="prog__container"><p>Update the metadata dictionary with the keywords and data provided\nby keywords.</p><pre><code>RealData.set_meta(**kwds)</code></pre><span class="prog__sub">Examples:</span><pre><code>data.set_meta(lab="Ph 7; Lab 26", title="Ag110 + Ag108 Decay")</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.RealData.set_meta.html
scipy odr RealData set_meta	R	scipy.odr.RealData.set_meta										
scipy odr.RealData.set_meta	R	scipy.odr.RealData.set_meta										
scipy.optimize.anderson	A										<section class="prog__container"><p>Find a root of a function, using (extended) Anderson mixing.</p><pre><code>scipy.optimize.anderson(F, xin, iter=None, alpha=None, w0=0.01, M=5, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : function(x) -> f\n    Function whose root to find; should take and return an array-like object. \nx0 : array_like\n    Initial guess for the solution \nalpha : float, optional\n    Initial guess for the Jacobian is (-1/alpha). \nM : float, optional\n    Number of previous vectors to retain. Defaults to 5. \nw0 : float, optional\n    Regularization parameter for numerical stability. Compared to unity, good values of the order of 0.01. \niter : int, optional\n    Number of iterations to make. If omitted (default), make as many as required to meet tolerances. \nverbose : bool, optional\n    Print status to stdout on every iteration. \nmaxiter : int, optional\n    Maximum number of iterations to make. If more are needed to meet convergence, NoConvergence is raised. \nf_tol : float, optional\n    Absolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6. \nf_rtol : float, optional\n    Relative tolerance for the residual. If omitted, not used. \nx_tol : float, optional\n    Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used. \nx_rtol : float, optional\n    Relative minimum step size. If omitted, not used. \ntol_norm : function(vector) -> scalar, optional\n    Norm to use in convergence check. Default is the maximum norm. \nline_search : {None, ‘armijo’ (default), ‘wolfe’}, optional\n    Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to ‘armijo’. \ncallback : function, optional\n    Optional callback function. It is called on every iteration as callback(x, f) where x is the current solution and f the corresponding residual.</code></pre><span class="prog__sub">Returns:</span><pre><code>sol : ndarray\n    An array (of similar array type as x0) containing the final solution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.anderson.html
scipy optimize anderson	R	scipy.optimize.anderson										
scipy optimize.anderson	R	scipy.optimize.anderson										
scipy.optimize.approx_fprime	A										<section class="prog__container"><p>Finite-difference approximation of the gradient of a scalar function.</p><pre><code>scipy.optimize.approx_fprime(xk, f, epsilon, *args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xk : array_like\n    The coordinate vector at which to determine the gradient of f. \nf : callable\n    The function of which to determine the gradient (partial derivatives). Should take xk as first argument, other arguments to f can be supplied in *args.  Should return a scalar, the value of the function at xk. \nepsilon : array_like\n    Increment to xk to use for determining the function gradient. If a scalar, uses the same finite difference delta for all partial derivatives.  If an array, should contain one value per element of xk. \n*args : args, optional\n    Any other arguments that are to be passed to f.</code></pre><span class="prog__sub">Returns:</span><pre><code>grad : ndarray\n    The partial derivatives of f to xk.</code></pre><span class="prog__sub">Examples:</span><pre><code>f(xk[i] + epsilon[i]) - f(xk[i])\nf'[i] = ---------------------------------\n                    epsilon[i]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.approx_fprime.html
scipy optimize approx_fprime	R	scipy.optimize.approx_fprime										
scipy optimize.approx_fprime	R	scipy.optimize.approx_fprime										
scipy.optimize.basinhopping	A										<section class="prog__container"><p>Find the global minimum of a function using the basin-hopping algorithm</p><pre><code>scipy.optimize.basinhopping(func, x0, niter=100, T=1.0, stepsize=0.5, minimizer_kwargs=None, take_step=None, accept_test=None, callback=None, interval=50, disp=False, niter_success=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(x, *args)\n    Function to be optimized.  args can be passed as an optional item in the dict minimizer_kwargs \nx0 : ndarray\n    Initial guess. \nniter : integer, optional\n    The number of basin hopping iterations \nT : float, optional\n    The “temperature” parameter for the accept or reject criterion.  Higher “temperatures” mean that larger jumps in function value will be accepted.  For best results T should be comparable to the separation (in function value) between local minima. \nstepsize : float, optional\n    initial step size for use in the random displacement. \nminimizer_kwargs : dict, optional\n    Extra keyword arguments to be passed to the minimizer scipy.optimize.minimize() Some important options could be:   method : str The minimization method (e.g. "L-BFGS-B")  args : tuple Extra arguments passed to the objective function (func) and its derivatives (Jacobian, Hessian).    \ntake_step : callable take_step(x), optional\n    Replace the default step taking routine with this routine.  The default step taking routine is a random displacement of the coordinates, but other step taking algorithms may be better for some systems. take_step can optionally have the attribute take_step.stepsize. If this attribute exists, then basinhopping will adjust take_step.stepsize in order to try to optimize the global minimum search. \naccept_test : callable, accept_test(f_new=f_new, x_new=x_new, f_old=fold, x_old=x_old), optional\n    Define a test which will be used to judge whether or not to accept the step.  This will be used in addition to the Metropolis test based on “temperature” T.  The acceptable return values are True, False, or "force accept". If any of the tests return False then the step is rejected. If the latter, then this will override any other tests in order to accept the step. This can be used, for example, to forcefully escape from a local minimum that basinhopping is trapped in. \ncallback : callable, callback(x, f, accept), optional\n    A callback function which will be called for all minima found.  x and f are the coordinates and function value of the trial minimum, and accept is whether or not that minimum was accepted.  This can be used, for example, to save the lowest N minima found.  Also, callback can be used to specify a user defined stop criterion by optionally returning True to stop the basinhopping routine. \ninterval : integer, optional\n    interval for how often to update the stepsize \ndisp : bool, optional\n    Set to True to print status messages \nniter_success : integer, optional\n    Stop the run if the global minimum candidate remains the same for this number of iterations.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : OptimizeResult\n    The optimization result represented as a OptimizeResult object.  Important attributes are: x the solution array, fun the value of the function at the solution, and message which describes the cause of the termination. The OptimzeResult object returned by the selected minimizer at the lowest minimum is also contained within this object and can be accessed through the lowest_optimization_result attribute. See OptimizeResult for a description of other attributes.</code></pre><span class="prog__sub">Examples:</span><pre><code>exp( -(func(xnew) - func(xold)) / T )</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.basinhopping.html
scipy optimize basinhopping	R	scipy.optimize.basinhopping										
scipy optimize.basinhopping	R	scipy.optimize.basinhopping										
scipy.optimize.bisect	A										<section class="prog__container"><p>Find root of a function within an interval.</p><pre><code>scipy.optimize.bisect(f, a, b, args=(), xtol=2e-12, rtol=8.8817841970012523e-16, maxiter=100, full_output=False, disp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : function\n    Python function returning a number.  f must be continuous, and f(a) and f(b) must have opposite signs. \na : number\n    One end of the bracketing interval [a,b]. \nb : number\n    The other end of the bracketing interval [a,b]. \nxtol : number, optional\n    The computed root x0 will satisfy np.allclose(x, x0, atol=xtol, rtol=rtol), where x is the exact root. The parameter must be nonnegative. \nrtol : number, optional\n    The computed root x0 will satisfy np.allclose(x, x0, atol=xtol, rtol=rtol), where x is the exact root. The parameter cannot be smaller than its default value of 4*np.finfo(float).eps. \nmaxiter : number, optional\n    if convergence is not achieved in maxiter iterations, an error is raised.  Must be >= 0. \nargs : tuple, optional\n    containing extra arguments for the function f. f is called by apply(f, (x)+args). \nfull_output : bool, optional\n    If full_output is False, the root is returned.  If full_output is True, the return value is (x, r), where x is the root, and r is a RootResults object. \ndisp : bool, optional\n    If True, raise RuntimeError if the algorithm didn’t converge.</code></pre><span class="prog__sub">Returns:</span><pre><code>x0 : float\n    Zero of f between a and b. \nr : RootResults (present if full_output = True)\n    Object containing information about the convergence.  In particular, r.converged is True if the routine converged.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bisect.html
scipy optimize bisect	R	scipy.optimize.bisect										
scipy optimize.bisect	R	scipy.optimize.bisect										
scipy.optimize.bracket	A										<section class="prog__container"><p>Bracket the minimum of the function.</p><pre><code>scipy.optimize.bracket(func, xa=0.0, xb=1.0, args=(), grow_limit=110.0, maxiter=1000)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(x,*args)\n    Objective function to minimize. \nxa, xb : float, optional\n    Bracketing interval. Defaults xa to 0.0, and xb to 1.0. \nargs : tuple, optional\n    Additional arguments (if present), passed to func. \ngrow_limit : float, optional\n    Maximum grow limit.  Defaults to 110.0 \nmaxiter : int, optional\n    Maximum number of iterations to perform. Defaults to 1000.</code></pre><span class="prog__sub">Returns:</span><pre><code>xa, xb, xc : float\n    Bracket. \nfa, fb, fc : float\n    Objective function values in bracket. \nfuncalls : int\n    Number of function evaluations made.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bracket.html
scipy optimize bracket	R	scipy.optimize.bracket										
scipy optimize.bracket	R	scipy.optimize.bracket										
scipy.optimize.brent	A										<section class="prog__container"><p>Given a function of one-variable and a possible bracketing interval,\nreturn the minimum of the function isolated to a fractional precision of\ntol.</p><pre><code>scipy.optimize.brent(func, args=(), brack=None, tol=1.48e-08, full_output=0, maxiter=500)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(x,*args)\n    Objective function. \nargs : tuple, optional\n    Additional arguments (if present). \nbrack : tuple, optional\n    Either a triple (xa,xb,xc) where xa<xb<xc and func(xb) < func(xa), func(xc) or a pair (xa,xb) which are used as a starting interval for a downhill bracket search (see bracket). Providing the pair (xa,xb) does not always mean the obtained solution will satisfy xa<=x<=xb. \ntol : float, optional\n    Stop if between iteration change is less than tol. \nfull_output : bool, optional\n    If True, return all output args (xmin, fval, iter, funcalls). \nmaxiter : int, optional\n    Maximum number of iterations in solution.</code></pre><span class="prog__sub">Returns:</span><pre><code>xmin : ndarray\n    Optimum point. \nfval : float\n    Optimum value. \niter : int\n    Number of iterations. \nfuncalls : int\n    Number of objective function evaluations made.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brent.html
scipy.optimize.brenth	A										<section class="prog__container"><p>Find root of f in [a,b].</p><pre><code>scipy.optimize.brenth(f, a, b, args=(), xtol=2e-12, rtol=8.8817841970012523e-16, maxiter=100, full_output=False, disp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : function\n    Python function returning a number.  f must be continuous, and f(a) and f(b) must have opposite signs. \na : number\n    One end of the bracketing interval [a,b]. \nb : number\n    The other end of the bracketing interval [a,b]. \nxtol : number, optional\n    The computed root x0 will satisfy np.allclose(x, x0, atol=xtol, rtol=rtol), where x is the exact root. The parameter must be nonnegative. As with brentq, for nice functions the method will often satisfy the above condition will xtol/2 and rtol/2. \nrtol : number, optional\n    The computed root x0 will satisfy np.allclose(x, x0, atol=xtol, rtol=rtol), where x is the exact root. The parameter cannot be smaller than its default value of 4*np.finfo(float).eps. As with brentq, for nice functions the method will often satisfy the above condition will xtol/2 and rtol/2. \nmaxiter : number, optional\n    if convergence is not achieved in maxiter iterations, an error is raised.  Must be >= 0. \nargs : tuple, optional\n    containing extra arguments for the function f. f is called by apply(f, (x)+args). \nfull_output : bool, optional\n    If full_output is False, the root is returned.  If full_output is True, the return value is (x, r), where x is the root, and r is a RootResults object. \ndisp : bool, optional\n    If True, raise RuntimeError if the algorithm didn’t converge.</code></pre><span class="prog__sub">Returns:</span><pre><code>x0 : float\n    Zero of f between a and b. \nr : RootResults (present if full_output = True)\n    Object containing information about the convergence.  In particular, r.converged is True if the routine converged.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brenth.html
scipy optimize brenth	R	scipy.optimize.brenth										
scipy optimize.brenth	R	scipy.optimize.brenth										
scipy.optimize.brentq	A										<section class="prog__container"><p>Find a root of a function in a bracketing interval using Brent’s method.</p><pre><code>scipy.optimize.brentq(f, a, b, args=(), xtol=2e-12, rtol=8.8817841970012523e-16, maxiter=100, full_output=False, disp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : function\n    Python function returning a number.  The function \(f\) must be continuous, and \(f(a)\) and \(f(b)\) must have opposite signs. \na : number\n    One end of the bracketing interval \([a, b]\). \nb : number\n    The other end of the bracketing interval \([a, b]\). \nxtol : number, optional\n    The computed root x0 will satisfy np.allclose(x, x0, atol=xtol, rtol=rtol), where x is the exact root. The parameter must be nonnegative. For nice functions, Brent’s method will often satisfy the above condition will xtol/2 and rtol/2. [Brent1973] \nrtol : number, optional\n    The computed root x0 will satisfy np.allclose(x, x0, atol=xtol, rtol=rtol), where x is the exact root. The parameter cannot be smaller than its default value of 4*np.finfo(float).eps. For nice functions, Brent’s method will often satisfy the above condition will xtol/2 and rtol/2. [Brent1973] \nmaxiter : number, optional\n    if convergence is not achieved in maxiter iterations, an error is raised.  Must be >= 0. \nargs : tuple, optional\n    containing extra arguments for the function f. f is called by apply(f, (x)+args). \nfull_output : bool, optional\n    If full_output is False, the root is returned.  If full_output is True, the return value is (x, r), where x is the root, and r is a RootResults object. \ndisp : bool, optional\n    If True, raise RuntimeError if the algorithm didn’t converge.</code></pre><span class="prog__sub">Returns:</span><pre><code>x0 : float\n    Zero of f between a and b. \nr : RootResults (present if full_output = True)\n    Object containing information about the convergence.  In particular, r.converged is True if the routine converged.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brentq.html
scipy optimize brentq	R	scipy.optimize.brentq										
scipy optimize.brentq	R	scipy.optimize.brentq										
scipy optimize brent	R	scipy.optimize.brent										
scipy optimize.brent	R	scipy.optimize.brent										
scipy.optimize.broyden1	A										<section class="prog__container"><p>Find a root of a function, using Broyden’s first Jacobian approximation.</p><pre><code>scipy.optimize.broyden1(F, xin, iter=None, alpha=None, reduction_method='restart', max_rank=None, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : function(x) -> f\n    Function whose root to find; should take and return an array-like object. \nx0 : array_like\n    Initial guess for the solution \nalpha : float, optional\n    Initial guess for the Jacobian is (-1/alpha). \nreduction_method : str or tuple, optional\n    Method used in ensuring that the rank of the Broyden matrix stays low. Can either be a string giving the name of the method, or a tuple of the form (method, param1, param2, ...) that gives the name of the method and values for additional parameters. Methods available:   restart: drop all matrix columns. Has no extra parameters. simple: drop oldest matrix column. Has no extra parameters. svd: keep only the most significant SVD components. Takes an extra parameter, to_retain, which determines the number of SVD components to retain when rank reduction is done. Default is max_rank - 2.   \nmax_rank : int, optional\n    Maximum rank for the Broyden matrix. Default is infinity (ie., no rank reduction). \niter : int, optional\n    Number of iterations to make. If omitted (default), make as many as required to meet tolerances. \nverbose : bool, optional\n    Print status to stdout on every iteration. \nmaxiter : int, optional\n    Maximum number of iterations to make. If more are needed to meet convergence, NoConvergence is raised. \nf_tol : float, optional\n    Absolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6. \nf_rtol : float, optional\n    Relative tolerance for the residual. If omitted, not used. \nx_tol : float, optional\n    Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used. \nx_rtol : float, optional\n    Relative minimum step size. If omitted, not used. \ntol_norm : function(vector) -> scalar, optional\n    Norm to use in convergence check. Default is the maximum norm. \nline_search : {None, ‘armijo’ (default), ‘wolfe’}, optional\n    Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to ‘armijo’. \ncallback : function, optional\n    Optional callback function. It is called on every iteration as callback(x, f) where x is the current solution and f the corresponding residual.</code></pre><span class="prog__sub">Returns:</span><pre><code>sol : ndarray\n    An array (of similar array type as x0) containing the final solution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.broyden1.html
scipy optimize broyden1	R	scipy.optimize.broyden1										
scipy optimize.broyden1	R	scipy.optimize.broyden1										
scipy.optimize.broyden2	A										<section class="prog__container"><p>Find a root of a function, using Broyden’s second Jacobian approximation.</p><pre><code>scipy.optimize.broyden2(F, xin, iter=None, alpha=None, reduction_method='restart', max_rank=None, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : function(x) -> f\n    Function whose root to find; should take and return an array-like object. \nx0 : array_like\n    Initial guess for the solution \nalpha : float, optional\n    Initial guess for the Jacobian is (-1/alpha). \nreduction_method : str or tuple, optional\n    Method used in ensuring that the rank of the Broyden matrix stays low. Can either be a string giving the name of the method, or a tuple of the form (method, param1, param2, ...) that gives the name of the method and values for additional parameters. Methods available:   restart: drop all matrix columns. Has no extra parameters. simple: drop oldest matrix column. Has no extra parameters. svd: keep only the most significant SVD components. Takes an extra parameter, to_retain, which determines the number of SVD components to retain when rank reduction is done. Default is max_rank - 2.   \nmax_rank : int, optional\n    Maximum rank for the Broyden matrix. Default is infinity (ie., no rank reduction). \niter : int, optional\n    Number of iterations to make. If omitted (default), make as many as required to meet tolerances. \nverbose : bool, optional\n    Print status to stdout on every iteration. \nmaxiter : int, optional\n    Maximum number of iterations to make. If more are needed to meet convergence, NoConvergence is raised. \nf_tol : float, optional\n    Absolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6. \nf_rtol : float, optional\n    Relative tolerance for the residual. If omitted, not used. \nx_tol : float, optional\n    Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used. \nx_rtol : float, optional\n    Relative minimum step size. If omitted, not used. \ntol_norm : function(vector) -> scalar, optional\n    Norm to use in convergence check. Default is the maximum norm. \nline_search : {None, ‘armijo’ (default), ‘wolfe’}, optional\n    Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to ‘armijo’. \ncallback : function, optional\n    Optional callback function. It is called on every iteration as callback(x, f) where x is the current solution and f the corresponding residual.</code></pre><span class="prog__sub">Returns:</span><pre><code>sol : ndarray\n    An array (of similar array type as x0) containing the final solution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.broyden2.html
scipy optimize broyden2	R	scipy.optimize.broyden2										
scipy optimize.broyden2	R	scipy.optimize.broyden2										
scipy.optimize.brute	A					[[scipy.optimize.basinhopping]]\\n[[scipy.optimize.differential_evolution]]					<section class="prog__container"><p>Minimize a function over a given range by brute force.</p><pre><code>scipy.optimize.brute(func, ranges, args=(), Ns=20, full_output=0, finish=<function fmin at 0x2aba91d922a8>, disp=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable\n    The objective function to be minimized. Must be in the form f(x, *args), where x is the argument in the form of a 1-D array and args is a tuple of any additional fixed parameters needed to completely specify the function. \nranges : tuple\n    Each component of the ranges tuple must be either a “slice object” or a range tuple of the form (low, high). The program uses these to create the grid of points on which the objective function will be computed. See Note 2 for more detail. \nargs : tuple, optional\n    Any additional fixed parameters needed to completely specify the function. \nNs : int, optional\n    Number of grid points along the axes, if not otherwise specified. See Note2. \nfull_output : bool, optional\n    If True, return the evaluation grid and the objective function’s values on it. \nfinish : callable, optional\n    An optimization function that is called with the result of brute force minimization as initial guess.  finish should take func and the initial guess as positional arguments, and take args as keyword arguments.  It may additionally take full_output and/or disp as keyword arguments.  Use None if no “polishing” function is to be used. See Notes for more details. \ndisp : bool, optional\n    Set to True to print convergence messages.</code></pre><span class="prog__sub">Returns:</span><pre><code>x0 : ndarray\n    A 1-D array containing the coordinates of a point at which the objective function had its minimum value. (See Note 1 for which point is returned.) \nfval : float\n    Function value at the point x0. (Returned when full_output is True.) \ngrid : tuple\n    Representation of the evaluation grid.  It has the same length as x0. (Returned when full_output is True.) \nJout : ndarray\n    Function values at each point of the evaluation grid, i.e., Jout = func(*grid). (Returned when full_output is True.)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)\n>>> def f1(z, *params):\n...     x, y = z\n...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params\n...     return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brute.html
scipy optimize brute	R	scipy.optimize.brute										
scipy optimize.brute	R	scipy.optimize.brute										
scipy.optimize.check_grad	A					[[scipy.optimize.approx_fprime]]					<section class="prog__container"><p>Check the correctness of a gradient function by comparing it against a\n(forward) finite-difference approximation of the gradient.</p><pre><code>scipy.optimize.check_grad(func, grad, x0, *args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable func(x0, *args)\n    Function whose derivative is to be checked. \ngrad : callable grad(x0, *args)\n    Gradient of func. \nx0 : ndarray\n    Points to check grad against forward difference approximation of grad using func. \nargs : *args, optional\n    Extra arguments passed to func and grad. \nepsilon : float, optional\n    Step size used for the finite difference approximation. It defaults to sqrt(numpy.finfo(float).eps), which is approximately 1.49e-08.</code></pre><span class="prog__sub">Returns:</span><pre><code>err : float\n    The square root of the sum of squares (i.e. the 2-norm) of the difference between grad(x0, *args) and the finite difference approximation of grad using func at the points x0.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def func(x):\n...     return x[0]**2 - 0.5 * x[1]**3\n>>> def grad(x):\n...     return [2 * x[0], -1.5 * x[1]**2]\n>>> from scipy.optimize import check_grad\n>>> check_grad(func, grad, [1.5, -1.5])\n2.9802322387695312e-08</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.check_grad.html
scipy optimize check_grad	R	scipy.optimize.check_grad										
scipy optimize.check_grad	R	scipy.optimize.check_grad										
scipy.optimize.curve_fit	A										<section class="prog__container"><p>Use non-linear least squares to fit a function, f, to data.</p><pre><code>scipy.optimize.curve_fit(f, xdata, ydata, p0=None, sigma=None, absolute_sigma=False, check_finite=True, bounds=(-inf, inf), method=None, jac=None, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : callable\n    The model function, f(x, ...).  It must take the independent variable as the first argument and the parameters to fit as separate remaining arguments. \nxdata : An M-length sequence or an (k,M)-shaped array\n    for functions with k predictors. The independent variable where the data is measured. \nydata : M-length sequence\n    The dependent data — nominally f(xdata, ...) \np0 : None, scalar, or N-length sequence, optional\n    Initial guess for the parameters.  If None, then the initial values will all be 1 (if the number of parameters for the function can be determined using introspection, otherwise a ValueError is raised). \nsigma : None or M-length sequence, optional\n    If not None, the uncertainties in the ydata array. These are used as weights in the least-squares problem i.e. minimising np.sum( ((f(xdata, *popt) - ydata) / sigma)**2 ) If None, the uncertainties are assumed to be 1. \nabsolute_sigma : bool, optional\n    If False, sigma denotes relative weights of the data points. The returned covariance matrix pcov is based on estimated errors in the data, and is not affected by the overall magnitude of the values in sigma. Only the relative magnitudes of the sigma values matter. If True, sigma describes one standard deviation errors of the input data points. The estimated covariance in pcov is based on these values. \ncheck_finite : bool, optional\n    If True, check that the input arrays do not contain nans of infs, and raise a ValueError if they do. Setting this parameter to False may silently produce nonsensical results if the input arrays do contain nans. Default is True. \nbounds : 2-tuple of array_like, optional\n    Lower and upper bounds on independent variables. Defaults to no bounds.         Each element of the tuple must be either an array with the length equal to the number of parameters, or a scalar (in which case the bound is taken to be the same for all parameters.) Use np.inf with an appropriate sign to disable bounds on all or some parameters.  New in version 0.17.  \nmethod : {‘lm’, ‘trf’, ‘dogbox’}, optional\n    Method to use for optimization.  See least_squares for more details. Default is ‘lm’ for unconstrained problems and ‘trf’ if bounds are provided. The method ‘lm’ won’t work when the number of observations is less than the number of variables, use ‘trf’ or ‘dogbox’ in this case.  New in version 0.17.  \njac : callable, string or None, optional\n    Function with signature jac(x, ...) which computes the Jacobian matrix of the model function with respect to parameters as a dense array_like structure. It will be scaled according to provided sigma. If None (default), the Jacobian will be estimated numerically. String keywords for ‘trf’ and ‘dogbox’ methods can be used to select a finite difference scheme, see least_squares.  New in version 0.18.  \nkwargs\n    Keyword arguments passed to leastsq for method='lm' or least_squares otherwise.</code></pre><span class="prog__sub">Returns:</span><pre><code>popt : array\n    Optimal values for the parameters so that the sum of the squared error of f(xdata, *popt) - ydata is minimized \npcov : 2d array\n    The estimated covariance of popt. The diagonals provide the variance of the parameter estimate. To compute one standard deviation errors on the parameters use perr = np.sqrt(np.diag(pcov)). How the sigma parameter affects the estimated covariance depends on absolute_sigma argument, as described above. If the Jacobian matrix at the solution doesn’t have a full rank, then ‘lm’ method returns a matrix filled with np.inf, on the other hand ‘trf’  and ‘dogbox’ methods use Moore-Penrose pseudoinverse to compute the covariance matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.optimize import curve_fit\n>>> def func(x, a, b, c):\n...     return a * np.exp(-b * x) + c</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html
scipy optimize curve_fit	R	scipy.optimize.curve_fit										
scipy optimize.curve_fit	R	scipy.optimize.curve_fit										
scipy.optimize.diagbroyden	A										<section class="prog__container"><p>Find a root of a function, using diagonal Broyden Jacobian approximation.</p><pre><code>scipy.optimize.diagbroyden(F, xin, iter=None, alpha=None, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : function(x) -> f\n    Function whose root to find; should take and return an array-like object. \nx0 : array_like\n    Initial guess for the solution \nalpha : float, optional\n    Initial guess for the Jacobian is (-1/alpha). \niter : int, optional\n    Number of iterations to make. If omitted (default), make as many as required to meet tolerances. \nverbose : bool, optional\n    Print status to stdout on every iteration. \nmaxiter : int, optional\n    Maximum number of iterations to make. If more are needed to meet convergence, NoConvergence is raised. \nf_tol : float, optional\n    Absolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6. \nf_rtol : float, optional\n    Relative tolerance for the residual. If omitted, not used. \nx_tol : float, optional\n    Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used. \nx_rtol : float, optional\n    Relative minimum step size. If omitted, not used. \ntol_norm : function(vector) -> scalar, optional\n    Norm to use in convergence check. Default is the maximum norm. \nline_search : {None, ‘armijo’ (default), ‘wolfe’}, optional\n    Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to ‘armijo’. \ncallback : function, optional\n    Optional callback function. It is called on every iteration as callback(x, f) where x is the current solution and f the corresponding residual.</code></pre><span class="prog__sub">Returns:</span><pre><code>sol : ndarray\n    An array (of similar array type as x0) containing the final solution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.diagbroyden.html
scipy optimize diagbroyden	R	scipy.optimize.diagbroyden										
scipy optimize.diagbroyden	R	scipy.optimize.diagbroyden										
scipy.optimize.differential_evolution	A										<section class="prog__container"><p>Finds the global minimum of a multivariate function.\nDifferential Evolution is stochastic in nature (does not use gradient\nmethods) to find the minimium, and can search large areas of candidate\nspace, but often requires larger numbers of function evaluations than\nconventional gradient based techniques.</p><pre><code>scipy.optimize.differential_evolution(func, bounds, args=(), strategy='best1bin', maxiter=1000, popsize=15, tol=0.01, mutation=(0.5, 1), recombination=0.7, seed=None, callback=None, disp=False, polish=True, init='latinhypercube')</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable\n    The objective function to be minimized.  Must be in the form f(x, *args), where x is the argument in the form of a 1-D array and args is a  tuple of any additional fixed parameters needed to completely specify the function. \nbounds : sequence\n    Bounds for variables.  (min, max) pairs for each element in x, defining the lower and upper bounds for the optimizing argument of func. It is required to have len(bounds) == len(x). len(bounds) is used to determine the number of parameters in x. \nargs : tuple, optional\n    Any additional fixed parameters needed to completely specify the objective function. \nstrategy : str, optional\n    The differential evolution strategy to use. Should be one of:   ‘best1bin’ ‘best1exp’ ‘rand1exp’ ‘randtobest1exp’ ‘best2exp’ ‘rand2exp’ ‘randtobest1bin’ ‘best2bin’ ‘rand2bin’ ‘rand1bin’   The default is ‘best1bin’. \nmaxiter : int, optional\n    The maximum number of generations over which the entire population is evolved. The maximum number of function evaluations (with no polishing) is: (maxiter + 1) * popsize * len(x) \npopsize : int, optional\n    A multiplier for setting the total population size.  The population has popsize * len(x) individuals. \ntol : float, optional\n    When the mean of the population energies, multiplied by tol, divided by the standard deviation of the population energies is greater than 1 the solving process terminates: convergence = mean(pop) * tol / stdev(pop) > 1 \nmutation : float or tuple(float, float), optional\n    The mutation constant. In the literature this is also known as differential weight, being denoted by F. If specified as a float it should be in the range [0, 2]. If specified as a tuple (min, max) dithering is employed. Dithering randomly changes the mutation constant on a generation by generation basis. The mutation constant for that generation is taken from U[min, max). Dithering can help speed convergence significantly. Increasing the mutation constant increases the search radius, but will slow down convergence. \nrecombination : float, optional\n    The recombination constant, should be in the range [0, 1]. In the literature this is also known as the crossover probability, being denoted by CR. Increasing this value allows a larger number of mutants to progress into the next generation, but at the risk of population stability. \nseed : int or np.random.RandomState, optional\n    If seed is not specified the np.RandomState singleton is used. If seed is an int, a new np.random.RandomState instance is used, seeded with seed. If seed is already a np.random.RandomState instance, then that np.random.RandomState instance is used. Specify seed for repeatable minimizations. \ndisp : bool, optional\n    Display status messages \ncallback : callable, callback(xk, convergence=val), optional\n    A function to follow the progress of the minimization. xk is the current value of x0. val represents the fractional value of the population convergence.  When val is greater than one the function halts. If callback returns True, then the minimization is halted (any polishing is still carried out). \npolish : bool, optional\n    If True (default), then scipy.optimize.minimize with the L-BFGS-B method is used to polish the best population member at the end, which can improve the minimization slightly. \ninit : string, optional\n    Specify how the population initialization is performed. Should be one of:   ‘latinhypercube’ ‘random’   The default is ‘latinhypercube’. Latin Hypercube sampling tries to maximize coverage of the available parameter space. ‘random’ initializes the population randomly - this has the drawback that clustering can occur, preventing the whole of parameter space being covered.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : OptimizeResult\n    The optimization result represented as a OptimizeResult object. Important attributes are: x the solution array, success a Boolean flag indicating if the optimizer exited successfully and message which describes the cause of the termination. See OptimizeResult for a description of other attributes.  If polish was employed, and a lower minimum was obtained by the polishing, then OptimizeResult also contains the jac attribute.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.optimize import rosen, differential_evolution\n>>> bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]\n>>> result = differential_evolution(rosen, bounds)\n>>> result.x, result.fun\n(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.differential_evolution.html
scipy optimize differential_evolution	R	scipy.optimize.differential_evolution										
scipy optimize.differential_evolution	R	scipy.optimize.differential_evolution										
scipy.optimize.excitingmixing	A										<section class="prog__container"><p>Find a root of a function, using a tuned diagonal Jacobian approximation.</p><pre><code>scipy.optimize.excitingmixing(F, xin, iter=None, alpha=None, alphamax=1.0, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : function(x) -> f\n    Function whose root to find; should take and return an array-like object. \nx0 : array_like\n    Initial guess for the solution \nalpha : float, optional\n    Initial Jacobian approximation is (-1/alpha). \nalphamax : float, optional\n    The entries of the diagonal Jacobian are kept in the range [alpha, alphamax]. \niter : int, optional\n    Number of iterations to make. If omitted (default), make as many as required to meet tolerances. \nverbose : bool, optional\n    Print status to stdout on every iteration. \nmaxiter : int, optional\n    Maximum number of iterations to make. If more are needed to meet convergence, NoConvergence is raised. \nf_tol : float, optional\n    Absolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6. \nf_rtol : float, optional\n    Relative tolerance for the residual. If omitted, not used. \nx_tol : float, optional\n    Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used. \nx_rtol : float, optional\n    Relative minimum step size. If omitted, not used. \ntol_norm : function(vector) -> scalar, optional\n    Norm to use in convergence check. Default is the maximum norm. \nline_search : {None, ‘armijo’ (default), ‘wolfe’}, optional\n    Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to ‘armijo’. \ncallback : function, optional\n    Optional callback function. It is called on every iteration as callback(x, f) where x is the current solution and f the corresponding residual.</code></pre><span class="prog__sub">Returns:</span><pre><code>sol : ndarray\n    An array (of similar array type as x0) containing the final solution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.excitingmixing.html
scipy optimize excitingmixing	R	scipy.optimize.excitingmixing										
scipy optimize.excitingmixing	R	scipy.optimize.excitingmixing										
scipy.optimize.fixed_point	A										<section class="prog__container"><p>Find a fixed point of the function.</p><pre><code>scipy.optimize.fixed_point(func, x0, args=(), xtol=1e-08, maxiter=500, method='del2')</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    Function to evaluate. \nx0 : array_like\n    Fixed point of function. \nargs : tuple, optional\n    Extra arguments to func. \nxtol : float, optional\n    Convergence tolerance, defaults to 1e-08. \nmaxiter : int, optional\n    Maximum number of iterations, defaults to 500. \nmethod : {“del2”, “iteration”}, optional\n    Method of finding the fixed-point, defaults to “del2” which uses Steffensen’s Method with Aitken’s Del^2 convergence acceleration [R153]. The “iteration” method simply iterates the function until convergence is detected, without attempting to accelerate the convergence.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import optimize\n>>> def func(x, c1, c2):\n...    return np.sqrt(c1/(x+c2))\n>>> c1 = np.array([10,12.])\n>>> c2 = np.array([3, 5.])\n>>> optimize.fixed_point(func, [1.2, 1.3], args=(c1,c2))\narray([ 1.4920333 ,  1.37228132])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fixed_point.html
scipy optimize fixed_point	R	scipy.optimize.fixed_point										
scipy optimize.fixed_point	R	scipy.optimize.fixed_point										
scipy.optimize.fmin	A										<section class="prog__container"><p>Minimize a function using the downhill simplex algorithm.</p><pre><code>scipy.optimize.fmin(func, x0, args=(), xtol=0.0001, ftol=0.0001, maxiter=None, maxfun=None, full_output=0, disp=1, retall=0, callback=None, initial_simplex=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable func(x,*args)\n    The objective function to be minimized. \nx0 : ndarray\n    Initial guess. \nargs : tuple, optional\n    Extra arguments passed to func, i.e. f(x,*args). \nxtol : float, optional\n    Absolute error in xopt between iterations that is acceptable for convergence. \nftol : number, optional\n    Absolute error in func(xopt) between iterations that is acceptable for convergence. \nmaxiter : int, optional\n    Maximum number of iterations to perform. \nmaxfun : number, optional\n    Maximum number of function evaluations to make. \nfull_output : bool, optional\n    Set to True if fopt and warnflag outputs are desired. \ndisp : bool, optional\n    Set to True to print convergence messages. \nretall : bool, optional\n    Set to True to return list of solutions at each iteration. \ncallback : callable, optional\n    Called after each iteration, as callback(xk), where xk is the current parameter vector. \ninitial_simplex : array_like of shape (N + 1, N), optional\n    Initial simplex. If given, overrides x0. initial_simplex[j,:] should contain the coordinates of the j-th vertex of the N+1 vertices in the simplex, where N is the dimension.</code></pre><span class="prog__sub">Returns:</span><pre><code>xopt : ndarray\n    Parameter that minimizes function. \nfopt : float\n    Value of function at minimum: fopt = func(xopt). \niter : int\n    Number of iterations performed. \nfuncalls : int\n    Number of function calls made. \nwarnflag : int\n    1 : Maximum number of function evaluations made. 2 : Maximum number of iterations reached. \nallvecs : list\n    Solution at each iteration.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin.html
scipy.optimize.fmin_bfgs	A										<section class="prog__container"><p>Minimize a function using the BFGS algorithm.</p><pre><code>scipy.optimize.fmin_bfgs(f, x0, fprime=None, args=(), gtol=1e-05, norm=inf, epsilon=1.4901161193847656e-08, maxiter=None, full_output=0, disp=1, retall=0, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : callable f(x,*args)\n    Objective function to be minimized. \nx0 : ndarray\n    Initial guess. \nfprime : callable f’(x,*args), optional\n    Gradient of f. \nargs : tuple, optional\n    Extra arguments passed to f and fprime. \ngtol : float, optional\n    Gradient norm must be less than gtol before successful termination. \nnorm : float, optional\n    Order of norm (Inf is max, -Inf is min) \nepsilon : int or ndarray, optional\n    If fprime is approximated, use this value for the step size. \ncallback : callable, optional\n    An optional user-supplied function to call after each iteration.  Called as callback(xk), where xk is the current parameter vector. \nmaxiter : int, optional\n    Maximum number of iterations to perform. \nfull_output : bool, optional\n    If True,return fopt, func_calls, grad_calls, and warnflag in addition to xopt. \ndisp : bool, optional\n    Print convergence message if True. \nretall : bool, optional\n    Return a list of results at each iteration if True.</code></pre><span class="prog__sub">Returns:</span><pre><code>xopt : ndarray\n    Parameters which minimize f, i.e. f(xopt) == fopt. \nfopt : float\n    Minimum value. \ngopt : ndarray\n    Value of gradient at minimum, f’(xopt), which should be near 0. \nBopt : ndarray\n    Value of 1/f’‘(xopt), i.e. the inverse hessian matrix. \nfunc_calls : int\n    Number of function_calls made. \ngrad_calls : int\n    Number of gradient calls made. \nwarnflag : integer\n    1 : Maximum number of iterations exceeded. 2 : Gradient and/or function calls not changing. \nallvecs :  list\n    OptimizeResult at each iteration.  Only returned if retall is True.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_bfgs.html
scipy optimize fmin_bfgs	R	scipy.optimize.fmin_bfgs										
scipy optimize.fmin_bfgs	R	scipy.optimize.fmin_bfgs										
scipy.optimize.fminbound	A										<section class="prog__container"><p>Bounded minimization for scalar functions.</p><pre><code>scipy.optimize.fminbound(func, x1, x2, args=(), xtol=1e-05, maxfun=500, full_output=0, disp=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(x,*args)\n    Objective function to be minimized (must accept and return scalars). \nx1, x2 : float or array scalar\n    The optimization bounds. \nargs : tuple, optional\n    Extra arguments passed to function. \nxtol : float, optional\n    The convergence tolerance. \nmaxfun : int, optional\n    Maximum number of function evaluations allowed. \nfull_output : bool, optional\n    If True, return optional outputs. \ndisp : int, optional\n    If non-zero, print messages. 0 : no message printing. 1 : non-convergence notification messages only. 2 : print a message on convergence too. 3 : print iteration results.</code></pre><span class="prog__sub">Returns:</span><pre><code>xopt : ndarray\n    Parameters (over given interval) which minimize the objective function. \nfval : number\n    The function value at the minimum point. \nierr : int\n    An error flag (0 if converged, 1 if maximum number of function calls reached). \nnumfunc : int\n    The number of function calls made.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fminbound.html
scipy optimize fminbound	R	scipy.optimize.fminbound										
scipy optimize.fminbound	R	scipy.optimize.fminbound										
scipy.optimize.fmin_cg	A										<section class="prog__container"><p>Minimize a function using a nonlinear conjugate gradient algorithm.</p><pre><code>scipy.optimize.fmin_cg(f, x0, fprime=None, args=(), gtol=1e-05, norm=inf, epsilon=1.4901161193847656e-08, maxiter=None, full_output=0, disp=1, retall=0, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : callable, f(x, *args)\n    Objective function to be minimized.  Here x must be a 1-D array of the variables that are to be changed in the search for a minimum, and args are the other (fixed) parameters of f. \nx0 : ndarray\n    A user-supplied initial estimate of xopt, the optimal value of x. It must be a 1-D array of values. \nfprime : callable, fprime(x, *args), optional\n    A function that returns the gradient of f at x. Here x and args are as described above for f. The returned value must be a 1-D array. Defaults to None, in which case the gradient is approximated numerically (see epsilon, below). \nargs : tuple, optional\n    Parameter values passed to f and fprime. Must be supplied whenever additional fixed parameters are needed to completely specify the functions f and fprime. \ngtol : float, optional\n    Stop when the norm of the gradient is less than gtol. \nnorm : float, optional\n    Order to use for the norm of the gradient (-np.Inf is min, np.Inf is max). \nepsilon : float or ndarray, optional\n    Step size(s) to use when fprime is approximated numerically. Can be a scalar or a 1-D array.  Defaults to sqrt(eps), with eps the floating point machine precision.  Usually sqrt(eps) is about 1.5e-8. \nmaxiter : int, optional\n    Maximum number of iterations to perform. Default is 200 * len(x0). \nfull_output : bool, optional\n    If True, return fopt, func_calls, grad_calls, and warnflag in addition to xopt.  See the Returns section below for additional information on optional return values. \ndisp : bool, optional\n    If True, return a convergence message, followed by xopt. \nretall : bool, optional\n    If True, add to the returned values the results of each iteration. \ncallback : callable, optional\n    An optional user-supplied function, called after each iteration. Called as callback(xk), where xk is the current value of x0.</code></pre><span class="prog__sub">Returns:</span><pre><code>xopt : ndarray\n    Parameters which minimize f, i.e. f(xopt) == fopt. \nfopt : float, optional\n    Minimum value found, f(xopt).  Only returned if full_output is True. \nfunc_calls : int, optional\n    The number of function_calls made.  Only returned if full_output is True. \ngrad_calls : int, optional\n    The number of gradient calls made. Only returned if full_output is True. \nwarnflag : int, optional\n    Integer value with warning status, only returned if full_output is True. 0 : Success. 1 : The maximum number of iterations was exceeded.  2 : Gradient and/or function calls were not changing.  May indicate that precision was lost, i.e., the routine did not converge.   \nallvecs : list of ndarray, optional\n    List of arrays, containing the results at each iteration. Only returned if retall is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> args = (2, 3, 7, 8, 9, 10)  # parameter values\n>>> def f(x, *args):\n...     u, v = x\n...     a, b, c, d, e, f = args\n...     return a*u**2 + b*u*v + c*v**2 + d*u + e*v + f\n>>> def gradf(x, *args):\n...     u, v = x\n...     a, b, c, d, e, f = args\n...     gu = 2*a*u + b*v + d     # u-component of the gradient\n...     gv = b*u + 2*c*v + e     # v-component of the gradient\n...     return np.asarray((gu, gv))\n>>> x0 = np.asarray((0, 0))  # Initial guess.\n>>> from scipy import optimize\n>>> res1 = optimize.fmin_cg(f, x0, fprime=gradf, args=args)\nOptimization terminated successfully.\n         Current function value: 1.617021\n         Iterations: 4\n         Function evaluations: 8\n         Gradient evaluations: 8\n>>> res1\narray([-1.80851064, -0.25531915])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_cg.html
scipy optimize fmin_cg	R	scipy.optimize.fmin_cg										
scipy optimize.fmin_cg	R	scipy.optimize.fmin_cg										
scipy.optimize.fmin_cobyla	A										<section class="prog__container"><p>Minimize a function using the Constrained Optimization BY Linear\nApproximation (COBYLA) method. This method wraps a FORTRAN\nimplementation of the algorithm.</p><pre><code>scipy.optimize.fmin_cobyla(func, x0, cons, args=(), consargs=None, rhobeg=1.0, rhoend=0.0001, iprint=1, maxfun=1000, disp=None, catol=0.0002)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable\n    Function to minimize. In the form func(x, *args). \nx0 : ndarray\n    Initial guess. \ncons : sequence\n    Constraint functions; must all be >=0 (a single function if only 1 constraint). Each function takes the parameters x as its first argument, and it can return either a single number or an array or list of numbers. \nargs : tuple, optional\n    Extra arguments to pass to function. \nconsargs : tuple, optional\n    Extra arguments to pass to constraint functions (default of None means use same extra arguments as those passed to func). Use () for no extra arguments. \nrhobeg : float, optional\n    Reasonable initial changes to the variables. \nrhoend : float, optional\n    Final accuracy in the optimization (not precisely guaranteed). This is a lower bound on the size of the trust region. \niprint : {0, 1, 2, 3}, optional\n    Controls the frequency of output; 0 implies no output.  Deprecated. \ndisp : {0, 1, 2, 3}, optional\n    Over-rides the iprint interface.  Preferred. \nmaxfun : int, optional\n    Maximum number of function evaluations. \ncatol : float, optional\n    Absolute tolerance for constraint violations.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    The argument that minimises f.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def objective(x):\n...     return x[0]*x[1]\n...\n>>> def constr1(x):\n...     return 1 - (x[0]**2 + x[1]**2)\n...\n>>> def constr2(x):\n...     return x[1]\n...\n>>> from scipy.optimize import fmin_cobyla\n>>> fmin_cobyla(objective, [0.0, 0.1], [constr1, constr2], rhoend=1e-7)\narray([-0.70710685,  0.70710671])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_cobyla.html
scipy optimize fmin_cobyla	R	scipy.optimize.fmin_cobyla										
scipy optimize.fmin_cobyla	R	scipy.optimize.fmin_cobyla										
scipy.optimize.fmin_l_bfgs_b	A										<section class="prog__container"><p>Minimize a function func using the L-BFGS-B algorithm.</p><pre><code>scipy.optimize.fmin_l_bfgs_b(func, x0, fprime=None, args=(), approx_grad=0, bounds=None, m=10, factr=10000000.0, pgtol=1e-05, epsilon=1e-08, iprint=-1, maxfun=15000, maxiter=15000, disp=None, callback=None, maxls=20)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(x,*args)\n    Function to minimise. \nx0 : ndarray\n    Initial guess. \nfprime : callable fprime(x,*args), optional\n    The gradient of func.  If None, then func returns the function value and the gradient (f, g = func(x, *args)), unless approx_grad is True in which case func returns only f. \nargs : sequence, optional\n    Arguments to pass to func and fprime. \napprox_grad : bool, optional\n    Whether to approximate the gradient numerically (in which case func returns only the function value). \nbounds : list, optional\n    (min, max) pairs for each element in x, defining the bounds on that parameter. Use None or +-inf for one of min or max when there is no bound in that direction. \nm : int, optional\n    The maximum number of variable metric corrections used to define the limited memory matrix. (The limited memory BFGS method does not store the full hessian but uses this many terms in an approximation to it.) \nfactr : float, optional\n    The iteration stops when (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr * eps, where eps is the machine precision, which is automatically generated by the code. Typical values for factr are: 1e12 for low accuracy; 1e7 for moderate accuracy; 10.0 for extremely high accuracy. \npgtol : float, optional\n    The iteration will stop when max{|proj g_i | i = 1, ..., n} <= pgtol where pg_i is the i-th component of the projected gradient. \nepsilon : float, optional\n    Step size used when approx_grad is True, for numerically calculating the gradient \niprint : int, optional\n    Controls the frequency of output. iprint < 0 means no output; iprint = 0    print only one line at the last iteration; 0 < iprint < 99 print also f and |proj g| every iprint iterations; iprint = 99   print details of every iteration except n-vectors; iprint = 100  print also the changes of active set and final x; iprint > 100  print details of every iteration including x and g. \ndisp : int, optional\n    If zero, then no output.  If a positive number, then this over-rides iprint (i.e., iprint gets the value of disp). \nmaxfun : int, optional\n    Maximum number of function evaluations. \nmaxiter : int, optional\n    Maximum number of iterations. \ncallback : callable, optional\n    Called after each iteration, as callback(xk), where xk is the current parameter vector. \nmaxls : int, optional\n    Maximum number of line search steps (per iteration). Default is 20.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array_like\n    Estimated position of the minimum. \nf : float\n    Value of func at the minimum. \nd : dict\n    Information dictionary.  d[‘warnflag’] is 0 if converged, 1 if too many function evaluations or too many iterations, 2 if stopped for another reason, given in d[‘task’]   d[‘grad’] is the gradient at the minimum (should be 0 ish) d[‘funcalls’] is the number of function calls made. d[‘nit’] is the number of iterations.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_l_bfgs_b.html
scipy optimize fmin_l_bfgs_b	R	scipy.optimize.fmin_l_bfgs_b										
scipy optimize.fmin_l_bfgs_b	R	scipy.optimize.fmin_l_bfgs_b										
scipy.optimize.fmin_ncg	A										<section class="prog__container"><p>Unconstrained minimization of a function using the Newton-CG method.</p><pre><code>scipy.optimize.fmin_ncg(f, x0, fprime, fhess_p=None, fhess=None, args=(), avextol=1e-05, epsilon=1.4901161193847656e-08, maxiter=None, full_output=0, disp=1, retall=0, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : callable f(x, *args)\n    Objective function to be minimized. \nx0 : ndarray\n    Initial guess. \nfprime : callable f'(x, *args)\n    Gradient of f. \nfhess_p : callable fhess_p(x, p, *args), optional\n    Function which computes the Hessian of f times an arbitrary vector, p. \nfhess : callable fhess(x, *args), optional\n    Function to compute the Hessian matrix of f. \nargs : tuple, optional\n    Extra arguments passed to f, fprime, fhess_p, and fhess (the same set of extra arguments is supplied to all of these functions). \nepsilon : float or ndarray, optional\n    If fhess is approximated, use this value for the step size. \ncallback : callable, optional\n    An optional user-supplied function which is called after each iteration.  Called as callback(xk), where xk is the current parameter vector. \navextol : float, optional\n    Convergence is assumed when the average relative error in the minimizer falls below this amount. \nmaxiter : int, optional\n    Maximum number of iterations to perform. \nfull_output : bool, optional\n    If True, return the optional outputs. \ndisp : bool, optional\n    If True, print convergence message. \nretall : bool, optional\n    If True, return a list of results at each iteration.</code></pre><span class="prog__sub">Returns:</span><pre><code>xopt : ndarray\n    Parameters which minimize f, i.e. f(xopt) == fopt. \nfopt : float\n    Value of the function at xopt, i.e. fopt = f(xopt). \nfcalls : int\n    Number of function calls made. \ngcalls : int\n    Number of gradient calls made. \nhcalls : int\n    Number of hessian calls made. \nwarnflag : int\n    Warnings generated by the algorithm. 1 : Maximum number of iterations exceeded. \nallvecs : list\n    The result at each iteration, if retall is True (see below).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_ncg.html
scipy optimize fmin_ncg	R	scipy.optimize.fmin_ncg										
scipy optimize.fmin_ncg	R	scipy.optimize.fmin_ncg										
scipy.optimize.fmin_powell	A										<section class="prog__container"><p>Minimize a function using modified Powell’s method. This method\nonly uses function values, not derivatives.</p><pre><code>scipy.optimize.fmin_powell(func, x0, args=(), xtol=0.0001, ftol=0.0001, maxiter=None, maxfun=None, full_output=0, disp=1, retall=0, callback=None, direc=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(x,*args)\n    Objective function to be minimized. \nx0 : ndarray\n    Initial guess. \nargs : tuple, optional\n    Extra arguments passed to func. \ncallback : callable, optional\n    An optional user-supplied function, called after each iteration.  Called as callback(xk), where xk is the current parameter vector. \ndirec : ndarray, optional\n    Initial direction set. \nxtol : float, optional\n    Line-search error tolerance. \nftol : float, optional\n    Relative error in func(xopt) acceptable for convergence. \nmaxiter : int, optional\n    Maximum number of iterations to perform. \nmaxfun : int, optional\n    Maximum number of function evaluations to make. \nfull_output : bool, optional\n    If True, fopt, xi, direc, iter, funcalls, and warnflag are returned. \ndisp : bool, optional\n    If True, print convergence messages. \nretall : bool, optional\n    If True, return a list of the solution at each iteration.</code></pre><span class="prog__sub">Returns:</span><pre><code>xopt : ndarray\n    Parameter which minimizes func. \nfopt : number\n    Value of function at minimum: fopt = func(xopt). \ndirec : ndarray\n    Current direction set. \niter : int\n    Number of iterations. \nfuncalls : int\n    Number of function calls made. \nwarnflag : int\n    Integer warning flag: 1 : Maximum number of function evaluations. 2 : Maximum number of iterations.   \nallvecs : list\n    List of solutions at each iteration.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_powell.html
scipy optimize fmin_powell	R	scipy.optimize.fmin_powell										
scipy optimize.fmin_powell	R	scipy.optimize.fmin_powell										
scipy optimize fmin	R	scipy.optimize.fmin										
scipy optimize.fmin	R	scipy.optimize.fmin										
scipy.optimize.fmin_slsqp	A										<section class="prog__container"><p>Minimize a function using Sequential Least SQuares Programming</p><pre><code>scipy.optimize.fmin_slsqp(func, x0, eqcons=(), f_eqcons=None, ieqcons=(), f_ieqcons=None, bounds=(), fprime=None, fprime_eqcons=None, fprime_ieqcons=None, args=(), iter=100, acc=1e-06, iprint=1, disp=None, full_output=0, epsilon=1.4901161193847656e-08, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(x,*args)\n    Objective function. \nx0 : 1-D ndarray of float\n    Initial guess for the independent variable(s). \neqcons : list, optional\n    A list of functions of length n such that eqcons[j](x,*args) == 0.0 in a successfully optimized problem. \nf_eqcons : callable f(x,*args), optional\n    Returns a 1-D array in which each element must equal 0.0 in a successfully optimized problem.  If f_eqcons is specified, eqcons is ignored. \nieqcons : list, optional\n    A list of functions of length n such that ieqcons[j](x,*args) >= 0.0 in a successfully optimized problem. \nf_ieqcons : callable f(x,*args), optional\n    Returns a 1-D ndarray in which each element must be greater or equal to 0.0 in a successfully optimized problem.  If f_ieqcons is specified, ieqcons is ignored. \nbounds : list, optional\n    A list of tuples specifying the lower and upper bound for each independent variable [(xl0, xu0),(xl1, xu1),...] Infinite values will be interpreted as large floating values. \nfprime : callable f(x,*args), optional\n    A function that evaluates the partial derivatives of func. \nfprime_eqcons : callable f(x,*args), optional\n    A function of the form f(x, *args) that returns the m by n array of equality constraint normals.  If not provided, the normals will be approximated. The array returned by fprime_eqcons should be sized as ( len(eqcons), len(x0) ). \nfprime_ieqcons : callable f(x,*args), optional\n    A function of the form f(x, *args) that returns the m by n array of inequality constraint normals.  If not provided, the normals will be approximated. The array returned by fprime_ieqcons should be sized as ( len(ieqcons), len(x0) ). \nargs : sequence, optional\n    Additional arguments passed to func and fprime. \niter : int, optional\n    The maximum number of iterations. \nacc : float, optional\n    Requested accuracy. \niprint : int, optional\n    The verbosity of fmin_slsqp :  iprint <= 0 : Silent operation iprint == 1 : Print summary upon completion (default) iprint >= 2 : Print status of each iterate and summary  \ndisp : int, optional\n    Over-rides the iprint interface (preferred). \nfull_output : bool, optional\n    If False, return only the minimizer of func (default). Otherwise, output final objective function and summary information. \nepsilon : float, optional\n    The step size for finite-difference derivative estimates. \ncallback : callable, optional\n    Called after each iteration, as callback(x), where x is the current parameter vector.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray of float\n    The final minimizer of func. \nfx : ndarray of float, if full_output is true\n    The final value of the objective function. \nits : int, if full_output is true\n    The number of iterations. \nimode : int, if full_output is true\n    The exit mode from the optimizer (see below). \nsmode : string, if full_output is true\n    Message describing the exit mode from the optimizer.</code></pre><span class="prog__sub">Examples:</span><pre><code>-1 : Gradient evaluation required (g & a)\n 0 : Optimization terminated successfully.\n 1 : Function evaluation required (f & c)\n 2 : More equality constraints than independent variables\n 3 : More than 3*n iterations in LSQ subproblem\n 4 : Inequality constraints incompatible\n 5 : Singular matrix E in LSQ subproblem\n 6 : Singular matrix C in LSQ subproblem\n 7 : Rank-deficient equality constraint subproblem HFTI\n 8 : Positive directional derivative for linesearch\n 9 : Iteration limit exceeded</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_slsqp.html
scipy optimize fmin_slsqp	R	scipy.optimize.fmin_slsqp										
scipy optimize.fmin_slsqp	R	scipy.optimize.fmin_slsqp										
scipy.optimize.fmin_tnc	A										<section class="prog__container"><p>Minimize a function with variables subject to bounds, using\ngradient information in a truncated Newton algorithm. This\nmethod wraps a C implementation of the algorithm.</p><pre><code>scipy.optimize.fmin_tnc(func, x0, fprime=None, args=(), approx_grad=0, bounds=None, epsilon=1e-08, scale=None, offset=None, messages=15, maxCGit=-1, maxfun=None, eta=-1, stepmx=0, accuracy=0, fmin=0, ftol=-1, xtol=-1, pgtol=-1, rescale=-1, disp=None, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable func(x, *args)\n    Function to minimize.  Must do one of:  Return f and g, where f is the value of the function and g its gradient (a list of floats). Return the function value but supply gradient function separately as fprime. Return the function value and set approx_grad=True.  If the function returns None, the minimization is aborted. \nx0 : array_like\n    Initial estimate of minimum. \nfprime : callable fprime(x, *args), optional\n    Gradient of func. If None, then either func must return the function value and the gradient (f,g = func(x, *args)) or approx_grad must be True. \nargs : tuple, optional\n    Arguments to pass to function. \napprox_grad : bool, optional\n    If true, approximate the gradient numerically. \nbounds : list, optional\n    (min, max) pairs for each element in x0, defining the bounds on that parameter. Use None or +/-inf for one of min or max when there is no bound in that direction. \nepsilon : float, optional\n    Used if approx_grad is True. The stepsize in a finite difference approximation for fprime. \nscale : array_like, optional\n    Scaling factors to apply to each variable.  If None, the factors are up-low for interval bounded variables and 1+|x| for the others.  Defaults to None. \noffset : array_like, optional\n    Value to subtract from each variable.  If None, the offsets are (up+low)/2 for interval bounded variables and x for the others. \nmessages : int, optional\n    Bit mask used to select messages display during minimization values defined in the MSGS dict.  Defaults to MGS_ALL. \ndisp : int, optional\n    Integer interface to messages.  0 = no message, 5 = all messages \nmaxCGit : int, optional\n    Maximum number of hessian*vector evaluations per main iteration.  If maxCGit == 0, the direction chosen is -gradient if maxCGit < 0, maxCGit is set to max(1,min(50,n/2)).  Defaults to -1. \nmaxfun : int, optional\n    Maximum number of function evaluation.  if None, maxfun is set to max(100, 10*len(x0)).  Defaults to None. \neta : float, optional\n    Severity of the line search. if < 0 or > 1, set to 0.25. Defaults to -1. \nstepmx : float, optional\n    Maximum step for the line search.  May be increased during call.  If too small, it will be set to 10.0.  Defaults to 0. \naccuracy : float, optional\n    Relative precision for finite difference calculations.  If <= machine_precision, set to sqrt(machine_precision). Defaults to 0. \nfmin : float, optional\n    Minimum function value estimate.  Defaults to 0. \nftol : float, optional\n    Precision goal for the value of f in the stoping criterion. If ftol < 0.0, ftol is set to 0.0 defaults to -1. \nxtol : float, optional\n    Precision goal for the value of x in the stopping criterion (after applying x scaling factors).  If xtol < 0.0, xtol is set to sqrt(machine_precision).  Defaults to -1. \npgtol : float, optional\n    Precision goal for the value of the projected gradient in the stopping criterion (after applying x scaling factors). If pgtol < 0.0, pgtol is set to 1e-2 * sqrt(accuracy). Setting it to 0.0 is not recommended.  Defaults to -1. \nrescale : float, optional\n    Scaling factor (in log10) used to trigger f value rescaling.  If 0, rescale at each iteration.  If a large value, never rescale.  If < 0, rescale is set to 1.3. \ncallback : callable, optional\n    Called after each iteration, as callback(xk), where xk is the current parameter vector.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    The solution. \nnfeval : int\n    The number of function evaluations. \nrc : int\n    Return code, see below</code></pre><span class="prog__sub">Examples:</span><pre><code>-1 : Infeasible (lower bound > upper bound)\n 0 : Local minimum reached (|pg| ~= 0)\n 1 : Converged (|f_n-f_(n-1)| ~= 0)\n 2 : Converged (|x_n-x_(n-1)| ~= 0)\n 3 : Max. number of function evaluations reached\n 4 : Linear search failed\n 5 : All lower bounds are equal to the upper bounds\n 6 : Unable to progress\n 7 : User requested end of minimization</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin_tnc.html
scipy optimize fmin_tnc	R	scipy.optimize.fmin_tnc										
scipy optimize.fmin_tnc	R	scipy.optimize.fmin_tnc										
scipy.optimize.fsolve	A										<section class="prog__container"><p>Find the roots of a function.</p><pre><code>scipy.optimize.fsolve(func, x0, args=(), fprime=None, full_output=0, col_deriv=0, xtol=1.49012e-08, maxfev=0, band=None, epsfcn=None, factor=100, diag=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable f(x, *args)\n    A function that takes at least one (possibly vector) argument. \nx0 : ndarray\n    The starting estimate for the roots of func(x) = 0. \nargs : tuple, optional\n    Any extra arguments to func. \nfprime : callable(x), optional\n    A function to compute the Jacobian of func with derivatives across the rows. By default, the Jacobian will be estimated. \nfull_output : bool, optional\n    If True, return optional outputs. \ncol_deriv : bool, optional\n    Specify whether the Jacobian function computes derivatives down the columns (faster, because there is no transpose operation). \nxtol : float, optional\n    The calculation will terminate if the relative error between two consecutive iterates is at most xtol. \nmaxfev : int, optional\n    The maximum number of calls to the function. If zero, then 100*(N+1) is the maximum where N is the number of elements in x0. \nband : tuple, optional\n    If set to a two-sequence containing the number of sub- and super-diagonals within the band of the Jacobi matrix, the Jacobi matrix is considered banded (only for fprime=None). \nepsfcn : float, optional\n    A suitable step length for the forward-difference approximation of the Jacobian (for fprime=None). If epsfcn is less than the machine precision, it is assumed that the relative errors in the functions are of the order of the machine precision. \nfactor : float, optional\n    A parameter determining the initial step bound (factor * || diag * x||).  Should be in the interval (0.1, 100). \ndiag : sequence, optional\n    N positive entries that serve as a scale factors for the variables.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    The solution (or the result of the last iteration for an unsuccessful call). \ninfodict : dict\n    A dictionary of optional outputs with the keys:  nfev number of function calls  njev number of Jacobian calls  fvec function evaluated at the output  fjac the orthogonal matrix, q, produced by the QR factorization of the final approximate Jacobian matrix, stored column wise  r upper triangular matrix produced by QR factorization of the same matrix  qtf the vector (transpose(q) * fvec)   \nier : int\n    An integer flag.  Set to 1 if a solution was found, otherwise refer to mesg for more information. \nmesg : str\n    If no solution is found, mesg details the cause of failure.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html
scipy optimize fsolve	R	scipy.optimize.fsolve										
scipy optimize.fsolve	R	scipy.optimize.fsolve										
scipy.optimize.golden	A										<section class="prog__container"><p>Return the minimum of a function of one variable.</p><pre><code>scipy.optimize.golden(func, args=(), brack=None, tol=1.4901161193847656e-08, full_output=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable func(x,*args)\n    Objective function to minimize. \nargs : tuple, optional\n    Additional arguments (if present), passed to func. \nbrack : tuple, optional\n    Triple (a,b,c), where (a<b<c) and func(b) < func(a),func(c).  If bracket consists of two numbers (a, c), then they are assumed to be a starting interval for a downhill bracket search (see bracket); it doesn’t always mean that obtained solution will satisfy a<=x<=c. \ntol : float, optional\n    x tolerance stop criterion \nfull_output : bool, optional\n    If True, return optional outputs.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.golden.html
scipy optimize golden	R	scipy.optimize.golden										
scipy optimize.golden	R	scipy.optimize.golden										
scipy.optimize.LbfgsInvHessProduct.adjoint	A										<section class="prog__container"><p>Hermitian adjoint.</p><pre><code>LbfgsInvHessProduct.adjoint()</code></pre><span class="prog__sub">Parameters:</span><pre><code>A_H : LinearOperator\n    Hermitian adjoint of self.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.adjoint.html
scipy optimize LbfgsInvHessProduct adjoint	R	scipy.optimize.LbfgsInvHessProduct.adjoint										
scipy optimize.LbfgsInvHessProduct.adjoint	R	scipy.optimize.LbfgsInvHessProduct.adjoint										
scipy.optimize.LbfgsInvHessProduct	A										<section class="prog__container"><p>Linear operator for the L-BFGS approximate inverse Hessian.</p><pre><code>class scipy.optimize.LbfgsInvHessProduct(sk, yk)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sk : array_like, shape=(n_corr, n)\n    Array of n_corr most recent updates to the solution vector. (See [1]). \nyk : array_like, shape=(n_corr, n)\n    Array of n_corr most recent updates to the gradient. (See [1]).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.html
scipy.optimize.LbfgsInvHessProduct.dot	A										<section class="prog__container"><p>Matrix-matrix or matrix-vector multiplication.</p><pre><code>LbfgsInvHessProduct.dot(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-d or 2-d array, representing a vector or matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>Ax : array\n    1-d or 2-d array (depending on the shape of x) that represents the result of applying this linear operator on x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.dot.html
scipy optimize LbfgsInvHessProduct dot	R	scipy.optimize.LbfgsInvHessProduct.dot										
scipy optimize.LbfgsInvHessProduct.dot	R	scipy.optimize.LbfgsInvHessProduct.dot										
scipy.optimize.LbfgsInvHessProduct.H	A										<section class="prog__container"><p>Hermitian adjoint.</p><pre><code>LbfgsInvHessProduct.H</code></pre><span class="prog__sub">Parameters:</span><pre><code>A_H : LinearOperator\n    Hermitian adjoint of self.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.H.html
scipy optimize LbfgsInvHessProduct H	R	scipy.optimize.LbfgsInvHessProduct.H										
scipy optimize.LbfgsInvHessProduct.H	R	scipy.optimize.LbfgsInvHessProduct.H										
scipy.optimize.LbfgsInvHessProduct.matmat	A										<section class="prog__container"><p>Matrix-matrix multiplication.</p><pre><code>LbfgsInvHessProduct.matmat(X)</code></pre><span class="prog__sub">Parameters:</span><pre><code>X : {matrix, ndarray}\n    An array with shape (N,K).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : {matrix, ndarray}\n    A matrix or ndarray with shape (M,K) depending on the type of the X argument.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.matmat.html
scipy optimize LbfgsInvHessProduct matmat	R	scipy.optimize.LbfgsInvHessProduct.matmat										
scipy optimize.LbfgsInvHessProduct.matmat	R	scipy.optimize.LbfgsInvHessProduct.matmat										
scipy.optimize.LbfgsInvHessProduct.matvec	A										<section class="prog__container"><p>Matrix-vector multiplication.</p><pre><code>LbfgsInvHessProduct.matvec(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : {matrix, ndarray}\n    An array with shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : {matrix, ndarray}\n    A matrix or ndarray with shape (M,) or (M,1) depending on the type and shape of the x argument.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.matvec.html
scipy optimize LbfgsInvHessProduct matvec	R	scipy.optimize.LbfgsInvHessProduct.matvec										
scipy optimize.LbfgsInvHessProduct.matvec	R	scipy.optimize.LbfgsInvHessProduct.matvec										
scipy.optimize.LbfgsInvHessProduct.rmatvec	A										<section class="prog__container"><p>Adjoint matrix-vector multiplication.</p><pre><code>LbfgsInvHessProduct.rmatvec(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : {matrix, ndarray}\n    An array with shape (M,) or (M,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : {matrix, ndarray}\n    A matrix or ndarray with shape (N,) or (N,1) depending on the type and shape of the x argument.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.rmatvec.html
scipy optimize LbfgsInvHessProduct rmatvec	R	scipy.optimize.LbfgsInvHessProduct.rmatvec										
scipy optimize.LbfgsInvHessProduct.rmatvec	R	scipy.optimize.LbfgsInvHessProduct.rmatvec										
scipy optimize LbfgsInvHessProduct	R	scipy.optimize.LbfgsInvHessProduct										
scipy optimize.LbfgsInvHessProduct	R	scipy.optimize.LbfgsInvHessProduct										
scipy.optimize.LbfgsInvHessProduct.T	A										<section class="prog__container"><p>Transpose this linear operator.</p><pre><code>LbfgsInvHessProduct.T</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.T.html
scipy.optimize.LbfgsInvHessProduct.todense	A										<section class="prog__container"><p>Return a dense array representation of this operator.</p><pre><code>LbfgsInvHessProduct.todense()</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : ndarray, shape=(n, n)\n    An array with the same shape and containing the same data represented by this LinearOperator.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.todense.html
scipy optimize LbfgsInvHessProduct todense	R	scipy.optimize.LbfgsInvHessProduct.todense										
scipy optimize.LbfgsInvHessProduct.todense	R	scipy.optimize.LbfgsInvHessProduct.todense										
scipy.optimize.LbfgsInvHessProduct.transpose	A										<section class="prog__container"><p>Transpose this linear operator.</p><pre><code>LbfgsInvHessProduct.transpose()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.LbfgsInvHessProduct.transpose.html
scipy optimize LbfgsInvHessProduct transpose	R	scipy.optimize.LbfgsInvHessProduct.transpose										
scipy optimize.LbfgsInvHessProduct.transpose	R	scipy.optimize.LbfgsInvHessProduct.transpose										
scipy optimize LbfgsInvHessProduct T	R	scipy.optimize.LbfgsInvHessProduct.T										
scipy optimize.LbfgsInvHessProduct.T	R	scipy.optimize.LbfgsInvHessProduct.T										
scipy.optimize.leastsq	A										<section class="prog__container"><p>Minimize the sum of squares of a set of equations.</p><pre><code>scipy.optimize.leastsq(func, x0, args=(), Dfun=None, full_output=0, col_deriv=0, ftol=1.49012e-08, xtol=1.49012e-08, gtol=0.0, maxfev=0, epsfcn=None, factor=100, diag=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable\n    should take at least one (possibly length N vector) argument and returns M floating point numbers. It must not return NaNs or fitting might fail. \nx0 : ndarray\n    The starting estimate for the minimization. \nargs : tuple, optional\n    Any extra arguments to func are placed in this tuple. \nDfun : callable, optional\n    A function or method to compute the Jacobian of func with derivatives across the rows. If this is None, the Jacobian will be estimated. \nfull_output : bool, optional\n    non-zero to return all optional outputs. \ncol_deriv : bool, optional\n    non-zero to specify that the Jacobian function computes derivatives down the columns (faster, because there is no transpose operation). \nftol : float, optional\n    Relative error desired in the sum of squares. \nxtol : float, optional\n    Relative error desired in the approximate solution. \ngtol : float, optional\n    Orthogonality desired between the function vector and the columns of the Jacobian. \nmaxfev : int, optional\n    The maximum number of calls to the function. If Dfun is provided then the default maxfev is 100*(N+1) where N is the number of elements in x0, otherwise the default maxfev is 200*(N+1). \nepsfcn : float, optional\n    A variable used in determining a suitable step length for the forward- difference approximation of the Jacobian (for Dfun=None). Normally the actual step length will be sqrt(epsfcn)*x If epsfcn is less than the machine precision, it is assumed that the relative errors are of the order of the machine precision. \nfactor : float, optional\n    A parameter determining the initial step bound (factor * || diag * x||). Should be in interval (0.1, 100). \ndiag : sequence, optional\n    N positive entries that serve as a scale factors for the variables.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    The solution (or the result of the last iteration for an unsuccessful call). \ncov_x : ndarray\n    Uses the fjac and ipvt optional outputs to construct an estimate of the jacobian around the solution. None if a singular matrix encountered (indicates very flat curvature in some direction).  This matrix must be multiplied by the residual variance to get the covariance of the parameter estimates – see curve_fit. \ninfodict : dict\n    a dictionary of optional outputs with the key s:  nfev The number of function calls  fvec The function evaluated at the output  fjac A permutation of the R matrix of a QR factorization of the final approximate Jacobian matrix, stored column wise. Together with ipvt, the covariance of the estimate can be approximated.  ipvt An integer array of length N which defines a permutation matrix, p, such that fjac*p = q*r, where r is upper triangular with diagonal elements of nonincreasing magnitude. Column j of p is column ipvt(j) of the identity matrix.  qtf The vector (transpose(q) * fvec).   \nmesg : str\n    A string message giving information about the cause of failure. \nier : int\n    An integer flag.  If it is equal to 1, 2, 3 or 4, the solution was found.  Otherwise, the solution was not found. In either case, the optional output variable ‘mesg’ gives more information.</code></pre><span class="prog__sub">Examples:</span><pre><code>x = arg min(sum(func(y)**2,axis=0))\n         y</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.leastsq.html
scipy optimize leastsq	R	scipy.optimize.leastsq										
scipy optimize.leastsq	R	scipy.optimize.leastsq										
scipy.optimize.least_squares	A										<section class="prog__container"><p>Solve a nonlinear least-squares problem with bounds on the variables.</p><pre><code>scipy.optimize.least_squares(fun, x0, jac='2-point', bounds=(-inf, inf), method='trf', ftol=1e-08, xtol=1e-08, gtol=1e-08, x_scale=1.0, loss='linear', f_scale=1.0, diff_step=None, tr_solver=None, tr_options={}, jac_sparsity=None, max_nfev=None, verbose=0, args=(), kwargs={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>fun : callable\n    Function which computes the vector of residuals, with the signature fun(x, *args, **kwargs), i.e., the minimization proceeds with respect to its first argument. The argument x passed to this function is an ndarray of shape (n,) (never a scalar, even for n=1). It must return a 1-d array_like of shape (m,) or a scalar. \nx0 : array_like with shape (n,) or float\n    Initial guess on independent variables. If float, it will be treated as a 1-d array with one element. \njac : {‘2-point’, ‘3-point’, ‘cs’, callable}, optional\n    Method of computing the Jacobian matrix (an m-by-n matrix, where element (i, j) is the partial derivative of f[i] with respect to x[j]). The keywords select a finite difference scheme for numerical estimation. The scheme ‘3-point’ is more accurate, but requires twice as much operations compared to ‘2-point’ (default). The scheme ‘cs’ uses complex steps, and while potentially the most accurate, it is applicable only when fun correctly handles complex inputs and can be analytically continued to the complex plane. Method ‘lm’ always uses the ‘2-point’ scheme. If callable, it is used as jac(x, *args, **kwargs) and should return a good approximation (or the exact value) for the Jacobian as an array_like (np.atleast_2d is applied), a sparse matrix or a scipy.sparse.linalg.LinearOperator. \nbounds : 2-tuple of array_like, optional\n    Lower and upper bounds on independent variables. Defaults to no bounds. Each array must match the size of x0 or be a scalar, in the latter case a bound will be the same for all variables. Use np.inf with an appropriate sign to disable bounds on all or some variables. \nmethod : {‘trf’, ‘dogbox’, ‘lm’}, optional\n    Algorithm to perform minimization.   ‘trf’ : Trust Region Reflective algorithm, particularly suitable for large sparse problems with bounds. Generally robust method. ‘dogbox’ : dogleg algorithm with rectangular trust regions, typical use case is small problems with bounds. Not recommended for problems with rank-deficient Jacobian. ‘lm’ : Levenberg-Marquardt algorithm as implemented in MINPACK. Doesn’t handle bounds and sparse Jacobians. Usually the most efficient method for small unconstrained problems.   Default is ‘trf’. See Notes for more information. \nftol : float, optional\n    Tolerance for termination by the change of the cost function. Default is 1e-8. The optimization process is stopped when  dF < ftol * F, and there was an adequate agreement between a local quadratic model and the true model in the last step. \nxtol : float, optional\n    Tolerance for termination by the change of the independent variables. Default is 1e-8. The exact condition depends on the method used:   For ‘trf’ and ‘dogbox’ : norm(dx) < xtol * (xtol + norm(x)) For ‘lm’ : Delta < xtol * norm(xs), where Delta is a trust-region radius and xs is the value of x scaled according to x_scale parameter (see below).   \ngtol : float, optional\n    Tolerance for termination by the norm of the gradient. Default is 1e-8. The exact condition depends on a method used:   For ‘trf’ : norm(g_scaled, ord=np.inf) < gtol, where g_scaled is the value of the gradient scaled to account for the presence of the bounds [STIR]. For ‘dogbox’ : norm(g_free, ord=np.inf) < gtol, where g_free is the gradient with respect to the variables which are not in the optimal state on the boundary. For ‘lm’ : the maximum absolute value of the cosine of angles between columns of the Jacobian and the residual vector is less than gtol, or the residual vector is zero.   \nx_scale : array_like or ‘jac’, optional\n    Characteristic scale of each variable. Setting x_scale is equivalent to reformulating the problem in scaled variables xs = x / x_scale. An alternative view is that the size of a trust region along j-th dimension is proportional to x_scale[j]. Improved convergence may be achieved by setting x_scale such that a step of a given size along any of the scaled variables has a similar effect on the cost function. If set to ‘jac’, the scale is iteratively updated using the inverse norms of the columns of the Jacobian matrix (as described in [JJMore]). \nloss : str or callable, optional\n    Determines the loss function. The following keyword values are allowed:   ‘linear’ (default) : rho(z) = z. Gives a standard least-squares problem. ‘soft_l1’ : rho(z) = 2 * ((1 + z)**0.5 - 1). The smooth approximation of l1 (absolute value) loss. Usually a good choice for robust least squares. ‘huber’ : rho(z) = z if z <= 1 else 2*z**0.5 - 1. Works similarly to ‘soft_l1’. ‘cauchy’ : rho(z) = ln(1 + z). Severely weakens outliers influence, but may cause difficulties in optimization process. ‘arctan’ : rho(z) = arctan(z). Limits a maximum loss on a single residual, has properties similar to ‘cauchy’.   If callable, it must take a 1-d ndarray z=f**2 and return an array_like with shape (3, m) where row 0 contains function values, row 1 contains first derivatives and row 2 contains second derivatives. Method ‘lm’ supports only ‘linear’ loss. \nf_scale : float, optional\n    Value of soft margin between inlier and outlier residuals, default is 1.0. The loss function is evaluated as follows rho_(f**2) = C**2 * rho(f**2 / C**2), where C is f_scale, and rho is determined by loss parameter. This parameter has no effect with loss='linear', but for other loss values it is of crucial importance. \nmax_nfev : None or int, optional\n    Maximum number of function evaluations before the termination. If None (default), the value is chosen automatically:   For ‘trf’ and ‘dogbox’ : 100 * n. For ‘lm’ :  100 * n if jac is callable and 100 * n * (n + 1) otherwise (because ‘lm’ counts function calls in Jacobian estimation).   \ndiff_step : None or array_like, optional\n    Determines the relative step size for the finite difference approximation of the Jacobian. The actual step is computed as x * diff_step. If None (default), then diff_step is taken to be a conventional “optimal” power of machine epsilon for the finite difference scheme used [NR]. \ntr_solver : {None, ‘exact’, ‘lsmr’}, optional\n    Method for solving trust-region subproblems, relevant only for ‘trf’ and ‘dogbox’ methods.   ‘exact’ is suitable for not very large problems with dense Jacobian matrices. The computational complexity per iteration is comparable to a singular value decomposition of the Jacobian matrix. ‘lsmr’ is suitable for problems with sparse and large Jacobian matrices. It uses the iterative procedure scipy.sparse.linalg.lsmr for finding a solution of a linear least-squares problem and only requires matrix-vector product evaluations.   If None (default) the solver is chosen based on the type of Jacobian returned on the first iteration. \ntr_options : dict, optional\n    Keyword options passed to trust-region solver.   tr_solver='exact': tr_options are ignored. tr_solver='lsmr': options for scipy.sparse.linalg.lsmr. Additionally  method='trf' supports  ‘regularize’ option (bool, default is True) which adds a regularization term to the normal equation, which improves convergence if the Jacobian is rank-deficient [Byrd] (eq. 3.4).   \njac_sparsity : {None, array_like, sparse matrix}, optional\n    Defines the sparsity structure of the Jacobian matrix for finite difference estimation, its shape must be (m, n). If the Jacobian has only few non-zero elements in each row, providing the sparsity structure will greatly speed up the computations [Curtis]. A zero entry means that a corresponding element in the Jacobian is identically zero. If provided, forces the use of ‘lsmr’ trust-region solver. If None (default) then dense differencing will be used. Has no effect for ‘lm’ method. \nverbose : {0, 1, 2}, optional\n    Level of algorithm’s verbosity:   0 (default) : work silently. 1 : display a termination report. 2 : display progress during iterations (not supported by ‘lm’ method).   \nargs, kwargs : tuple and dict, optional\n    Additional arguments passed to fun and jac. Both empty by default. The calling signature is fun(x, *args, **kwargs) and the same for jac.</code></pre><span class="prog__sub">Returns:</span><pre><code>OptimizeResult with the following fields defined:\nx : ndarray, shape (n,)\n    Solution found. \ncost : float\n    Value of the cost function at the solution. \nfun : ndarray, shape (m,)\n    Vector of residuals at the solution. \njac : ndarray, sparse matrix or LinearOperator, shape (m, n)\n    Modified Jacobian matrix at the solution, in the sense that J^T J is a Gauss-Newton approximation of the Hessian of the cost function. The type is the same as the one used by the algorithm. \ngrad : ndarray, shape (m,)\n    Gradient of the cost function at the solution. \noptimality : float\n    First-order optimality measure. In unconstrained problems, it is always the uniform norm of the gradient. In constrained problems, it is the quantity which was compared with gtol during iterations. \nactive_mask : ndarray of int, shape (n,)\n    Each component shows whether a corresponding constraint is active (that is, whether a variable is at the bound):   0 : a constraint is not active. -1 : a lower bound is active. 1 : an upper bound is active.   Might be somewhat arbitrary for ‘trf’ method as it generates a sequence of strictly feasible iterates and active_mask is determined within a tolerance threshold. \nnfev : int\n    Number of function evaluations done. Methods ‘trf’ and ‘dogbox’ do not count function calls for numerical Jacobian approximation, as opposed to ‘lm’ method. \nnjev : int or None\n    Number of Jacobian evaluations done. If numerical Jacobian approximation is used in ‘lm’ method, it is set to None. \nstatus : int\n    The reason for algorithm termination:   -1 : improper input parameters status returned from MINPACK. 0 : the maximum number of function evaluations is exceeded. 1 : gtol termination condition is satisfied. 2 : ftol termination condition is satisfied. 3 : xtol termination condition is satisfied. 4 : Both ftol and xtol termination conditions are satisfied.   \nmessage : str\n    Verbal description of the termination reason. \nsuccess : bool\n    True if one of the convergence criteria is satisfied (status > 0).</code></pre><span class="prog__sub">Examples:</span><pre><code>minimize F(x) = 0.5 * sum(rho(f_i(x)**2), i = 0, ..., m - 1)\nsubject to lb <= x <= ub</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html
scipy optimize least_squares	R	scipy.optimize.least_squares										
scipy optimize.least_squares	R	scipy.optimize.least_squares										
scipy.optimize.linearmixing	A										<section class="prog__container"><p>Find a root of a function, using a scalar Jacobian approximation.</p><pre><code>scipy.optimize.linearmixing(F, xin, iter=None, alpha=None, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : function(x) -> f\n    Function whose root to find; should take and return an array-like object. \nx0 : array_like\n    Initial guess for the solution \nalpha : float, optional\n    The Jacobian approximation is (-1/alpha). \niter : int, optional\n    Number of iterations to make. If omitted (default), make as many as required to meet tolerances. \nverbose : bool, optional\n    Print status to stdout on every iteration. \nmaxiter : int, optional\n    Maximum number of iterations to make. If more are needed to meet convergence, NoConvergence is raised. \nf_tol : float, optional\n    Absolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6. \nf_rtol : float, optional\n    Relative tolerance for the residual. If omitted, not used. \nx_tol : float, optional\n    Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used. \nx_rtol : float, optional\n    Relative minimum step size. If omitted, not used. \ntol_norm : function(vector) -> scalar, optional\n    Norm to use in convergence check. Default is the maximum norm. \nline_search : {None, ‘armijo’ (default), ‘wolfe’}, optional\n    Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to ‘armijo’. \ncallback : function, optional\n    Optional callback function. It is called on every iteration as callback(x, f) where x is the current solution and f the corresponding residual.</code></pre><span class="prog__sub">Returns:</span><pre><code>sol : ndarray\n    An array (of similar array type as x0) containing the final solution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linearmixing.html
scipy optimize linearmixing	R	scipy.optimize.linearmixing										
scipy optimize.linearmixing	R	scipy.optimize.linearmixing										
scipy.optimize.linear_sum_assignment	A										<section class="prog__container"><p>Solve the linear sum assignment problem.</p><pre><code>scipy.optimize.linear_sum_assignment(cost_matrix)</code></pre><span class="prog__sub">Parameters:</span><pre><code>cost_matrix : array\n    The cost matrix of the bipartite graph.</code></pre><span class="prog__sub">Returns:</span><pre><code>row_ind, col_ind : array\n    An array of row indices and one of corresponding column indices giving the optimal assignment. The cost of the assignment can be computed as cost_matrix[row_ind, col_ind].sum(). The row indices will be sorted; in the case of a square cost matrix they will be equal to numpy.arange(cost_matrix.shape[0]).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> cost = np.array([[4, 1, 3], [2, 0, 5], [3, 2, 2]])\n>>> from scipy.optimize import linear_sum_assignment\n>>> row_ind, col_ind = linear_sum_assignment(cost)\n>>> col_ind\narray([1, 0, 2])\n>>> cost[row_ind, col_ind].sum()\n5</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linear_sum_assignment.html
scipy optimize linear_sum_assignment	R	scipy.optimize.linear_sum_assignment										
scipy optimize.linear_sum_assignment	R	scipy.optimize.linear_sum_assignment										
scipy.optimize.line_search	A										<section class="prog__container"><p>Find alpha that satisfies strong Wolfe conditions.</p><pre><code>scipy.optimize.line_search(f, myfprime, xk, pk, gfk=None, old_fval=None, old_old_fval=None, args=(), c1=0.0001, c2=0.9, amax=50)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : callable f(x,*args)\n    Objective function. \nmyfprime : callable f’(x,*args)\n    Objective function gradient. \nxk : ndarray\n    Starting point. \npk : ndarray\n    Search direction. \ngfk : ndarray, optional\n    Gradient value for x=xk (xk being the current parameter estimate). Will be recomputed if omitted. \nold_fval : float, optional\n    Function value for x=xk. Will be recomputed if omitted. \nold_old_fval : float, optional\n    Function value for the point preceding x=xk \nargs : tuple, optional\n    Additional arguments passed to objective function. \nc1 : float, optional\n    Parameter for Armijo condition rule. \nc2 : float, optional\n    Parameter for curvature condition rule. \namax : float, optional\n    Maximum step size</code></pre><span class="prog__sub">Returns:</span><pre><code>alpha : float or None\n    Alpha for which x_new = x0 + alpha * pk, or None if the line search algorithm did not converge. \nfc : int\n    Number of function evaluations made. \ngc : int\n    Number of gradient evaluations made. \nnew_fval : float or None\n    New function value f(x_new)=f(x0+alpha*pk), or None if the line search algorithm did not converge. \nold_fval : float\n    Old function value f(x0). \nnew_slope : float or None\n    The local slope along the search direction at the new value <myfprime(x_new), pk>, or None if the line search algorithm did not converge.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.line_search.html
scipy optimize line_search	R	scipy.optimize.line_search										
scipy optimize.line_search	R	scipy.optimize.line_search										
scipy.optimize.linprog	A										<section class="prog__container"><p>Minimize a linear objective function subject to linear\nequality and inequality constraints.</p><pre><code>scipy.optimize.linprog(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='simplex', callback=None, options=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>c : array_like\n    Coefficients of the linear objective function to be minimized. \nA_ub : array_like, optional\n    2-D array which, when matrix-multiplied by x, gives the values of the upper-bound inequality constraints at x. \nb_ub : array_like, optional\n    1-D array of values representing the upper-bound of each inequality constraint (row) in A_ub. \nA_eq : array_like, optional\n    2-D array which, when matrix-multiplied by x, gives the values of the equality constraints at x. \nb_eq : array_like, optional\n    1-D array of values representing the RHS of each equality constraint (row) in A_eq. \nbounds : sequence, optional\n    (min, max) pairs for each element in x, defining the bounds on that parameter. Use None for one of min or max when there is no bound in that direction. By default bounds are (0, None) (non-negative) If a sequence containing a single tuple is provided, then min and max will be applied to all variables in the problem. \nmethod : str, optional\n    Type of solver.  At this time only ‘simplex’ is supported (see here). \ncallback : callable, optional\n    If a callback function is provide, it will be called within each iteration of the simplex algorithm. The callback must have the signature callback(xk, **kwargs) where xk is the current solution vector and kwargs is a dictionary containing the following: "tableau" : The current Simplex algorithm tableau "nit" : The current iteration. "pivot" : The pivot (row, column) used for the next iteration. "phase" : Whether the algorithm is in Phase 1 or Phase 2. "basis" : The indices of the columns of the basic variables.   \noptions : dict, optional\n    A dictionary of solver options. All methods accept the following generic options:   maxiter : int Maximum number of iterations to perform.  disp : bool Set to True to print convergence messages.    For method-specific options, see show_options(‘linprog’).</code></pre><span class="prog__sub">Returns:</span><pre><code>A scipy.optimize.OptimizeResult consisting of the following fields:\n    x : ndarray The independent variable vector which optimizes the linear programming problem.  fun : float Value of the objective function.  slack : ndarray The values of the slack variables.  Each slack variable corresponds to an inequality constraint.  If the slack is zero, then the corresponding constraint is active.  success : bool Returns True if the algorithm succeeded in finding an optimal solution.  status : int An integer representing the exit status of the optimization: 0 : Optimization terminated successfully 1 : Iteration limit reached 2 : Problem appears to be infeasible 3 : Problem appears to be unbounded    nit : int The number of iterations performed.  message : str A string descriptor of the exit status of the optimization.</code></pre><span class="prog__sub">Examples:</span><pre><code>"tableau" : The current Simplex algorithm tableau\n"nit" : The current iteration.\n"pivot" : The pivot (row, column) used for the next iteration.\n"phase" : Whether the algorithm is in Phase 1 or Phase 2.\n"basis" : The indices of the columns of the basic variables.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html
scipy optimize linprog	R	scipy.optimize.linprog										
scipy optimize.linprog	R	scipy.optimize.linprog										
scipy.optimize.linprog_verbose_callback	A										<section class="prog__container"><p>A sample callback function demonstrating the linprog callback interface.\nThis callback produces detailed output to sys.stdout before each iteration\nand after the final iteration of the simplex algorithm.</p><pre><code>scipy.optimize.linprog_verbose_callback(xk, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>xk : array_like\n    The current solution vector. \n**kwargs : dict\n    A dictionary containing the following parameters:  tableau : array_like The current tableau of the simplex algorithm. Its structure is defined in _solve_simplex.  phase : int The current Phase of the simplex algorithm (1 or 2)  nit : int The current iteration number.  pivot : tuple(int, int) The index of the tableau selected as the next pivot, or nan if no pivot exists  basis : array(int) A list of the current basic variables. Each element contains the name of a basic variable and its value.  complete : bool True if the simplex algorithm has completed (and this is the final call to callback), otherwise False.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog_verbose_callback.html
scipy optimize linprog_verbose_callback	R	scipy.optimize.linprog_verbose_callback										
scipy optimize.linprog_verbose_callback	R	scipy.optimize.linprog_verbose_callback										
scipy.optimize.lsq_linear	A										<section class="prog__container"><p>Solve a linear least-squares problem with bounds on the variables.</p><pre><code>scipy.optimize.lsq_linear(A, b, bounds=(-inf, inf), method='trf', tol=1e-10, lsq_solver=None, lsmr_tol=None, max_iter=None, verbose=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : array_like, sparse matrix of LinearOperator, shape (m, n)\n    Design matrix. Can be scipy.sparse.linalg.LinearOperator. \nb : array_like, shape (m,)\n    Target vector. \nbounds : 2-tuple of array_like, optional\n    Lower and upper bounds on independent variables. Defaults to no bounds. Each array must have shape (n,) or be a scalar, in the latter case a bound will be the same for all variables. Use np.inf with an appropriate sign to disable bounds on all or some variables. \nmethod : ‘trf’ or ‘bvls’, optional\n    Method to perform minimization.   ‘trf’ : Trust Region Reflective algorithm adapted for a linear least-squares problem. This is an interior-point-like method and the required number of iterations is weakly correlated with the number of variables. ‘bvls’ : Bounded-Variable Least-Squares algorithm. This is an active set method, which requires the number of iterations comparable to the number of variables. Can’t be used when A is sparse or LinearOperator.   Default is ‘trf’. \ntol : float, optional\n    Tolerance parameter. The algorithm terminates if a relative change of the cost function is less than tol on the last iteration. Additionally the first-order optimality measure is considered:   method='trf' terminates if the uniform norm of the gradient, scaled to account for the presence of the bounds, is less than tol. method='bvls' terminates if Karush-Kuhn-Tucker conditions are satisfied within tol tolerance.   \nlsq_solver : {None, ‘exact’, ‘lsmr’}, optional\n    Method of solving unbounded least-squares problems throughout iterations:   ‘exact’ : Use dense QR or SVD decomposition approach. Can’t be used when A is sparse or LinearOperator. ‘lsmr’ : Use scipy.sparse.linalg.lsmr iterative procedure which requires only matrix-vector product evaluations. Can’t be used with method='bvls'.   If None (default) the solver is chosen based on type of A. \nlsmr_tol : None, float or ‘auto’, optional\n    Tolerance parameters ‘atol’ and ‘btol’ for scipy.sparse.linalg.lsmr If None (default), it is set to 1e-2 * tol. If ‘auto’, the tolerance will be adjusted based on the optimality of the current iterate, which can speed up the optimization process, but is not always reliable. \nmax_iter : None or int, optional\n    Maximum number of iterations before termination. If None (default), it is set to 100 for method='trf' or to the number of variables for method='bvls' (not counting iterations for ‘bvls’ initialization). \nverbose : {0, 1, 2}, optional\n    Level of algorithm’s verbosity:   0 : work silently (default). 1 : display a termination report. 2 : display progress during iterations.</code></pre><span class="prog__sub">Returns:</span><pre><code>OptimizeResult with the following fields defined:\nx : ndarray, shape (n,)\n    Solution found. \ncost : float\n    Value of the cost function at the solution. \nfun : ndarray, shape (m,)\n    Vector of residuals at the solution. \noptimality : float\n    First-order optimality measure. The exact meaning depends on method, refer to the description of tol parameter. \nactive_mask : ndarray of int, shape (n,)\n    Each component shows whether a corresponding constraint is active (that is, whether a variable is at the bound):   0 : a constraint is not active. -1 : a lower bound is active. 1 : an upper bound is active.   Might be somewhat arbitrary for the trf method as it generates a sequence of strictly feasible iterates and active_mask is determined within a tolerance threshold. \nnit : int\n    Number of iterations. Zero if the unconstrained solution is optimal. \nstatus : int\n    Reason for algorithm termination:   -1 : the algorithm was not able to make progress on the last iteration. 0 : the maximum number of iterations is exceeded. 1 : the first-order optimality measure is less than tol. 2 : the relative change of the cost function is less than tol. 3 : the unconstrained solution is optimal.   \nmessage : str\n    Verbal description of the termination reason. \nsuccess : bool\n    True if one of the convergence criteria is satisfied (status > 0).</code></pre><span class="prog__sub">Examples:</span><pre><code>minimize 0.5 * ||A x - b||**2\nsubject to lb <= x <= ub</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.lsq_linear.html
scipy optimize lsq_linear	R	scipy.optimize.lsq_linear										
scipy optimize.lsq_linear	R	scipy.optimize.lsq_linear										
scipy.optimize.minimize	A										<section class="prog__container"><p>Minimization of scalar function of one or more variables.</p><pre><code>scipy.optimize.minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fun : callable\n    Objective function. \nx0 : ndarray\n    Initial guess. \nargs : tuple, optional\n    Extra arguments passed to the objective function and its derivatives (Jacobian, Hessian). \nmethod : str or callable, optional\n    Type of solver.  Should be one of   ‘Nelder-Mead’ (see here) ‘Powell’      (see here) ‘CG’          (see here) ‘BFGS’        (see here) ‘Newton-CG’   (see here) ‘L-BFGS-B’    (see here) ‘TNC’         (see here) ‘COBYLA’      (see here) ‘SLSQP’       (see here) ‘dogleg’      (see here) ‘trust-ncg’   (see here) custom - a callable object (added in version 0.14.0), see below for description.   If not given, chosen to be one of BFGS, L-BFGS-B, SLSQP, depending if the problem has constraints or bounds. \njac : bool or callable, optional\n    Jacobian (gradient) of objective function. Only for CG, BFGS, Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg. If jac is a Boolean and is True, fun is assumed to return the gradient along with the objective function. If False, the gradient will be estimated numerically. jac can also be a callable returning the gradient of the objective. In this case, it must accept the same arguments as fun. \nhess, hessp : callable, optional\n    Hessian (matrix of second-order derivatives) of objective function or Hessian of objective function times an arbitrary vector p.  Only for Newton-CG, dogleg, trust-ncg. Only one of hessp or hess needs to be given.  If hess is provided, then hessp will be ignored.  If neither hess nor hessp is provided, then the Hessian product will be approximated using finite differences on jac. hessp must compute the Hessian times an arbitrary vector. \nbounds : sequence, optional\n    Bounds for variables (only for L-BFGS-B, TNC and SLSQP). (min, max) pairs for each element in x, defining the bounds on that parameter. Use None for one of min or max when there is no bound in that direction. \nconstraints : dict or sequence of dict, optional\n    Constraints definition (only for COBYLA and SLSQP). Each constraint is defined in a dictionary with fields:   type : str Constraint type: ‘eq’ for equality, ‘ineq’ for inequality.  fun : callable The function defining the constraint.  jac : callable, optional The Jacobian of fun (only for SLSQP).  args : sequence, optional Extra arguments to be passed to the function and Jacobian.    Equality constraint means that the constraint function result is to be zero whereas inequality means that it is to be non-negative. Note that COBYLA only supports inequality constraints. \ntol : float, optional\n    Tolerance for termination. For detailed control, use solver-specific options. \noptions : dict, optional\n    A dictionary of solver options. All methods accept the following generic options:   maxiter : int Maximum number of iterations to perform.  disp : bool Set to True to print convergence messages.    For method-specific options, see show_options. \ncallback : callable, optional\n    Called after each iteration, as callback(xk), where xk is the current parameter vector.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : OptimizeResult\n    The optimization result represented as a OptimizeResult object. Important attributes are: x the solution array, success a Boolean flag indicating if the optimizer exited successfully and message which describes the cause of the termination. See OptimizeResult for a description of other attributes.</code></pre><span class="prog__sub">Examples:</span><pre><code>minimize f(x) subject to\n\ng_i(x) >= 0,  i = 1,...,m\nh_j(x)  = 0,  j = 1,...,p</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html
scipy optimize minimize	R	scipy.optimize.minimize										
scipy optimize.minimize	R	scipy.optimize.minimize										
scipy.optimize.minimize_scalar	A										<section class="prog__container"><p>Minimization of scalar function of one variable.</p><pre><code>scipy.optimize.minimize_scalar(fun, bracket=None, bounds=None, args=(), method='brent', tol=None, options=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fun : callable\n    Objective function. Scalar function, must return a scalar. \nbracket : sequence, optional\n    For methods ‘brent’ and ‘golden’, bracket defines the bracketing interval and can either have three items (a, b, c) so that a < b < c and fun(b) < fun(a), fun(c) or two items a and c which are assumed to be a starting interval for a downhill bracket search (see bracket); it doesn’t always mean that the obtained solution will satisfy a <= x <= c. \nbounds : sequence, optional\n    For method ‘bounded’, bounds is mandatory and must have two items corresponding to the optimization bounds. \nargs : tuple, optional\n    Extra arguments passed to the objective function. \nmethod : str or callable, optional\n    Type of solver.  Should be one of   ‘Brent’     (see here) ‘Bounded’   (see here) ‘Golden’    (see here) custom - a callable object (added in version 0.14.0), see below   \ntol : float, optional\n    Tolerance for termination. For detailed control, use solver-specific options. \noptions : dict, optional\n    A dictionary of solver options.  maxiter : int Maximum number of iterations to perform.  disp : bool Set to True to print convergence messages.     See show_options for solver-specific options.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : OptimizeResult\n    The optimization result represented as a OptimizeResult object. Important attributes are: x the solution array, success a Boolean flag indicating if the optimizer exited successfully and message which describes the cause of the termination. See OptimizeResult for a description of other attributes.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def f(x):\n...     return (x - 2) * x * (x + 2)**2</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html
scipy optimize minimize_scalar	R	scipy.optimize.minimize_scalar										
scipy optimize.minimize_scalar	R	scipy.optimize.minimize_scalar										
scipy.optimize.newton	A										<section class="prog__container"><p>Find a zero using the Newton-Raphson or secant method.</p><pre><code>scipy.optimize.newton(func, x0, fprime=None, args=(), tol=1.48e-08, maxiter=50, fprime2=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : function\n    The function whose zero is wanted. It must be a function of a single variable of the form f(x,a,b,c...), where a,b,c... are extra arguments that can be passed in the args parameter. \nx0 : float\n    An initial estimate of the zero that should be somewhere near the actual zero. \nfprime : function, optional\n    The derivative of the function when available and convenient. If it is None (default), then the secant method is used. \nargs : tuple, optional\n    Extra arguments to be used in the function call. \ntol : float, optional\n    The allowable error of the zero value. \nmaxiter : int, optional\n    Maximum number of iterations. \nfprime2 : function, optional\n    The second order derivative of the function when available and convenient. If it is None (default), then the normal Newton-Raphson or the secant method is used. If it is given, parabolic Halley’s method is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>zero : float\n    Estimated location where function is zero.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html
scipy.optimize.newton_krylov	A					[[scipy.sparse.linalg.gmres]]\\n[[scipy.sparse.linalg.lgmres]]					<section class="prog__container"><p>Find a root of a function, using Krylov approximation for inverse Jacobian.</p><pre><code>scipy.optimize.newton_krylov(F, xin, iter=None, rdiff=None, method='lgmres', inner_maxiter=20, inner_M=None, outer_k=10, verbose=False, maxiter=None, f_tol=None, f_rtol=None, x_tol=None, x_rtol=None, tol_norm=None, line_search='armijo', callback=None, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>F : function(x) -> f\n    Function whose root to find; should take and return an array-like object. \nx0 : array_like\n    Initial guess for the solution \nrdiff : float, optional\n    Relative step size to use in numerical differentiation. \nmethod : {‘lgmres’, ‘gmres’, ‘bicgstab’, ‘cgs’, ‘minres’} or function\n    Krylov method to use to approximate the Jacobian. Can be a string, or a function implementing the same interface as the iterative solvers in scipy.sparse.linalg. The default is scipy.sparse.linalg.lgmres. \ninner_M : LinearOperator or InverseJacobian\n    Preconditioner for the inner Krylov iteration. Note that you can use also inverse Jacobians as (adaptive) preconditioners. For example, >>> from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian >>> from scipy.optimize.nonlin import InverseJacobian >>> jac = BroydenFirst() >>> kjac = KrylovJacobian(inner_M=InverseJacobian(jac))   If the preconditioner has a method named ‘update’, it will be called as update(x, f) after each nonlinear step, with x giving the current point, and f the current function value. \ninner_tol, inner_maxiter, ...\n    Parameters to pass on to the “inner” Krylov solver. See scipy.sparse.linalg.gmres for details. \nouter_k : int, optional\n    Size of the subspace kept across LGMRES nonlinear iterations. See scipy.sparse.linalg.lgmres for details. \niter : int, optional\n    Number of iterations to make. If omitted (default), make as many as required to meet tolerances. \nverbose : bool, optional\n    Print status to stdout on every iteration. \nmaxiter : int, optional\n    Maximum number of iterations to make. If more are needed to meet convergence, NoConvergence is raised. \nf_tol : float, optional\n    Absolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6. \nf_rtol : float, optional\n    Relative tolerance for the residual. If omitted, not used. \nx_tol : float, optional\n    Absolute minimum step size, as determined from the Jacobian approximation. If the step size is smaller than this, optimization is terminated as successful. If omitted, not used. \nx_rtol : float, optional\n    Relative minimum step size. If omitted, not used. \ntol_norm : function(vector) -> scalar, optional\n    Norm to use in convergence check. Default is the maximum norm. \nline_search : {None, ‘armijo’ (default), ‘wolfe’}, optional\n    Which type of a line search to use to determine the step size in the direction given by the Jacobian approximation. Defaults to ‘armijo’. \ncallback : function, optional\n    Optional callback function. It is called on every iteration as callback(x, f) where x is the current solution and f the corresponding residual.</code></pre><span class="prog__sub">Returns:</span><pre><code>sol : ndarray\n    An array (of similar array type as x0) containing the final solution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian\n>>> from scipy.optimize.nonlin import InverseJacobian\n>>> jac = BroydenFirst()\n>>> kjac = KrylovJacobian(inner_M=InverseJacobian(jac))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton_krylov.html
scipy optimize newton_krylov	R	scipy.optimize.newton_krylov										
scipy optimize.newton_krylov	R	scipy.optimize.newton_krylov										
scipy optimize newton	R	scipy.optimize.newton										
scipy optimize.newton	R	scipy.optimize.newton										
scipy.optimize.nnls	A										<section class="prog__container"><p>Solve argmin_x || Ax - b ||_2 for x>=0. This is a wrapper\nfor a FORTAN non-negative least squares solver.</p><pre><code>scipy.optimize.nnls(A, b)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : ndarray\n    Matrix A as shown above. \nb : ndarray\n    Right-hand side vector.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Solution vector. \nrnorm : float\n    The residual, || Ax-b ||_2.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.nnls.html
scipy optimize nnls	R	scipy.optimize.nnls										
scipy optimize.nnls	R	scipy.optimize.nnls										
scipy.optimize.OptimizeResult	A										<section class="prog__container"><p>Represents the optimization result.</p><pre><code>class scipy.optimize.OptimizeResult</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html
scipy.optimize.OptimizeResult.fromkeys	A										<section class="prog__container"><p>v defaults to None.</p><pre><code>static OptimizeResult.fromkeys(S[, v]) → New dict with keys from S and values equal to v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.fromkeys.html
scipy optimize OptimizeResult fromkeys	R	scipy.optimize.OptimizeResult.fromkeys										
scipy optimize.OptimizeResult.fromkeys	R	scipy.optimize.OptimizeResult.fromkeys										
scipy.optimize.OptimizeResult.pop	A										<section class="prog__container"><p>If key is not found, d is returned if given, otherwise KeyError is raised</p><pre><code>OptimizeResult.pop(k[, d]) → v, remove specified key and return the corresponding value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.pop.html
scipy.optimize.OptimizeResult.popitem	A										<section class="prog__container"><p>2-tuple; but raise KeyError if D is empty.</p><pre><code>OptimizeResult.popitem() → (k, v), remove and return some (key, value) pair as a</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.popitem.html
scipy optimize OptimizeResult popitem	R	scipy.optimize.OptimizeResult.popitem										
scipy optimize.OptimizeResult.popitem	R	scipy.optimize.OptimizeResult.popitem										
scipy optimize OptimizeResult pop	R	scipy.optimize.OptimizeResult.pop										
scipy optimize.OptimizeResult.pop	R	scipy.optimize.OptimizeResult.pop										
scipy optimize OptimizeResult	R	scipy.optimize.OptimizeResult										
scipy optimize.OptimizeResult	R	scipy.optimize.OptimizeResult										
scipy.optimize.OptimizeResult.update	A										<section class="prog__container"><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]\nIf E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\nIn either case, this is followed by: for k in F: D[k] = F[k]</p><pre><code>OptimizeResult.update([E, ]**F) → None.  Update D from dict/iterable E and F.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.update.html
scipy optimize OptimizeResult update	R	scipy.optimize.OptimizeResult.update										
scipy optimize.OptimizeResult.update	R	scipy.optimize.OptimizeResult.update										
scipy.optimize.ridder	A										<section class="prog__container"><p>Find a root of a function in an interval.</p><pre><code>scipy.optimize.ridder(f, a, b, args=(), xtol=2e-12, rtol=8.8817841970012523e-16, maxiter=100, full_output=False, disp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f : function\n    Python function returning a number.  f must be continuous, and f(a) and f(b) must have opposite signs. \na : number\n    One end of the bracketing interval [a,b]. \nb : number\n    The other end of the bracketing interval [a,b]. \nxtol : number, optional\n    The computed root x0 will satisfy np.allclose(x, x0, atol=xtol, rtol=rtol), where x is the exact root. The parameter must be nonnegative. \nrtol : number, optional\n    The computed root x0 will satisfy np.allclose(x, x0, atol=xtol, rtol=rtol), where x is the exact root. The parameter cannot be smaller than its default value of 4*np.finfo(float).eps. \nmaxiter : number, optional\n    if convergence is not achieved in maxiter iterations, an error is raised.  Must be >= 0. \nargs : tuple, optional\n    containing extra arguments for the function f. f is called by apply(f, (x)+args). \nfull_output : bool, optional\n    If full_output is False, the root is returned.  If full_output is True, the return value is (x, r), where x is the root, and r is a RootResults object. \ndisp : bool, optional\n    If True, raise RuntimeError if the algorithm didn’t converge.</code></pre><span class="prog__sub">Returns:</span><pre><code>x0 : float\n    Zero of f between a and b. \nr : RootResults (present if full_output = True)\n    Object containing information about the convergence. In particular, r.converged is True if the routine converged.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.ridder.html
scipy optimize ridder	R	scipy.optimize.ridder										
scipy optimize.ridder	R	scipy.optimize.ridder										
scipy.optimize.root	A										<section class="prog__container"><p>Find a root of a vector function.</p><pre><code>scipy.optimize.root(fun, x0, args=(), method='hybr', jac=None, tol=None, callback=None, options=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>fun : callable\n    A vector function to find a root of. \nx0 : ndarray\n    Initial guess. \nargs : tuple, optional\n    Extra arguments passed to the objective function and its Jacobian. \nmethod : str, optional\n    Type of solver.  Should be one of   ‘hybr’             (see here) ‘lm’               (see here) ‘broyden1’         (see here) ‘broyden2’         (see here) ‘anderson’         (see here) ‘linearmixing’     (see here) ‘diagbroyden’      (see here) ‘excitingmixing’   (see here) ‘krylov’           (see here) ‘df-sane’          (see here)   \njac : bool or callable, optional\n    If jac is a Boolean and is True, fun is assumed to return the value of Jacobian along with the objective function. If False, the Jacobian will be estimated numerically. jac can also be a callable returning the Jacobian of fun. In this case, it must accept the same arguments as fun. \ntol : float, optional\n    Tolerance for termination. For detailed control, use solver-specific options. \ncallback : function, optional\n    Optional callback function. It is called on every iteration as callback(x, f) where x is the current solution and f the corresponding residual. For all methods but ‘hybr’ and ‘lm’. \noptions : dict, optional\n    A dictionary of solver options. E.g. xtol or maxiter, see show_options() for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>sol : OptimizeResult\n    The solution represented as a OptimizeResult object. Important attributes are: x the solution array, success a Boolean flag indicating if the algorithm exited successfully and message which describes the cause of the termination. See OptimizeResult for a description of other attributes.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> def fun(x):\n...     return [x[0]  + 0.5 * (x[0] - x[1])**3 - 1.0,\n...             0.5 * (x[1] - x[0])**3 + x[1]]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html
scipy optimize root	R	scipy.optimize.root										
scipy optimize.root	R	scipy.optimize.root										
scipy.optimize.rosen	A					[[scipy.optimize.rosen_der]]\\n[[scipy.optimize.rosen_hess]]\\n[[scipy.optimize.rosen_hess_prod]]					<section class="prog__container"><p>The Rosenbrock function.</p><pre><code>scipy.optimize.rosen(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-D array of points at which the Rosenbrock function is to be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>f : float\n    The value of the Rosenbrock function.</code></pre><span class="prog__sub">Examples:</span><pre><code>sum(100.0*(x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.rosen.html
scipy.optimize.rosen_der	A					[[scipy.optimize.rosen]]\\n[[scipy.optimize.rosen_hess]]\\n[[scipy.optimize.rosen_hess_prod]]					<section class="prog__container"><p>The derivative (i.e. gradient) of the Rosenbrock function.</p><pre><code>scipy.optimize.rosen_der(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-D array of points at which the derivative is to be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>rosen_der : (N,) ndarray\n    The gradient of the Rosenbrock function at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.rosen_der.html
scipy optimize rosen_der	R	scipy.optimize.rosen_der										
scipy optimize.rosen_der	R	scipy.optimize.rosen_der										
scipy.optimize.rosen_hess	A					[[scipy.optimize.rosen]]\\n[[scipy.optimize.rosen_der]]\\n[[scipy.optimize.rosen_hess_prod]]					<section class="prog__container"><p>The Hessian matrix of the Rosenbrock function.</p><pre><code>scipy.optimize.rosen_hess(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-D array of points at which the Hessian matrix is to be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>rosen_hess : ndarray\n    The Hessian matrix of the Rosenbrock function at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.rosen_hess.html
scipy.optimize.rosen_hess_prod	A					[[scipy.optimize.rosen]]\\n[[scipy.optimize.rosen_der]]\\n[[scipy.optimize.rosen_hess]]					<section class="prog__container"><p>Product of the Hessian matrix of the Rosenbrock function with a vector.</p><pre><code>scipy.optimize.rosen_hess_prod(x, p)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-D array of points at which the Hessian matrix is to be computed. \np : array_like\n    1-D array, the vector to be multiplied by the Hessian matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>rosen_hess_prod : ndarray\n    The Hessian matrix of the Rosenbrock function at x multiplied by the vector p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.rosen_hess_prod.html
scipy optimize rosen_hess_prod	R	scipy.optimize.rosen_hess_prod										
scipy optimize.rosen_hess_prod	R	scipy.optimize.rosen_hess_prod										
scipy optimize rosen_hess	R	scipy.optimize.rosen_hess										
scipy optimize.rosen_hess	R	scipy.optimize.rosen_hess										
scipy optimize rosen	R	scipy.optimize.rosen										
scipy optimize.rosen	R	scipy.optimize.rosen										
scipy.optimize.show_options	A										<section class="prog__container"><p>Show documentation for additional options of optimization solvers.</p><pre><code>scipy.optimize.show_options(solver=None, method=None, disp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>solver : str\n    Type of optimization solver. One of ‘minimize’, ‘minimize_scalar’, ‘root’, or ‘linprog’. \nmethod : str, optional\n    If not given, shows all methods of the specified solver. Otherwise, show only the options for the specified method. Valid values corresponds to methods’ names of respective solver (e.g. ‘BFGS’ for ‘minimize’). \ndisp : bool, optional\n    Whether to print the result rather than returning it.</code></pre><span class="prog__sub">Returns:</span><pre><code>text\n    Either None (for disp=False) or the text string (disp=True)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.show_options.html
scipy optimize show_options	R	scipy.optimize.show_options										
scipy optimize.show_options	R	scipy.optimize.show_options										
scipy.signal.abcd_normalize	A										<section class="prog__container"><p>Check state-space matrices and ensure they are two-dimensional.</p><pre><code>scipy.signal.abcd_normalize(A=None, B=None, C=None, D=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A, B, C, D : array_like, optional\n    State-space matrices. All of them are None (missing) by default. See ss2tf for format.</code></pre><span class="prog__sub">Returns:</span><pre><code>A, B, C, D : array\n    Properly shaped state-space matrices.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.abcd_normalize.html
scipy signal abcd_normalize	R	scipy.signal.abcd_normalize										
scipy signal.abcd_normalize	R	scipy.signal.abcd_normalize										
scipy.signal.argrelextrema	A					[[scipy.signal.argrelmin]]\\n[[scipy.signal.argrelmax]]					<section class="prog__container"><p>Calculate the relative extrema of data.</p><pre><code>scipy.signal.argrelextrema(data, comparator, axis=0, order=1, mode='clip')</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    Array in which to find the relative extrema. \ncomparator : callable\n    Function to use to compare two data points. Should take 2 numbers as arguments. \naxis : int, optional\n    Axis over which to select from data.  Default is 0. \norder : int, optional\n    How many points on each side to use for the comparison to consider comparator(n, n+x) to be True. \nmode : str, optional\n    How the edges of the vector are treated.  ‘wrap’ (wrap around) or ‘clip’ (treat overflow as the same as the last (or first) element). Default is ‘clip’.  See numpy.take.</code></pre><span class="prog__sub">Returns:</span><pre><code>extrema : tuple of ndarrays\n    Indices of the maxima in arrays of integers.  extrema[k] is the array of indices of axis k of data.  Note that the return value is a tuple even when data is one-dimensional.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.signal import argrelextrema\n>>> x = np.array([2, 1, 2, 3, 2, 0, 1, 0])\n>>> argrelextrema(x, np.greater)\n(array([3, 6]),)\n>>> y = np.array([[1, 2, 1, 2],\n...               [2, 2, 0, 0],\n...               [5, 3, 4, 4]])\n...\n>>> argrelextrema(y, np.less, axis=1)\n(array([0, 2]), array([2, 1]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.argrelextrema.html
scipy signal argrelextrema	R	scipy.signal.argrelextrema										
scipy signal.argrelextrema	R	scipy.signal.argrelextrema										
scipy.signal.argrelmax	A					[[scipy.signal.argrelextrema]]\\n[[scipy.signal.argrelmin]]					<section class="prog__container"><p>Calculate the relative maxima of data.</p><pre><code>scipy.signal.argrelmax(data, axis=0, order=1, mode='clip')</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    Array in which to find the relative maxima. \naxis : int, optional\n    Axis over which to select from data.  Default is 0. \norder : int, optional\n    How many points on each side to use for the comparison to consider comparator(n, n+x) to be True. \nmode : str, optional\n    How the edges of the vector are treated. Available options are ‘wrap’ (wrap around) or ‘clip’ (treat overflow as the same as the last (or first) element). Default ‘clip’.  See numpy.take.</code></pre><span class="prog__sub">Returns:</span><pre><code>extrema : tuple of ndarrays\n    Indices of the maxima in arrays of integers.  extrema[k] is the array of indices of axis k of data.  Note that the return value is a tuple even when data is one-dimensional.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.signal import argrelmax\n>>> x = np.array([2, 1, 2, 3, 2, 0, 1, 0])\n>>> argrelmax(x)\n(array([3, 6]),)\n>>> y = np.array([[1, 2, 1, 2],\n...               [2, 2, 0, 0],\n...               [5, 3, 4, 4]])\n...\n>>> argrelmax(y, axis=1)\n(array([0]), array([1]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.argrelmax.html
scipy signal argrelmax	R	scipy.signal.argrelmax										
scipy signal.argrelmax	R	scipy.signal.argrelmax										
scipy.signal.argrelmin	A					[[scipy.signal.argrelextrema]]\\n[[scipy.signal.argrelmax]]					<section class="prog__container"><p>Calculate the relative minima of data.</p><pre><code>scipy.signal.argrelmin(data, axis=0, order=1, mode='clip')</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    Array in which to find the relative minima. \naxis : int, optional\n    Axis over which to select from data.  Default is 0. \norder : int, optional\n    How many points on each side to use for the comparison to consider comparator(n, n+x) to be True. \nmode : str, optional\n    How the edges of the vector are treated. Available options are ‘wrap’ (wrap around) or ‘clip’ (treat overflow as the same as the last (or first) element). Default ‘clip’. See numpy.take</code></pre><span class="prog__sub">Returns:</span><pre><code>extrema : tuple of ndarrays\n    Indices of the minima in arrays of integers.  extrema[k] is the array of indices of axis k of data.  Note that the return value is a tuple even when data is one-dimensional.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.signal import argrelmin\n>>> x = np.array([2, 1, 2, 3, 2, 0, 1, 0])\n>>> argrelmin(x)\n(array([1, 5]),)\n>>> y = np.array([[1, 2, 1, 2],\n...               [2, 2, 0, 0],\n...               [5, 3, 4, 4]])\n...\n>>> argrelmin(y, axis=1)\n(array([0, 2]), array([2, 1]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.argrelmin.html
scipy signal argrelmin	R	scipy.signal.argrelmin										
scipy signal.argrelmin	R	scipy.signal.argrelmin										
scipy.signal.BadCoefficients	A										<section class="prog__container"><p>Warning about badly conditioned filter coefficients</p><pre><code>exception scipy.signal.BadCoefficients</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.BadCoefficients.html
scipy signal BadCoefficients	R	scipy.signal.BadCoefficients										
scipy signal.BadCoefficients	R	scipy.signal.BadCoefficients										
scipy.signal.band_stop_obj	A										<section class="prog__container"><p>Band Stop Objective Function for order minimization.</p><pre><code>scipy.signal.band_stop_obj(wp, ind, passb, stopb, gpass, gstop, type)</code></pre><span class="prog__sub">Parameters:</span><pre><code>wp : scalar\n    Edge of passband passb. \nind : int, {0, 1}\n    Index specifying which passb edge to vary (0 or 1). \npassb : ndarray\n    Two element sequence of fixed passband edges. \nstopb : ndarray\n    Two element sequence of fixed stopband edges. \ngstop : float\n    Amount of attenuation in stopband in dB. \ngpass : float\n    Amount of ripple in the passband in dB. \ntype : {‘butter’, ‘cheby’, ‘ellip’}\n    Type of filter.</code></pre><span class="prog__sub">Returns:</span><pre><code>n : scalar\n    Filter order (possibly non-integer).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.band_stop_obj.html
scipy signal band_stop_obj	R	scipy.signal.band_stop_obj										
scipy signal.band_stop_obj	R	scipy.signal.band_stop_obj										
scipy.signal.barthann	A										<section class="prog__container"><p>Return a modified Bartlett-Hann window.</p><pre><code>scipy.signal.barthann(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.barthann.html
scipy signal barthann	R	scipy.signal.barthann										
scipy signal.barthann	R	scipy.signal.barthann										
scipy.signal.bartlett	A										<section class="prog__container"><p>Return a Bartlett window.</p><pre><code>scipy.signal.bartlett(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The triangular window, with the first and last samples equal to zero and the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.bartlett.html
scipy signal bartlett	R	scipy.signal.bartlett										
scipy signal.bartlett	R	scipy.signal.bartlett										
scipy.signal.besselap	A										<section class="prog__container"><p>Return (z,p,k) for analog prototype of an Nth-order Bessel filter.</p><pre><code>scipy.signal.besselap(N, norm='phase')</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    The order of the filter. \nnorm : {‘phase’, ‘delay’, ‘mag’}, optional\n    Frequency normalization:  phase The filter is normalized such that the phase response reaches its midpoint at an angular (e.g. rad/s) cutoff frequency of 1.  This happens for both low-pass and high-pass filters, so this is the “phase-matched” case. [R185] The magnitude response asymptotes are the same as a Butterworth filter of the same order with a cutoff of Wn. This is the default, and matches MATLAB’s implementation.  delay The filter is normalized such that the group delay in the passband is 1 (e.g. 1 second).  This is the “natural” type obtained by solving Bessel polynomials  mag The filter is normalized such that the gain magnitude is -3 dB at angular frequency 1.  This is called “frequency normalization” by Bond. [R180]    New in version 0.18.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : ndarray\n    Zeros of the transfer function. Is always an empty array. \np : ndarray\n    Poles of the transfer function. \nk : scalar\n    Gain of the transfer function.  For phase-normalized, this is always 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.besselap.html
scipy signal besselap	R	scipy.signal.besselap										
scipy signal.besselap	R	scipy.signal.besselap										
scipy.signal.bessel	A										<section class="prog__container"><p>Bessel/Thomson digital and analog filter design.</p><pre><code>scipy.signal.bessel(N, Wn, btype='low', analog=False, output='ba', norm='phase')</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    The order of the filter. \nWn : array_like\n    A scalar or length-2 sequence giving the critical frequencies (defined by the norm parameter). For analog filters, Wn is an angular frequency (e.g. rad/s). For digital filters, Wn is normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (Wn is thus in half-cycles / sample.) \nbtype : {‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’}, optional\n    The type of filter.  Default is ‘lowpass’. \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned.  (See Notes.) \noutput : {‘ba’, ‘zpk’, ‘sos’}, optional\n    Type of output:  numerator/denominator (‘ba’), pole-zero (‘zpk’), or second-order sections (‘sos’). Default is ‘ba’. \nnorm : {‘phase’, ‘delay’, ‘mag’}, optional\n    Critical frequency normalization:  phase The filter is normalized such that the phase response reaches its midpoint at angular (e.g. rad/s) frequency Wn.  This happens for both low-pass and high-pass filters, so this is the “phase-matched” case. The magnitude response asymptotes are the same as a Butterworth filter of the same order with a cutoff of Wn. This is the default, and matches MATLAB’s implementation.  delay The filter is normalized such that the group delay in the passband is 1/Wn (e.g. seconds).  This is the “natural” type obtained by solving Bessel polynomials.  mag The filter is normalized such that the gain magnitude is -3 dB at angular frequency Wn.    New in version 0.18.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>b, a : ndarray, ndarray\n    Numerator (b) and denominator (a) polynomials of the IIR filter. Only returned if output='ba'. \nz, p, k : ndarray, ndarray, float\n    Zeros, poles, and system gain of the IIR filter transfer function.  Only returned if output='zpk'. \nsos : ndarray\n    Second-order sections representation of the IIR filter. Only returned if output=='sos'.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.bessel.html
scipy signal bessel	R	scipy.signal.bessel										
scipy signal.bessel	R	scipy.signal.bessel										
scipy.signal.bilinear	A										<section class="prog__container"><p>Return a digital filter from an analog one using a bilinear transform.</p><pre><code>scipy.signal.bilinear(b, a, fs=1.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.bilinear.html
scipy signal bilinear	R	scipy.signal.bilinear										
scipy signal.bilinear	R	scipy.signal.bilinear										
scipy.signal.blackman	A										<section class="prog__container"><p>Return a Blackman window.</p><pre><code>scipy.signal.blackman(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.blackman.html
scipy.signal.blackmanharris	A										<section class="prog__container"><p>Return a minimum 4-term Blackman-Harris window.</p><pre><code>scipy.signal.blackmanharris(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.blackmanharris.html
scipy signal blackmanharris	R	scipy.signal.blackmanharris										
scipy signal.blackmanharris	R	scipy.signal.blackmanharris										
scipy signal blackman	R	scipy.signal.blackman										
scipy signal.blackman	R	scipy.signal.blackman										
scipy.signal.bode	A										<section class="prog__container"><p>Calculate Bode magnitude and phase data of a continuous-time system.</p><pre><code>scipy.signal.bode(system, w=None, n=100)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the LTI class or a tuple describing the system.\n    The following gives the number of elements in the tuple and the interpretation:   1 (instance of lti) 2 (num, den) 3 (zeros, poles, gain) 4 (A, B, C, D)   \nw : array_like, optional\n    Array of frequencies (in rad/s). Magnitude and phase data is calculated for every value in this array. If not given a reasonable set will be calculated. \nn : int, optional\n    Number of frequency points to compute if w is not given. The n frequencies are logarithmically spaced in an interval chosen to include the influence of the poles and zeros of the system.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : 1D ndarray\n    Frequency array [rad/s] \nmag : 1D ndarray\n    Magnitude array [dB] \nphase : 1D ndarray\n    Phase array [deg]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.bode.html
scipy signal bode	R	scipy.signal.bode										
scipy signal.bode	R	scipy.signal.bode										
scipy.signal.bohman	A										<section class="prog__container"><p>Return a Bohman window.</p><pre><code>scipy.signal.bohman(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.bohman.html
scipy signal bohman	R	scipy.signal.bohman										
scipy signal.bohman	R	scipy.signal.bohman										
scipy.signal.boxcar	A										<section class="prog__container"><p>Return a boxcar or rectangular window.</p><pre><code>scipy.signal.boxcar(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    Whether the window is symmetric. (Has no effect for boxcar.)</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.boxcar.html
scipy signal boxcar	R	scipy.signal.boxcar										
scipy signal.boxcar	R	scipy.signal.boxcar										
scipy.signal.bspline	A										<section class="prog__container"><p>B-spline basis function of order n.</p><pre><code>scipy.signal.bspline(x, n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.bspline.html
scipy signal bspline	R	scipy.signal.bspline										
scipy signal.bspline	R	scipy.signal.bspline										
scipy.signal.buttap	A										<section class="prog__container"><p>Return (z,p,k) for analog prototype of Nth-order Butterworth filter.</p><pre><code>scipy.signal.buttap(N)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.buttap.html
scipy signal buttap	R	scipy.signal.buttap										
scipy signal.buttap	R	scipy.signal.buttap										
scipy.signal.butter	A					[[scipy.signal.buttord]]\\n[[scipy.signal.buttap]]					<section class="prog__container"><p>Butterworth digital and analog filter design.</p><pre><code>scipy.signal.butter(N, Wn, btype='low', analog=False, output='ba')</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    The order of the filter. \nWn : array_like\n    A scalar or length-2 sequence giving the critical frequencies. For a Butterworth filter, this is the point at which the gain drops to 1/sqrt(2) that of the passband (the “-3 dB point”). For digital filters, Wn is normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (Wn is thus in half-cycles / sample.) For analog filters, Wn is an angular frequency (e.g. rad/s). \nbtype : {‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’}, optional\n    The type of filter.  Default is ‘lowpass’. \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned. \noutput : {‘ba’, ‘zpk’, ‘sos’}, optional\n    Type of output:  numerator/denominator (‘ba’), pole-zero (‘zpk’), or second-order sections (‘sos’). Default is ‘ba’.</code></pre><span class="prog__sub">Returns:</span><pre><code>b, a : ndarray, ndarray\n    Numerator (b) and denominator (a) polynomials of the IIR filter. Only returned if output='ba'. \nz, p, k : ndarray, ndarray, float\n    Zeros, poles, and system gain of the IIR filter transfer function.  Only returned if output='zpk'. \nsos : ndarray\n    Second-order sections representation of the IIR filter. Only returned if output=='sos'.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
scipy signal butter	R	scipy.signal.butter										
scipy signal.butter	R	scipy.signal.butter										
scipy.signal.buttord	A										<section class="prog__container"><p>Butterworth filter order selection.</p><pre><code>scipy.signal.buttord(wp, ws, gpass, gstop, analog=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>wp, ws : float\n    Passband and stopband edge frequencies. For digital filters, these are normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (wp and ws are thus in half-cycles / sample.)  For example:   Lowpass:   wp = 0.2,          ws = 0.3 Highpass:  wp = 0.3,          ws = 0.2 Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]   For analog filters, wp and ws are angular frequencies (e.g. rad/s). \ngpass : float\n    The maximum loss in the passband (dB). \ngstop : float\n    The minimum attenuation in the stopband (dB). \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>ord : int\n    The lowest order for a Butterworth filter which meets specs. \nwn : ndarray or float\n    The Butterworth natural frequency (i.e. the “3dB frequency”).  Should be used with butter to give filter results.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.buttord.html
scipy signal buttord	R	scipy.signal.buttord										
scipy signal.buttord	R	scipy.signal.buttord										
scipy.signal.cascade	A										<section class="prog__container"><p>Return (x, phi, psi) at dyadic points K/2**J from filter coefficients.</p><pre><code>scipy.signal.cascade(hk, J=7)</code></pre><span class="prog__sub">Parameters:</span><pre><code>hk : array_like\n    Coefficients of low-pass filter. \nJ : int, optional\n    Values will be computed at grid points K/2**J. Default is 7.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    The dyadic points K/2**J for K=0...N * (2**J)-1 where len(hk) = len(gk) = N+1. \nphi : ndarray\n    The scaling function phi(x) at x: phi(x) = sum(hk * phi(2x-k)), where k is from 0 to N. \npsi : ndarray, optional\n    The wavelet function psi(x) at x: phi(x) = sum(gk * phi(2x-k)), where k is from 0 to N. psi is only returned if gk is not None.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cascade.html
scipy signal cascade	R	scipy.signal.cascade										
scipy signal.cascade	R	scipy.signal.cascade										
scipy.signal.cheb1ap	A										<section class="prog__container"><p>Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.</p><pre><code>scipy.signal.cheb1ap(N, rp)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cheb1ap.html
scipy signal cheb1ap	R	scipy.signal.cheb1ap										
scipy signal.cheb1ap	R	scipy.signal.cheb1ap										
scipy.signal.cheb1ord	A										<section class="prog__container"><p>Chebyshev type I filter order selection.</p><pre><code>scipy.signal.cheb1ord(wp, ws, gpass, gstop, analog=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>wp, ws : float\n    Passband and stopband edge frequencies. For digital filters, these are normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (wp and ws are thus in half-cycles / sample.)  For example:   Lowpass:   wp = 0.2,          ws = 0.3 Highpass:  wp = 0.3,          ws = 0.2 Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]   For analog filters, wp and ws are angular frequencies (e.g. rad/s). \ngpass : float\n    The maximum loss in the passband (dB). \ngstop : float\n    The minimum attenuation in the stopband (dB). \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>ord : int\n    The lowest order for a Chebyshev type I filter that meets specs. \nwn : ndarray or float\n    The Chebyshev natural frequency (the “3dB frequency”) for use with cheby1 to give filter results.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cheb1ord.html
scipy signal cheb1ord	R	scipy.signal.cheb1ord										
scipy signal.cheb1ord	R	scipy.signal.cheb1ord										
scipy.signal.cheb2ap	A										<section class="prog__container"><p>Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.</p><pre><code>scipy.signal.cheb2ap(N, rs)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cheb2ap.html
scipy signal cheb2ap	R	scipy.signal.cheb2ap										
scipy signal.cheb2ap	R	scipy.signal.cheb2ap										
scipy.signal.cheb2ord	A										<section class="prog__container"><p>Chebyshev type II filter order selection.</p><pre><code>scipy.signal.cheb2ord(wp, ws, gpass, gstop, analog=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>wp, ws : float\n    Passband and stopband edge frequencies. For digital filters, these are normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (wp and ws are thus in half-cycles / sample.)  For example:   Lowpass:   wp = 0.2,          ws = 0.3 Highpass:  wp = 0.3,          ws = 0.2 Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]   For analog filters, wp and ws are angular frequencies (e.g. rad/s). \ngpass : float\n    The maximum loss in the passband (dB). \ngstop : float\n    The minimum attenuation in the stopband (dB). \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>ord : int\n    The lowest order for a Chebyshev type II filter that meets specs. \nwn : ndarray or float\n    The Chebyshev natural frequency (the “3dB frequency”) for use with cheby2 to give filter results.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cheb2ord.html
scipy signal cheb2ord	R	scipy.signal.cheb2ord										
scipy signal.cheb2ord	R	scipy.signal.cheb2ord										
scipy.signal.chebwin	A										<section class="prog__container"><p>Return a Dolph-Chebyshev window.</p><pre><code>scipy.signal.chebwin(M, at, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nat : float\n    Attenuation (in dB). \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value always normalized to 1</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.chebwin.html
scipy signal chebwin	R	scipy.signal.chebwin										
scipy signal.chebwin	R	scipy.signal.chebwin										
scipy.signal.cheby1	A					[[scipy.signal.cheb1ord]]\\n[[scipy.signal.cheb1ap]]					<section class="prog__container"><p>Chebyshev type I digital and analog filter design.</p><pre><code>scipy.signal.cheby1(N, rp, Wn, btype='low', analog=False, output='ba')</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    The order of the filter. \nrp : float\n    The maximum ripple allowed below unity gain in the passband. Specified in decibels, as a positive number. \nWn : array_like\n    A scalar or length-2 sequence giving the critical frequencies. For Type I filters, this is the point in the transition band at which the gain first drops below -rp. For digital filters, Wn is normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (Wn is thus in half-cycles / sample.) For analog filters, Wn is an angular frequency (e.g. rad/s). \nbtype : {‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’}, optional\n    The type of filter.  Default is ‘lowpass’. \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned. \noutput : {‘ba’, ‘zpk’, ‘sos’}, optional\n    Type of output:  numerator/denominator (‘ba’), pole-zero (‘zpk’), or second-order sections (‘sos’). Default is ‘ba’.</code></pre><span class="prog__sub">Returns:</span><pre><code>b, a : ndarray, ndarray\n    Numerator (b) and denominator (a) polynomials of the IIR filter. Only returned if output='ba'. \nz, p, k : ndarray, ndarray, float\n    Zeros, poles, and system gain of the IIR filter transfer function.  Only returned if output='zpk'. \nsos : ndarray\n    Second-order sections representation of the IIR filter. Only returned if output=='sos'.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cheby1.html
scipy signal cheby1	R	scipy.signal.cheby1										
scipy signal.cheby1	R	scipy.signal.cheby1										
scipy.signal.cheby2	A					[[scipy.signal.cheb2ord]]\\n[[scipy.signal.cheb2ap]]					<section class="prog__container"><p>Chebyshev type II digital and analog filter design.</p><pre><code>scipy.signal.cheby2(N, rs, Wn, btype='low', analog=False, output='ba')</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    The order of the filter. \nrs : float\n    The minimum attenuation required in the stop band. Specified in decibels, as a positive number. \nWn : array_like\n    A scalar or length-2 sequence giving the critical frequencies. For Type II filters, this is the point in the transition band at which the gain first reaches -rs. For digital filters, Wn is normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (Wn is thus in half-cycles / sample.) For analog filters, Wn is an angular frequency (e.g. rad/s). \nbtype : {‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’}, optional\n    The type of filter.  Default is ‘lowpass’. \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned. \noutput : {‘ba’, ‘zpk’, ‘sos’}, optional\n    Type of output:  numerator/denominator (‘ba’), pole-zero (‘zpk’), or second-order sections (‘sos’). Default is ‘ba’.</code></pre><span class="prog__sub">Returns:</span><pre><code>b, a : ndarray, ndarray\n    Numerator (b) and denominator (a) polynomials of the IIR filter. Only returned if output='ba'. \nz, p, k : ndarray, ndarray, float\n    Zeros, poles, and system gain of the IIR filter transfer function.  Only returned if output='zpk'. \nsos : ndarray\n    Second-order sections representation of the IIR filter. Only returned if output=='sos'.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cheby2.html
scipy signal cheby2	R	scipy.signal.cheby2										
scipy signal.cheby2	R	scipy.signal.cheby2										
scipy.signal.chirp	A					[[scipy.signal.sweep_poly]]					<section class="prog__container"><p>Frequency-swept cosine generator.</p><pre><code>scipy.signal.chirp(t, f0, t1, f1, method='linear', phi=0, vertex_zero=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>t : array_like\n    Times at which to evaluate the waveform. \nf0 : float\n    Frequency (e.g. Hz) at time t=0. \nt1 : float\n    Time at which f1 is specified. \nf1 : float\n    Frequency (e.g. Hz) of the waveform at time t1. \nmethod : {‘linear’, ‘quadratic’, ‘logarithmic’, ‘hyperbolic’}, optional\n    Kind of frequency sweep.  If not given, linear is assumed.  See Notes below for more details. \nphi : float, optional\n    Phase offset, in degrees. Default is 0. \nvertex_zero : bool, optional\n    This parameter is only used when method is ‘quadratic’. It determines whether the vertex of the parabola that is the graph of the frequency is at t=0 or t=t1.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    A numpy array containing the signal evaluated at t with the requested time-varying frequency.  More precisely, the function returns cos(phase + (pi/180)*phi) where phase is the integral (from 0 to t) of 2*pi*f(t). f(t) is defined below.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.chirp.html
scipy signal chirp	R	scipy.signal.chirp										
scipy signal.chirp	R	scipy.signal.chirp										
scipy.signal.cmplx_sort	A										<section class="prog__container"><p>Sort roots based on magnitude.</p><pre><code>scipy.signal.cmplx_sort(p)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    The roots to sort, as a 1-D array.</code></pre><span class="prog__sub">Returns:</span><pre><code>p_sorted : ndarray\n    Sorted roots. \nindx : ndarray\n    Array of indices needed to sort the input p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cmplx_sort.html
scipy signal cmplx_sort	R	scipy.signal.cmplx_sort										
scipy signal.cmplx_sort	R	scipy.signal.cmplx_sort										
scipy.signal.coherence	A										<section class="prog__container"><p>Estimate the magnitude squared coherence estimate, Cxy, of discrete-time\nsignals X and Y using Welch’s method.</p><pre><code>scipy.signal.coherence(x, y, fs=1.0, window='hann', nperseg=256, noverlap=None, nfft=None, detrend='constant', axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Time series of measurement values \ny : array_like\n    Time series of measurement values \nfs : float, optional\n    Sampling frequency of the x and y time series. Defaults to 1.0. \nwindow : str or tuple or array_like, optional\n    Desired window to use. See get_window for a list of windows and required parameters. If window is array_like it will be used directly as the window and its length will be used for nperseg. Defaults to ‘hann’. \nnperseg : int, optional\n    Length of each segment.  Defaults to 256. \nnoverlap: int, optional\n    Number of points to overlap between segments. If None, noverlap = nperseg // 2.  Defaults to None. \nnfft : int, optional\n    Length of the FFT used, if a zero padded FFT is desired.  If None, the FFT length is nperseg. Defaults to None. \ndetrend : str or function or False, optional\n    Specifies how to detrend each segment. If detrend is a string, it is passed as the type argument to detrend.  If it is a function, it takes a segment and returns a detrended segment. If detrend is False, no detrending is done.  Defaults to ‘constant’. \naxis : int, optional\n    Axis along which the coherence is computed for both inputs; the default is over the last axis (i.e. axis=-1).</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of sample frequencies. \nCxy : ndarray\n    Magnitude squared coherence of x and y.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.coherence.html
scipy signal coherence	R	scipy.signal.coherence										
scipy signal.coherence	R	scipy.signal.coherence										
scipy.signal.cont2discrete	A										<section class="prog__container"><p>Transform a continuous to a discrete state-space system.</p><pre><code>scipy.signal.cont2discrete(system, dt, method='zoh', alpha=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : a tuple describing the system or an instance of lti\n    The following gives the number of elements in the tuple and the interpretation:   1: (instance of lti) 2: (num, den) 3: (zeros, poles, gain) 4: (A, B, C, D)   \ndt : float\n    The discretization time step. \nmethod : {“gbt”, “bilinear”, “euler”, “backward_diff”, “zoh”}, optional\n    Which method to use:   gbt: generalized bilinear transformation bilinear: Tustin’s approximation (“gbt” with alpha=0.5) euler: Euler (or forward differencing) method (“gbt” with alpha=0) backward_diff: Backwards differencing (“gbt” with alpha=1.0) zoh: zero-order hold (default)   \nalpha : float within [0, 1], optional\n    The generalized bilinear transformation weighting parameter, which should only be specified with method=”gbt”, and is ignored otherwise</code></pre><span class="prog__sub">Returns:</span><pre><code>sysd : tuple containing the discrete system\n    Based on the input type, the output will be of the form  (num, den, dt)   for transfer function input (zeros, poles, gain, dt)   for zeros-poles-gain input (A, B, C, D, dt) for state-space system input</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cont2discrete.html
scipy signal cont2discrete	R	scipy.signal.cont2discrete										
scipy signal.cont2discrete	R	scipy.signal.cont2discrete										
scipy.signal.convolve2d	A										<section class="prog__container"><p>Convolve two 2-dimensional arrays.</p><pre><code>scipy.signal.convolve2d(in1, in2, mode='full', boundary='fill', fillvalue=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>in1 : array_like\n    First input. \nin2 : array_like\n    Second input. Should have the same number of dimensions as in1. If operating in ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. \nmode : str {‘full’, ‘valid’, ‘same’}, optional\n    A string indicating the size of the output:  full The output is the full discrete linear convolution of the inputs. (Default)  valid The output consists only of those elements that do not rely on the zero-padding.  same The output is the same size as in1, centered with respect to the ‘full’ output.   \nboundary : str {‘fill’, ‘wrap’, ‘symm’}, optional\n    A flag indicating how to handle boundaries:  fill pad input arrays with fillvalue. (default)  wrap circular boundary conditions.  symm symmetrical boundary conditions.   \nfillvalue : scalar, optional\n    Value to fill pad input arrays with. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    A 2-dimensional array containing a subset of the discrete linear convolution of in1 with in2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy import misc\n>>> ascent = misc.ascent()\n>>> scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],\n...                    [-10+0j, 0+ 0j, +10 +0j],\n...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy\n>>> grad = signal.convolve2d(ascent, scharr, boundary='symm', mode='same')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve2d.html
scipy signal convolve2d	R	scipy.signal.convolve2d										
scipy signal.convolve2d	R	scipy.signal.convolve2d										
scipy.signal.convolve	A										<section class="prog__container"><p>Convolve two N-dimensional arrays.</p><pre><code>scipy.signal.convolve(in1, in2, mode='full')</code></pre><span class="prog__sub">Parameters:</span><pre><code>in1 : array_like\n    First input. \nin2 : array_like\n    Second input. Should have the same number of dimensions as in1. If operating in ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. \nmode : str {‘full’, ‘valid’, ‘same’}, optional\n    A string indicating the size of the output:  full The output is the full discrete linear convolution of the inputs. (Default)  valid The output consists only of those elements that do not rely on the zero-padding.  same The output is the same size as in1, centered with respect to the ‘full’ output.</code></pre><span class="prog__sub">Returns:</span><pre><code>convolve : array\n    An N-dimensional array containing a subset of the discrete linear convolution of in1 with in2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> sig = np.repeat([0., 1., 0.], 100)\n>>> win = signal.hann(50)\n>>> filtered = signal.convolve(sig, win, mode='same') / sum(win)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve.html
scipy signal convolve	R	scipy.signal.convolve										
scipy signal.convolve	R	scipy.signal.convolve										
scipy.signal.correlate2d	A										<section class="prog__container"><p>Cross-correlate two 2-dimensional arrays.</p><pre><code>scipy.signal.correlate2d(in1, in2, mode='full', boundary='fill', fillvalue=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>in1 : array_like\n    First input. \nin2 : array_like\n    Second input. Should have the same number of dimensions as in1. If operating in ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. \nmode : str {‘full’, ‘valid’, ‘same’}, optional\n    A string indicating the size of the output:  full The output is the full discrete linear cross-correlation of the inputs. (Default)  valid The output consists only of those elements that do not rely on the zero-padding.  same The output is the same size as in1, centered with respect to the ‘full’ output.   \nboundary : str {‘fill’, ‘wrap’, ‘symm’}, optional\n    A flag indicating how to handle boundaries:  fill pad input arrays with fillvalue. (default)  wrap circular boundary conditions.  symm symmetrical boundary conditions.   \nfillvalue : scalar, optional\n    Value to fill pad input arrays with. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>correlate2d : ndarray\n    A 2-dimensional array containing a subset of the discrete linear cross-correlation of in1 with in2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy import misc\n>>> face = misc.face(gray=True) - misc.face(gray=True).mean()\n>>> template = np.copy(face[300:365, 670:750])  # right eye\n>>> template -= template.mean()\n>>> face = face + np.random.randn(*face.shape) * 50  # add noise\n>>> corr = signal.correlate2d(face, template, boundary='symm', mode='same')\n>>> y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.correlate2d.html
scipy signal correlate2d	R	scipy.signal.correlate2d										
scipy signal.correlate2d	R	scipy.signal.correlate2d										
scipy.signal.correlate	A										<section class="prog__container"><p>Cross-correlate two N-dimensional arrays.</p><pre><code>scipy.signal.correlate(in1, in2, mode='full')</code></pre><span class="prog__sub">Parameters:</span><pre><code>in1 : array_like\n    First input. \nin2 : array_like\n    Second input. Should have the same number of dimensions as in1. If operating in ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. \nmode : str {‘full’, ‘valid’, ‘same’}, optional\n    A string indicating the size of the output:  full The output is the full discrete linear cross-correlation of the inputs. (Default)  valid The output consists only of those elements that do not rely on the zero-padding.  same The output is the same size as in1, centered with respect to the ‘full’ output.</code></pre><span class="prog__sub">Returns:</span><pre><code>correlate : array\n    An N-dimensional array containing a subset of the discrete linear cross-correlation of in1 with in2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128)\n>>> sig_noise = sig + np.random.randn(len(sig))\n>>> corr = signal.correlate(sig_noise, np.ones(128), mode='same') / 128</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.correlate.html
scipy signal correlate	R	scipy.signal.correlate										
scipy signal.correlate	R	scipy.signal.correlate										
scipy.signal.cosine	A										<section class="prog__container"><p>Return a window with a simple cosine shape.</p><pre><code>scipy.signal.cosine(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cosine.html
scipy signal cosine	R	scipy.signal.cosine										
scipy signal.cosine	R	scipy.signal.cosine										
scipy.signal.csd	A										<section class="prog__container"><p>Estimate the cross power spectral density, Pxy, using Welch’s method.</p><pre><code>scipy.signal.csd(x, y, fs=1.0, window='hann', nperseg=256, noverlap=None, nfft=None, detrend='constant', return_onesided=True, scaling='density', axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Time series of measurement values \ny : array_like\n    Time series of measurement values \nfs : float, optional\n    Sampling frequency of the x and y time series. Defaults to 1.0. \nwindow : str or tuple or array_like, optional\n    Desired window to use. See get_window for a list of windows and required parameters. If window is array_like it will be used directly as the window and its length will be used for nperseg. Defaults to ‘hann’. \nnperseg : int, optional\n    Length of each segment.  Defaults to 256. \nnoverlap: int, optional\n    Number of points to overlap between segments. If None, noverlap = nperseg // 2.  Defaults to None. \nnfft : int, optional\n    Length of the FFT used, if a zero padded FFT is desired.  If None, the FFT length is nperseg. Defaults to None. \ndetrend : str or function or False, optional\n    Specifies how to detrend each segment. If detrend is a string, it is passed as the type argument to detrend.  If it is a function, it takes a segment and returns a detrended segment. If detrend is False, no detrending is done.  Defaults to ‘constant’. \nreturn_onesided : bool, optional\n    If True, return a one-sided spectrum for real data. If False return a two-sided spectrum. Note that for complex data, a two-sided spectrum is always returned. \nscaling : { ‘density’, ‘spectrum’ }, optional\n    Selects between computing the cross spectral density (‘density’) where Pxy has units of V**2/Hz and computing the cross spectrum (‘spectrum’) where Pxy has units of V**2, if x and y are measured in V and fs is measured in Hz.  Defaults to ‘density’ \naxis : int, optional\n    Axis along which the CSD is computed for both inputs; the default is over the last axis (i.e. axis=-1).</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of sample frequencies. \nPxy : ndarray\n    Cross spectral density or cross power spectrum of x,y.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.csd.html
scipy signal csd	R	scipy.signal.csd										
scipy signal.csd	R	scipy.signal.csd										
scipy.signal.cspline1d	A										<section class="prog__container"><p>Compute cubic spline coefficients for rank-1 array.</p><pre><code>scipy.signal.cspline1d(signal, lamb=0.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>signal : ndarray\n    A rank-1 array representing samples of a signal. \nlamb : float, optional\n    Smoothing coefficient, default is 0.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    Cubic spline coefficients.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cspline1d.html
scipy.signal.cspline1d_eval	A										<section class="prog__container"><p>Evaluate a spline at the new set of points.</p><pre><code>scipy.signal.cspline1d_eval(cj, newx, dx=1.0, x0=0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cspline1d_eval.html
scipy signal cspline1d_eval	R	scipy.signal.cspline1d_eval										
scipy signal.cspline1d_eval	R	scipy.signal.cspline1d_eval										
scipy signal cspline1d	R	scipy.signal.cspline1d										
scipy signal.cspline1d	R	scipy.signal.cspline1d										
scipy.signal.cspline2d	A										<section class="prog__container"><p>Description:</p><pre><code>scipy.signal.cspline2d(input {, lambda, precision}) → ck</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cspline2d.html
scipy signal cspline2d	R	scipy.signal.cspline2d										
scipy signal.cspline2d	R	scipy.signal.cspline2d										
scipy.signal.cubic	A										<section class="prog__container"><p>A cubic B-spline.</p><pre><code>scipy.signal.cubic(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cubic.html
scipy signal cubic	R	scipy.signal.cubic										
scipy signal.cubic	R	scipy.signal.cubic										
scipy.signal.cwt	A										<section class="prog__container"><p>Continuous wavelet transform.</p><pre><code>scipy.signal.cwt(data, wavelet, widths)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : (N,) ndarray\n    data on which to perform the transform. \nwavelet : function\n    Wavelet function, which should take 2 arguments. The first argument is the number of points that the returned vector will have (len(wavelet(length,width)) == length). The second is a width parameter, defining the size of the wavelet (e.g. standard deviation of a gaussian). See ricker, which satisfies these requirements. \nwidths : (M,) sequence\n    Widths to use for transform.</code></pre><span class="prog__sub">Returns:</span><pre><code>cwt: (M, N) ndarray\n    Will have shape of (len(widths), len(data)).</code></pre><span class="prog__sub">Examples:</span><pre><code>length = min(10 * width[ii], len(data))\ncwt[ii,:] = signal.convolve(data, wavelet(length,\n                            width[ii]), mode='same')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cwt.html
scipy signal cwt	R	scipy.signal.cwt										
scipy signal.cwt	R	scipy.signal.cwt										
scipy.signal.daub	A										<section class="prog__container"><p>The coefficients for the FIR low-pass filter producing Daubechies wavelets.</p><pre><code>scipy.signal.daub(p)</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : int\n    Order of the zero at f=1/2, can have values from 1 to 34.</code></pre><span class="prog__sub">Returns:</span><pre><code>daub : ndarray\n    Return</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.daub.html
scipy signal daub	R	scipy.signal.daub										
scipy signal.daub	R	scipy.signal.daub										
scipy.signal.dbode	A										<section class="prog__container"><p>Calculate Bode magnitude and phase data of a discrete-time system.</p><pre><code>scipy.signal.dbode(system, w=None, n=100)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the LTI class or a tuple describing the system.\n    The following gives the number of elements in the tuple and the interpretation:   1 (instance of dlti) 2 (num, den, dt) 3 (zeros, poles, gain, dt) 4 (A, B, C, D, dt)   \nw : array_like, optional\n    Array of frequencies (in radians/sample). Magnitude and phase data is calculated for every value in this array. If not given a reasonable set will be calculated. \nn : int, optional\n    Number of frequency points to compute if w is not given. The n frequencies are logarithmically spaced in an interval chosen to include the influence of the poles and zeros of the system.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : 1D ndarray\n    Frequency array [rad/time_unit] \nmag : 1D ndarray\n    Magnitude array [dB] \nphase : 1D ndarray\n    Phase array [deg]</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dbode.html
scipy signal dbode	R	scipy.signal.dbode										
scipy signal.dbode	R	scipy.signal.dbode										
scipy.signal.decimate	A										<section class="prog__container"><p>Downsample the signal after applying an anti-aliasing filter.</p><pre><code>scipy.signal.decimate(x, q, n=None, ftype='iir', axis=-1, zero_phase=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    The signal to be downsampled, as an N-dimensional array. \nq : int\n    The downsampling factor. For downsampling factors higher than 13, it is recommended to call decimate multiple times. \nn : int, optional\n    The order of the filter (1 less than the length for ‘fir’). Defaults to 8 for ‘iir’ and 30 for ‘fir’. \nftype : str {‘iir’, ‘fir’} or dlti instance, optional\n    If ‘iir’ or ‘fir’, specifies the type of lowpass filter. If an instance of an dlti object, uses that object to filter before downsampling. \naxis : int, optional\n    The axis along which to decimate. \nzero_phase : bool, optional\n    Prevent phase shift by filtering with filtfilt instead of lfilter when using an IIR filter, and shifting the outputs back by the filter’s group delay when using an FIR filter. A value of True is recommended, since a phase shift is generally not desired. Using None defaults to False for backwards compatibility. This default will change to True in a future release, so it is best to set this argument explicitly.  New in version 0.18.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The down-sampled signal.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.decimate.html
scipy signal decimate	R	scipy.signal.decimate										
scipy signal.decimate	R	scipy.signal.decimate										
scipy.signal.deconvolve	A										<section class="prog__container"><p>Deconvolves divisor out of signal.</p><pre><code>scipy.signal.deconvolve(signal, divisor)</code></pre><span class="prog__sub">Parameters:</span><pre><code>signal : array_like\n    Signal data, typically a recorded signal \ndivisor : array_like\n    Divisor data, typically an impulse response or filter that was applied to the original signal</code></pre><span class="prog__sub">Returns:</span><pre><code>quotient : ndarray\n    Quotient, typically the recovered original signal \nremainder : ndarray\n    Remainder</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> original = [0, 1, 0, 0, 1, 1, 0, 0]\n>>> impulse_response = [2, 1]\n>>> recorded = signal.convolve(impulse_response, original)\n>>> recorded\narray([0, 2, 1, 0, 2, 3, 1, 0, 0])\n>>> recovered, remainder = signal.deconvolve(recorded, impulse_response)\n>>> recovered\narray([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.deconvolve.html
scipy signal deconvolve	R	scipy.signal.deconvolve										
scipy signal.deconvolve	R	scipy.signal.deconvolve										
scipy.signal.detrend	A										<section class="prog__container"><p>Remove linear trend along axis from data.</p><pre><code>scipy.signal.detrend(data, axis=-1, type='linear', bp=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    The input data. \naxis : int, optional\n    The axis along which to detrend the data. By default this is the last axis (-1). \ntype : {‘linear’, ‘constant’}, optional\n    The type of detrending. If type == 'linear' (default), the result of a linear least-squares fit to data is subtracted from data. If type == 'constant', only the mean of data is subtracted. \nbp : array_like of ints, optional\n    A sequence of break points. If given, an individual linear fit is performed for each part of data between two break points. Break points are specified as indices into data.</code></pre><span class="prog__sub">Returns:</span><pre><code>ret : ndarray\n    The detrended input data.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> randgen = np.random.RandomState(9)\n>>> npoints = 1000\n>>> noise = randgen.randn(npoints)\n>>> x = 3 + 2*np.linspace(0, 1, npoints) + noise\n>>> (signal.detrend(x) - noise).max() < 0.01\nTrue</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.detrend.html
scipy signal detrend	R	scipy.signal.detrend										
scipy signal.detrend	R	scipy.signal.detrend										
scipy.signal.dfreqresp	A										<section class="prog__container"><p>Calculate the frequency response of a discrete-time system.</p><pre><code>scipy.signal.dfreqresp(system, w=None, n=10000, whole=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the dlti class or a tuple describing the system.\n    The following gives the number of elements in the tuple and the interpretation:   1 (instance of dlti) 2 (numerator, denominator, dt) 3 (zeros, poles, gain, dt) 4 (A, B, C, D, dt)   \nw : array_like, optional\n    Array of frequencies (in radians/sample). Magnitude and phase data is calculated for every value in this array. If not given a reasonable set will be calculated. \nn : int, optional\n    Number of frequency points to compute if w is not given. The n frequencies are logarithmically spaced in an interval chosen to include the influence of the poles and zeros of the system. \nwhole : bool, optional\n    Normally, if ‘w’ is not given, frequencies are computed from 0 to the Nyquist frequency, pi radians/sample (upper-half of unit-circle). If whole is True, compute frequencies from 0 to 2*pi radians/sample.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : 1D ndarray\n    Frequency array [radians/sample] \nH : 1D ndarray\n    Array of complex magnitude values</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dfreqresp.html
scipy signal dfreqresp	R	scipy.signal.dfreqresp										
scipy signal.dfreqresp	R	scipy.signal.dfreqresp										
scipy.signal.dimpulse	A					[[scipy.signal.impulse]]\\n[[scipy.signal.dstep]]\\n[[scipy.signal.dlsim]]\\n[[scipy.signal.cont2discrete]]					<section class="prog__container"><p>Impulse response of discrete-time system.</p><pre><code>scipy.signal.dimpulse(system, x0=None, t=None, n=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : tuple of array_like or instance of dlti\n    A tuple describing the system. The following gives the number of elements in the tuple and the interpretation:   1: (instance of dlti) 3: (num, den, dt) 4: (zeros, poles, gain, dt) 5: (A, B, C, D, dt)   \nx0 : array_like, optional\n    Initial state-vector.  Defaults to zero. \nt : array_like, optional\n    Time points.  Computed if not given. \nn : int, optional\n    The number of time points to compute (if t is not given).</code></pre><span class="prog__sub">Returns:</span><pre><code>tout : ndarray\n    Time values for the output, as a 1-D array. \nyout : ndarray\n    Impulse response of system.  Each element of the tuple represents the output of the system based on an impulse in each input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dimpulse.html
scipy signal dimpulse	R	scipy.signal.dimpulse										
scipy signal.dimpulse	R	scipy.signal.dimpulse										
scipy.signal.dlsim	A					[[scipy.signal.lsim]]\\n[[scipy.signal.dstep]]\\n[[scipy.signal.dimpulse]]\\n[[scipy.signal.cont2discrete]]					<section class="prog__container"><p>Simulate output of a discrete-time linear system.</p><pre><code>scipy.signal.dlsim(system, u, t=None, x0=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : tuple of array_like or instance of dlti\n    A tuple describing the system. The following gives the number of elements in the tuple and the interpretation:   1: (instance of dlti) 3: (num, den, dt) 4: (zeros, poles, gain, dt) 5: (A, B, C, D, dt)   \nu : array_like\n    An input array describing the input at each time t (interpolation is assumed between given times).  If there are multiple inputs, then each column of the rank-2 array represents an input. \nt : array_like, optional\n    The time steps at which the input is defined.  If t is given, it must be the same length as u, and the final value in t determines the number of steps returned in the output. \nx0 : array_like, optional\n    The initial conditions on the state vector (zero by default).</code></pre><span class="prog__sub">Returns:</span><pre><code>tout : ndarray\n    Time values for the output, as a 1-D array. \nyout : ndarray\n    System response, as a 1-D array. \nxout : ndarray, optional\n    Time-evolution of the state-vector.  Only generated if the input is a StateSpace system.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> tf = ([1.0,], [1.0, -1.0], 1.0)\n>>> t_in = [0.0, 1.0, 2.0, 3.0]\n>>> u = np.asarray([0.0, 0.0, 1.0, 1.0])\n>>> t_out, y = signal.dlsim(tf, u, t=t_in)\n>>> y.T\narray([[ 0.,  0.,  0.,  1.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlsim.html
scipy signal dlsim	R	scipy.signal.dlsim										
scipy signal.dlsim	R	scipy.signal.dlsim										
scipy.signal.dlti.A	A										<section class="prog__container"><p>State matrix of the StateSpace system.</p><pre><code>dlti.A</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.A.html
scipy signal dlti A	R	scipy.signal.dlti.A										
scipy signal.dlti.A	R	scipy.signal.dlti.A										
scipy.signal.dlti	A					[[scipy.signal.ZerosPolesGain]]\\n[[scipy.signal.StateSpace]]\\n[[scipy.signal.TransferFunction]]\\n[[scipy.signal.lti]]					<section class="prog__container"><p>Discrete-time linear time invariant system base class.</p><pre><code>class scipy.signal.dlti(*system, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*system: arguments\n    The dlti class can be instantiated with either 2, 3 or 4 arguments. The following gives the number of arguments and the corresponding discrete-time subclass that is created:   2: TransferFunction:  (numerator, denominator) 3: ZerosPolesGain: (zeros, poles, gain) 4: StateSpace:  (A, B, C, D)   Each argument can be an array or a sequence. \ndt: float, optional\n    Sampling time [s] of the discrete-time systems. Defaults to True (unspecified sampling time). Must be specified as a keyword argument, for example, dt=0.1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.html
scipy.signal.dlti.B	A										<section class="prog__container"><p>Input matrix of the StateSpace system.</p><pre><code>dlti.B</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.B.html
scipy.signal.dlti.bode	A										<section class="prog__container"><p>Calculate Bode magnitude and phase data of a discrete-time system.</p><pre><code>dlti.bode(w=None, n=100)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.bode.html
scipy signal dlti bode	R	scipy.signal.dlti.bode										
scipy signal.dlti.bode	R	scipy.signal.dlti.bode										
scipy signal dlti B	R	scipy.signal.dlti.B										
scipy signal.dlti.B	R	scipy.signal.dlti.B										
scipy.signal.dlti.C	A										<section class="prog__container"><p>Output matrix of the StateSpace system.</p><pre><code>dlti.C</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.C.html
scipy signal dlti C	R	scipy.signal.dlti.C										
scipy signal.dlti.C	R	scipy.signal.dlti.C										
scipy.signal.dlti.D	A										<section class="prog__container"><p>Feedthrough matrix of the StateSpace system.</p><pre><code>dlti.D</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.D.html
scipy.signal.dlti.den	A										<section class="prog__container"><p>Denominator of the TransferFunction system.</p><pre><code>dlti.den</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.den.html
scipy signal dlti den	R	scipy.signal.dlti.den										
scipy signal.dlti.den	R	scipy.signal.dlti.den										
scipy signal dlti D	R	scipy.signal.dlti.D										
scipy signal.dlti.D	R	scipy.signal.dlti.D										
scipy.signal.dlti.dt	A										<section class="prog__container"><p>Return the sampling time of the system.</p><pre><code>dlti.dt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.dt.html
scipy signal dlti dt	R	scipy.signal.dlti.dt										
scipy signal.dlti.dt	R	scipy.signal.dlti.dt										
scipy.signal.dlti.freqresp	A										<section class="prog__container"><p>Calculate the frequency response of a discrete-time system.</p><pre><code>dlti.freqresp(w=None, n=10000, whole=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.freqresp.html
scipy signal dlti freqresp	R	scipy.signal.dlti.freqresp										
scipy signal.dlti.freqresp	R	scipy.signal.dlti.freqresp										
scipy.signal.dlti.gain	A										<section class="prog__container"><p>Gain of the ZerosPolesGain system.</p><pre><code>dlti.gain</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.gain.html
scipy signal dlti gain	R	scipy.signal.dlti.gain										
scipy signal.dlti.gain	R	scipy.signal.dlti.gain										
scipy.signal.dlti.impulse	A										<section class="prog__container"><p>Return the impulse response of the discrete-time dlti system.\nSee dimpulse for details.</p><pre><code>dlti.impulse(x0=None, t=None, n=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.impulse.html
scipy signal dlti impulse	R	scipy.signal.dlti.impulse										
scipy signal.dlti.impulse	R	scipy.signal.dlti.impulse										
scipy.signal.dlti.num	A										<section class="prog__container"><p>Numerator of the TransferFunction system.</p><pre><code>dlti.num</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.num.html
scipy signal dlti num	R	scipy.signal.dlti.num										
scipy signal.dlti.num	R	scipy.signal.dlti.num										
scipy.signal.dlti.output	A										<section class="prog__container"><p>Return the response of the discrete-time system to input u.\nSee dlsim for details.</p><pre><code>dlti.output(u, t, x0=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.output.html
scipy signal dlti output	R	scipy.signal.dlti.output										
scipy signal.dlti.output	R	scipy.signal.dlti.output										
scipy.signal.dlti.poles	A										<section class="prog__container"><p>Poles of the system.</p><pre><code>dlti.poles</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.poles.html
scipy signal dlti poles	R	scipy.signal.dlti.poles										
scipy signal.dlti.poles	R	scipy.signal.dlti.poles										
scipy signal dlti	R	scipy.signal.dlti										
scipy signal.dlti	R	scipy.signal.dlti										
scipy.signal.dlti.step	A										<section class="prog__container"><p>Return the step response of the discrete-time dlti system.\nSee dstep for details.</p><pre><code>dlti.step(x0=None, t=None, n=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.step.html
scipy signal dlti step	R	scipy.signal.dlti.step										
scipy signal.dlti.step	R	scipy.signal.dlti.step										
scipy.signal.dlti.zeros	A										<section class="prog__container"><p>Zeros of the system.</p><pre><code>dlti.zeros</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dlti.zeros.html
scipy signal dlti zeros	R	scipy.signal.dlti.zeros										
scipy signal.dlti.zeros	R	scipy.signal.dlti.zeros										
scipy.signal.dstep	A					[[scipy.signal.step]]\\n[[scipy.signal.dimpulse]]\\n[[scipy.signal.dlsim]]\\n[[scipy.signal.cont2discrete]]					<section class="prog__container"><p>Step response of discrete-time system.</p><pre><code>scipy.signal.dstep(system, x0=None, t=None, n=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : tuple of array_like\n    A tuple describing the system. The following gives the number of elements in the tuple and the interpretation:   1: (instance of dlti) 3: (num, den, dt) 4: (zeros, poles, gain, dt) 5: (A, B, C, D, dt)   \nx0 : array_like, optional\n    Initial state-vector.  Defaults to zero. \nt : array_like, optional\n    Time points.  Computed if not given. \nn : int, optional\n    The number of time points to compute (if t is not given).</code></pre><span class="prog__sub">Returns:</span><pre><code>tout : ndarray\n    Output time points, as a 1-D array. \nyout : ndarray\n    Step response of system.  Each element of the tuple represents the output of the system based on a step response to each input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.dstep.html
scipy signal dstep	R	scipy.signal.dstep										
scipy signal.dstep	R	scipy.signal.dstep										
scipy.signal.ellipap	A										<section class="prog__container"><p>Return (z,p,k) of Nth-order elliptic analog lowpass filter.</p><pre><code>scipy.signal.ellipap(N, rp, rs)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ellipap.html
scipy signal ellipap	R	scipy.signal.ellipap										
scipy signal.ellipap	R	scipy.signal.ellipap										
scipy.signal.ellip	A					[[scipy.signal.ellipord]]\\n[[scipy.signal.ellipap]]					<section class="prog__container"><p>Elliptic (Cauer) digital and analog filter design.</p><pre><code>scipy.signal.ellip(N, rp, rs, Wn, btype='low', analog=False, output='ba')</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    The order of the filter. \nrp : float\n    The maximum ripple allowed below unity gain in the passband. Specified in decibels, as a positive number. \nrs : float\n    The minimum attenuation required in the stop band. Specified in decibels, as a positive number. \nWn : array_like\n    A scalar or length-2 sequence giving the critical frequencies. For elliptic filters, this is the point in the transition band at which the gain first drops below -rp. For digital filters, Wn is normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (Wn is thus in half-cycles / sample.) For analog filters, Wn is an angular frequency (e.g. rad/s). \nbtype : {‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’}, optional\n    The type of filter.  Default is ‘lowpass’. \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned. \noutput : {‘ba’, ‘zpk’, ‘sos’}, optional\n    Type of output:  numerator/denominator (‘ba’), pole-zero (‘zpk’), or second-order sections (‘sos’). Default is ‘ba’.</code></pre><span class="prog__sub">Returns:</span><pre><code>b, a : ndarray, ndarray\n    Numerator (b) and denominator (a) polynomials of the IIR filter. Only returned if output='ba'. \nz, p, k : ndarray, ndarray, float\n    Zeros, poles, and system gain of the IIR filter transfer function.  Only returned if output='zpk'. \nsos : ndarray\n    Second-order sections representation of the IIR filter. Only returned if output=='sos'.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ellip.html
scipy.signal.ellipord	A										<section class="prog__container"><p>Elliptic (Cauer) filter order selection.</p><pre><code>scipy.signal.ellipord(wp, ws, gpass, gstop, analog=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>wp, ws : float\n    Passband and stopband edge frequencies. For digital filters, these are normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (wp and ws are thus in half-cycles / sample.)  For example:   Lowpass:   wp = 0.2,          ws = 0.3 Highpass:  wp = 0.3,          ws = 0.2 Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]   For analog filters, wp and ws are angular frequencies (e.g. rad/s). \ngpass : float\n    The maximum loss in the passband (dB). \ngstop : float\n    The minimum attenuation in the stopband (dB). \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>ord : int\n    The lowest order for an Elliptic (Cauer) filter that meets specs. \nwn : ndarray or float\n    The Chebyshev natural frequency (the “3dB frequency”) for use with ellip to give filter results.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ellipord.html
scipy signal ellipord	R	scipy.signal.ellipord										
scipy signal.ellipord	R	scipy.signal.ellipord										
scipy signal ellip	R	scipy.signal.ellip										
scipy signal.ellip	R	scipy.signal.ellip										
scipy.signal.exponential	A										<section class="prog__container"><p>Return an exponential (or Poisson) window.</p><pre><code>scipy.signal.exponential(M, center=None, tau=1.0, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \ncenter : float, optional\n    Parameter defining the center location of the window function. The default value if not given is center = (M-1) / 2.  This parameter must take its default value for symmetric windows. \ntau : float, optional\n    Parameter defining the decay.  For center = 0 use tau = -(M-1) / ln(x) if x is the fraction of the window remaining at the end. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.exponential.html
scipy signal exponential	R	scipy.signal.exponential										
scipy signal.exponential	R	scipy.signal.exponential										
scipy.signal.fftconvolve	A										<section class="prog__container"><p>Convolve two N-dimensional arrays using FFT.</p><pre><code>scipy.signal.fftconvolve(in1, in2, mode='full')</code></pre><span class="prog__sub">Parameters:</span><pre><code>in1 : array_like\n    First input. \nin2 : array_like\n    Second input. Should have the same number of dimensions as in1. If operating in ‘valid’ mode, either in1 or in2 must be at least as large as the other in every dimension. \nmode : str {‘full’, ‘valid’, ‘same’}, optional\n    A string indicating the size of the output:  full The output is the full discrete linear convolution of the inputs. (Default)  valid The output consists only of those elements that do not rely on the zero-padding.  same The output is the same size as in1, centered with respect to the ‘full’ output.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : array\n    An N-dimensional array containing a subset of the discrete linear convolution of in1 with in2.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> sig = np.random.randn(1000)\n>>> autocorr = signal.fftconvolve(sig, sig[::-1], mode='full')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.fftconvolve.html
scipy signal fftconvolve	R	scipy.signal.fftconvolve										
scipy signal.fftconvolve	R	scipy.signal.fftconvolve										
scipy.signal.filtfilt	A					[[scipy.signal.sosfiltfilt]]\\n[[scipy.signal.lfilter_zi]]\\n[[scipy.signal.lfilter]]\\n[[scipy.signal.lfiltic]]\\n[[scipy.signal.savgol_filter]]\\n[[scipy.signal.sosfilt]]					<section class="prog__container"><p>A forward-backward filter.</p><pre><code>scipy.signal.filtfilt(b, a, x, axis=-1, padtype='odd', padlen=None, method='pad', irlen=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : (N,) array_like\n    The numerator coefficient vector of the filter. \na : (N,) array_like\n    The denominator coefficient vector of the filter.  If a[0] is not 1, then both a and b are normalized by a[0]. \nx : array_like\n    The array of data to be filtered. \naxis : int, optional\n    The axis of x to which the filter is applied. Default is -1. \npadtype : str or None, optional\n    Must be ‘odd’, ‘even’, ‘constant’, or None.  This determines the type of extension to use for the padded signal to which the filter is applied.  If padtype is None, no padding is used.  The default is ‘odd’. \npadlen : int or None, optional\n    The number of elements by which to extend x at both ends of axis before applying the filter.  This value must be less than x.shape[axis] - 1.  padlen=0 implies no padding. The default value is 3 * max(len(a), len(b)). \nmethod : str, optional\n    Determines the method for handling the edges of the signal, either “pad” or “gust”.  When method is “pad”, the signal is padded; the type of padding is determined by padtype and padlen, and irlen is ignored.  When method is “gust”, Gustafsson’s method is used, and padtype and padlen are ignored. \nirlen : int or None, optional\n    When method is “gust”, irlen specifies the length of the impulse response of the filter.  If irlen is None, no part of the impulse response is ignored.  For a long signal, specifying irlen can significantly improve the performance of the filter.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The filtered output with the same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.filtfilt.html
scipy signal filtfilt	R	scipy.signal.filtfilt										
scipy signal.filtfilt	R	scipy.signal.filtfilt										
scipy.signal.findfreqs	A										<section class="prog__container"><p>Find array of frequencies for computing the response of an analog filter.</p><pre><code>scipy.signal.findfreqs(num, den, N)</code></pre><span class="prog__sub">Parameters:</span><pre><code>num, den : array_like, 1-D\n    The polynomial coefficients of the numerator and denominator of the transfer function of the filter or LTI system.  The coefficients are ordered from highest to lowest degree. \nN : int\n    The length of the array to be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : (N,) ndarray\n    A 1-D array of frequencies, logarithmically spaced.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> signal.findfreqs([1, 0], [1, 8, 25], N=9)\narray([  1.00000000e-02,   3.16227766e-02,   1.00000000e-01,\n         3.16227766e-01,   1.00000000e+00,   3.16227766e+00,\n         1.00000000e+01,   3.16227766e+01,   1.00000000e+02])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.findfreqs.html
scipy signal findfreqs	R	scipy.signal.findfreqs										
scipy signal.findfreqs	R	scipy.signal.findfreqs										
scipy.signal.find_peaks_cwt	A					[[scipy.signal.cwt]]					<section class="prog__container"><p>Attempt to find the peaks in a 1-D array.</p><pre><code>scipy.signal.find_peaks_cwt(vector, widths, wavelet=None, max_distances=None, gap_thresh=None, min_length=None, min_snr=1, noise_perc=10)</code></pre><span class="prog__sub">Parameters:</span><pre><code>vector : ndarray\n    1-D array in which to find the peaks. \nwidths : sequence\n    1-D array of widths to use for calculating the CWT matrix. In general, this range should cover the expected width of peaks of interest. \nwavelet : callable, optional\n    Should take two parameters and return a 1-D array to convolve with vector. The first parameter determines the number of points  of the returned wavelet array, the second parameter is the scale  (width) of the wavelet. Should be normalized and symmetric. Default is the ricker wavelet. \nmax_distances : ndarray, optional\n    At each row, a ridge line is only connected if the relative max at row[n] is within max_distances[n] from the relative max at row[n+1].  Default value is widths/4. \ngap_thresh : float, optional\n    If a relative maximum is not found within max_distances, there will be a gap. A ridge line is discontinued if there are more than gap_thresh points without connecting a new relative maximum. Default is 2. \nmin_length : int, optional\n    Minimum length a ridge line needs to be acceptable. Default is cwt.shape[0] / 4, ie 1/4-th the number of widths. \nmin_snr : float, optional\n    Minimum SNR ratio. Default 1. The signal is the value of the cwt matrix at the shortest length scale (cwt[0, loc]), the noise is the noise_perc`th percentile of datapoints contained within a window of `window_size around cwt[0, loc]. \nnoise_perc : float, optional\n    When calculating the noise floor, percentile of data points examined below which to consider noise. Calculated using stats.scoreatpercentile.  Default is 10.</code></pre><span class="prog__sub">Returns:</span><pre><code>peaks_indices : list\n    Indices of the locations in the vector where peaks were found. The list is sorted.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> xs = np.arange(0, np.pi, 0.05)\n>>> data = np.sin(xs)\n>>> peakind = signal.find_peaks_cwt(data, np.arange(1,10))\n>>> peakind, xs[peakind], data[peakind]\n([32], array([ 1.6]), array([ 0.9995736]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.find_peaks_cwt.html
scipy signal find_peaks_cwt	R	scipy.signal.find_peaks_cwt										
scipy signal.find_peaks_cwt	R	scipy.signal.find_peaks_cwt										
scipy.signal.firls	A					[[scipy.signal.firwin]]\\n[[scipy.signal.firwin2]]					<section class="prog__container"><p>FIR filter design using least-squares error minimization.</p><pre><code>scipy.signal.firls(numtaps, bands, desired, weight=None, nyq=1.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>numtaps : int\n    The number of taps in the FIR filter.  numtaps must be odd. \nbands : array_like\n    A monotonic nondecreasing sequence containing the band edges in Hz. All elements must be non-negative and less than or equal to the Nyquist frequency given by nyq. \ndesired : array_like\n    A sequence the same size as bands containing the desired gain at the start and end point of each band. \nweight : array_like, optional\n    A relative weighting to give to each band region when solving the least squares problem. weight has to be half the size of bands. \nnyq : float, optional\n    Nyquist frequency. Each frequency in bands must be between 0 and nyq (inclusive).</code></pre><span class="prog__sub">Returns:</span><pre><code>coeffs : ndarray\n    Coefficients of the optimal (in a least squares sense) FIR filter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt\n>>> fig, axs = plt.subplots(2)\n>>> nyq = 5.  # Hz\n>>> desired = (0, 0, 1, 1, 0, 0)\n>>> for bi, bands in enumerate(((0, 1, 2, 3, 4, 5), (0, 1, 2, 4, 4.5, 5))):\n...     fir_firls = signal.firls(73, bands, desired, nyq=nyq)\n...     fir_remez = signal.remez(73, bands, desired[::2], Hz=2 * nyq)\n...     fir_firwin2 = signal.firwin2(73, bands, desired, nyq=nyq)\n...     hs = list()\n...     ax = axs[bi]\n...     for fir in (fir_firls, fir_remez, fir_firwin2):\n...         freq, response = signal.freqz(fir)\n...         hs.append(ax.semilogy(nyq*freq/(np.pi), np.abs(response))[0])\n...     for band, gains in zip(zip(bands[::2], bands[1::2]), zip(desired[::2], desired[1::2])):\n...         ax.semilogy(band, np.maximum(gains, 1e-7), 'k--', linewidth=2)\n...     if bi == 0:\n...         ax.legend(hs, ('firls', 'remez', 'firwin2'), loc='lower center', frameon=False)\n...     else:\n...         ax.set_xlabel('Frequency (Hz)')\n...     ax.grid(True)\n...     ax.set(title='Band-pass %d-%d Hz' % bands[2:4], ylabel='Magnitude')\n...\n>>> fig.tight_layout()\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.firls.html
scipy signal firls	R	scipy.signal.firls										
scipy signal.firls	R	scipy.signal.firls										
scipy.signal.firwin2	A					[[scipy.signal.firls]]\\n[[scipy.signal.firwin]]\\n[[scipy.signal.remez]]					<section class="prog__container"><p>FIR filter design using the window method.</p><pre><code>scipy.signal.firwin2(numtaps, freq, gain, nfreqs=None, window='hamming', nyq=1.0, antisymmetric=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>numtaps : int\n    The number of taps in the FIR filter.  numtaps must be less than nfreqs. \nfreq : array_like, 1D\n    The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being Nyquist.  The Nyquist frequency can be redefined with the argument nyq. The values in freq must be nondecreasing.  A value can be repeated once to implement a discontinuity.  The first value in freq must be 0, and the last value must be nyq. \ngain : array_like\n    The filter gains at the frequency sampling points. Certain constraints to gain values, depending on the filter type, are applied, see Notes for details. \nnfreqs : int, optional\n    The size of the interpolation mesh used to construct the filter. For most efficient behavior, this should be a power of 2 plus 1 (e.g, 129, 257, etc).  The default is one more than the smallest power of 2 that is not less than numtaps.  nfreqs must be greater than numtaps. \nwindow : string or (string, float) or float, or None, optional\n    Window function to use. Default is “hamming”.  See scipy.signal.get_window for the complete list of possible values. If None, no window function is applied. \nnyq : float, optional\n    Nyquist frequency.  Each frequency in freq must be between 0 and nyq (inclusive). \nantisymmetric : bool, optional\n    Whether resulting impulse response is symmetric/antisymmetric. See Notes for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>taps : ndarray\n    The filter coefficients of the FIR filter, as a 1-D array of length numtaps.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> taps = signal.firwin2(150, [0.0, 0.5, 1.0], [1.0, 1.0, 0.0])\n>>> print(taps[72:78])\n[-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.firwin2.html
scipy signal firwin2	R	scipy.signal.firwin2										
scipy signal.firwin2	R	scipy.signal.firwin2										
scipy.signal.firwin	A					[[scipy.signal.firwin2]]\\n[[scipy.signal.firls]]\\n[[scipy.signal.remez]]					<section class="prog__container"><p>FIR filter design using the window method.</p><pre><code>scipy.signal.firwin(numtaps, cutoff, width=None, window='hamming', pass_zero=True, scale=True, nyq=1.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>numtaps : int\n    Length of the filter (number of coefficients, i.e. the filter order + 1).  numtaps must be even if a passband includes the Nyquist frequency. \ncutoff : float or 1D array_like\n    Cutoff frequency of filter (expressed in the same units as nyq) OR an array of cutoff frequencies (that is, band edges). In the latter case, the frequencies in cutoff should be positive and monotonically increasing between 0 and nyq.  The values 0 and nyq must not be included in cutoff. \nwidth : float or None, optional\n    If width is not None, then assume it is the approximate width of the transition region (expressed in the same units as nyq) for use in Kaiser FIR filter design.  In this case, the window argument is ignored. \nwindow : string or tuple of string and parameter values, optional\n    Desired window to use. See scipy.signal.get_window for a list of windows and required parameters. \npass_zero : bool, optional\n    If True, the gain at the frequency 0 (i.e. the “DC gain”) is 1. Otherwise the DC gain is 0. \nscale : bool, optional\n    Set to True to scale the coefficients so that the frequency response is exactly unity at a certain frequency. That frequency is either:  0 (DC) if the first passband starts at 0 (i.e. pass_zero is True) nyq (the Nyquist rate) if the first passband ends at nyq (i.e the filter is a single band highpass filter); center of first passband otherwise  \nnyq : float, optional\n    Nyquist frequency.  Each frequency in cutoff must be between 0 and nyq.</code></pre><span class="prog__sub">Returns:</span><pre><code>h : (numtaps,) ndarray\n    Coefficients of length numtaps FIR filter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> numtaps = 3\n>>> f = 0.1\n>>> signal.firwin(numtaps, f)\narray([ 0.06799017,  0.86401967,  0.06799017])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.firwin.html
scipy signal firwin	R	scipy.signal.firwin										
scipy signal.firwin	R	scipy.signal.firwin										
scipy.signal.flattop	A										<section class="prog__container"><p>Return a flat top window.</p><pre><code>scipy.signal.flattop(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.flattop.html
scipy signal flattop	R	scipy.signal.flattop										
scipy signal.flattop	R	scipy.signal.flattop										
scipy.signal.freqresp	A										<section class="prog__container"><p>Calculate the frequency response of a continuous-time system.</p><pre><code>scipy.signal.freqresp(system, w=None, n=10000)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the lti class or a tuple describing the system.\n    The following gives the number of elements in the tuple and the interpretation:   1 (instance of lti) 2 (num, den) 3 (zeros, poles, gain) 4 (A, B, C, D)   \nw : array_like, optional\n    Array of frequencies (in rad/s). Magnitude and phase data is calculated for every value in this array. If not given, a reasonable set will be calculated. \nn : int, optional\n    Number of frequency points to compute if w is not given. The n frequencies are logarithmically spaced in an interval chosen to include the influence of the poles and zeros of the system.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : 1D ndarray\n    Frequency array [rad/s] \nH : 1D ndarray\n    Array of complex magnitude values</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.freqresp.html
scipy signal freqresp	R	scipy.signal.freqresp										
scipy signal.freqresp	R	scipy.signal.freqresp										
scipy.signal.freqs	A										<section class="prog__container"><p>Compute frequency response of analog filter.</p><pre><code>scipy.signal.freqs(b, a, worN=None, plot=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : array_like\n    Numerator of a linear filter. \na : array_like\n    Denominator of a linear filter. \nworN : {None, int, array_like}, optional\n    If None, then compute at 200 frequencies around the interesting parts of the response curve (determined by pole-zero locations).  If a single integer, then compute at that many frequencies.  Otherwise, compute the response at the angular frequencies (e.g. rad/s) given in worN. \nplot : callable, optional\n    A callable that takes two arguments. If given, the return parameters w and h are passed to plot. Useful for plotting the frequency response inside freqs.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The angular frequencies at which h was computed. \nh : ndarray\n    The frequency response.</code></pre><span class="prog__sub">Examples:</span><pre><code>b[0]*(jw)**M + b[1]*(jw)**(M-1) + ... + b[M]\nH(w) = ----------------------------------------------\n        a[0]*(jw)**N + a[1]*(jw)**(N-1) + ... + a[N]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.freqs.html
scipy signal freqs	R	scipy.signal.freqs										
scipy signal.freqs	R	scipy.signal.freqs										
scipy.signal.freqz	A										<section class="prog__container"><p>Compute the frequency response of a digital filter.</p><pre><code>scipy.signal.freqz(b, a=1, worN=None, whole=False, plot=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : array_like\n    numerator of a linear filter \na : array_like\n    denominator of a linear filter \nworN : {None, int, array_like}, optional\n    If None (default), then compute at 512 frequencies equally spaced around the unit circle. If a single integer, then compute at that many frequencies. If an array_like, compute the response at the frequencies given (in radians/sample). \nwhole : bool, optional\n    Normally, frequencies are computed from 0 to the Nyquist frequency, pi radians/sample (upper-half of unit-circle).  If whole is True, compute frequencies from 0 to 2*pi radians/sample. \nplot : callable\n    A callable that takes two arguments. If given, the return parameters w and h are passed to plot. Useful for plotting the frequency response inside freqz.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The normalized frequencies at which h was computed, in radians/sample. \nh : ndarray\n    The frequency response.</code></pre><span class="prog__sub">Examples:</span><pre><code>jw               -jw               -jwM\n   jw    B(e  )  b[0] + b[1]e    + .... + b[M]e\nH(e  ) = ---- = -----------------------------------\n            jw               -jw               -jwN\n         A(e  )  a[0] + a[1]e    + .... + a[N]e</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.freqz.html
scipy signal freqz	R	scipy.signal.freqz										
scipy signal.freqz	R	scipy.signal.freqz										
scipy.signal.gaussian	A										<section class="prog__container"><p>Return a Gaussian window.</p><pre><code>scipy.signal.gaussian(M, std, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nstd : float\n    The standard deviation, sigma. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.gaussian.html
scipy signal gaussian	R	scipy.signal.gaussian										
scipy signal.gaussian	R	scipy.signal.gaussian										
scipy.signal.gausspulse	A					[[scipy.signal.morlet]]					<section class="prog__container"><p>Return a Gaussian modulated sinusoid:</p><pre><code>scipy.signal.gausspulse(t, fc=1000, bw=0.5, bwr=-6, tpr=-60, retquad=False, retenv=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>t : ndarray or the string ‘cutoff’\n    Input array. \nfc : int, optional\n    Center frequency (e.g. Hz).  Default is 1000. \nbw : float, optional\n    Fractional bandwidth in frequency domain of pulse (e.g. Hz). Default is 0.5. \nbwr : float, optional\n    Reference level at which fractional bandwidth is calculated (dB). Default is -6. \ntpr : float, optional\n    If t is ‘cutoff’, then the function returns the cutoff time for when the pulse amplitude falls below tpr (in dB). Default is -60. \nretquad : bool, optional\n    If True, return the quadrature (imaginary) as well as the real part of the signal.  Default is False. \nretenv : bool, optional\n    If True, return the envelope of the signal.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>yI : ndarray\n    Real part of signal.  Always returned. \nyQ : ndarray\n    Imaginary part of signal.  Only returned if retquad is True. \nyenv : ndarray\n    Envelope of signal.  Only returned if retenv is True.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt\n>>> t = np.linspace(-1, 1, 2 * 100, endpoint=False)\n>>> i, q, e = signal.gausspulse(t, fc=5, retquad=True, retenv=True)\n>>> plt.plot(t, i, t, q, t, e, '--')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.gausspulse.html
scipy signal gausspulse	R	scipy.signal.gausspulse										
scipy signal.gausspulse	R	scipy.signal.gausspulse										
scipy.signal.gauss_spline	A										<section class="prog__container"><p>Gaussian approximation to B-spline basis function of order n.</p><pre><code>scipy.signal.gauss_spline(x, n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.gauss_spline.html
scipy signal gauss_spline	R	scipy.signal.gauss_spline										
scipy signal.gauss_spline	R	scipy.signal.gauss_spline										
scipy.signal.general_gaussian	A										<section class="prog__container"><p>Return a window with a generalized Gaussian shape.</p><pre><code>scipy.signal.general_gaussian(M, p, sig, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \np : float\n    Shape parameter.  p = 1 is identical to gaussian, p = 0.5 is the same shape as the Laplace distribution. \nsig : float\n    The standard deviation, sigma. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.general_gaussian.html
scipy signal general_gaussian	R	scipy.signal.general_gaussian										
scipy signal.general_gaussian	R	scipy.signal.general_gaussian										
scipy.signal.get_window	A										<section class="prog__container"><p>Return a window.</p><pre><code>scipy.signal.get_window(window, Nx, fftbins=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>window : string, float, or tuple\n    The type of window to create. See below for more details. \nNx : int\n    The number of samples in the window. \nfftbins : bool, optional\n    If True (default), create a “periodic” window, ready to use with ifftshift and be multiplied by the result of an FFT (see also fftpack.fftfreq). If False, create a “symmetric” window, for use in filter design.</code></pre><span class="prog__sub">Returns:</span><pre><code>get_window : ndarray\n    Returns a window of length Nx and type window</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> signal.get_window('triang', 7)\narray([ 0.25,  0.5 ,  0.75,  1.  ,  0.75,  0.5 ,  0.25])\n>>> signal.get_window(('kaiser', 4.0), 9)\narray([ 0.08848053,  0.32578323,  0.63343178,  0.89640418,  1.        ,\n        0.89640418,  0.63343178,  0.32578323,  0.08848053])\n>>> signal.get_window(4.0, 9)\narray([ 0.08848053,  0.32578323,  0.63343178,  0.89640418,  1.        ,\n        0.89640418,  0.63343178,  0.32578323,  0.08848053])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html
scipy signal get_window	R	scipy.signal.get_window										
scipy signal.get_window	R	scipy.signal.get_window										
scipy.signal.group_delay	A										<section class="prog__container"><p>Compute the group delay of a digital filter.</p><pre><code>scipy.signal.group_delay(system, w=None, whole=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : tuple of array_like (b, a)\n    Numerator and denominator coefficients of a filter transfer function. \nw : {None, int, array-like}, optional\n    If None (default), then compute at 512 frequencies equally spaced around the unit circle. If a single integer, then compute at that many frequencies. If array, compute the delay at the frequencies given (in radians/sample). \nwhole : bool, optional\n    Normally, frequencies are computed from 0 to the Nyquist frequency, pi radians/sample (upper-half of unit-circle).  If whole is True, compute frequencies from 0 to 2*pi radians/sample.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The normalized frequencies at which the group delay was computed, in radians/sample. \ngd : ndarray\n    The group delay.</code></pre><span class="prog__sub">Examples:</span><pre><code>d        jw\nD(w) = - -- arg H(e)\n         dw</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.group_delay.html
scipy signal group_delay	R	scipy.signal.group_delay										
scipy signal.group_delay	R	scipy.signal.group_delay										
scipy.signal.hamming	A										<section class="prog__container"><p>Return a Hamming window.</p><pre><code>scipy.signal.hamming(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hamming.html
scipy signal hamming	R	scipy.signal.hamming										
scipy signal.hamming	R	scipy.signal.hamming										
scipy.signal.hann	A										<section class="prog__container"><p>Return a Hann window.</p><pre><code>scipy.signal.hann(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hann.html
scipy.signal.hanning	A										<section class="prog__container"><p>Return a Hann window.</p><pre><code>scipy.signal.hanning(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hanning.html
scipy signal hanning	R	scipy.signal.hanning										
scipy signal.hanning	R	scipy.signal.hanning										
scipy signal hann	R	scipy.signal.hann										
scipy signal.hann	R	scipy.signal.hann										
scipy.signal.hilbert2	A										<section class="prog__container"><p>Compute the ‘2-D’ analytic signal of x</p><pre><code>scipy.signal.hilbert2(x, N=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    2-D signal data. \nN : int or tuple of two ints, optional\n    Number of Fourier components. Default is x.shape</code></pre><span class="prog__sub">Returns:</span><pre><code>xa : ndarray\n    Analytic signal of x taken along axes (0,1).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hilbert2.html
scipy signal hilbert2	R	scipy.signal.hilbert2										
scipy signal.hilbert2	R	scipy.signal.hilbert2										
scipy.signal.hilbert	A										<section class="prog__container"><p>Compute the analytic signal, using the Hilbert transform.</p><pre><code>scipy.signal.hilbert(x, N=None, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Signal data.  Must be real. \nN : int, optional\n    Number of Fourier components.  Default: x.shape[axis] \naxis : int, optional\n    Axis along which to do the transformation.  Default: -1.</code></pre><span class="prog__sub">Returns:</span><pre><code>xa : ndarray\n    Analytic signal of x, of each 1-D array along axis</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> from scipy.signal import hilbert, chirp</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.hilbert.html
scipy signal hilbert	R	scipy.signal.hilbert										
scipy signal.hilbert	R	scipy.signal.hilbert										
scipy.signal.iirdesign	A										<section class="prog__container"><p>Complete IIR digital and analog filter design.</p><pre><code>scipy.signal.iirdesign(wp, ws, gpass, gstop, analog=False, ftype='ellip', output='ba')</code></pre><span class="prog__sub">Parameters:</span><pre><code>wp, ws : float\n    Passband and stopband edge frequencies. For digital filters, these are normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (wp and ws are thus in half-cycles / sample.)  For example:   Lowpass:   wp = 0.2,          ws = 0.3 Highpass:  wp = 0.3,          ws = 0.2 Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]   For analog filters, wp and ws are angular frequencies (e.g. rad/s). \ngpass : float\n    The maximum loss in the passband (dB). \ngstop : float\n    The minimum attenuation in the stopband (dB). \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned. \nftype : str, optional\n    The type of IIR filter to design:   Butterworth   : ‘butter’ Chebyshev I   : ‘cheby1’ Chebyshev II  : ‘cheby2’ Cauer/elliptic: ‘ellip’ Bessel/Thomson: ‘bessel’   \noutput : {‘ba’, ‘zpk’, ‘sos’}, optional\n    Type of output:  numerator/denominator (‘ba’), pole-zero (‘zpk’), or second-order sections (‘sos’). Default is ‘ba’.</code></pre><span class="prog__sub">Returns:</span><pre><code>b, a : ndarray, ndarray\n    Numerator (b) and denominator (a) polynomials of the IIR filter. Only returned if output='ba'. \nz, p, k : ndarray, ndarray, float\n    Zeros, poles, and system gain of the IIR filter transfer function.  Only returned if output='zpk'. \nsos : ndarray\n    Second-order sections representation of the IIR filter. Only returned if output=='sos'.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.iirdesign.html
scipy signal iirdesign	R	scipy.signal.iirdesign										
scipy signal.iirdesign	R	scipy.signal.iirdesign										
scipy.signal.iirfilter	A										<section class="prog__container"><p>IIR digital and analog filter design given order and critical points.</p><pre><code>scipy.signal.iirfilter(N, Wn, rp=None, rs=None, btype='band', analog=False, ftype='butter', output='ba')</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int\n    The order of the filter. \nWn : array_like\n    A scalar or length-2 sequence giving the critical frequencies. For digital filters, Wn is normalized from 0 to 1, where 1 is the Nyquist frequency, pi radians/sample.  (Wn is thus in half-cycles / sample.) For analog filters, Wn is an angular frequency (e.g. rad/s). \nrp : float, optional\n    For Chebyshev and elliptic filters, provides the maximum ripple in the passband. (dB) \nrs : float, optional\n    For Chebyshev and elliptic filters, provides the minimum attenuation in the stop band. (dB) \nbtype : {‘bandpass’, ‘lowpass’, ‘highpass’, ‘bandstop’}, optional\n    The type of filter.  Default is ‘bandpass’. \nanalog : bool, optional\n    When True, return an analog filter, otherwise a digital filter is returned. \nftype : str, optional\n    The type of IIR filter to design:   Butterworth   : ‘butter’ Chebyshev I   : ‘cheby1’ Chebyshev II  : ‘cheby2’ Cauer/elliptic: ‘ellip’ Bessel/Thomson: ‘bessel’   \noutput : {‘ba’, ‘zpk’, ‘sos’}, optional\n    Type of output:  numerator/denominator (‘ba’), pole-zero (‘zpk’), or second-order sections (‘sos’). Default is ‘ba’.</code></pre><span class="prog__sub">Returns:</span><pre><code>b, a : ndarray, ndarray\n    Numerator (b) and denominator (a) polynomials of the IIR filter. Only returned if output='ba'. \nz, p, k : ndarray, ndarray, float\n    Zeros, poles, and system gain of the IIR filter transfer function.  Only returned if output='zpk'. \nsos : ndarray\n    Second-order sections representation of the IIR filter. Only returned if output=='sos'.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.iirfilter.html
scipy signal iirfilter	R	scipy.signal.iirfilter										
scipy signal.iirfilter	R	scipy.signal.iirfilter										
scipy.signal.impulse2	A					[[scipy.signal.impulse]]\\n[[scipy.signal.lsim2]]					<section class="prog__container"><p>Impulse response of a single-input, continuous-time linear system.</p><pre><code>scipy.signal.impulse2(system, X0=None, T=None, N=None, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the LTI class or a tuple of array_like\n    describing the system. The following gives the number of elements in the tuple and the interpretation:   1 (instance of lti) 2 (num, den) 3 (zeros, poles, gain) 4 (A, B, C, D)   \nX0 : 1-D array_like, optional\n    The initial condition of the state vector.  Default: 0 (the zero vector). \nT : 1-D array_like, optional\n    The time steps at which the input is defined and at which the output is desired.  If T is not given, the function will generate a set of time samples automatically. \nN : int, optional\n    Number of time points to compute.  Default: 100. \nkwargs : various types\n    Additional keyword arguments are passed on to the function scipy.signal.lsim2, which in turn passes them on to scipy.integrate.odeint; see the latter’s documentation for information about these arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>T : ndarray\n    The time values for the output. \nyout : ndarray\n    The output response of the system.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> system = ([1.0], [1.0, 2.0, 1.0])\n>>> t, y = signal.impulse2(system)\n>>> import matplotlib.pyplot as plt\n>>> plt.plot(t, y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.impulse2.html
scipy signal impulse2	R	scipy.signal.impulse2										
scipy signal.impulse2	R	scipy.signal.impulse2										
scipy.signal.impulse	A										<section class="prog__container"><p>Impulse response of continuous-time system.</p><pre><code>scipy.signal.impulse(system, X0=None, T=None, N=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the LTI class or a tuple of array_like\n    describing the system. The following gives the number of elements in the tuple and the interpretation:   1 (instance of lti) 2 (num, den) 3 (zeros, poles, gain) 4 (A, B, C, D)   \nX0 : array_like, optional\n    Initial state-vector.  Defaults to zero. \nT : array_like, optional\n    Time points.  Computed if not given. \nN : int, optional\n    The number of time points to compute (if T is not given).</code></pre><span class="prog__sub">Returns:</span><pre><code>T : ndarray\n    A 1-D array of time points. \nyout : ndarray\n    A 1-D array containing the impulse response of the system (except for singularities at zero).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.impulse.html
scipy signal impulse	R	scipy.signal.impulse										
scipy signal.impulse	R	scipy.signal.impulse										
scipy.signal.invres	A					[[scipy.signal.residue]]\\n[[scipy.signal.invresz]]\\n[[scipy.signal.unique_roots]]					<section class="prog__container"><p>Compute b(s) and a(s) from partial fraction expansion.</p><pre><code>scipy.signal.invres(r, p, k, tol=0.001, rtype='avg')</code></pre><span class="prog__sub">Parameters:</span><pre><code>r : array_like\n    Residues. \np : array_like\n    Poles. \nk : array_like\n    Coefficients of the direct polynomial term. \ntol : float, optional\n    The tolerance for two roots to be considered equal. Default is 1e-3. \nrtype : {‘max’, ‘min, ‘avg’}, optional\n    How to determine the returned root if multiple roots are within tol of each other.   ‘max’: pick the maximum of those roots. ‘min’: pick the minimum of those roots. ‘avg’: take the average of those roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    Numerator polynomial coefficients. \na : ndarray\n    Denominator polynomial coefficients.</code></pre><span class="prog__sub">Examples:</span><pre><code>b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]\nH(s) = ------ = ------------------------------------------\n        a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.invres.html
scipy signal invres	R	scipy.signal.invres										
scipy signal.invres	R	scipy.signal.invres										
scipy.signal.invresz	A					[[scipy.signal.residuez]]\\n[[scipy.signal.unique_roots]]\\n[[scipy.signal.invres]]					<section class="prog__container"><p>Compute b(z) and a(z) from partial fraction expansion.</p><pre><code>scipy.signal.invresz(r, p, k, tol=0.001, rtype='avg')</code></pre><span class="prog__sub">Parameters:</span><pre><code>r : array_like\n    Residues. \np : array_like\n    Poles. \nk : array_like\n    Coefficients of the direct polynomial term. \ntol : float, optional\n    The tolerance for two roots to be considered equal. Default is 1e-3. \nrtype : {‘max’, ‘min, ‘avg’}, optional\n    How to determine the returned root if multiple roots are within tol of each other.   ‘max’: pick the maximum of those roots. ‘min’: pick the minimum of those roots. ‘avg’: take the average of those roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    Numerator polynomial coefficients. \na : ndarray\n    Denominator polynomial coefficients.</code></pre><span class="prog__sub">Examples:</span><pre><code>b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)\nH(z) = ------ = ------------------------------------------\n        a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.invresz.html
scipy signal invresz	R	scipy.signal.invresz										
scipy signal.invresz	R	scipy.signal.invresz										
scipy.signal.kaiser	A										<section class="prog__container"><p>Return a Kaiser window.</p><pre><code>scipy.signal.kaiser(M, beta, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nbeta : float\n    Shape parameter, determines trade-off between main-lobe width and side lobe level. As beta gets large, the window narrows. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.kaiser.html
scipy.signal.kaiser_atten	A					[[scipy.signal.kaiserord]]\\n[[scipy.signal.kaiser_beta]]					<section class="prog__container"><p>Compute the attenuation of a Kaiser FIR filter.</p><pre><code>scipy.signal.kaiser_atten(numtaps, width)</code></pre><span class="prog__sub">Parameters:</span><pre><code>numtaps : int\n    The number of taps in the FIR filter. \nwidth : float\n    The desired width of the transition region between passband and stopband (or, in general, at any discontinuity) for the filter.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : float\n    The attenuation of the ripple, in dB.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.kaiser_atten.html
scipy signal kaiser_atten	R	scipy.signal.kaiser_atten										
scipy signal.kaiser_atten	R	scipy.signal.kaiser_atten										
scipy.signal.kaiser_beta	A										<section class="prog__container"><p>Compute the Kaiser parameter beta, given the attenuation a.</p><pre><code>scipy.signal.kaiser_beta(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float\n    The desired attenuation in the stopband and maximum ripple in the passband, in dB.  This should be a positive number.</code></pre><span class="prog__sub">Returns:</span><pre><code>beta : float\n    The beta parameter to be used in the formula for a Kaiser window.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.kaiser_beta.html
scipy signal kaiser_beta	R	scipy.signal.kaiser_beta										
scipy signal.kaiser_beta	R	scipy.signal.kaiser_beta										
scipy.signal.kaiserord	A					[[scipy.signal.kaiser_beta]]\\n[[scipy.signal.kaiser_atten]]					<section class="prog__container"><p>Design a Kaiser window to limit ripple and width of transition region.</p><pre><code>scipy.signal.kaiserord(ripple, width)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ripple : float\n    Positive number specifying maximum ripple in passband (dB) and minimum ripple in stopband. \nwidth : float\n    Width of transition region (normalized so that 1 corresponds to pi radians / sample).</code></pre><span class="prog__sub">Returns:</span><pre><code>numtaps : int\n    The length of the kaiser window. \nbeta : float\n    The beta parameter for the kaiser window.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.kaiserord.html
scipy signal kaiserord	R	scipy.signal.kaiserord										
scipy signal.kaiserord	R	scipy.signal.kaiserord										
scipy signal kaiser	R	scipy.signal.kaiser										
scipy signal.kaiser	R	scipy.signal.kaiser										
scipy.signal.lfilter	A										<section class="prog__container"><p>Filter data along one-dimension with an IIR or FIR filter.</p><pre><code>scipy.signal.lfilter(b, a, x, axis=-1, zi=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : array_like\n    The numerator coefficient vector in a 1-D sequence. \na : array_like\n    The denominator coefficient vector in a 1-D sequence.  If a[0] is not 1, then both a and b are normalized by a[0]. \nx : array_like\n    An N-dimensional input array. \naxis : int, optional\n    The axis of the input data array along which to apply the linear filter. The filter is applied to each subarray along this axis.  Default is -1. \nzi : array_like, optional\n    Initial conditions for the filter delays.  It is a vector (or array of vectors for an N-dimensional input) of length max(len(a), len(b)) - 1.  If zi is None or is not given then initial rest is assumed.  See lfiltic for more information.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array\n    The output of the digital filter. \nzf : array, optional\n    If zi is None, this is not returned, otherwise, zf holds the final filter delay values.</code></pre><span class="prog__sub">Examples:</span><pre><code>a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[M]*x[n-M]\n                      - a[1]*y[n-1] - ... - a[N]*y[n-N]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lfilter.html
scipy signal lfilter	R	scipy.signal.lfilter										
scipy signal.lfilter	R	scipy.signal.lfilter										
scipy.signal.lfilter_zi	A					[[scipy.signal.lfilter]]\\n[[scipy.signal.lfiltic]]\\n[[scipy.signal.filtfilt]]					<section class="prog__container"><p>Compute an initial state zi for the lfilter function that corresponds\nto the steady state of the step response.</p><pre><code>scipy.signal.lfilter_zi(b, a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b, a : array_like (1-D)\n    The IIR filter coefficients. See lfilter for more information.</code></pre><span class="prog__sub">Returns:</span><pre><code>zi : 1-D ndarray\n    The initial state for the filter.</code></pre><span class="prog__sub">Examples:</span><pre><code>z(n+1) = A*z(n) + B*x(n)\ny(n)   = C*z(n) + D*x(n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lfilter_zi.html
scipy signal lfilter_zi	R	scipy.signal.lfilter_zi										
scipy signal.lfilter_zi	R	scipy.signal.lfilter_zi										
scipy.signal.lfiltic	A					[[scipy.signal.lfilter]]\\n[[scipy.signal.lfilter_zi]]					<section class="prog__container"><p>Construct initial conditions for lfilter.</p><pre><code>scipy.signal.lfiltic(b, a, y, x=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : array_like\n    Linear filter term. \na : array_like\n    Linear filter term. \ny : array_like\n    Initial conditions. If N = len(a) - 1, then y = {y[-1], y[-2], ..., y[-N]}. If y is too short, it is padded with zeros. \nx : array_like, optional\n    Initial conditions. If M = len(b) - 1, then x = {x[-1], x[-2], ..., x[-M]}. If x is not given, its initial conditions are assumed zero. If x is too short, it is padded with zeros.</code></pre><span class="prog__sub">Returns:</span><pre><code>zi : ndarray\n    The state vector zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}, where K = max(M, N).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lfiltic.html
scipy signal lfiltic	R	scipy.signal.lfiltic										
scipy signal.lfiltic	R	scipy.signal.lfiltic										
scipy.signal.lombscargle	A										<section class="prog__container"><p>Computes the Lomb-Scargle periodogram.</p><pre><code>scipy.signal.lombscargle(x, y, freqs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Sample times. \ny : array_like\n    Measurement values. \nfreqs : array_like\n    Angular frequencies for output periodogram.</code></pre><span class="prog__sub">Returns:</span><pre><code>pgram : array_like\n    Lomb-Scargle periodogram.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import scipy.signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lombscargle.html
scipy signal lombscargle	R	scipy.signal.lombscargle										
scipy signal.lombscargle	R	scipy.signal.lombscargle										
scipy.signal.lp2bp	A										<section class="prog__container"><p>Transform a lowpass filter prototype to a bandpass filter.</p><pre><code>scipy.signal.lp2bp(b, a, wo=1.0, bw=1.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lp2bp.html
scipy signal lp2bp	R	scipy.signal.lp2bp										
scipy signal.lp2bp	R	scipy.signal.lp2bp										
scipy.signal.lp2bs	A										<section class="prog__container"><p>Transform a lowpass filter prototype to a bandstop filter.</p><pre><code>scipy.signal.lp2bs(b, a, wo=1.0, bw=1.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lp2bs.html
scipy signal lp2bs	R	scipy.signal.lp2bs										
scipy signal.lp2bs	R	scipy.signal.lp2bs										
scipy.signal.lp2hp	A										<section class="prog__container"><p>Transform a lowpass filter prototype to a highpass filter.</p><pre><code>scipy.signal.lp2hp(b, a, wo=1.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lp2hp.html
scipy signal lp2hp	R	scipy.signal.lp2hp										
scipy signal.lp2hp	R	scipy.signal.lp2hp										
scipy.signal.lp2lp	A										<section class="prog__container"><p>Transform a lowpass filter prototype to a different frequency.</p><pre><code>scipy.signal.lp2lp(b, a, wo=1.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lp2lp.html
scipy signal lp2lp	R	scipy.signal.lp2lp										
scipy signal.lp2lp	R	scipy.signal.lp2lp										
scipy.signal.lsim2	A										<section class="prog__container"><p>Simulate output of a continuous-time linear system, by using\nthe ODE solver scipy.integrate.odeint.</p><pre><code>scipy.signal.lsim2(system, U=None, T=None, X0=None, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the lti class or a tuple describing the system.\n    The following gives the number of elements in the tuple and the interpretation:  1: (instance of lti) 2: (num, den) 3: (zeros, poles, gain) 4: (A, B, C, D)  \nU : array_like (1D or 2D), optional\n    An input array describing the input at each time T.  Linear interpolation is used between given times.  If there are multiple inputs, then each column of the rank-2 array represents an input.  If U is not given, the input is assumed to be zero. \nT : array_like (1D or 2D), optional\n    The time steps at which the input is defined and at which the output is desired.  The default is 101 evenly spaced points on the interval [0,10.0]. \nX0 : array_like (1D), optional\n    The initial condition of the state vector.  If X0 is not given, the initial conditions are assumed to be 0. \nkwargs : dict\n    Additional keyword arguments are passed on to the function odeint.  See the notes below for more details.</code></pre><span class="prog__sub">Returns:</span><pre><code>T : 1D ndarray\n    The time values for the output. \nyout : ndarray\n    The response of the system. \nxout : ndarray\n    The time-evolution of the state-vector.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lsim2.html
scipy signal lsim2	R	scipy.signal.lsim2										
scipy signal.lsim2	R	scipy.signal.lsim2										
scipy.signal.lsim	A										<section class="prog__container"><p>Simulate output of a continuous-time linear system.</p><pre><code>scipy.signal.lsim(system, U, T, X0=None, interp=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the LTI class or a tuple describing the system.\n    The following gives the number of elements in the tuple and the interpretation:  1: (instance of lti) 2: (num, den) 3: (zeros, poles, gain) 4: (A, B, C, D)  \nU : array_like\n    An input array describing the input at each time T (interpolation is assumed between given times).  If there are multiple inputs, then each column of the rank-2 array represents an input.  If U = 0 or None, a zero input is used. \nT : array_like\n    The time steps at which the input is defined and at which the output is desired.  Must be nonnegative, increasing, and equally spaced. \nX0 : array_like, optional\n    The initial conditions on the state vector (zero by default). \ninterp : bool, optional\n    Whether to use linear (True, the default) or zero-order-hold (False) interpolation for the input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>T : 1D ndarray\n    Time values for the output. \nyout : 1D ndarray\n    System response. \nxout : ndarray\n    Time evolution of the state vector.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> system = signal.lti([[0., 1.], [0., 0.]], [[0.], [1.]], [[1., 0.]], 0.)\n>>> t = np.linspace(0, 5)\n>>> u = np.ones_like(t)\n>>> tout, y, x = signal.lsim(system, u, t)\n>>> import matplotlib.pyplot as plt\n>>> plt.plot(t, y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lsim.html
scipy signal lsim	R	scipy.signal.lsim										
scipy signal.lsim	R	scipy.signal.lsim										
scipy.signal.lti.A	A										<section class="prog__container"><p>State matrix of the StateSpace system.</p><pre><code>lti.A</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.A.html
scipy signal lti A	R	scipy.signal.lti.A										
scipy signal.lti.A	R	scipy.signal.lti.A										
scipy.signal.lti	A					[[scipy.signal.ZerosPolesGain]]\\n[[scipy.signal.StateSpace]]\\n[[scipy.signal.TransferFunction]]\\n[[scipy.signal.dlti]]					<section class="prog__container"><p>Continuous-time linear time invariant system base class.</p><pre><code>class scipy.signal.lti(*system)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*system : arguments\n    The lti class can be instantiated with either 2, 3 or 4 arguments. The following gives the number of arguments and the corresponding continuous-time subclass that is created:   2: TransferFunction:  (numerator, denominator) 3: ZerosPolesGain: (zeros, poles, gain) 4: StateSpace:  (A, B, C, D)   Each argument can be an array or a sequence.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.html
scipy.signal.lti.B	A										<section class="prog__container"><p>Input matrix of the StateSpace system.</p><pre><code>lti.B</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.B.html
scipy.signal.lti.bode	A										<section class="prog__container"><p>Calculate Bode magnitude and phase data of a continuous-time system.</p><pre><code>lti.bode(w=None, n=100)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.bode.html
scipy signal lti bode	R	scipy.signal.lti.bode										
scipy signal.lti.bode	R	scipy.signal.lti.bode										
scipy signal lti B	R	scipy.signal.lti.B										
scipy signal.lti.B	R	scipy.signal.lti.B										
scipy.signal.lti.C	A										<section class="prog__container"><p>Output matrix of the StateSpace system.</p><pre><code>lti.C</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.C.html
scipy signal lti C	R	scipy.signal.lti.C										
scipy signal.lti.C	R	scipy.signal.lti.C										
scipy.signal.lti.D	A										<section class="prog__container"><p>Feedthrough matrix of the StateSpace system.</p><pre><code>lti.D</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.D.html
scipy.signal.lti.den	A										<section class="prog__container"><p>Denominator of the TransferFunction system.</p><pre><code>lti.den</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.den.html
scipy signal lti den	R	scipy.signal.lti.den										
scipy signal.lti.den	R	scipy.signal.lti.den										
scipy signal lti D	R	scipy.signal.lti.D										
scipy signal.lti.D	R	scipy.signal.lti.D										
scipy.signal.lti.dt	A										<section class="prog__container"><p>Return the sampling time of the system, None for lti systems.</p><pre><code>lti.dt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.dt.html
scipy signal lti dt	R	scipy.signal.lti.dt										
scipy signal.lti.dt	R	scipy.signal.lti.dt										
scipy.signal.lti.freqresp	A										<section class="prog__container"><p>Calculate the frequency response of a continuous-time system.</p><pre><code>lti.freqresp(w=None, n=10000)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.freqresp.html
scipy signal lti freqresp	R	scipy.signal.lti.freqresp										
scipy signal.lti.freqresp	R	scipy.signal.lti.freqresp										
scipy.signal.lti.gain	A										<section class="prog__container"><p>Gain of the ZerosPolesGain system.</p><pre><code>lti.gain</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.gain.html
scipy signal lti gain	R	scipy.signal.lti.gain										
scipy signal.lti.gain	R	scipy.signal.lti.gain										
scipy.signal.lti.impulse	A										<section class="prog__container"><p>Return the impulse response of a continuous-time system.\nSee impulse for details.</p><pre><code>lti.impulse(X0=None, T=None, N=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.impulse.html
scipy signal lti impulse	R	scipy.signal.lti.impulse										
scipy signal.lti.impulse	R	scipy.signal.lti.impulse										
scipy.signal.lti.num	A										<section class="prog__container"><p>Numerator of the TransferFunction system.</p><pre><code>lti.num</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.num.html
scipy signal lti num	R	scipy.signal.lti.num										
scipy signal.lti.num	R	scipy.signal.lti.num										
scipy.signal.lti.output	A										<section class="prog__container"><p>Return the response of a continuous-time system to input U.\nSee lsim for details.</p><pre><code>lti.output(U, T, X0=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.output.html
scipy signal lti output	R	scipy.signal.lti.output										
scipy signal.lti.output	R	scipy.signal.lti.output										
scipy.signal.lti.poles	A										<section class="prog__container"><p>Poles of the system.</p><pre><code>lti.poles</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.poles.html
scipy signal lti poles	R	scipy.signal.lti.poles										
scipy signal.lti.poles	R	scipy.signal.lti.poles										
scipy signal lti	R	scipy.signal.lti										
scipy signal.lti	R	scipy.signal.lti										
scipy.signal.lti.step	A										<section class="prog__container"><p>Return the step response of a continuous-time system.\nSee step for details.</p><pre><code>lti.step(X0=None, T=None, N=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.step.html
scipy signal lti step	R	scipy.signal.lti.step										
scipy signal.lti.step	R	scipy.signal.lti.step										
scipy.signal.lti.to_discrete	A										<section class="prog__container"><p>Return a discretized version of the current system.</p><pre><code>lti.to_discrete(dt, method='zoh', alpha=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dlti</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.to_discrete.html
scipy signal lti to_discrete	R	scipy.signal.lti.to_discrete										
scipy signal.lti.to_discrete	R	scipy.signal.lti.to_discrete										
scipy.signal.lti.zeros	A										<section class="prog__container"><p>Zeros of the system.</p><pre><code>lti.zeros</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lti.zeros.html
scipy signal lti zeros	R	scipy.signal.lti.zeros										
scipy signal.lti.zeros	R	scipy.signal.lti.zeros										
scipy.signal.max_len_seq	A										<section class="prog__container"><p>Maximum length sequence (MLS) generator.</p><pre><code>scipy.signal.max_len_seq(nbits, state=None, length=None, taps=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nbits : int\n    Number of bits to use. Length of the resulting sequence will be (2**nbits) - 1. Note that generating long sequences (e.g., greater than nbits == 16) can take a long time. \nstate : array_like, optional\n    If array, must be of length nbits, and will be cast to binary (bool) representation. If None, a seed of ones will be used, producing a repeatable representation. If state is all zeros, an error is raised as this is invalid. Default: None. \nlength : int, optional\n    Number of samples to compute. If None, the entire length (2**nbits) - 1 is computed. \ntaps : array_like, optional\n    Polynomial taps to use (e.g., [7, 6, 1] for an 8-bit sequence). If None, taps will be automatically selected (for up to nbits == 32).</code></pre><span class="prog__sub">Returns:</span><pre><code>seq : array\n    Resulting MLS sequence of 0’s and 1’s. \nstate : array\n    The final state of the shift register.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.signal import max_len_seq\n>>> max_len_seq(4)[0]\narray([1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], dtype=int8)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.max_len_seq.html
scipy signal max_len_seq	R	scipy.signal.max_len_seq										
scipy signal.max_len_seq	R	scipy.signal.max_len_seq										
scipy.signal.medfilt2d	A										<section class="prog__container"><p>Median filter a 2-dimensional array.</p><pre><code>scipy.signal.medfilt2d(input, kernel_size=3)</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : array_like\n    A 2-dimensional input array. \nkernel_size : array_like, optional\n    A scalar or a list of length 2, giving the size of the median filter window in each dimension.  Elements of kernel_size should be odd.  If kernel_size is a scalar, then this scalar is used as the size in each dimension. Default is a kernel of size (3, 3).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    An array the same size as input containing the median filtered result.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.medfilt2d.html
scipy signal medfilt2d	R	scipy.signal.medfilt2d										
scipy signal.medfilt2d	R	scipy.signal.medfilt2d										
scipy.signal.medfilt	A										<section class="prog__container"><p>Perform a median filter on an N-dimensional array.</p><pre><code>scipy.signal.medfilt(volume, kernel_size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>volume : array_like\n    An N-dimensional input array. \nkernel_size : array_like, optional\n    A scalar or an N-length list giving the size of the median filter window in each dimension.  Elements of kernel_size should be odd. If kernel_size is a scalar, then this scalar is used as the size in each dimension. Default size is 3 for each dimension.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    An array the same size as input containing the median filtered result.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.medfilt.html
scipy signal medfilt	R	scipy.signal.medfilt										
scipy signal.medfilt	R	scipy.signal.medfilt										
scipy.signal.morlet	A					[[scipy.signal.gausspulse]]					<section class="prog__container"><p>Complex Morlet wavelet.</p><pre><code>scipy.signal.morlet(M, w=5.0, s=1.0, complete=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Length of the wavelet. \nw : float, optional\n    Omega0. Default is 5 \ns : float, optional\n    Scaling factor, windowed from -s*2*pi to +s*2*pi. Default is 1. \ncomplete : bool, optional\n    Whether to use the complete or the standard version.</code></pre><span class="prog__sub">Returns:</span><pre><code>morlet : (M,) ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>pi**-0.25 * exp(1j*w*x) * exp(-0.5*(x**2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.morlet.html
scipy signal morlet	R	scipy.signal.morlet										
scipy signal.morlet	R	scipy.signal.morlet										
scipy.signal.normalize	A										<section class="prog__container"><p>Normalize polynomial representation of a transfer function.</p><pre><code>scipy.signal.normalize(b, a)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.normalize.html
scipy signal normalize	R	scipy.signal.normalize										
scipy signal.normalize	R	scipy.signal.normalize										
scipy.signal.nuttall	A										<section class="prog__container"><p>Return a minimum 4-term Blackman-Harris window according to Nuttall.</p><pre><code>scipy.signal.nuttall(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.nuttall.html
scipy signal nuttall	R	scipy.signal.nuttall										
scipy signal.nuttall	R	scipy.signal.nuttall										
scipy.signal.order_filter	A										<section class="prog__container"><p>Perform an order filter on an N-dimensional array.</p><pre><code>scipy.signal.order_filter(a, domain, rank)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    The N-dimensional input array. \ndomain : array_like\n    A mask array with the same number of dimensions as a. Each dimension should have an odd number of elements. \nrank : int\n    A non-negative integer which selects the element from the sorted list (0 corresponds to the smallest element, 1 is the next smallest element, etc.).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The results of the order filter in an array with the same shape as a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> x = np.arange(25).reshape(5, 5)\n>>> domain = np.identity(3)\n>>> x\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14],\n       [15, 16, 17, 18, 19],\n       [20, 21, 22, 23, 24]])\n>>> signal.order_filter(x, domain, 0)\narray([[  0.,   0.,   0.,   0.,   0.],\n       [  0.,   0.,   1.,   2.,   0.],\n       [  0.,   5.,   6.,   7.,   0.],\n       [  0.,  10.,  11.,  12.,   0.],\n       [  0.,   0.,   0.,   0.,   0.]])\n>>> signal.order_filter(x, domain, 2)\narray([[  6.,   7.,   8.,   9.,   4.],\n       [ 11.,  12.,  13.,  14.,   9.],\n       [ 16.,  17.,  18.,  19.,  14.],\n       [ 21.,  22.,  23.,  24.,  19.],\n       [ 20.,  21.,  22.,  23.,  24.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.order_filter.html
scipy signal order_filter	R	scipy.signal.order_filter										
scipy signal.order_filter	R	scipy.signal.order_filter										
scipy.signal.parzen	A										<section class="prog__container"><p>Return a Parzen window.</p><pre><code>scipy.signal.parzen(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.parzen.html
scipy signal parzen	R	scipy.signal.parzen										
scipy signal.parzen	R	scipy.signal.parzen										
scipy.signal.periodogram	A										<section class="prog__container"><p>Estimate power spectral density using a periodogram.</p><pre><code>scipy.signal.periodogram(x, fs=1.0, window=None, nfft=None, detrend='constant', return_onesided=True, scaling='density', axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Time series of measurement values \nfs : float, optional\n    Sampling frequency of the x time series. Defaults to 1.0. \nwindow : str or tuple or array_like, optional\n    Desired window to use. See get_window for a list of windows and required parameters. If window is an array it will be used directly as the window. Defaults to None; equivalent to ‘boxcar’. \nnfft : int, optional\n    Length of the FFT used. If None the length of x will be used. \ndetrend : str or function or False, optional\n    Specifies how to detrend x prior to computing the spectrum. If detrend is a string, it is passed as the type argument to detrend.  If it is a function, it should return a detrended array. If detrend is False, no detrending is done.  Defaults to ‘constant’. \nreturn_onesided : bool, optional\n    If True, return a one-sided spectrum for real data. If False return a two-sided spectrum. Note that for complex data, a two-sided spectrum is always returned. \nscaling : { ‘density’, ‘spectrum’ }, optional\n    Selects between computing the power spectral density (‘density’) where Pxx has units of V**2/Hz and computing the power spectrum (‘spectrum’) where Pxx has units of V**2, if x is measured in V and fs is measured in Hz.  Defaults to ‘density’ \naxis : int, optional\n    Axis along which the periodogram is computed; the default is over the last axis (i.e. axis=-1).</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of sample frequencies. \nPxx : ndarray\n    Power spectral density or power spectrum of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt\n>>> np.random.seed(1234)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.periodogram.html
scipy signal periodogram	R	scipy.signal.periodogram										
scipy signal.periodogram	R	scipy.signal.periodogram										
scipy.signal.place_poles	A										<section class="prog__container"><p>Compute K such that eigenvalues (A - dot(B, K))=poles.</p><pre><code>scipy.signal.place_poles(A, B, poles, method='YT', rtol=0.001, maxiter=30)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A, B : ndarray\n    State-space representation of linear system AX + BU. \npoles : array_like\n    Desired real poles and/or complex conjugates poles. Complex poles are only supported with method="YT" (default). \nmethod: {‘YT’, ‘KNV0’}, optional\n    Which method to choose to find the gain matrix K. One of:   ‘YT’: Yang Tits ‘KNV0’: Kautsky, Nichols, Van Dooren update method 0   See References and Notes for details on the algorithms. \nrtol: float, optional\n    After each iteration the determinant of the eigenvectors of A - B*K is compared to its previous value, when the relative error between these two values becomes lower than rtol the algorithm stops.  Default is 1e-3. \nmaxiter: int, optional\n    Maximum number of iterations to compute the gain matrix. Default is 30.</code></pre><span class="prog__sub">Returns:</span><pre><code>full_state_feedback : Bunch object\n    full_state_feedback is composed of:  gain_matrix : 1-D ndarray The closed loop matrix K such as the eigenvalues of A-BK are as close as possible to the requested poles.  computed_poles : 1-D ndarray The poles corresponding to A-BK sorted as first the real poles in increasing order, then the complex congugates in lexicographic order.  requested_poles : 1-D ndarray The poles the algorithm was asked to place sorted as above, they may differ from what was achieved.  X : 2-D ndarray The transfer matrix such as X * diag(poles) = (A - B*K)*X (see Notes)  rtol : float The relative tolerance achieved on det(X) (see Notes). rtol will be NaN if it is possible to solve the system diag(poles) = (A - B*K), or 0 when the optimization algorithms can’t do anything i.e when B.shape[1] == 1.  nb_iter : int The number of iterations performed before converging. nb_iter will be NaN if it is possible to solve the system diag(poles) = (A - B*K), or 0 when the optimization algorithms can’t do anything i.e when B.shape[1] == 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.place_poles.html
scipy signal place_poles	R	scipy.signal.place_poles										
scipy signal.place_poles	R	scipy.signal.place_poles										
scipy.signal.qmf	A										<section class="prog__container"><p>Return high-pass qmf filter from low-pass</p><pre><code>scipy.signal.qmf(hk)</code></pre><span class="prog__sub">Parameters:</span><pre><code>hk : array_like\n    Coefficients of high-pass filter.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.qmf.html
scipy signal qmf	R	scipy.signal.qmf										
scipy signal.qmf	R	scipy.signal.qmf										
scipy.signal.qspline1d	A										<section class="prog__container"><p>Compute quadratic spline coefficients for rank-1 array.</p><pre><code>scipy.signal.qspline1d(signal, lamb=0.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>signal : ndarray\n    A rank-1 array representing samples of a signal. \nlamb : float, optional\n    Smoothing coefficient (must be zero for now).</code></pre><span class="prog__sub">Returns:</span><pre><code>c : ndarray\n    Cubic spline coefficients.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.qspline1d.html
scipy.signal.qspline1d_eval	A										<section class="prog__container"><p>Evaluate a quadratic spline at the new set of points.</p><pre><code>scipy.signal.qspline1d_eval(cj, newx, dx=1.0, x0=0)</code></pre><span class="prog__sub">Examples:</span><pre><code>oldx = x0 + j*dx  j=0...N-1, with N=len(cj)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.qspline1d_eval.html
scipy signal qspline1d_eval	R	scipy.signal.qspline1d_eval										
scipy signal.qspline1d_eval	R	scipy.signal.qspline1d_eval										
scipy signal qspline1d	R	scipy.signal.qspline1d										
scipy signal.qspline1d	R	scipy.signal.qspline1d										
scipy.signal.qspline2d	A										<section class="prog__container"><p>Description:</p><pre><code>scipy.signal.qspline2d(input {, lambda, precision}) → qk</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.qspline2d.html
scipy signal qspline2d	R	scipy.signal.qspline2d										
scipy signal.qspline2d	R	scipy.signal.qspline2d										
scipy.signal.quadratic	A										<section class="prog__container"><p>A quadratic B-spline.</p><pre><code>scipy.signal.quadratic(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.quadratic.html
scipy signal quadratic	R	scipy.signal.quadratic										
scipy signal.quadratic	R	scipy.signal.quadratic										
scipy.signal.remez	A					[[scipy.signal.freqz]]\\n[[scipy.signal.firls]]\\n[[scipy.signal.firwin]]\\n[[scipy.signal.firwin2]]					<section class="prog__container"><p>Calculate the minimax optimal filter using the Remez exchange algorithm.</p><pre><code>scipy.signal.remez(numtaps, bands, desired, weight=None, Hz=1, type='bandpass', maxiter=25, grid_density=16)</code></pre><span class="prog__sub">Parameters:</span><pre><code>numtaps : int\n    The desired number of taps in the filter. The number of taps is the number of terms in the filter, or the filter order plus one. \nbands : array_like\n    A monotonic sequence containing the band edges in Hz. All elements must be non-negative and less than half the sampling frequency as given by Hz. \ndesired : array_like\n    A sequence half the size of bands containing the desired gain in each of the specified bands. \nweight : array_like, optional\n    A relative weighting to give to each band region. The length of weight has to be half the length of bands. \nHz : scalar, optional\n    The sampling frequency in Hz. Default is 1. \ntype : {‘bandpass’, ‘differentiator’, ‘hilbert’}, optional\n    The type of filter:   ‘bandpass’ : flat response in bands. This is the default.  ‘differentiator’ : frequency proportional response in bands.   ‘hilbert’ : filter with odd symmetry, that is, type III (for even order) or type IV (for odd order) linear phase filters.      \nmaxiter : int, optional\n    Maximum number of iterations of the algorithm. Default is 25. \ngrid_density : int, optional\n    Grid density. The dense grid used in remez is of size (numtaps + 1) * grid_density. Default is 16.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    A rank-1 array containing the coefficients of the optimal (in a minimax sense) filter.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> bpass = signal.remez(72, [0, 0.1, 0.2, 0.4, 0.45, 0.5], [0, 1, 0])\n>>> freq, response = signal.freqz(bpass)\n>>> ampl = np.abs(response)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.remez.html
scipy signal remez	R	scipy.signal.remez										
scipy signal.remez	R	scipy.signal.remez										
scipy.signal.resample	A										<section class="prog__container"><p>Resample x to num samples using Fourier method along the given axis.</p><pre><code>scipy.signal.resample(x, num, t=None, axis=0, window=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The data to be resampled. \nnum : int\n    The number of samples in the resampled signal. \nt : array_like, optional\n    If t is given, it is assumed to be the sample positions associated with the signal data in x. \naxis : int, optional\n    The axis of x that is resampled.  Default is 0. \nwindow : array_like, callable, string, float, or tuple, optional\n    Specifies the window applied to the signal in the Fourier domain.  See below for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>resampled_x or (resampled_x, resampled_t)\n    Either the resampled array, or, if t was given, a tuple containing the resampled array and the corresponding resampled positions.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.resample.html
scipy.signal.resample_poly	A										<section class="prog__container"><p>Resample x along the given axis using polyphase filtering.</p><pre><code>scipy.signal.resample_poly(x, up, down, axis=0, window=('kaiser', 5.0))</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The data to be resampled. \nup : int\n    The upsampling factor. \ndown : int\n    The downsampling factor. \naxis : int, optional\n    The axis of x that is resampled. Default is 0. \nwindow : string, tuple, or array_like, optional\n    Desired window to use to design the low-pass filter, or the FIR filter coefficients to employ. See below for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>resampled_x : array\n    The resampled array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.resample_poly.html
scipy signal resample_poly	R	scipy.signal.resample_poly										
scipy signal.resample_poly	R	scipy.signal.resample_poly										
scipy signal resample	R	scipy.signal.resample										
scipy signal.resample	R	scipy.signal.resample										
scipy.signal.residue	A					[[scipy.signal.invres]]\\n[[scipy.signal.residuez]]\\n[[(in NumPy v1.11)]]\\n[[scipy.signal.unique_roots]]					<section class="prog__container"><p>Compute partial-fraction expansion of b(s) / a(s).</p><pre><code>scipy.signal.residue(b, a, tol=0.001, rtype='avg')</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : array_like\n    Numerator polynomial coefficients. \na : array_like\n    Denominator polynomial coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    Residues. \np : ndarray\n    Poles. \nk : ndarray\n    Coefficients of the direct polynomial term.</code></pre><span class="prog__sub">Examples:</span><pre><code>b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]\nH(s) = ------ = ------------------------------------------\n        a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.residue.html
scipy signal residue	R	scipy.signal.residue										
scipy signal.residue	R	scipy.signal.residue										
scipy.signal.residuez	A					[[scipy.signal.invresz]]\\n[[scipy.signal.residue]]\\n[[scipy.signal.unique_roots]]					<section class="prog__container"><p>Compute partial-fraction expansion of b(z) / a(z).</p><pre><code>scipy.signal.residuez(b, a, tol=0.001, rtype='avg')</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : array_like\n    Numerator polynomial coefficients. \na : array_like\n    Denominator polynomial coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>r : ndarray\n    Residues. \np : ndarray\n    Poles. \nk : ndarray\n    Coefficients of the direct polynomial term.</code></pre><span class="prog__sub">Examples:</span><pre><code>b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)\nH(z) = ------ = ------------------------------------------\n        a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.residuez.html
scipy signal residuez	R	scipy.signal.residuez										
scipy signal.residuez	R	scipy.signal.residuez										
scipy.signal.ricker	A										<section class="prog__container"><p>Return a Ricker wavelet, also known as the “Mexican hat wavelet”.</p><pre><code>scipy.signal.ricker(points, a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : int\n    Number of points in vector. Will be centered around 0. \na : scalar\n    Width parameter of the wavelet.</code></pre><span class="prog__sub">Returns:</span><pre><code>vector : (N,) ndarray\n    Array of length points in shape of ricker curve.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ricker.html
scipy signal ricker	R	scipy.signal.ricker										
scipy signal.ricker	R	scipy.signal.ricker										
scipy.signal.savgol_coeffs	A					[[scipy.signal.savgol_filter]]					<section class="prog__container"><p>Compute the coefficients for a 1-d Savitzky-Golay FIR filter.</p><pre><code>scipy.signal.savgol_coeffs(window_length, polyorder, deriv=0, delta=1.0, pos=None, use='conv')</code></pre><span class="prog__sub">Parameters:</span><pre><code>window_length : int\n    The length of the filter window (i.e. the number of coefficients). window_length must be an odd positive integer. \npolyorder : int\n    The order of the polynomial used to fit the samples. polyorder must be less than window_length. \nderiv : int, optional\n    The order of the derivative to compute.  This must be a nonnegative integer.  The default is 0, which means to filter the data without differentiating. \ndelta : float, optional\n    The spacing of the samples to which the filter will be applied. This is only used if deriv > 0. \npos : int or None, optional\n    If pos is not None, it specifies evaluation position within the window.  The default is the middle of the window. \nuse : str, optional\n    Either ‘conv’ or ‘dot’.  This argument chooses the order of the coefficients.  The default is ‘conv’, which means that the coefficients are ordered to be used in a convolution.  With use=’dot’, the order is reversed, so the filter is applied by dotting the coefficients with the data set.</code></pre><span class="prog__sub">Returns:</span><pre><code>coeffs : 1-d ndarray\n    The filter coefficients.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.signal import savgol_coeffs\n>>> savgol_coeffs(5, 2)\narray([-0.08571429,  0.34285714,  0.48571429,  0.34285714, -0.08571429])\n>>> savgol_coeffs(5, 2, deriv=1)\narray([  2.00000000e-01,   1.00000000e-01,   2.00607895e-16,\n        -1.00000000e-01,  -2.00000000e-01])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.savgol_coeffs.html
scipy signal savgol_coeffs	R	scipy.signal.savgol_coeffs										
scipy signal.savgol_coeffs	R	scipy.signal.savgol_coeffs										
scipy.signal.savgol_filter	A					[[scipy.signal.savgol_coeffs]]					<section class="prog__container"><p>Apply a Savitzky-Golay filter to an array.</p><pre><code>scipy.signal.savgol_filter(x, window_length, polyorder, deriv=0, delta=1.0, axis=-1, mode='interp', cval=0.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The data to be filtered.  If x is not a single or double precision floating point array, it will be converted to type numpy.float64 before filtering. \nwindow_length : int\n    The length of the filter window (i.e. the number of coefficients). window_length must be a positive odd integer. \npolyorder : int\n    The order of the polynomial used to fit the samples. polyorder must be less than window_length. \nderiv : int, optional\n    The order of the derivative to compute.  This must be a nonnegative integer.  The default is 0, which means to filter the data without differentiating. \ndelta : float, optional\n    The spacing of the samples to which the filter will be applied. This is only used if deriv > 0.  Default is 1.0. \naxis : int, optional\n    The axis of the array x along which the filter is to be applied. Default is -1. \nmode : str, optional\n    Must be ‘mirror’, ‘constant’, ‘nearest’, ‘wrap’ or ‘interp’.  This determines the type of extension to use for the padded signal to which the filter is applied.  When mode is ‘constant’, the padding value is given by cval.  See the Notes for more details on ‘mirror’, ‘constant’, ‘wrap’, and ‘nearest’. When the ‘interp’ mode is selected (the default), no extension is used.  Instead, a degree polyorder polynomial is fit to the last window_length values of the edges, and this polynomial is used to evaluate the last window_length // 2 output values. \ncval : scalar, optional\n    Value to fill past the edges of the input if mode is ‘constant’. Default is 0.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray, same shape as x\n    The filtered data.</code></pre><span class="prog__sub">Examples:</span><pre><code>mode       |   Ext   |         Input          |   Ext\n-----------+---------+------------------------+---------\n'mirror'   | 4  3  2 | 1  2  3  4  5  6  7  8 | 7  6  5\n'nearest'  | 1  1  1 | 1  2  3  4  5  6  7  8 | 8  8  8\n'constant' | 0  0  0 | 1  2  3  4  5  6  7  8 | 0  0  0\n'wrap'     | 6  7  8 | 1  2  3  4  5  6  7  8 | 1  2  3</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.savgol_filter.html
scipy signal savgol_filter	R	scipy.signal.savgol_filter										
scipy signal.savgol_filter	R	scipy.signal.savgol_filter										
scipy.signal.sawtooth	A										<section class="prog__container"><p>Return a periodic sawtooth or triangle waveform.</p><pre><code>scipy.signal.sawtooth(t, width=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>t : array_like\n    Time. \nwidth : array_like, optional\n    Width of the rising ramp as a proportion of the total cycle. Default is 1, producing a rising ramp, while 0 produces a falling ramp.  width = 0.5 produces a triangle wave. If an array, causes wave shape to change over time, and must be the same length as t.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Output array containing the sawtooth waveform.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt\n>>> t = np.linspace(0, 1, 500)\n>>> plt.plot(t, signal.sawtooth(2 * np.pi * 5 * t))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sawtooth.html
scipy signal sawtooth	R	scipy.signal.sawtooth										
scipy signal.sawtooth	R	scipy.signal.sawtooth										
scipy.signal.sepfir2d	A										<section class="prog__container"><p>Description:</p><pre><code>scipy.signal.sepfir2d(input, hrow, hcol) → output</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sepfir2d.html
scipy signal sepfir2d	R	scipy.signal.sepfir2d										
scipy signal.sepfir2d	R	scipy.signal.sepfir2d										
scipy.signal.slepian	A										<section class="prog__container"><p>Return a digital Slepian (DPSS) window.</p><pre><code>scipy.signal.slepian(M, width, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nwidth : float\n    Bandwidth \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value always normalized to 1</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.slepian.html
scipy signal slepian	R	scipy.signal.slepian										
scipy signal.slepian	R	scipy.signal.slepian										
scipy.signal.sos2tf	A										<section class="prog__container"><p>Return a single transfer function from a series of second-order sections</p><pre><code>scipy.signal.sos2tf(sos)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sos : array_like\n    Array of second-order filter coefficients, must have shape (n_sections, 6). See sosfilt for the SOS filter format specification.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    Numerator polynomial coefficients. \na : ndarray\n    Denominator polynomial coefficients.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sos2tf.html
scipy signal sos2tf	R	scipy.signal.sos2tf										
scipy signal.sos2tf	R	scipy.signal.sos2tf										
scipy.signal.sos2zpk	A										<section class="prog__container"><p>Return zeros, poles, and gain of a series of second-order sections</p><pre><code>scipy.signal.sos2zpk(sos)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sos : array_like\n    Array of second-order filter coefficients, must have shape (n_sections, 6). See sosfilt for the SOS filter format specification.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : ndarray\n    Zeros of the transfer function. \np : ndarray\n    Poles of the transfer function. \nk : float\n    System gain.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sos2zpk.html
scipy signal sos2zpk	R	scipy.signal.sos2zpk										
scipy signal.sos2zpk	R	scipy.signal.sos2zpk										
scipy.signal.sosfilt	A					[[scipy.signal.zpk2sos]]\\n[[scipy.signal.sos2zpk]]\\n[[scipy.signal.sosfilt_zi]]\\n[[scipy.signal.sosfiltfilt]]					<section class="prog__container"><p>Filter data along one dimension using cascaded second-order sections</p><pre><code>scipy.signal.sosfilt(sos, x, axis=-1, zi=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sos : array_like\n    Array of second-order filter coefficients, must have shape (n_sections, 6). Each row corresponds to a second-order section, with the first three columns providing the numerator coefficients and the last three providing the denominator coefficients. \nx : array_like\n    An N-dimensional input array. \naxis : int, optional\n    The axis of the input data array along which to apply the linear filter. The filter is applied to each subarray along this axis.  Default is -1. \nzi : array_like, optional\n    Initial conditions for the cascaded filter delays.  It is a (at least 2D) vector of shape (n_sections, ..., 2, ...), where ..., 2, ... denotes the shape of x, but with x.shape[axis] replaced by 2.  If zi is None or is not given then initial rest (i.e. all zeros) is assumed. Note that these initial conditions are not the same as the initial conditions given by lfiltic or lfilter_zi.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The output of the digital filter. \nzf : ndarray, optional\n    If zi is None, this is not returned, otherwise, zf holds the final filter delay values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy import signal\n>>> b, a = signal.ellip(13, 0.009, 80, 0.05, output='ba')\n>>> sos = signal.ellip(13, 0.009, 80, 0.05, output='sos')\n>>> x = np.zeros(700)\n>>> x[0] = 1.\n>>> y_tf = signal.lfilter(b, a, x)\n>>> y_sos = signal.sosfilt(sos, x)\n>>> plt.plot(y_tf, 'r', label='TF')\n>>> plt.plot(y_sos, 'k', label='SOS')\n>>> plt.legend(loc='best')\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfilt.html
scipy.signal.sosfiltfilt	A					[[scipy.signal.filtfilt]]\\n[[scipy.signal.sosfilt]]\\n[[scipy.signal.sosfilt_zi]]					<section class="prog__container"><p>A forward-backward filter using cascaded second-order sections.</p><pre><code>scipy.signal.sosfiltfilt(sos, x, axis=-1, padtype='odd', padlen=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sos : array_like\n    Array of second-order filter coefficients, must have shape (n_sections, 6). Each row corresponds to a second-order section, with the first three columns providing the numerator coefficients and the last three providing the denominator coefficients. \nx : array_like\n    The array of data to be filtered. \naxis : int, optional\n    The axis of x to which the filter is applied. Default is -1. \npadtype : str or None, optional\n    Must be ‘odd’, ‘even’, ‘constant’, or None.  This determines the type of extension to use for the padded signal to which the filter is applied.  If padtype is None, no padding is used.  The default is ‘odd’. \npadlen : int or None, optional\n    The number of elements by which to extend x at both ends of axis before applying the filter.  This value must be less than x.shape[axis] - 1.  padlen=0 implies no padding. The default value is: 3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),                             (sos[:, 5] == 0).sum()))   The extra subtraction at the end attempts to compensate for poles and zeros at the origin (e.g. for odd-order filters) to yield equivalent estimates of padlen to those of filtfilt for second-order section filters built with scipy.signal functions.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The filtered output with the same shape as x.</code></pre><span class="prog__sub">Examples:</span><pre><code>3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),\n                            (sos[:, 5] == 0).sum()))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfiltfilt.html
scipy signal sosfiltfilt	R	scipy.signal.sosfiltfilt										
scipy signal.sosfiltfilt	R	scipy.signal.sosfiltfilt										
scipy signal sosfilt	R	scipy.signal.sosfilt										
scipy signal.sosfilt	R	scipy.signal.sosfilt										
scipy.signal.sosfilt_zi	A					[[scipy.signal.sosfilt]]\\n[[scipy.signal.zpk2sos]]					<section class="prog__container"><p>Compute an initial state zi for the sosfilt function that corresponds\nto the steady state of the step response.</p><pre><code>scipy.signal.sosfilt_zi(sos)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sos : array_like\n    Array of second-order filter coefficients, must have shape (n_sections, 6). See sosfilt for the SOS filter format specification.</code></pre><span class="prog__sub">Returns:</span><pre><code>zi : ndarray\n    Initial conditions suitable for use with sosfilt, shape (n_sections, 2).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sosfilt_zi.html
scipy signal sosfilt_zi	R	scipy.signal.sosfilt_zi										
scipy signal.sosfilt_zi	R	scipy.signal.sosfilt_zi										
scipy.signal.spectrogram	A										<section class="prog__container"><p>Compute a spectrogram with consecutive Fourier transforms.</p><pre><code>scipy.signal.spectrogram(x, fs=1.0, window=('tukey', 0.25), nperseg=256, noverlap=None, nfft=None, detrend='constant', return_onesided=True, scaling='density', axis=-1, mode='psd')</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Time series of measurement values \nfs : float, optional\n    Sampling frequency of the x time series. Defaults to 1.0. \nwindow : str or tuple or array_like, optional\n    Desired window to use. See get_window for a list of windows and required parameters. If window is array_like it will be used directly as the window and its length will be used for nperseg. Defaults to a Tukey window with shape parameter of 0.25. \nnperseg : int, optional\n    Length of each segment.  Defaults to 256. \nnoverlap : int, optional\n    Number of points to overlap between segments. If None, noverlap = nperseg // 8.  Defaults to None. \nnfft : int, optional\n    Length of the FFT used, if a zero padded FFT is desired.  If None, the FFT length is nperseg. Defaults to None. \ndetrend : str or function or False, optional\n    Specifies how to detrend each segment. If detrend is a string, it is passed as the type argument to detrend.  If it is a function, it takes a segment and returns a detrended segment. If detrend is False, no detrending is done.  Defaults to ‘constant’. \nreturn_onesided : bool, optional\n    If True, return a one-sided spectrum for real data. If False return a two-sided spectrum. Note that for complex data, a two-sided spectrum is always returned. \nscaling : { ‘density’, ‘spectrum’ }, optional\n    Selects between computing the power spectral density (‘density’) where Pxx has units of V**2/Hz and computing the power spectrum (‘spectrum’) where Pxx has units of V**2, if x is measured in V and fs is measured in Hz.  Defaults to ‘density’ \naxis : int, optional\n    Axis along which the spectrogram is computed; the default is over the last axis (i.e. axis=-1). \nmode : str, optional\n    Defines what kind of return values are expected. Options are [‘psd’, ‘complex’, ‘magnitude’, ‘angle’, ‘phase’].</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of sample frequencies. \nt : ndarray\n    Array of segment times. \nSxx : ndarray\n    Spectrogram of x. By default, the last axis of Sxx corresponds to the segment times.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.spectrogram.html
scipy signal spectrogram	R	scipy.signal.spectrogram										
scipy signal.spectrogram	R	scipy.signal.spectrogram										
scipy.signal.spline_filter	A										<section class="prog__container"><p>Smoothing spline (cubic) filtering of a rank-2 array.</p><pre><code>scipy.signal.spline_filter(Iin, lmbda=5.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.spline_filter.html
scipy signal spline_filter	R	scipy.signal.spline_filter										
scipy signal.spline_filter	R	scipy.signal.spline_filter										
scipy.signal.square	A										<section class="prog__container"><p>Return a periodic square-wave waveform.</p><pre><code>scipy.signal.square(t, duty=0.5)</code></pre><span class="prog__sub">Parameters:</span><pre><code>t : array_like\n    The input time array. \nduty : array_like, optional\n    Duty cycle.  Default is 0.5 (50% duty cycle). If an array, causes wave shape to change over time, and must be the same length as t.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Output array containing the square waveform.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt\n>>> t = np.linspace(0, 1, 500, endpoint=False)\n>>> plt.plot(t, signal.square(2 * np.pi * 5 * t))\n>>> plt.ylim(-2, 2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.square.html
scipy signal square	R	scipy.signal.square										
scipy signal.square	R	scipy.signal.square										
scipy.signal.ss2tf	A										<section class="prog__container"><p>State-space to transfer function.</p><pre><code>scipy.signal.ss2tf(A, B, C, D, input=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : array_like\n    State (or system) matrix of shape (n, n) \nB : array_like\n    Input matrix of shape (n, p) \nC : array_like\n    Output matrix of shape (q, n) \nD : array_like\n    Feedthrough (or feedforward) matrix of shape (q, p) \ninput : int, optional\n    For multiple-input systems, the index of the input to use.</code></pre><span class="prog__sub">Returns:</span><pre><code>num : 2-D ndarray\n    Numerator(s) of the resulting transfer function(s).  num has one row for each of the system’s outputs. Each row is a sequence representation of the numerator polynomial. \nden : 1-D ndarray\n    Denominator of the resulting transfer function(s).  den is a sequence representation of the denominator polynomial.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> A = [[-2, -1], [1, 0]]\n>>> B = [[1], [0]]  # 2-dimensional column vector\n>>> C = [[1, 2]]    # 2-dimensional row vector\n>>> D = 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ss2tf.html
scipy signal ss2tf	R	scipy.signal.ss2tf										
scipy signal.ss2tf	R	scipy.signal.ss2tf										
scipy.signal.ss2zpk	A										<section class="prog__container"><p>State-space representation to zero-pole-gain representation.</p><pre><code>scipy.signal.ss2zpk(A, B, C, D, input=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : array_like\n    State (or system) matrix of shape (n, n) \nB : array_like\n    Input matrix of shape (n, p) \nC : array_like\n    Output matrix of shape (q, n) \nD : array_like\n    Feedthrough (or feedforward) matrix of shape (q, p) \ninput : int, optional\n    For multiple-input systems, the index of the input to use.</code></pre><span class="prog__sub">Returns:</span><pre><code>z, p : sequence\n    Zeros and poles. \nk : float\n    System gain.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ss2zpk.html
scipy signal ss2zpk	R	scipy.signal.ss2zpk										
scipy signal.ss2zpk	R	scipy.signal.ss2zpk										
scipy.signal.StateSpace.A	A										<section class="prog__container"><p>State matrix of the StateSpace system.</p><pre><code>StateSpace.A</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.A.html
scipy signal StateSpace A	R	scipy.signal.StateSpace.A										
scipy signal.StateSpace.A	R	scipy.signal.StateSpace.A										
scipy.signal.StateSpace	A					[[scipy.signal.TransferFunction]]\\n[[scipy.signal.ZerosPolesGain]]\\n[[scipy.signal.lti]]\\n[[scipy.signal.dlti]]\\n[[scipy.signal.ss2zpk]]\\n[[scipy.signal.ss2tf]]\\n[[scipy.signal.zpk2sos]]					<section class="prog__container"><p>Linear Time Invariant system in state-space form.</p><pre><code>class scipy.signal.StateSpace(*system, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*system: arguments\n    The StateSpace class can be instantiated with 1 or 3 arguments. The following gives the number of input arguments and their interpretation:   1: lti or dlti system: (StateSpace, TransferFunction or ZerosPolesGain) 4: array_like: (A, B, C, D)   \ndt: float, optional\n    Sampling time [s] of the discrete-time systems. Defaults to None (continuous-time). Must be specified as a keyword argument, for example, dt=0.1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.html
scipy.signal.StateSpace.B	A										<section class="prog__container"><p>Input matrix of the StateSpace system.</p><pre><code>StateSpace.B</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.B.html
scipy signal StateSpace B	R	scipy.signal.StateSpace.B										
scipy signal.StateSpace.B	R	scipy.signal.StateSpace.B										
scipy.signal.StateSpace.C	A										<section class="prog__container"><p>Output matrix of the StateSpace system.</p><pre><code>StateSpace.C</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.C.html
scipy signal StateSpace C	R	scipy.signal.StateSpace.C										
scipy signal.StateSpace.C	R	scipy.signal.StateSpace.C										
scipy.signal.StateSpace.D	A										<section class="prog__container"><p>Feedthrough matrix of the StateSpace system.</p><pre><code>StateSpace.D</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.D.html
scipy.signal.StateSpace.den	A										<section class="prog__container"><p>Denominator of the TransferFunction system.</p><pre><code>StateSpace.den</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.den.html
scipy signal StateSpace den	R	scipy.signal.StateSpace.den										
scipy signal.StateSpace.den	R	scipy.signal.StateSpace.den										
scipy signal StateSpace D	R	scipy.signal.StateSpace.D										
scipy signal.StateSpace.D	R	scipy.signal.StateSpace.D										
scipy.signal.StateSpace.dt	A										<section class="prog__container"><p>Return the sampling time of the system, None for lti systems.</p><pre><code>StateSpace.dt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.dt.html
scipy signal StateSpace dt	R	scipy.signal.StateSpace.dt										
scipy signal.StateSpace.dt	R	scipy.signal.StateSpace.dt										
scipy.signal.StateSpace.gain	A										<section class="prog__container"><p>Gain of the ZerosPolesGain system.</p><pre><code>StateSpace.gain</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.gain.html
scipy signal StateSpace gain	R	scipy.signal.StateSpace.gain										
scipy signal.StateSpace.gain	R	scipy.signal.StateSpace.gain										
scipy.signal.StateSpace.num	A										<section class="prog__container"><p>Numerator of the TransferFunction system.</p><pre><code>StateSpace.num</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.num.html
scipy signal StateSpace num	R	scipy.signal.StateSpace.num										
scipy signal.StateSpace.num	R	scipy.signal.StateSpace.num										
scipy.signal.StateSpace.poles	A										<section class="prog__container"><p>Poles of the system.</p><pre><code>StateSpace.poles</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.poles.html
scipy signal StateSpace poles	R	scipy.signal.StateSpace.poles										
scipy signal.StateSpace.poles	R	scipy.signal.StateSpace.poles										
scipy signal StateSpace	R	scipy.signal.StateSpace										
scipy signal.StateSpace	R	scipy.signal.StateSpace										
scipy.signal.StateSpace.to_ss	A										<section class="prog__container"><p>Return a copy of the current StateSpace system.</p><pre><code>StateSpace.to_ss()</code></pre><span class="prog__sub">Parameters:</span><pre><code>sys : instance of StateSpace\n    The current system (copy)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.to_ss.html
scipy signal StateSpace to_ss	R	scipy.signal.StateSpace.to_ss										
scipy signal.StateSpace.to_ss	R	scipy.signal.StateSpace.to_ss										
scipy.signal.StateSpace.to_tf	A										<section class="prog__container"><p>Convert system representation to TransferFunction.</p><pre><code>StateSpace.to_tf(**kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kwargs : dict, optional\n    Additional keywords passed to ss2zpk</code></pre><span class="prog__sub">Returns:</span><pre><code>sys : instance of TransferFunction\n    Transfer function of the current system</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.to_tf.html
scipy signal StateSpace to_tf	R	scipy.signal.StateSpace.to_tf										
scipy signal.StateSpace.to_tf	R	scipy.signal.StateSpace.to_tf										
scipy.signal.StateSpace.to_zpk	A										<section class="prog__container"><p>Convert system representation to ZerosPolesGain.</p><pre><code>StateSpace.to_zpk(**kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>kwargs : dict, optional\n    Additional keywords passed to ss2zpk</code></pre><span class="prog__sub">Returns:</span><pre><code>sys : instance of ZerosPolesGain\n    Zeros, poles, gain representation of the current system</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.to_zpk.html
scipy signal StateSpace to_zpk	R	scipy.signal.StateSpace.to_zpk										
scipy signal.StateSpace.to_zpk	R	scipy.signal.StateSpace.to_zpk										
scipy.signal.StateSpace.zeros	A										<section class="prog__container"><p>Zeros of the system.</p><pre><code>StateSpace.zeros</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.StateSpace.zeros.html
scipy signal StateSpace zeros	R	scipy.signal.StateSpace.zeros										
scipy signal.StateSpace.zeros	R	scipy.signal.StateSpace.zeros										
scipy.signal.step2	A					[[scipy.signal.step]]					<section class="prog__container"><p>Step response of continuous-time system.</p><pre><code>scipy.signal.step2(system, X0=None, T=None, N=None, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the LTI class or a tuple of array_like\n    describing the system. The following gives the number of elements in the tuple and the interpretation:   1 (instance of lti) 2 (num, den) 3 (zeros, poles, gain) 4 (A, B, C, D)   \nX0 : array_like, optional\n    Initial state-vector (default is zero). \nT : array_like, optional\n    Time points (computed if not given). \nN : int, optional\n    Number of time points to compute if T is not given. \nkwargs : various types\n    Additional keyword arguments are passed on the function scipy.signal.lsim2, which in turn passes them on to scipy.integrate.odeint.  See the documentation for scipy.integrate.odeint for information about these arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>T : 1D ndarray\n    Output time points. \nyout : 1D ndarray\n    Step response of system.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.step2.html
scipy signal step2	R	scipy.signal.step2										
scipy signal.step2	R	scipy.signal.step2										
scipy.signal.step	A					[[scipy.signal.step2]]					<section class="prog__container"><p>Step response of continuous-time system.</p><pre><code>scipy.signal.step(system, X0=None, T=None, N=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>system : an instance of the LTI class or a tuple of array_like\n    describing the system. The following gives the number of elements in the tuple and the interpretation:   1 (instance of lti) 2 (num, den) 3 (zeros, poles, gain) 4 (A, B, C, D)   \nX0 : array_like, optional\n    Initial state-vector (default is zero). \nT : array_like, optional\n    Time points (computed if not given). \nN : int, optional\n    Number of time points to compute if T is not given.</code></pre><span class="prog__sub">Returns:</span><pre><code>T : 1D ndarray\n    Output time points. \nyout : 1D ndarray\n    Step response of system.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.step.html
scipy signal step	R	scipy.signal.step										
scipy signal.step	R	scipy.signal.step										
scipy.signal.sweep_poly	A					[[scipy.signal.chirp]]					<section class="prog__container"><p>Frequency-swept cosine generator, with a time-dependent frequency.</p><pre><code>scipy.signal.sweep_poly(t, poly, phi=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>t : ndarray\n    Times at which to evaluate the waveform. \npoly : 1-D array_like or instance of numpy.poly1d\n    The desired frequency expressed as a polynomial.  If poly is a list or ndarray of length n, then the elements of poly are the coefficients of the polynomial, and the instantaneous frequency is  f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]  If poly is an instance of numpy.poly1d, then the instantaneous frequency is  f(t) = poly(t)  \nphi : float, optional\n    Phase offset, in degrees, Default: 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>sweep_poly : ndarray\n    A numpy array containing the signal evaluated at t with the requested time-varying frequency.  More precisely, the function returns cos(phase + (pi/180)*phi), where phase is the integral (from 0 to t) of 2 * pi * f(t); f(t) is defined above.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.sweep_poly.html
scipy signal sweep_poly	R	scipy.signal.sweep_poly										
scipy signal.sweep_poly	R	scipy.signal.sweep_poly										
scipy.signal.symiirorder1	A										<section class="prog__container"><p>Implement a smoothing IIR filter with mirror-symmetric boundary conditions\nusing a cascade of first-order sections.  The second section uses a\nreversed sequence.  This implements a system with the following\ntransfer function and mirror-symmetric boundary conditions:</p><pre><code>scipy.signal.symiirorder1(input, c0, z1 {, precision}) → output</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    The input signal. \nc0, z1 : scalar\n    Parameters in the transfer function. \nprecision :\n    Specifies the precision for calculating initial conditions of the recursive filter based on mirror-symmetric input.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    The filtered signal.</code></pre><span class="prog__sub">Examples:</span><pre><code>c0              \nH(z) = ---------------------    \n        (1-z1/z) (1 - z1 z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.symiirorder1.html
scipy signal symiirorder1	R	scipy.signal.symiirorder1										
scipy signal.symiirorder1	R	scipy.signal.symiirorder1										
scipy.signal.symiirorder2	A										<section class="prog__container"><p>Implement a smoothing IIR filter with mirror-symmetric boundary conditions\nusing a cascade of second-order sections.  The second section uses a\nreversed sequence.  This implements the following transfer function:</p><pre><code>scipy.signal.symiirorder2(input, r, omega {, precision}) → output</code></pre><span class="prog__sub">Parameters:</span><pre><code>input : ndarray\n    The input signal. \nr, omega : scalar\n    Parameters in the transfer function. \nprecision :\n    Specifies the precision for calculating initial conditions of the recursive filter based on mirror-symmetric input.</code></pre><span class="prog__sub">Returns:</span><pre><code>output : ndarray\n    The filtered signal.</code></pre><span class="prog__sub">Examples:</span><pre><code>cs^2\nH(z) = ---------------------------------------\n       (1 - a2/z - a3/z^2) (1 - a2 z - a3 z^2 )</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.symiirorder2.html
scipy signal symiirorder2	R	scipy.signal.symiirorder2										
scipy signal.symiirorder2	R	scipy.signal.symiirorder2										
scipy.signal.tf2sos	A					[[scipy.signal.zpk2sos]]\\n[[scipy.signal.sosfilt]]					<section class="prog__container"><p>Return second-order sections from transfer function representation</p><pre><code>scipy.signal.tf2sos(b, a, pairing='nearest')</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : array_like\n    Numerator polynomial coefficients. \na : array_like\n    Denominator polynomial coefficients. \npairing : {‘nearest’, ‘keep_odd’}, optional\n    The method to use to combine pairs of poles and zeros into sections. See zpk2sos.</code></pre><span class="prog__sub">Returns:</span><pre><code>sos : ndarray\n    Array of second-order filter coefficients, with shape (n_sections, 6). See sosfilt for the SOS filter format specification.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.tf2sos.html
scipy signal tf2sos	R	scipy.signal.tf2sos										
scipy signal.tf2sos	R	scipy.signal.tf2sos										
scipy.signal.tf2ss	A										<section class="prog__container"><p>Transfer function to state-space representation.</p><pre><code>scipy.signal.tf2ss(num, den)</code></pre><span class="prog__sub">Parameters:</span><pre><code>num, den : array_like\n    Sequences representing the coefficients of the numerator and denominator polynomials, in order of descending degree. The denominator needs to be at least as long as the numerator.</code></pre><span class="prog__sub">Returns:</span><pre><code>A, B, C, D : ndarray\n    State space representation of the system, in controller canonical form.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> num = [1, 3, 3]\n>>> den = [1, 2, 1]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.tf2ss.html
scipy signal tf2ss	R	scipy.signal.tf2ss										
scipy signal.tf2ss	R	scipy.signal.tf2ss										
scipy.signal.tf2zpk	A										<section class="prog__container"><p>Return zero, pole, gain (z, p, k) representation from a numerator,\ndenominator representation of a linear filter.</p><pre><code>scipy.signal.tf2zpk(b, a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>b : array_like\n    Numerator polynomial coefficients. \na : array_like\n    Denominator polynomial coefficients.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : ndarray\n    Zeros of the transfer function. \np : ndarray\n    Poles of the transfer function. \nk : float\n    System gain.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.tf2zpk.html
scipy signal tf2zpk	R	scipy.signal.tf2zpk										
scipy signal.tf2zpk	R	scipy.signal.tf2zpk										
scipy.signal.TransferFunction.A	A										<section class="prog__container"><p>State matrix of the StateSpace system.</p><pre><code>TransferFunction.A</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.A.html
scipy signal TransferFunction A	R	scipy.signal.TransferFunction.A										
scipy signal.TransferFunction.A	R	scipy.signal.TransferFunction.A										
scipy.signal.TransferFunction	A					[[scipy.signal.ZerosPolesGain]]\\n[[scipy.signal.StateSpace]]\\n[[scipy.signal.lti]]\\n[[scipy.signal.dlti]]\\n[[scipy.signal.tf2ss]]\\n[[scipy.signal.tf2zpk]]\\n[[scipy.signal.tf2sos]]					<section class="prog__container"><p>Linear Time Invariant system class in transfer function form.</p><pre><code>class scipy.signal.TransferFunction(*system, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*system: arguments\n    The TransferFunction class can be instantiated with 1 or 2 arguments. The following gives the number of input arguments and their interpretation:   1: lti or dlti system: (StateSpace, TransferFunction or ZerosPolesGain) 2: array_like: (numerator, denominator)   \ndt: float, optional\n    Sampling time [s] of the discrete-time systems. Defaults to None (continuous-time). Must be specified as a keyword argument, for example, dt=0.1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.html
scipy.signal.TransferFunction.B	A										<section class="prog__container"><p>Input matrix of the StateSpace system.</p><pre><code>TransferFunction.B</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.B.html
scipy signal TransferFunction B	R	scipy.signal.TransferFunction.B										
scipy signal.TransferFunction.B	R	scipy.signal.TransferFunction.B										
scipy.signal.TransferFunction.C	A										<section class="prog__container"><p>Output matrix of the StateSpace system.</p><pre><code>TransferFunction.C</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.C.html
scipy signal TransferFunction C	R	scipy.signal.TransferFunction.C										
scipy signal.TransferFunction.C	R	scipy.signal.TransferFunction.C										
scipy.signal.TransferFunction.D	A										<section class="prog__container"><p>Feedthrough matrix of the StateSpace system.</p><pre><code>TransferFunction.D</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.D.html
scipy.signal.TransferFunction.den	A										<section class="prog__container"><p>Denominator of the TransferFunction system.</p><pre><code>TransferFunction.den</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.den.html
scipy signal TransferFunction den	R	scipy.signal.TransferFunction.den										
scipy signal.TransferFunction.den	R	scipy.signal.TransferFunction.den										
scipy signal TransferFunction D	R	scipy.signal.TransferFunction.D										
scipy signal.TransferFunction.D	R	scipy.signal.TransferFunction.D										
scipy.signal.TransferFunction.dt	A										<section class="prog__container"><p>Return the sampling time of the system, None for lti systems.</p><pre><code>TransferFunction.dt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.dt.html
scipy signal TransferFunction dt	R	scipy.signal.TransferFunction.dt										
scipy signal.TransferFunction.dt	R	scipy.signal.TransferFunction.dt										
scipy.signal.TransferFunction.gain	A										<section class="prog__container"><p>Gain of the ZerosPolesGain system.</p><pre><code>TransferFunction.gain</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.gain.html
scipy signal TransferFunction gain	R	scipy.signal.TransferFunction.gain										
scipy signal.TransferFunction.gain	R	scipy.signal.TransferFunction.gain										
scipy.signal.TransferFunction.num	A										<section class="prog__container"><p>Numerator of the TransferFunction system.</p><pre><code>TransferFunction.num</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.num.html
scipy signal TransferFunction num	R	scipy.signal.TransferFunction.num										
scipy signal.TransferFunction.num	R	scipy.signal.TransferFunction.num										
scipy.signal.TransferFunction.poles	A										<section class="prog__container"><p>Poles of the system.</p><pre><code>TransferFunction.poles</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.poles.html
scipy signal TransferFunction poles	R	scipy.signal.TransferFunction.poles										
scipy signal.TransferFunction.poles	R	scipy.signal.TransferFunction.poles										
scipy signal TransferFunction	R	scipy.signal.TransferFunction										
scipy signal.TransferFunction	R	scipy.signal.TransferFunction										
scipy.signal.TransferFunction.to_ss	A										<section class="prog__container"><p>Convert system representation to StateSpace.</p><pre><code>TransferFunction.to_ss()</code></pre><span class="prog__sub">Parameters:</span><pre><code>sys : instance of StateSpace\n    State space model of the current system</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.to_ss.html
scipy signal TransferFunction to_ss	R	scipy.signal.TransferFunction.to_ss										
scipy signal.TransferFunction.to_ss	R	scipy.signal.TransferFunction.to_ss										
scipy.signal.TransferFunction.to_tf	A										<section class="prog__container"><p>Return a copy of the current TransferFunction system.</p><pre><code>TransferFunction.to_tf()</code></pre><span class="prog__sub">Parameters:</span><pre><code>sys : instance of TransferFunction\n    The current system (copy)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.to_tf.html
scipy signal TransferFunction to_tf	R	scipy.signal.TransferFunction.to_tf										
scipy signal.TransferFunction.to_tf	R	scipy.signal.TransferFunction.to_tf										
scipy.signal.TransferFunction.to_zpk	A										<section class="prog__container"><p>Convert system representation to ZerosPolesGain.</p><pre><code>TransferFunction.to_zpk()</code></pre><span class="prog__sub">Parameters:</span><pre><code>sys : instance of ZerosPolesGain\n    Zeros, poles, gain representation of the current system</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.to_zpk.html
scipy signal TransferFunction to_zpk	R	scipy.signal.TransferFunction.to_zpk										
scipy signal.TransferFunction.to_zpk	R	scipy.signal.TransferFunction.to_zpk										
scipy.signal.TransferFunction.zeros	A										<section class="prog__container"><p>Zeros of the system.</p><pre><code>TransferFunction.zeros</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.TransferFunction.zeros.html
scipy signal TransferFunction zeros	R	scipy.signal.TransferFunction.zeros										
scipy signal.TransferFunction.zeros	R	scipy.signal.TransferFunction.zeros										
scipy.signal.triang	A										<section class="prog__container"><p>Return a triangular window.</p><pre><code>scipy.signal.triang(M, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.triang.html
scipy signal triang	R	scipy.signal.triang										
scipy signal.triang	R	scipy.signal.triang										
scipy.signal.tukey	A										<section class="prog__container"><p>Return a Tukey window, also known as a tapered cosine window.</p><pre><code>scipy.signal.tukey(M, alpha=0.5, sym=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>M : int\n    Number of points in the output window. If zero or less, an empty array is returned. \nalpha : float, optional\n    Shape parameter of the Tukey window, representing the faction of the window inside the cosine tapered region. If zero, the Tukey window is equivalent to a rectangular window. If one, the Tukey window is equivalent to a Hann window. \nsym : bool, optional\n    When True (default), generates a symmetric window, for use in filter design. When False, generates a periodic window, for use in spectral analysis.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    The window, with the maximum value normalized to 1 (though the value 1 does not appear if M is even and sym is True).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> from scipy.fftpack import fft, fftshift\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.tukey.html
scipy signal tukey	R	scipy.signal.tukey										
scipy signal.tukey	R	scipy.signal.tukey										
scipy.signal.unique_roots	A										<section class="prog__container"><p>Determine unique roots and their multiplicities from a list of roots.</p><pre><code>scipy.signal.unique_roots(p, tol=0.001, rtype='min')</code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    The list of roots. \ntol : float, optional\n    The tolerance for two roots to be considered equal. Default is 1e-3. \nrtype : {‘max’, ‘min, ‘avg’}, optional\n    How to determine the returned root if multiple roots are within tol of each other.   ‘max’: pick the maximum of those roots. ‘min’: pick the minimum of those roots. ‘avg’: take the average of those roots.</code></pre><span class="prog__sub">Returns:</span><pre><code>pout : ndarray\n    The list of unique roots, sorted from low to high. \nmult : ndarray\n    The multiplicity of each root.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]\n>>> uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype='avg')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.unique_roots.html
scipy signal unique_roots	R	scipy.signal.unique_roots										
scipy signal.unique_roots	R	scipy.signal.unique_roots										
scipy.signal.upfirdn	A										<section class="prog__container"><p>Upsample, FIR filter, and downsample</p><pre><code>scipy.signal.upfirdn(h, x, up=1, down=1, axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>h : array_like\n    1-dimensional FIR (finite-impulse response) filter coefficients. \nx : array_like\n    Input signal array. \nup : int, optional\n    Upsampling rate. Default is 1. \ndown : int, optional\n    Downsampling rate. Default is 1. \naxis : int, optional\n    The axis of the input data array along which to apply the linear filter. The filter is applied to each subarray along this axis. Default is -1.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The output signal array. Dimensions will be the same as x except for along axis, which will change size according to the h, up,  and down parameters.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.signal import upfirdn\n>>> upfirdn([1, 1, 1], [1, 1, 1])   # FIR filter\narray([ 1.,  2.,  3.,  2.,  1.])\n>>> upfirdn([1], [1, 2, 3], 3)  # upsampling with zeros insertion\narray([ 1.,  0.,  0.,  2.,  0.,  0.,  3.,  0.,  0.])\n>>> upfirdn([1, 1, 1], [1, 2, 3], 3)  # upsampling with sample-and-hold\narray([ 1.,  1.,  1.,  2.,  2.,  2.,  3.,  3.,  3.])\n>>> upfirdn([.5, 1, .5], [1, 1, 1], 2)  # linear interpolation\narray([ 0.5,  1. ,  1. ,  1. ,  1. ,  1. ,  0.5,  0. ])\n>>> upfirdn([1], np.arange(10), 1, 3)  # decimation by 3\narray([ 0.,  3.,  6.,  9.])\n>>> upfirdn([.5, 1, .5], np.arange(10), 2, 3)  # linear interp, rate 2/3\narray([ 0. ,  1. ,  2.5,  4. ,  5.5,  7. ,  8.5,  0. ])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.upfirdn.html
scipy signal upfirdn	R	scipy.signal.upfirdn										
scipy signal.upfirdn	R	scipy.signal.upfirdn										
scipy.signal.vectorstrength	A										<section class="prog__container"><p>Determine the vector strength of the events corresponding to the given\nperiod.</p><pre><code>scipy.signal.vectorstrength(events, period)</code></pre><span class="prog__sub">Parameters:</span><pre><code>events : 1D array_like\n    An array of time points containing the timing of the events. \nperiod : float or array_like\n    The period of the signal that the events should synchronize to. The period is in the same units as events.  It can also be an array of periods, in which case the outputs are arrays of the same length.</code></pre><span class="prog__sub">Returns:</span><pre><code>strength : float or 1D array\n    The strength of the synchronization.  1.0 is perfect synchronization and 0.0 is no synchronization.  If period is an array, this is also an array with each element containing the vector strength at the corresponding period. \nphase : float or array\n    The phase that the events are most strongly synchronized to in radians. If period is an array, this is also an array with each element containing the phase for the corresponding period.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.vectorstrength.html
scipy signal vectorstrength	R	scipy.signal.vectorstrength										
scipy signal.vectorstrength	R	scipy.signal.vectorstrength										
scipy.signal.welch	A										<section class="prog__container"><p>Estimate power spectral density using Welch’s method.</p><pre><code>scipy.signal.welch(x, fs=1.0, window='hann', nperseg=256, noverlap=None, nfft=None, detrend='constant', return_onesided=True, scaling='density', axis=-1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Time series of measurement values \nfs : float, optional\n    Sampling frequency of the x time series. Defaults to 1.0. \nwindow : str or tuple or array_like, optional\n    Desired window to use. See get_window for a list of windows and required parameters. If window is array_like it will be used directly as the window and its length will be used for nperseg. Defaults to ‘hann’. \nnperseg : int, optional\n    Length of each segment.  Defaults to 256. \nnoverlap : int, optional\n    Number of points to overlap between segments. If None, noverlap = nperseg // 2.  Defaults to None. \nnfft : int, optional\n    Length of the FFT used, if a zero padded FFT is desired.  If None, the FFT length is nperseg. Defaults to None. \ndetrend : str or function or False, optional\n    Specifies how to detrend each segment. If detrend is a string, it is passed as the type argument to detrend.  If it is a function, it takes a segment and returns a detrended segment. If detrend is False, no detrending is done.  Defaults to ‘constant’. \nreturn_onesided : bool, optional\n    If True, return a one-sided spectrum for real data. If False return a two-sided spectrum. Note that for complex data, a two-sided spectrum is always returned. \nscaling : { ‘density’, ‘spectrum’ }, optional\n    Selects between computing the power spectral density (‘density’) where Pxx has units of V**2/Hz and computing the power spectrum (‘spectrum’) where Pxx has units of V**2, if x is measured in V and fs is measured in Hz.  Defaults to ‘density’ \naxis : int, optional\n    Axis along which the periodogram is computed; the default is over the last axis (i.e. axis=-1).</code></pre><span class="prog__sub">Returns:</span><pre><code>f : ndarray\n    Array of sample frequencies. \nPxx : ndarray\n    Power spectral density or power spectrum of x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> import matplotlib.pyplot as plt\n>>> np.random.seed(1234)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html
scipy signal welch	R	scipy.signal.welch										
scipy signal.welch	R	scipy.signal.welch										
scipy.signal.wiener	A										<section class="prog__container"><p>Perform a Wiener filter on an N-dimensional array.</p><pre><code>scipy.signal.wiener(im, mysize=None, noise=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>im : ndarray\n    An N-dimensional array. \nmysize : int or array_like, optional\n    A scalar or an N-length list giving the size of the Wiener filter window in each dimension.  Elements of mysize should be odd. If mysize is a scalar, then this scalar is used as the size in each dimension. \nnoise : float, optional\n    The noise-power to use. If None, then noise is estimated as the average of the local variance of the input.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Wiener filtered result with the same shape as im.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.wiener.html
scipy signal wiener	R	scipy.signal.wiener										
scipy signal.wiener	R	scipy.signal.wiener										
scipy.signal.ZerosPolesGain.A	A										<section class="prog__container"><p>State matrix of the StateSpace system.</p><pre><code>ZerosPolesGain.A</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.A.html
scipy signal ZerosPolesGain A	R	scipy.signal.ZerosPolesGain.A										
scipy signal.ZerosPolesGain.A	R	scipy.signal.ZerosPolesGain.A										
scipy.signal.ZerosPolesGain	A					[[scipy.signal.TransferFunction]]\\n[[scipy.signal.StateSpace]]\\n[[scipy.signal.lti]]\\n[[scipy.signal.dlti]]\\n[[scipy.signal.zpk2ss]]\\n[[scipy.signal.zpk2tf]]\\n[[scipy.signal.zpk2sos]]					<section class="prog__container"><p>Linear Time Invariant system class in zeros, poles, gain form.</p><pre><code>class scipy.signal.ZerosPolesGain(*system, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>*system : arguments\n    The ZerosPolesGain class can be instantiated with 1 or 3 arguments. The following gives the number of input arguments and their interpretation:   1: lti or dlti system: (StateSpace, TransferFunction or ZerosPolesGain) 3: array_like: (zeros, poles, gain)   \ndt: float, optional\n    Sampling time [s] of the discrete-time systems. Defaults to None (continuous-time). Must be specified as a keyword argument, for example, dt=0.1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.html
scipy.signal.ZerosPolesGain.B	A										<section class="prog__container"><p>Input matrix of the StateSpace system.</p><pre><code>ZerosPolesGain.B</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.B.html
scipy signal ZerosPolesGain B	R	scipy.signal.ZerosPolesGain.B										
scipy signal.ZerosPolesGain.B	R	scipy.signal.ZerosPolesGain.B										
scipy.signal.ZerosPolesGain.C	A										<section class="prog__container"><p>Output matrix of the StateSpace system.</p><pre><code>ZerosPolesGain.C</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.C.html
scipy signal ZerosPolesGain C	R	scipy.signal.ZerosPolesGain.C										
scipy signal.ZerosPolesGain.C	R	scipy.signal.ZerosPolesGain.C										
scipy.signal.ZerosPolesGain.D	A										<section class="prog__container"><p>Feedthrough matrix of the StateSpace system.</p><pre><code>ZerosPolesGain.D</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.D.html
scipy.signal.ZerosPolesGain.den	A										<section class="prog__container"><p>Denominator of the TransferFunction system.</p><pre><code>ZerosPolesGain.den</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.den.html
scipy signal ZerosPolesGain den	R	scipy.signal.ZerosPolesGain.den										
scipy signal.ZerosPolesGain.den	R	scipy.signal.ZerosPolesGain.den										
scipy signal ZerosPolesGain D	R	scipy.signal.ZerosPolesGain.D										
scipy signal.ZerosPolesGain.D	R	scipy.signal.ZerosPolesGain.D										
scipy.signal.ZerosPolesGain.dt	A										<section class="prog__container"><p>Return the sampling time of the system, None for lti systems.</p><pre><code>ZerosPolesGain.dt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.dt.html
scipy signal ZerosPolesGain dt	R	scipy.signal.ZerosPolesGain.dt										
scipy signal.ZerosPolesGain.dt	R	scipy.signal.ZerosPolesGain.dt										
scipy.signal.ZerosPolesGain.gain	A										<section class="prog__container"><p>Gain of the ZerosPolesGain system.</p><pre><code>ZerosPolesGain.gain</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.gain.html
scipy signal ZerosPolesGain gain	R	scipy.signal.ZerosPolesGain.gain										
scipy signal.ZerosPolesGain.gain	R	scipy.signal.ZerosPolesGain.gain										
scipy.signal.ZerosPolesGain.num	A										<section class="prog__container"><p>Numerator of the TransferFunction system.</p><pre><code>ZerosPolesGain.num</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.num.html
scipy signal ZerosPolesGain num	R	scipy.signal.ZerosPolesGain.num										
scipy signal.ZerosPolesGain.num	R	scipy.signal.ZerosPolesGain.num										
scipy.signal.ZerosPolesGain.poles	A										<section class="prog__container"><p>Poles of the ZerosPolesGain system.</p><pre><code>ZerosPolesGain.poles</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.poles.html
scipy signal ZerosPolesGain poles	R	scipy.signal.ZerosPolesGain.poles										
scipy signal.ZerosPolesGain.poles	R	scipy.signal.ZerosPolesGain.poles										
scipy signal ZerosPolesGain	R	scipy.signal.ZerosPolesGain										
scipy signal.ZerosPolesGain	R	scipy.signal.ZerosPolesGain										
scipy.signal.ZerosPolesGain.to_ss	A										<section class="prog__container"><p>Convert system representation to StateSpace.</p><pre><code>ZerosPolesGain.to_ss()</code></pre><span class="prog__sub">Parameters:</span><pre><code>sys : instance of StateSpace\n    State space model of the current system</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.to_ss.html
scipy signal ZerosPolesGain to_ss	R	scipy.signal.ZerosPolesGain.to_ss										
scipy signal.ZerosPolesGain.to_ss	R	scipy.signal.ZerosPolesGain.to_ss										
scipy.signal.ZerosPolesGain.to_tf	A										<section class="prog__container"><p>Convert system representation to TransferFunction.</p><pre><code>ZerosPolesGain.to_tf()</code></pre><span class="prog__sub">Parameters:</span><pre><code>sys : instance of TransferFunction\n    Transfer function of the current system</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.to_tf.html
scipy signal ZerosPolesGain to_tf	R	scipy.signal.ZerosPolesGain.to_tf										
scipy signal.ZerosPolesGain.to_tf	R	scipy.signal.ZerosPolesGain.to_tf										
scipy.signal.ZerosPolesGain.to_zpk	A										<section class="prog__container"><p>Return a copy of the current ‘ZerosPolesGain’ system.</p><pre><code>ZerosPolesGain.to_zpk()</code></pre><span class="prog__sub">Parameters:</span><pre><code>sys : instance of ZerosPolesGain\n    The current system (copy)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.to_zpk.html
scipy signal ZerosPolesGain to_zpk	R	scipy.signal.ZerosPolesGain.to_zpk										
scipy signal.ZerosPolesGain.to_zpk	R	scipy.signal.ZerosPolesGain.to_zpk										
scipy.signal.ZerosPolesGain.zeros	A										<section class="prog__container"><p>Zeros of the ZerosPolesGain system.</p><pre><code>ZerosPolesGain.zeros</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.ZerosPolesGain.zeros.html
scipy signal ZerosPolesGain zeros	R	scipy.signal.ZerosPolesGain.zeros										
scipy signal.ZerosPolesGain.zeros	R	scipy.signal.ZerosPolesGain.zeros										
scipy.signal.zpk2sos	A					[[scipy.signal.sosfilt]]					<section class="prog__container"><p>Return second-order sections from zeros, poles, and gain of a system</p><pre><code>scipy.signal.zpk2sos(z, p, k, pairing='nearest')</code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    Zeros of the transfer function. \np : array_like\n    Poles of the transfer function. \nk : float\n    System gain. \npairing : {‘nearest’, ‘keep_odd’}, optional\n    The method to use to combine pairs of poles and zeros into sections. See Notes below.</code></pre><span class="prog__sub">Returns:</span><pre><code>sos : ndarray\n    Array of second-order filter coefficients, with shape (n_sections, 6). See sosfilt for the SOS filter format specification.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import signal\n>>> z, p, k = signal.ellip(6, 0.087, 90, 1000/(0.5*8000), output='zpk')</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.zpk2sos.html
scipy signal zpk2sos	R	scipy.signal.zpk2sos										
scipy signal.zpk2sos	R	scipy.signal.zpk2sos										
scipy.signal.zpk2ss	A										<section class="prog__container"><p>Zero-pole-gain representation to state-space representation</p><pre><code>scipy.signal.zpk2ss(z, p, k)</code></pre><span class="prog__sub">Parameters:</span><pre><code>z, p : sequence\n    Zeros and poles. \nk : float\n    System gain.</code></pre><span class="prog__sub">Returns:</span><pre><code>A, B, C, D : ndarray\n    State space representation of the system, in controller canonical form.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.zpk2ss.html
scipy signal zpk2ss	R	scipy.signal.zpk2ss										
scipy signal.zpk2ss	R	scipy.signal.zpk2ss										
scipy.signal.zpk2tf	A										<section class="prog__container"><p>Return polynomial transfer function representation from zeros and poles</p><pre><code>scipy.signal.zpk2tf(z, p, k)</code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    Zeros of the transfer function. \np : array_like\n    Poles of the transfer function. \nk : float\n    System gain.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    Numerator polynomial coefficients. \na : ndarray\n    Denominator polynomial coefficients.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.zpk2tf.html
scipy signal zpk2tf	R	scipy.signal.zpk2tf										
scipy signal.zpk2tf	R	scipy.signal.zpk2tf										
scipy.sparse.block_diag	A					[[scipy.sparse.bmat]]\\n[[scipy.sparse.diags]]					<section class="prog__container"><p>Build a block diagonal sparse matrix from provided matrices.</p><pre><code>scipy.sparse.block_diag(mats, format=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mats : sequence of matrices\n    Input matrices. \nformat : str, optional\n    The sparse format of the result (e.g. “csr”).  If not given, the matrix is returned in “coo” format. \ndtype : dtype specifier, optional\n    The data-type of the output matrix.  If not given, the dtype is determined from that of blocks.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : sparse matrix</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import coo_matrix, block_diag\n>>> A = coo_matrix([[1, 2], [3, 4]])\n>>> B = coo_matrix([[5], [6]])\n>>> C = coo_matrix([[7]])\n>>> block_diag((A, B, C)).toarray()\narray([[1, 2, 0, 0],\n       [3, 4, 0, 0],\n       [0, 0, 5, 0],\n       [0, 0, 6, 0],\n       [0, 0, 0, 7]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.block_diag.html
scipy sparse block_diag	R	scipy.sparse.block_diag										
scipy sparse.block_diag	R	scipy.sparse.block_diag										
scipy.sparse.bmat	A					[[scipy.sparse.block_diag]]\\n[[scipy.sparse.diags]]					<section class="prog__container"><p>Build a sparse matrix from sparse sub-blocks</p><pre><code>scipy.sparse.bmat(blocks, format=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>blocks : array_like\n    Grid of sparse matrices with compatible shapes. An entry of None implies an all-zero matrix. \nformat : {‘bsr’, ‘coo’, ‘csc’, ‘csr’, ‘dia’, ‘dok’, ‘lil’}, optional\n    The sparse format of the result (e.g. “csr”).  By default an appropriate sparse matrix format is returned. This choice is subject to change. \ndtype : dtype, optional\n    The data-type of the output matrix.  If not given, the dtype is determined from that of blocks.</code></pre><span class="prog__sub">Returns:</span><pre><code>bmat : sparse matrix</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import coo_matrix, bmat\n>>> A = coo_matrix([[1, 2], [3, 4]])\n>>> B = coo_matrix([[5], [6]])\n>>> C = coo_matrix([[7]])\n>>> bmat([[A, B], [None, C]]).toarray()\narray([[1, 2, 5],\n       [3, 4, 6],\n       [0, 0, 7]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bmat.html
scipy sparse bmat	R	scipy.sparse.bmat										
scipy sparse.bmat	R	scipy.sparse.bmat										
scipy.sparse.bsr_matrix.arcsin	A										<section class="prog__container"><p>Element-wise arcsin.</p><pre><code>bsr_matrix.arcsin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.arcsin.html
scipy.sparse.bsr_matrix.arcsinh	A										<section class="prog__container"><p>Element-wise arcsinh.</p><pre><code>bsr_matrix.arcsinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.arcsinh.html
scipy sparse bsr_matrix arcsinh	R	scipy.sparse.bsr_matrix.arcsinh										
scipy sparse.bsr_matrix.arcsinh	R	scipy.sparse.bsr_matrix.arcsinh										
scipy sparse bsr_matrix arcsin	R	scipy.sparse.bsr_matrix.arcsin										
scipy sparse.bsr_matrix.arcsin	R	scipy.sparse.bsr_matrix.arcsin										
scipy.sparse.bsr_matrix.arctan	A										<section class="prog__container"><p>Element-wise arctan.</p><pre><code>bsr_matrix.arctan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.arctan.html
scipy.sparse.bsr_matrix.arctanh	A										<section class="prog__container"><p>Element-wise arctanh.</p><pre><code>bsr_matrix.arctanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.arctanh.html
scipy sparse bsr_matrix arctanh	R	scipy.sparse.bsr_matrix.arctanh										
scipy sparse.bsr_matrix.arctanh	R	scipy.sparse.bsr_matrix.arctanh										
scipy sparse bsr_matrix arctan	R	scipy.sparse.bsr_matrix.arctan										
scipy sparse.bsr_matrix.arctan	R	scipy.sparse.bsr_matrix.arctan										
scipy.sparse.bsr_matrix	A										<section class="prog__container"><p>Block Sparse Row matrix</p><pre><code>class scipy.sparse.bsr_matrix(arg1, shape=None, dtype=None, copy=False, blocksize=None)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import bsr_matrix\n>>> bsr_matrix((3, 4), dtype=np.int8).toarray()\narray([[0, 0, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 0]], dtype=int8)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.html
scipy.sparse.bsr_matrix.asformat	A										<section class="prog__container"><p>Return this matrix in a given sparse format</p><pre><code>bsr_matrix.asformat(format)</code></pre><span class="prog__sub">Parameters:</span><pre><code>format : {string, None}\n    desired sparse matrix format  None for no format conversion “csr” for csr_matrix format “csc” for csc_matrix format “lil” for lil_matrix format “dok” for dok_matrix format and so on</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.asformat.html
scipy sparse bsr_matrix asformat	R	scipy.sparse.bsr_matrix.asformat										
scipy sparse.bsr_matrix.asformat	R	scipy.sparse.bsr_matrix.asformat										
scipy.sparse.bsr_matrix.asfptype	A										<section class="prog__container"><p>Upcast matrix to a floating point format (if necessary)</p><pre><code>bsr_matrix.asfptype()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.asfptype.html
scipy sparse bsr_matrix asfptype	R	scipy.sparse.bsr_matrix.asfptype										
scipy sparse.bsr_matrix.asfptype	R	scipy.sparse.bsr_matrix.asfptype										
scipy.sparse.bsr_matrix.ceil	A										<section class="prog__container"><p>Element-wise ceil.</p><pre><code>bsr_matrix.ceil()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.ceil.html
scipy sparse bsr_matrix ceil	R	scipy.sparse.bsr_matrix.ceil										
scipy sparse.bsr_matrix.ceil	R	scipy.sparse.bsr_matrix.ceil										
scipy.sparse.bsr_matrix.check_format	A										<section class="prog__container"><p>check whether the matrix format is valid</p><pre><code>bsr_matrix.check_format(full_check=True)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.check_format.html
scipy sparse bsr_matrix check_format	R	scipy.sparse.bsr_matrix.check_format										
scipy sparse.bsr_matrix.check_format	R	scipy.sparse.bsr_matrix.check_format										
scipy.sparse.bsr_matrix.count_nonzero	A										<section class="prog__container"><p>Number of non-zero entries, equivalent to</p><pre><code>bsr_matrix.count_nonzero()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.count_nonzero.html
scipy sparse bsr_matrix count_nonzero	R	scipy.sparse.bsr_matrix.count_nonzero										
scipy sparse.bsr_matrix.count_nonzero	R	scipy.sparse.bsr_matrix.count_nonzero										
scipy.sparse.bsr_matrix.deg2rad	A										<section class="prog__container"><p>Element-wise deg2rad.</p><pre><code>bsr_matrix.deg2rad()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.deg2rad.html
scipy sparse bsr_matrix deg2rad	R	scipy.sparse.bsr_matrix.deg2rad										
scipy sparse.bsr_matrix.deg2rad	R	scipy.sparse.bsr_matrix.deg2rad										
scipy.sparse.bsr_matrix.diagonal	A										<section class="prog__container"><p>Returns the main diagonal of the matrix</p><pre><code>bsr_matrix.diagonal()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.diagonal.html
scipy sparse bsr_matrix diagonal	R	scipy.sparse.bsr_matrix.diagonal										
scipy sparse.bsr_matrix.diagonal	R	scipy.sparse.bsr_matrix.diagonal										
scipy.sparse.bsr_matrix.dot	A										<section class="prog__container"><p>Ordinary dot product</p><pre><code>bsr_matrix.dot(other)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.dot.html
scipy sparse bsr_matrix dot	R	scipy.sparse.bsr_matrix.dot										
scipy sparse.bsr_matrix.dot	R	scipy.sparse.bsr_matrix.dot										
scipy.sparse.bsr_matrix.expm1	A										<section class="prog__container"><p>Element-wise expm1.</p><pre><code>bsr_matrix.expm1()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.expm1.html
scipy sparse bsr_matrix expm1	R	scipy.sparse.bsr_matrix.expm1										
scipy sparse.bsr_matrix.expm1	R	scipy.sparse.bsr_matrix.expm1										
scipy.sparse.bsr_matrix.floor	A										<section class="prog__container"><p>Element-wise floor.</p><pre><code>bsr_matrix.floor()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.floor.html
scipy sparse bsr_matrix floor	R	scipy.sparse.bsr_matrix.floor										
scipy sparse.bsr_matrix.floor	R	scipy.sparse.bsr_matrix.floor										
scipy.sparse.bsr_matrix.getcol	A										<section class="prog__container"><p>Returns a copy of column j of the matrix, as an (m x 1) sparse\nmatrix (column vector).</p><pre><code>bsr_matrix.getcol(j)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.getcol.html
scipy sparse bsr_matrix getcol	R	scipy.sparse.bsr_matrix.getcol										
scipy sparse.bsr_matrix.getcol	R	scipy.sparse.bsr_matrix.getcol										
scipy.sparse.bsr_matrix.getnnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>bsr_matrix.getnnz(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None, 0, or 1\n    Select between the number of values across the whole matrix, in each column, or in each row.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.getnnz.html
scipy sparse bsr_matrix getnnz	R	scipy.sparse.bsr_matrix.getnnz										
scipy sparse.bsr_matrix.getnnz	R	scipy.sparse.bsr_matrix.getnnz										
scipy.sparse.bsr_matrix.getrow	A										<section class="prog__container"><p>Returns a copy of row i of the matrix, as a (1 x n) sparse\nmatrix (row vector).</p><pre><code>bsr_matrix.getrow(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.getrow.html
scipy sparse bsr_matrix getrow	R	scipy.sparse.bsr_matrix.getrow										
scipy sparse.bsr_matrix.getrow	R	scipy.sparse.bsr_matrix.getrow										
scipy.sparse.bsr_matrix.has_canonical_format	A										<section class="prog__container"><p>Determine whether the matrix has sorted indices and no duplicates</p><pre><code>bsr_matrix.has_canonical_format</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.has_canonical_format.html
scipy sparse bsr_matrix has_canonical_format	R	scipy.sparse.bsr_matrix.has_canonical_format										
scipy sparse.bsr_matrix.has_canonical_format	R	scipy.sparse.bsr_matrix.has_canonical_format										
scipy.sparse.bsr_matrix.has_sorted_indices	A										<section class="prog__container"><p>Determine whether the matrix has sorted indices</p><pre><code>bsr_matrix.has_sorted_indices</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.has_sorted_indices.html
scipy sparse bsr_matrix has_sorted_indices	R	scipy.sparse.bsr_matrix.has_sorted_indices										
scipy sparse.bsr_matrix.has_sorted_indices	R	scipy.sparse.bsr_matrix.has_sorted_indices										
scipy.sparse.bsr_matrix.log1p	A										<section class="prog__container"><p>Element-wise log1p.</p><pre><code>bsr_matrix.log1p()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.log1p.html
scipy sparse bsr_matrix log1p	R	scipy.sparse.bsr_matrix.log1p										
scipy sparse.bsr_matrix.log1p	R	scipy.sparse.bsr_matrix.log1p										
scipy.sparse.bsr_matrix.max	A										<section class="prog__container"><p>Return the maximum of the matrix or maximum along an axis.\nThis takes all elements into account, not just the non-zero ones.</p><pre><code>bsr_matrix.max(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the maximum over all the matrix elements, returning a scalar (i.e. axis = None). \nout : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : coo_matrix or scalar\n    Maximum of a. If axis is None, the result is a scalar value. If axis is given, the result is a sparse.coo_matrix of dimension a.ndim - 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.max.html
scipy sparse bsr_matrix max	R	scipy.sparse.bsr_matrix.max										
scipy sparse.bsr_matrix.max	R	scipy.sparse.bsr_matrix.max										
scipy.sparse.bsr_matrix.mean	A										<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>bsr_matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the mean is computed. The default is to compute the mean of all elements in the matrix (i.e. axis = None). \ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : np.matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.mean.html
scipy sparse bsr_matrix mean	R	scipy.sparse.bsr_matrix.mean										
scipy sparse.bsr_matrix.mean	R	scipy.sparse.bsr_matrix.mean										
scipy.sparse.bsr_matrix.min	A										<section class="prog__container"><p>Return the minimum of the matrix or maximum along an axis.\nThis takes all elements into account, not just the non-zero ones.</p><pre><code>bsr_matrix.min(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the minimum over all the matrix elements, returning a scalar (i.e. axis = None). \nout : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : coo_matrix or scalar\n    Minimum of a. If axis is None, the result is a scalar value. If axis is given, the result is a sparse.coo_matrix of dimension a.ndim - 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.min.html
scipy sparse bsr_matrix min	R	scipy.sparse.bsr_matrix.min										
scipy sparse.bsr_matrix.min	R	scipy.sparse.bsr_matrix.min										
scipy.sparse.bsr_matrix.multiply	A										<section class="prog__container"><p>Point-wise multiplication by another matrix, vector, or\nscalar.</p><pre><code>bsr_matrix.multiply(other)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.multiply.html
scipy sparse bsr_matrix multiply	R	scipy.sparse.bsr_matrix.multiply										
scipy sparse.bsr_matrix.multiply	R	scipy.sparse.bsr_matrix.multiply										
scipy.sparse.bsr_matrix.nnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>bsr_matrix.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.nnz.html
scipy sparse bsr_matrix nnz	R	scipy.sparse.bsr_matrix.nnz										
scipy sparse.bsr_matrix.nnz	R	scipy.sparse.bsr_matrix.nnz										
scipy.sparse.bsr_matrix.nonzero	A										<section class="prog__container"><p>nonzero indices</p><pre><code>bsr_matrix.nonzero()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])\n>>> A.nonzero()\n(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.nonzero.html
scipy sparse bsr_matrix nonzero	R	scipy.sparse.bsr_matrix.nonzero										
scipy sparse.bsr_matrix.nonzero	R	scipy.sparse.bsr_matrix.nonzero										
scipy.sparse.bsr_matrix.power	A										<section class="prog__container"><p>This function performs element-wise power.</p><pre><code>bsr_matrix.power(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : n is a scalar\ndtype : If dtype is not specified, the current dtype will be preserved.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.power.html
scipy sparse bsr_matrix power	R	scipy.sparse.bsr_matrix.power										
scipy sparse.bsr_matrix.power	R	scipy.sparse.bsr_matrix.power										
scipy.sparse.bsr_matrix.prune	A										<section class="prog__container"><p>Remove empty space after all non-zero elements.</p><pre><code>bsr_matrix.prune()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.prune.html
scipy sparse bsr_matrix prune	R	scipy.sparse.bsr_matrix.prune										
scipy sparse.bsr_matrix.prune	R	scipy.sparse.bsr_matrix.prune										
scipy.sparse.bsr_matrix.rad2deg	A										<section class="prog__container"><p>Element-wise rad2deg.</p><pre><code>bsr_matrix.rad2deg()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.rad2deg.html
scipy sparse bsr_matrix rad2deg	R	scipy.sparse.bsr_matrix.rad2deg										
scipy sparse.bsr_matrix.rad2deg	R	scipy.sparse.bsr_matrix.rad2deg										
scipy.sparse.bsr_matrix.reshape	A										<section class="prog__container"><p>Gives a new shape to a sparse matrix without changing its data.</p><pre><code>bsr_matrix.reshape(shape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : length-2 tuple of ints\n    The new shape should be compatible with the original shape. \norder : ‘C’, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_matrix : self with the new dimensions of shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.reshape.html
scipy sparse bsr_matrix reshape	R	scipy.sparse.bsr_matrix.reshape										
scipy sparse.bsr_matrix.reshape	R	scipy.sparse.bsr_matrix.reshape										
scipy.sparse.bsr_matrix.rint	A										<section class="prog__container"><p>Element-wise rint.</p><pre><code>bsr_matrix.rint()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.rint.html
scipy sparse bsr_matrix rint	R	scipy.sparse.bsr_matrix.rint										
scipy sparse.bsr_matrix.rint	R	scipy.sparse.bsr_matrix.rint										
scipy sparse bsr_matrix	R	scipy.sparse.bsr_matrix										
scipy sparse.bsr_matrix	R	scipy.sparse.bsr_matrix										
scipy.sparse.bsr_matrix.setdiag	A										<section class="prog__container"><p>Set diagonal or off-diagonal elements of the array.</p><pre><code>bsr_matrix.setdiag(values, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    New values of the diagonal elements. Values may have any length.  If the diagonal is longer than values, then the remaining diagonal entries will not be set.  If values if longer than the diagonal, then the remaining values are ignored. If a scalar value is given, all of the diagonal is set to it. \nk : int, optional\n    Which off-diagonal to set, corresponding to elements a[i,i+k]. Default: 0 (the main diagonal).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.setdiag.html
scipy sparse bsr_matrix setdiag	R	scipy.sparse.bsr_matrix.setdiag										
scipy sparse.bsr_matrix.setdiag	R	scipy.sparse.bsr_matrix.setdiag										
scipy.sparse.bsr_matrix.sign	A										<section class="prog__container"><p>Element-wise sign.</p><pre><code>bsr_matrix.sign()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.sign.html
scipy sparse bsr_matrix sign	R	scipy.sparse.bsr_matrix.sign										
scipy sparse.bsr_matrix.sign	R	scipy.sparse.bsr_matrix.sign										
scipy.sparse.bsr_matrix.sin	A										<section class="prog__container"><p>Element-wise sin.</p><pre><code>bsr_matrix.sin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.sin.html
scipy.sparse.bsr_matrix.sinh	A										<section class="prog__container"><p>Element-wise sinh.</p><pre><code>bsr_matrix.sinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.sinh.html
scipy sparse bsr_matrix sinh	R	scipy.sparse.bsr_matrix.sinh										
scipy sparse.bsr_matrix.sinh	R	scipy.sparse.bsr_matrix.sinh										
scipy sparse bsr_matrix sin	R	scipy.sparse.bsr_matrix.sin										
scipy sparse.bsr_matrix.sin	R	scipy.sparse.bsr_matrix.sin										
scipy.sparse.bsr_matrix.sorted_indices	A										<section class="prog__container"><p>Return a copy of this matrix with sorted indices</p><pre><code>bsr_matrix.sorted_indices()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.sorted_indices.html
scipy sparse bsr_matrix sorted_indices	R	scipy.sparse.bsr_matrix.sorted_indices										
scipy sparse.bsr_matrix.sorted_indices	R	scipy.sparse.bsr_matrix.sorted_indices										
scipy.sparse.bsr_matrix.sort_indices	A										<section class="prog__container"><p>Sort the indices of this matrix in place</p><pre><code>bsr_matrix.sort_indices()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.sort_indices.html
scipy sparse bsr_matrix sort_indices	R	scipy.sparse.bsr_matrix.sort_indices										
scipy sparse.bsr_matrix.sort_indices	R	scipy.sparse.bsr_matrix.sort_indices										
scipy.sparse.bsr_matrix.sqrt	A										<section class="prog__container"><p>Element-wise sqrt.</p><pre><code>bsr_matrix.sqrt()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.sqrt.html
scipy sparse bsr_matrix sqrt	R	scipy.sparse.bsr_matrix.sqrt										
scipy sparse.bsr_matrix.sqrt	R	scipy.sparse.bsr_matrix.sqrt										
scipy.sparse.bsr_matrix.sum	A										<section class="prog__container"><p>Sum the matrix elements over a given axis.</p><pre><code>bsr_matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the sum of all the matrix elements, returning a scalar (i.e. axis = None). \ndtype : dtype, optional\n    The type of the returned matrix and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : np.matrix\n    A matrix with the same shape as self, with the specified axis removed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.sum.html
scipy.sparse.bsr_matrix.sum_duplicates	A										<section class="prog__container"><p>Eliminate duplicate matrix entries by adding them together</p><pre><code>bsr_matrix.sum_duplicates()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.sum_duplicates.html
scipy sparse bsr_matrix sum_duplicates	R	scipy.sparse.bsr_matrix.sum_duplicates										
scipy sparse.bsr_matrix.sum_duplicates	R	scipy.sparse.bsr_matrix.sum_duplicates										
scipy sparse bsr_matrix sum	R	scipy.sparse.bsr_matrix.sum										
scipy sparse.bsr_matrix.sum	R	scipy.sparse.bsr_matrix.sum										
scipy.sparse.bsr_matrix.tan	A										<section class="prog__container"><p>Element-wise tan.</p><pre><code>bsr_matrix.tan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.tan.html
scipy.sparse.bsr_matrix.tanh	A										<section class="prog__container"><p>Element-wise tanh.</p><pre><code>bsr_matrix.tanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.tanh.html
scipy sparse bsr_matrix tanh	R	scipy.sparse.bsr_matrix.tanh										
scipy sparse.bsr_matrix.tanh	R	scipy.sparse.bsr_matrix.tanh										
scipy sparse bsr_matrix tan	R	scipy.sparse.bsr_matrix.tan										
scipy sparse.bsr_matrix.tan	R	scipy.sparse.bsr_matrix.tan										
scipy.sparse.bsr_matrix.toarray	A										<section class="prog__container"><p>See the docstring for spmatrix.toarray.</p><pre><code>bsr_matrix.toarray(order=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.toarray.html
scipy sparse bsr_matrix toarray	R	scipy.sparse.bsr_matrix.toarray										
scipy sparse.bsr_matrix.toarray	R	scipy.sparse.bsr_matrix.toarray										
scipy.sparse.bsr_matrix.tobsr	A										<section class="prog__container"><p>Convert this matrix into Block Sparse Row Format.</p><pre><code>bsr_matrix.tobsr(blocksize=None, copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.tobsr.html
scipy sparse bsr_matrix tobsr	R	scipy.sparse.bsr_matrix.tobsr										
scipy sparse.bsr_matrix.tobsr	R	scipy.sparse.bsr_matrix.tobsr										
scipy.sparse.bsr_matrix.tocoo	A										<section class="prog__container"><p>Convert this matrix to COOrdinate format.</p><pre><code>bsr_matrix.tocoo(copy=True)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.tocoo.html
scipy sparse bsr_matrix tocoo	R	scipy.sparse.bsr_matrix.tocoo										
scipy sparse.bsr_matrix.tocoo	R	scipy.sparse.bsr_matrix.tocoo										
scipy.sparse.bsr_matrix.tocsc	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Column format.</p><pre><code>bsr_matrix.tocsc(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.tocsc.html
scipy sparse bsr_matrix tocsc	R	scipy.sparse.bsr_matrix.tocsc										
scipy sparse.bsr_matrix.tocsc	R	scipy.sparse.bsr_matrix.tocsc										
scipy.sparse.bsr_matrix.tocsr	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Row format.</p><pre><code>bsr_matrix.tocsr(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.tocsr.html
scipy sparse bsr_matrix tocsr	R	scipy.sparse.bsr_matrix.tocsr										
scipy sparse.bsr_matrix.tocsr	R	scipy.sparse.bsr_matrix.tocsr										
scipy.sparse.bsr_matrix.todense	A										<section class="prog__container"><p>Return a dense matrix representation of this matrix.</p><pre><code>bsr_matrix.todense(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array (or numpy.matrix) as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : numpy.matrix, 2-dimensional\n    A NumPy matrix object with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed and was an array (rather than a numpy.matrix), it will be filled with the appropriate values and returned wrapped in a numpy.matrix object that shares the same memory.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.todense.html
scipy sparse bsr_matrix todense	R	scipy.sparse.bsr_matrix.todense										
scipy sparse.bsr_matrix.todense	R	scipy.sparse.bsr_matrix.todense										
scipy.sparse.bsr_matrix.todia	A										<section class="prog__container"><p>Convert this matrix to sparse DIAgonal format.</p><pre><code>bsr_matrix.todia(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.todia.html
scipy sparse bsr_matrix todia	R	scipy.sparse.bsr_matrix.todia										
scipy sparse.bsr_matrix.todia	R	scipy.sparse.bsr_matrix.todia										
scipy.sparse.bsr_matrix.todok	A										<section class="prog__container"><p>Convert this matrix to Dictionary Of Keys format.</p><pre><code>bsr_matrix.todok(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.todok.html
scipy sparse bsr_matrix todok	R	scipy.sparse.bsr_matrix.todok										
scipy sparse.bsr_matrix.todok	R	scipy.sparse.bsr_matrix.todok										
scipy.sparse.bsr_matrix.tolil	A										<section class="prog__container"><p>Convert this matrix to LInked List format.</p><pre><code>bsr_matrix.tolil(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.tolil.html
scipy sparse bsr_matrix tolil	R	scipy.sparse.bsr_matrix.tolil										
scipy sparse.bsr_matrix.tolil	R	scipy.sparse.bsr_matrix.tolil										
scipy.sparse.bsr_matrix.transpose	A										<section class="prog__container"><p>Reverses the dimensions of the sparse matrix.</p><pre><code>bsr_matrix.transpose(axes=None, copy=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value. \ncopy : bool, optional\n    Indicates whether or not attributes of self should be copied whenever possible. The degree to which attributes are copied varies depending on the type of sparse matrix being used.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : self with the dimensions reversed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.transpose.html
scipy sparse bsr_matrix transpose	R	scipy.sparse.bsr_matrix.transpose										
scipy sparse.bsr_matrix.transpose	R	scipy.sparse.bsr_matrix.transpose										
scipy.sparse.bsr_matrix.trunc	A										<section class="prog__container"><p>Element-wise trunc.</p><pre><code>bsr_matrix.trunc()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.trunc.html
scipy sparse bsr_matrix trunc	R	scipy.sparse.bsr_matrix.trunc										
scipy sparse.bsr_matrix.trunc	R	scipy.sparse.bsr_matrix.trunc										
scipy.sparse.coo_matrix.arcsin	A										<section class="prog__container"><p>Element-wise arcsin.</p><pre><code>coo_matrix.arcsin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.arcsin.html
scipy.sparse.coo_matrix.arcsinh	A										<section class="prog__container"><p>Element-wise arcsinh.</p><pre><code>coo_matrix.arcsinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.arcsinh.html
scipy sparse coo_matrix arcsinh	R	scipy.sparse.coo_matrix.arcsinh										
scipy sparse.coo_matrix.arcsinh	R	scipy.sparse.coo_matrix.arcsinh										
scipy sparse coo_matrix arcsin	R	scipy.sparse.coo_matrix.arcsin										
scipy sparse.coo_matrix.arcsin	R	scipy.sparse.coo_matrix.arcsin										
scipy.sparse.coo_matrix.arctan	A										<section class="prog__container"><p>Element-wise arctan.</p><pre><code>coo_matrix.arctan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.arctan.html
scipy.sparse.coo_matrix.arctanh	A										<section class="prog__container"><p>Element-wise arctanh.</p><pre><code>coo_matrix.arctanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.arctanh.html
scipy sparse coo_matrix arctanh	R	scipy.sparse.coo_matrix.arctanh										
scipy sparse.coo_matrix.arctanh	R	scipy.sparse.coo_matrix.arctanh										
scipy sparse coo_matrix arctan	R	scipy.sparse.coo_matrix.arctan										
scipy sparse.coo_matrix.arctan	R	scipy.sparse.coo_matrix.arctan										
scipy.sparse.coo_matrix	A										<section class="prog__container"><p>A sparse matrix in COOrdinate format.</p><pre><code>class scipy.sparse.coo_matrix(arg1, shape=None, dtype=None, copy=False)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import coo_matrix\n>>> coo_matrix((3, 4), dtype=np.int8).toarray()\narray([[0, 0, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 0]], dtype=int8)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html
scipy.sparse.coo_matrix.asformat	A										<section class="prog__container"><p>Return this matrix in a given sparse format</p><pre><code>coo_matrix.asformat(format)</code></pre><span class="prog__sub">Parameters:</span><pre><code>format : {string, None}\n    desired sparse matrix format  None for no format conversion “csr” for csr_matrix format “csc” for csc_matrix format “lil” for lil_matrix format “dok” for dok_matrix format and so on</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.asformat.html
scipy sparse coo_matrix asformat	R	scipy.sparse.coo_matrix.asformat										
scipy sparse.coo_matrix.asformat	R	scipy.sparse.coo_matrix.asformat										
scipy.sparse.coo_matrix.asfptype	A										<section class="prog__container"><p>Upcast matrix to a floating point format (if necessary)</p><pre><code>coo_matrix.asfptype()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.asfptype.html
scipy sparse coo_matrix asfptype	R	scipy.sparse.coo_matrix.asfptype										
scipy sparse.coo_matrix.asfptype	R	scipy.sparse.coo_matrix.asfptype										
scipy.sparse.coo_matrix.ceil	A										<section class="prog__container"><p>Element-wise ceil.</p><pre><code>coo_matrix.ceil()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.ceil.html
scipy sparse coo_matrix ceil	R	scipy.sparse.coo_matrix.ceil										
scipy sparse.coo_matrix.ceil	R	scipy.sparse.coo_matrix.ceil										
scipy.sparse.coo_matrix.count_nonzero	A										<section class="prog__container"><p>Number of non-zero entries, equivalent to</p><pre><code>coo_matrix.count_nonzero()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.count_nonzero.html
scipy sparse coo_matrix count_nonzero	R	scipy.sparse.coo_matrix.count_nonzero										
scipy sparse.coo_matrix.count_nonzero	R	scipy.sparse.coo_matrix.count_nonzero										
scipy.sparse.coo_matrix.deg2rad	A										<section class="prog__container"><p>Element-wise deg2rad.</p><pre><code>coo_matrix.deg2rad()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.deg2rad.html
scipy sparse coo_matrix deg2rad	R	scipy.sparse.coo_matrix.deg2rad										
scipy sparse.coo_matrix.deg2rad	R	scipy.sparse.coo_matrix.deg2rad										
scipy.sparse.coo_matrix.diagonal	A										<section class="prog__container"><p>Returns the main diagonal of the matrix</p><pre><code>coo_matrix.diagonal()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.diagonal.html
scipy sparse coo_matrix diagonal	R	scipy.sparse.coo_matrix.diagonal										
scipy sparse.coo_matrix.diagonal	R	scipy.sparse.coo_matrix.diagonal										
scipy.sparse.coo_matrix.dot	A										<section class="prog__container"><p>Ordinary dot product</p><pre><code>coo_matrix.dot(other)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.dot.html
scipy sparse coo_matrix dot	R	scipy.sparse.coo_matrix.dot										
scipy sparse.coo_matrix.dot	R	scipy.sparse.coo_matrix.dot										
scipy.sparse.coo_matrix.eliminate_zeros	A										<section class="prog__container"><p>Remove zero entries from the matrix</p><pre><code>coo_matrix.eliminate_zeros()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.eliminate_zeros.html
scipy sparse coo_matrix eliminate_zeros	R	scipy.sparse.coo_matrix.eliminate_zeros										
scipy sparse.coo_matrix.eliminate_zeros	R	scipy.sparse.coo_matrix.eliminate_zeros										
scipy.sparse.coo_matrix.expm1	A										<section class="prog__container"><p>Element-wise expm1.</p><pre><code>coo_matrix.expm1()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.expm1.html
scipy sparse coo_matrix expm1	R	scipy.sparse.coo_matrix.expm1										
scipy sparse.coo_matrix.expm1	R	scipy.sparse.coo_matrix.expm1										
scipy.sparse.coo_matrix.floor	A										<section class="prog__container"><p>Element-wise floor.</p><pre><code>coo_matrix.floor()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.floor.html
scipy sparse coo_matrix floor	R	scipy.sparse.coo_matrix.floor										
scipy sparse.coo_matrix.floor	R	scipy.sparse.coo_matrix.floor										
scipy.sparse.coo_matrix.getcol	A										<section class="prog__container"><p>Returns a copy of column j of the matrix, as an (m x 1) sparse\nmatrix (column vector).</p><pre><code>coo_matrix.getcol(j)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.getcol.html
scipy sparse coo_matrix getcol	R	scipy.sparse.coo_matrix.getcol										
scipy sparse.coo_matrix.getcol	R	scipy.sparse.coo_matrix.getcol										
scipy.sparse.coo_matrix.getnnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>coo_matrix.getnnz(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None, 0, or 1\n    Select between the number of values across the whole matrix, in each column, or in each row.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.getnnz.html
scipy sparse coo_matrix getnnz	R	scipy.sparse.coo_matrix.getnnz										
scipy sparse.coo_matrix.getnnz	R	scipy.sparse.coo_matrix.getnnz										
scipy.sparse.coo_matrix.getrow	A										<section class="prog__container"><p>Returns a copy of row i of the matrix, as a (1 x n) sparse\nmatrix (row vector).</p><pre><code>coo_matrix.getrow(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.getrow.html
scipy sparse coo_matrix getrow	R	scipy.sparse.coo_matrix.getrow										
scipy sparse.coo_matrix.getrow	R	scipy.sparse.coo_matrix.getrow										
scipy.sparse.coo_matrix.log1p	A										<section class="prog__container"><p>Element-wise log1p.</p><pre><code>coo_matrix.log1p()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.log1p.html
scipy sparse coo_matrix log1p	R	scipy.sparse.coo_matrix.log1p										
scipy sparse.coo_matrix.log1p	R	scipy.sparse.coo_matrix.log1p										
scipy.sparse.coo_matrix.max	A										<section class="prog__container"><p>Return the maximum of the matrix or maximum along an axis.\nThis takes all elements into account, not just the non-zero ones.</p><pre><code>coo_matrix.max(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the maximum over all the matrix elements, returning a scalar (i.e. axis = None). \nout : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : coo_matrix or scalar\n    Maximum of a. If axis is None, the result is a scalar value. If axis is given, the result is a sparse.coo_matrix of dimension a.ndim - 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.max.html
scipy sparse coo_matrix max	R	scipy.sparse.coo_matrix.max										
scipy sparse.coo_matrix.max	R	scipy.sparse.coo_matrix.max										
scipy.sparse.coo_matrix.mean	A										<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>coo_matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the mean is computed. The default is to compute the mean of all elements in the matrix (i.e. axis = None). \ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : np.matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.mean.html
scipy sparse coo_matrix mean	R	scipy.sparse.coo_matrix.mean										
scipy sparse.coo_matrix.mean	R	scipy.sparse.coo_matrix.mean										
scipy.sparse.coo_matrix.min	A										<section class="prog__container"><p>Return the minimum of the matrix or maximum along an axis.\nThis takes all elements into account, not just the non-zero ones.</p><pre><code>coo_matrix.min(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the minimum over all the matrix elements, returning a scalar (i.e. axis = None). \nout : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : coo_matrix or scalar\n    Minimum of a. If axis is None, the result is a scalar value. If axis is given, the result is a sparse.coo_matrix of dimension a.ndim - 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.min.html
scipy sparse coo_matrix min	R	scipy.sparse.coo_matrix.min										
scipy sparse.coo_matrix.min	R	scipy.sparse.coo_matrix.min										
scipy.sparse.coo_matrix.multiply	A										<section class="prog__container"><p>Point-wise multiplication by another matrix</p><pre><code>coo_matrix.multiply(other)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.multiply.html
scipy sparse coo_matrix multiply	R	scipy.sparse.coo_matrix.multiply										
scipy sparse.coo_matrix.multiply	R	scipy.sparse.coo_matrix.multiply										
scipy.sparse.coo_matrix.nnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>coo_matrix.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.nnz.html
scipy sparse coo_matrix nnz	R	scipy.sparse.coo_matrix.nnz										
scipy sparse.coo_matrix.nnz	R	scipy.sparse.coo_matrix.nnz										
scipy.sparse.coo_matrix.nonzero	A										<section class="prog__container"><p>nonzero indices</p><pre><code>coo_matrix.nonzero()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])\n>>> A.nonzero()\n(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.nonzero.html
scipy sparse coo_matrix nonzero	R	scipy.sparse.coo_matrix.nonzero										
scipy sparse.coo_matrix.nonzero	R	scipy.sparse.coo_matrix.nonzero										
scipy.sparse.coo_matrix.power	A										<section class="prog__container"><p>This function performs element-wise power.</p><pre><code>coo_matrix.power(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : n is a scalar\ndtype : If dtype is not specified, the current dtype will be preserved.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.power.html
scipy sparse coo_matrix power	R	scipy.sparse.coo_matrix.power										
scipy sparse.coo_matrix.power	R	scipy.sparse.coo_matrix.power										
scipy.sparse.coo_matrix.rad2deg	A										<section class="prog__container"><p>Element-wise rad2deg.</p><pre><code>coo_matrix.rad2deg()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.rad2deg.html
scipy sparse coo_matrix rad2deg	R	scipy.sparse.coo_matrix.rad2deg										
scipy sparse.coo_matrix.rad2deg	R	scipy.sparse.coo_matrix.rad2deg										
scipy.sparse.coo_matrix.reshape	A										<section class="prog__container"><p>Gives a new shape to a sparse matrix without changing its data.</p><pre><code>coo_matrix.reshape(shape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : length-2 tuple of ints\n    The new shape should be compatible with the original shape. \norder : ‘C’, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_matrix : self with the new dimensions of shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.reshape.html
scipy sparse coo_matrix reshape	R	scipy.sparse.coo_matrix.reshape										
scipy sparse.coo_matrix.reshape	R	scipy.sparse.coo_matrix.reshape										
scipy.sparse.coo_matrix.rint	A										<section class="prog__container"><p>Element-wise rint.</p><pre><code>coo_matrix.rint()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.rint.html
scipy sparse coo_matrix rint	R	scipy.sparse.coo_matrix.rint										
scipy sparse.coo_matrix.rint	R	scipy.sparse.coo_matrix.rint										
scipy sparse coo_matrix	R	scipy.sparse.coo_matrix										
scipy sparse.coo_matrix	R	scipy.sparse.coo_matrix										
scipy.sparse.coo_matrix.setdiag	A										<section class="prog__container"><p>Set diagonal or off-diagonal elements of the array.</p><pre><code>coo_matrix.setdiag(values, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    New values of the diagonal elements. Values may have any length.  If the diagonal is longer than values, then the remaining diagonal entries will not be set.  If values if longer than the diagonal, then the remaining values are ignored. If a scalar value is given, all of the diagonal is set to it. \nk : int, optional\n    Which off-diagonal to set, corresponding to elements a[i,i+k]. Default: 0 (the main diagonal).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.setdiag.html
scipy sparse coo_matrix setdiag	R	scipy.sparse.coo_matrix.setdiag										
scipy sparse.coo_matrix.setdiag	R	scipy.sparse.coo_matrix.setdiag										
scipy.sparse.coo_matrix.sign	A										<section class="prog__container"><p>Element-wise sign.</p><pre><code>coo_matrix.sign()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.sign.html
scipy sparse coo_matrix sign	R	scipy.sparse.coo_matrix.sign										
scipy sparse.coo_matrix.sign	R	scipy.sparse.coo_matrix.sign										
scipy.sparse.coo_matrix.sin	A										<section class="prog__container"><p>Element-wise sin.</p><pre><code>coo_matrix.sin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.sin.html
scipy.sparse.coo_matrix.sinh	A										<section class="prog__container"><p>Element-wise sinh.</p><pre><code>coo_matrix.sinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.sinh.html
scipy sparse coo_matrix sinh	R	scipy.sparse.coo_matrix.sinh										
scipy sparse.coo_matrix.sinh	R	scipy.sparse.coo_matrix.sinh										
scipy sparse coo_matrix sin	R	scipy.sparse.coo_matrix.sin										
scipy sparse.coo_matrix.sin	R	scipy.sparse.coo_matrix.sin										
scipy.sparse.coo_matrix.sqrt	A										<section class="prog__container"><p>Element-wise sqrt.</p><pre><code>coo_matrix.sqrt()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.sqrt.html
scipy sparse coo_matrix sqrt	R	scipy.sparse.coo_matrix.sqrt										
scipy sparse.coo_matrix.sqrt	R	scipy.sparse.coo_matrix.sqrt										
scipy.sparse.coo_matrix.sum	A										<section class="prog__container"><p>Sum the matrix elements over a given axis.</p><pre><code>coo_matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the sum of all the matrix elements, returning a scalar (i.e. axis = None). \ndtype : dtype, optional\n    The type of the returned matrix and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : np.matrix\n    A matrix with the same shape as self, with the specified axis removed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.sum.html
scipy.sparse.coo_matrix.sum_duplicates	A										<section class="prog__container"><p>Eliminate duplicate matrix entries by adding them together</p><pre><code>coo_matrix.sum_duplicates()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.sum_duplicates.html
scipy sparse coo_matrix sum_duplicates	R	scipy.sparse.coo_matrix.sum_duplicates										
scipy sparse.coo_matrix.sum_duplicates	R	scipy.sparse.coo_matrix.sum_duplicates										
scipy sparse coo_matrix sum	R	scipy.sparse.coo_matrix.sum										
scipy sparse.coo_matrix.sum	R	scipy.sparse.coo_matrix.sum										
scipy.sparse.coo_matrix.tan	A										<section class="prog__container"><p>Element-wise tan.</p><pre><code>coo_matrix.tan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.tan.html
scipy.sparse.coo_matrix.tanh	A										<section class="prog__container"><p>Element-wise tanh.</p><pre><code>coo_matrix.tanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.tanh.html
scipy sparse coo_matrix tanh	R	scipy.sparse.coo_matrix.tanh										
scipy sparse.coo_matrix.tanh	R	scipy.sparse.coo_matrix.tanh										
scipy sparse coo_matrix tan	R	scipy.sparse.coo_matrix.tan										
scipy sparse.coo_matrix.tan	R	scipy.sparse.coo_matrix.tan										
scipy.sparse.coo_matrix.toarray	A										<section class="prog__container"><p>See the docstring for spmatrix.toarray.</p><pre><code>coo_matrix.toarray(order=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.toarray.html
scipy sparse coo_matrix toarray	R	scipy.sparse.coo_matrix.toarray										
scipy sparse.coo_matrix.toarray	R	scipy.sparse.coo_matrix.toarray										
scipy.sparse.coo_matrix.tobsr	A										<section class="prog__container"><p>Convert this matrix to Block Sparse Row format.</p><pre><code>coo_matrix.tobsr(blocksize=None, copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.tobsr.html
scipy sparse coo_matrix tobsr	R	scipy.sparse.coo_matrix.tobsr										
scipy sparse.coo_matrix.tobsr	R	scipy.sparse.coo_matrix.tobsr										
scipy.sparse.coo_matrix.tocoo	A										<section class="prog__container"><p>Convert this matrix to COOrdinate format.</p><pre><code>coo_matrix.tocoo(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.tocoo.html
scipy sparse coo_matrix tocoo	R	scipy.sparse.coo_matrix.tocoo										
scipy sparse.coo_matrix.tocoo	R	scipy.sparse.coo_matrix.tocoo										
scipy.sparse.coo_matrix.tocsc	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Column format</p><pre><code>coo_matrix.tocsc(copy=False)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import array\n>>> from scipy.sparse import coo_matrix\n>>> row  = array([0, 0, 1, 3, 1, 0, 0])\n>>> col  = array([0, 2, 1, 3, 1, 0, 0])\n>>> data = array([1, 1, 1, 1, 1, 1, 1])\n>>> A = coo_matrix((data, (row, col)), shape=(4, 4)).tocsc()\n>>> A.toarray()\narray([[3, 0, 1, 0],\n       [0, 2, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 1]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.tocsc.html
scipy sparse coo_matrix tocsc	R	scipy.sparse.coo_matrix.tocsc										
scipy sparse.coo_matrix.tocsc	R	scipy.sparse.coo_matrix.tocsc										
scipy.sparse.coo_matrix.tocsr	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Row format</p><pre><code>coo_matrix.tocsr(copy=False)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from numpy import array\n>>> from scipy.sparse import coo_matrix\n>>> row  = array([0, 0, 1, 3, 1, 0, 0])\n>>> col  = array([0, 2, 1, 3, 1, 0, 0])\n>>> data = array([1, 1, 1, 1, 1, 1, 1])\n>>> A = coo_matrix((data, (row, col)), shape=(4, 4)).tocsr()\n>>> A.toarray()\narray([[3, 0, 1, 0],\n       [0, 2, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 1]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.tocsr.html
scipy sparse coo_matrix tocsr	R	scipy.sparse.coo_matrix.tocsr										
scipy sparse.coo_matrix.tocsr	R	scipy.sparse.coo_matrix.tocsr										
scipy.sparse.coo_matrix.todense	A										<section class="prog__container"><p>Return a dense matrix representation of this matrix.</p><pre><code>coo_matrix.todense(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array (or numpy.matrix) as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : numpy.matrix, 2-dimensional\n    A NumPy matrix object with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed and was an array (rather than a numpy.matrix), it will be filled with the appropriate values and returned wrapped in a numpy.matrix object that shares the same memory.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.todense.html
scipy sparse coo_matrix todense	R	scipy.sparse.coo_matrix.todense										
scipy sparse.coo_matrix.todense	R	scipy.sparse.coo_matrix.todense										
scipy.sparse.coo_matrix.todia	A										<section class="prog__container"><p>Convert this matrix to sparse DIAgonal format.</p><pre><code>coo_matrix.todia(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.todia.html
scipy sparse coo_matrix todia	R	scipy.sparse.coo_matrix.todia										
scipy sparse.coo_matrix.todia	R	scipy.sparse.coo_matrix.todia										
scipy.sparse.coo_matrix.todok	A										<section class="prog__container"><p>Convert this matrix to Dictionary Of Keys format.</p><pre><code>coo_matrix.todok(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.todok.html
scipy sparse coo_matrix todok	R	scipy.sparse.coo_matrix.todok										
scipy sparse.coo_matrix.todok	R	scipy.sparse.coo_matrix.todok										
scipy.sparse.coo_matrix.tolil	A										<section class="prog__container"><p>Convert this matrix to LInked List format.</p><pre><code>coo_matrix.tolil(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.tolil.html
scipy sparse coo_matrix tolil	R	scipy.sparse.coo_matrix.tolil										
scipy sparse.coo_matrix.tolil	R	scipy.sparse.coo_matrix.tolil										
scipy.sparse.coo_matrix.transpose	A										<section class="prog__container"><p>Reverses the dimensions of the sparse matrix.</p><pre><code>coo_matrix.transpose(axes=None, copy=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value. \ncopy : bool, optional\n    Indicates whether or not attributes of self should be copied whenever possible. The degree to which attributes are copied varies depending on the type of sparse matrix being used.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : self with the dimensions reversed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.transpose.html
scipy sparse coo_matrix transpose	R	scipy.sparse.coo_matrix.transpose										
scipy sparse.coo_matrix.transpose	R	scipy.sparse.coo_matrix.transpose										
scipy.sparse.coo_matrix.trunc	A										<section class="prog__container"><p>Element-wise trunc.</p><pre><code>coo_matrix.trunc()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.trunc.html
scipy sparse coo_matrix trunc	R	scipy.sparse.coo_matrix.trunc										
scipy sparse.coo_matrix.trunc	R	scipy.sparse.coo_matrix.trunc										
scipy.sparse.csc_matrix.arcsin	A										<section class="prog__container"><p>Element-wise arcsin.</p><pre><code>csc_matrix.arcsin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.arcsin.html
scipy.sparse.csc_matrix.arcsinh	A										<section class="prog__container"><p>Element-wise arcsinh.</p><pre><code>csc_matrix.arcsinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.arcsinh.html
scipy sparse csc_matrix arcsinh	R	scipy.sparse.csc_matrix.arcsinh										
scipy sparse.csc_matrix.arcsinh	R	scipy.sparse.csc_matrix.arcsinh										
scipy sparse csc_matrix arcsin	R	scipy.sparse.csc_matrix.arcsin										
scipy sparse.csc_matrix.arcsin	R	scipy.sparse.csc_matrix.arcsin										
scipy.sparse.csc_matrix.arctan	A										<section class="prog__container"><p>Element-wise arctan.</p><pre><code>csc_matrix.arctan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.arctan.html
scipy.sparse.csc_matrix.arctanh	A										<section class="prog__container"><p>Element-wise arctanh.</p><pre><code>csc_matrix.arctanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.arctanh.html
scipy sparse csc_matrix arctanh	R	scipy.sparse.csc_matrix.arctanh										
scipy sparse.csc_matrix.arctanh	R	scipy.sparse.csc_matrix.arctanh										
scipy sparse csc_matrix arctan	R	scipy.sparse.csc_matrix.arctan										
scipy sparse.csc_matrix.arctan	R	scipy.sparse.csc_matrix.arctan										
scipy.sparse.csc_matrix	A										<section class="prog__container"><p>Compressed Sparse Column matrix</p><pre><code>class scipy.sparse.csc_matrix(arg1, shape=None, dtype=None, copy=False)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csc_matrix\n>>> csc_matrix((3, 4), dtype=np.int8).toarray()\narray([[0, 0, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 0]], dtype=int8)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.html
scipy.sparse.csc_matrix.asformat	A										<section class="prog__container"><p>Return this matrix in a given sparse format</p><pre><code>csc_matrix.asformat(format)</code></pre><span class="prog__sub">Parameters:</span><pre><code>format : {string, None}\n    desired sparse matrix format  None for no format conversion “csr” for csr_matrix format “csc” for csc_matrix format “lil” for lil_matrix format “dok” for dok_matrix format and so on</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.asformat.html
scipy sparse csc_matrix asformat	R	scipy.sparse.csc_matrix.asformat										
scipy sparse.csc_matrix.asformat	R	scipy.sparse.csc_matrix.asformat										
scipy.sparse.csc_matrix.asfptype	A										<section class="prog__container"><p>Upcast matrix to a floating point format (if necessary)</p><pre><code>csc_matrix.asfptype()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.asfptype.html
scipy sparse csc_matrix asfptype	R	scipy.sparse.csc_matrix.asfptype										
scipy sparse.csc_matrix.asfptype	R	scipy.sparse.csc_matrix.asfptype										
scipy.sparse.csc_matrix.ceil	A										<section class="prog__container"><p>Element-wise ceil.</p><pre><code>csc_matrix.ceil()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.ceil.html
scipy sparse csc_matrix ceil	R	scipy.sparse.csc_matrix.ceil										
scipy sparse.csc_matrix.ceil	R	scipy.sparse.csc_matrix.ceil										
scipy.sparse.csc_matrix.check_format	A										<section class="prog__container"><p>check whether the matrix format is valid</p><pre><code>csc_matrix.check_format(full_check=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>full_check : bool, optional\n    If True, rigorous check, O(N) operations. Otherwise basic check, O(1) operations (default True).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.check_format.html
scipy sparse csc_matrix check_format	R	scipy.sparse.csc_matrix.check_format										
scipy sparse.csc_matrix.check_format	R	scipy.sparse.csc_matrix.check_format										
scipy.sparse.csc_matrix.count_nonzero	A										<section class="prog__container"><p>Number of non-zero entries, equivalent to</p><pre><code>csc_matrix.count_nonzero()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.count_nonzero.html
scipy sparse csc_matrix count_nonzero	R	scipy.sparse.csc_matrix.count_nonzero										
scipy sparse.csc_matrix.count_nonzero	R	scipy.sparse.csc_matrix.count_nonzero										
scipy.sparse.csc_matrix.deg2rad	A										<section class="prog__container"><p>Element-wise deg2rad.</p><pre><code>csc_matrix.deg2rad()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.deg2rad.html
scipy sparse csc_matrix deg2rad	R	scipy.sparse.csc_matrix.deg2rad										
scipy sparse.csc_matrix.deg2rad	R	scipy.sparse.csc_matrix.deg2rad										
scipy.sparse.csc_matrix.diagonal	A										<section class="prog__container"><p>Returns the main diagonal of the matrix</p><pre><code>csc_matrix.diagonal()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.diagonal.html
scipy sparse csc_matrix diagonal	R	scipy.sparse.csc_matrix.diagonal										
scipy sparse.csc_matrix.diagonal	R	scipy.sparse.csc_matrix.diagonal										
scipy.sparse.csc_matrix.dot	A										<section class="prog__container"><p>Ordinary dot product</p><pre><code>csc_matrix.dot(other)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.dot.html
scipy sparse csc_matrix dot	R	scipy.sparse.csc_matrix.dot										
scipy sparse.csc_matrix.dot	R	scipy.sparse.csc_matrix.dot										
scipy.sparse.csc_matrix.eliminate_zeros	A										<section class="prog__container"><p>Remove zero entries from the matrix</p><pre><code>csc_matrix.eliminate_zeros()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.eliminate_zeros.html
scipy sparse csc_matrix eliminate_zeros	R	scipy.sparse.csc_matrix.eliminate_zeros										
scipy sparse.csc_matrix.eliminate_zeros	R	scipy.sparse.csc_matrix.eliminate_zeros										
scipy.sparse.csc_matrix.expm1	A										<section class="prog__container"><p>Element-wise expm1.</p><pre><code>csc_matrix.expm1()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.expm1.html
scipy sparse csc_matrix expm1	R	scipy.sparse.csc_matrix.expm1										
scipy sparse.csc_matrix.expm1	R	scipy.sparse.csc_matrix.expm1										
scipy.sparse.csc_matrix.floor	A										<section class="prog__container"><p>Element-wise floor.</p><pre><code>csc_matrix.floor()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.floor.html
scipy sparse csc_matrix floor	R	scipy.sparse.csc_matrix.floor										
scipy sparse.csc_matrix.floor	R	scipy.sparse.csc_matrix.floor										
scipy.sparse.csc_matrix.getcol	A										<section class="prog__container"><p>Returns a copy of column i of the matrix, as a (m x 1)\nCSC matrix (column vector).</p><pre><code>csc_matrix.getcol(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.getcol.html
scipy sparse csc_matrix getcol	R	scipy.sparse.csc_matrix.getcol										
scipy sparse.csc_matrix.getcol	R	scipy.sparse.csc_matrix.getcol										
scipy.sparse.csc_matrix.getnnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>csc_matrix.getnnz(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None, 0, or 1\n    Select between the number of values across the whole matrix, in each column, or in each row.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.getnnz.html
scipy sparse csc_matrix getnnz	R	scipy.sparse.csc_matrix.getnnz										
scipy sparse.csc_matrix.getnnz	R	scipy.sparse.csc_matrix.getnnz										
scipy.sparse.csc_matrix.getrow	A										<section class="prog__container"><p>Returns a copy of row i of the matrix, as a (1 x n)\nCSR matrix (row vector).</p><pre><code>csc_matrix.getrow(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.getrow.html
scipy sparse csc_matrix getrow	R	scipy.sparse.csc_matrix.getrow										
scipy sparse.csc_matrix.getrow	R	scipy.sparse.csc_matrix.getrow										
scipy.sparse.csc_matrix.has_canonical_format	A										<section class="prog__container"><p>Determine whether the matrix has sorted indices and no duplicates</p><pre><code>csc_matrix.has_canonical_format</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.has_canonical_format.html
scipy sparse csc_matrix has_canonical_format	R	scipy.sparse.csc_matrix.has_canonical_format										
scipy sparse.csc_matrix.has_canonical_format	R	scipy.sparse.csc_matrix.has_canonical_format										
scipy.sparse.csc_matrix.has_sorted_indices	A										<section class="prog__container"><p>Determine whether the matrix has sorted indices</p><pre><code>csc_matrix.has_sorted_indices</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.has_sorted_indices.html
scipy sparse csc_matrix has_sorted_indices	R	scipy.sparse.csc_matrix.has_sorted_indices										
scipy sparse.csc_matrix.has_sorted_indices	R	scipy.sparse.csc_matrix.has_sorted_indices										
scipy.sparse.csc_matrix.log1p	A										<section class="prog__container"><p>Element-wise log1p.</p><pre><code>csc_matrix.log1p()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.log1p.html
scipy sparse csc_matrix log1p	R	scipy.sparse.csc_matrix.log1p										
scipy sparse.csc_matrix.log1p	R	scipy.sparse.csc_matrix.log1p										
scipy.sparse.csc_matrix.max	A										<section class="prog__container"><p>Return the maximum of the matrix or maximum along an axis.\nThis takes all elements into account, not just the non-zero ones.</p><pre><code>csc_matrix.max(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the maximum over all the matrix elements, returning a scalar (i.e. axis = None). \nout : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : coo_matrix or scalar\n    Maximum of a. If axis is None, the result is a scalar value. If axis is given, the result is a sparse.coo_matrix of dimension a.ndim - 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.max.html
scipy sparse csc_matrix max	R	scipy.sparse.csc_matrix.max										
scipy sparse.csc_matrix.max	R	scipy.sparse.csc_matrix.max										
scipy.sparse.csc_matrix.mean	A										<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>csc_matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the mean is computed. The default is to compute the mean of all elements in the matrix (i.e. axis = None). \ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : np.matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.mean.html
scipy sparse csc_matrix mean	R	scipy.sparse.csc_matrix.mean										
scipy sparse.csc_matrix.mean	R	scipy.sparse.csc_matrix.mean										
scipy.sparse.csc_matrix.min	A										<section class="prog__container"><p>Return the minimum of the matrix or maximum along an axis.\nThis takes all elements into account, not just the non-zero ones.</p><pre><code>csc_matrix.min(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the minimum over all the matrix elements, returning a scalar (i.e. axis = None). \nout : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : coo_matrix or scalar\n    Minimum of a. If axis is None, the result is a scalar value. If axis is given, the result is a sparse.coo_matrix of dimension a.ndim - 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.min.html
scipy sparse csc_matrix min	R	scipy.sparse.csc_matrix.min										
scipy sparse.csc_matrix.min	R	scipy.sparse.csc_matrix.min										
scipy.sparse.csc_matrix.multiply	A										<section class="prog__container"><p>Point-wise multiplication by another matrix, vector, or\nscalar.</p><pre><code>csc_matrix.multiply(other)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.multiply.html
scipy sparse csc_matrix multiply	R	scipy.sparse.csc_matrix.multiply										
scipy sparse.csc_matrix.multiply	R	scipy.sparse.csc_matrix.multiply										
scipy.sparse.csc_matrix.nnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>csc_matrix.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.nnz.html
scipy sparse csc_matrix nnz	R	scipy.sparse.csc_matrix.nnz										
scipy sparse.csc_matrix.nnz	R	scipy.sparse.csc_matrix.nnz										
scipy.sparse.csc_matrix.nonzero	A										<section class="prog__container"><p>nonzero indices</p><pre><code>csc_matrix.nonzero()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])\n>>> A.nonzero()\n(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.nonzero.html
scipy sparse csc_matrix nonzero	R	scipy.sparse.csc_matrix.nonzero										
scipy sparse.csc_matrix.nonzero	R	scipy.sparse.csc_matrix.nonzero										
scipy.sparse.csc_matrix.power	A										<section class="prog__container"><p>This function performs element-wise power.</p><pre><code>csc_matrix.power(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : n is a scalar\ndtype : If dtype is not specified, the current dtype will be preserved.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.power.html
scipy sparse csc_matrix power	R	scipy.sparse.csc_matrix.power										
scipy sparse.csc_matrix.power	R	scipy.sparse.csc_matrix.power										
scipy.sparse.csc_matrix.prune	A										<section class="prog__container"><p>Remove empty space after all non-zero elements.</p><pre><code>csc_matrix.prune()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.prune.html
scipy sparse csc_matrix prune	R	scipy.sparse.csc_matrix.prune										
scipy sparse.csc_matrix.prune	R	scipy.sparse.csc_matrix.prune										
scipy.sparse.csc_matrix.rad2deg	A										<section class="prog__container"><p>Element-wise rad2deg.</p><pre><code>csc_matrix.rad2deg()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.rad2deg.html
scipy sparse csc_matrix rad2deg	R	scipy.sparse.csc_matrix.rad2deg										
scipy sparse.csc_matrix.rad2deg	R	scipy.sparse.csc_matrix.rad2deg										
scipy.sparse.csc_matrix.reshape	A										<section class="prog__container"><p>Gives a new shape to a sparse matrix without changing its data.</p><pre><code>csc_matrix.reshape(shape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : length-2 tuple of ints\n    The new shape should be compatible with the original shape. \norder : ‘C’, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_matrix : self with the new dimensions of shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.reshape.html
scipy sparse csc_matrix reshape	R	scipy.sparse.csc_matrix.reshape										
scipy sparse.csc_matrix.reshape	R	scipy.sparse.csc_matrix.reshape										
scipy.sparse.csc_matrix.rint	A										<section class="prog__container"><p>Element-wise rint.</p><pre><code>csc_matrix.rint()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.rint.html
scipy sparse csc_matrix rint	R	scipy.sparse.csc_matrix.rint										
scipy sparse.csc_matrix.rint	R	scipy.sparse.csc_matrix.rint										
scipy sparse csc_matrix	R	scipy.sparse.csc_matrix										
scipy sparse.csc_matrix	R	scipy.sparse.csc_matrix										
scipy.sparse.csc_matrix.setdiag	A										<section class="prog__container"><p>Set diagonal or off-diagonal elements of the array.</p><pre><code>csc_matrix.setdiag(values, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    New values of the diagonal elements. Values may have any length.  If the diagonal is longer than values, then the remaining diagonal entries will not be set.  If values if longer than the diagonal, then the remaining values are ignored. If a scalar value is given, all of the diagonal is set to it. \nk : int, optional\n    Which off-diagonal to set, corresponding to elements a[i,i+k]. Default: 0 (the main diagonal).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.setdiag.html
scipy sparse csc_matrix setdiag	R	scipy.sparse.csc_matrix.setdiag										
scipy sparse.csc_matrix.setdiag	R	scipy.sparse.csc_matrix.setdiag										
scipy.sparse.csc_matrix.sign	A										<section class="prog__container"><p>Element-wise sign.</p><pre><code>csc_matrix.sign()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.sign.html
scipy sparse csc_matrix sign	R	scipy.sparse.csc_matrix.sign										
scipy sparse.csc_matrix.sign	R	scipy.sparse.csc_matrix.sign										
scipy.sparse.csc_matrix.sin	A										<section class="prog__container"><p>Element-wise sin.</p><pre><code>csc_matrix.sin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.sin.html
scipy.sparse.csc_matrix.sinh	A										<section class="prog__container"><p>Element-wise sinh.</p><pre><code>csc_matrix.sinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.sinh.html
scipy sparse csc_matrix sinh	R	scipy.sparse.csc_matrix.sinh										
scipy sparse.csc_matrix.sinh	R	scipy.sparse.csc_matrix.sinh										
scipy sparse csc_matrix sin	R	scipy.sparse.csc_matrix.sin										
scipy sparse.csc_matrix.sin	R	scipy.sparse.csc_matrix.sin										
scipy.sparse.csc_matrix.sorted_indices	A										<section class="prog__container"><p>Return a copy of this matrix with sorted indices</p><pre><code>csc_matrix.sorted_indices()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.sorted_indices.html
scipy sparse csc_matrix sorted_indices	R	scipy.sparse.csc_matrix.sorted_indices										
scipy sparse.csc_matrix.sorted_indices	R	scipy.sparse.csc_matrix.sorted_indices										
scipy.sparse.csc_matrix.sort_indices	A										<section class="prog__container"><p>Sort the indices of this matrix in place</p><pre><code>csc_matrix.sort_indices()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.sort_indices.html
scipy sparse csc_matrix sort_indices	R	scipy.sparse.csc_matrix.sort_indices										
scipy sparse.csc_matrix.sort_indices	R	scipy.sparse.csc_matrix.sort_indices										
scipy.sparse.csc_matrix.sqrt	A										<section class="prog__container"><p>Element-wise sqrt.</p><pre><code>csc_matrix.sqrt()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.sqrt.html
scipy sparse csc_matrix sqrt	R	scipy.sparse.csc_matrix.sqrt										
scipy sparse.csc_matrix.sqrt	R	scipy.sparse.csc_matrix.sqrt										
scipy.sparse.csc_matrix.sum	A										<section class="prog__container"><p>Sum the matrix elements over a given axis.</p><pre><code>csc_matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the sum of all the matrix elements, returning a scalar (i.e. axis = None). \ndtype : dtype, optional\n    The type of the returned matrix and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : np.matrix\n    A matrix with the same shape as self, with the specified axis removed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.sum.html
scipy.sparse.csc_matrix.sum_duplicates	A										<section class="prog__container"><p>Eliminate duplicate matrix entries by adding them together</p><pre><code>csc_matrix.sum_duplicates()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.sum_duplicates.html
scipy sparse csc_matrix sum_duplicates	R	scipy.sparse.csc_matrix.sum_duplicates										
scipy sparse.csc_matrix.sum_duplicates	R	scipy.sparse.csc_matrix.sum_duplicates										
scipy sparse csc_matrix sum	R	scipy.sparse.csc_matrix.sum										
scipy sparse.csc_matrix.sum	R	scipy.sparse.csc_matrix.sum										
scipy.sparse.csc_matrix.tan	A										<section class="prog__container"><p>Element-wise tan.</p><pre><code>csc_matrix.tan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.tan.html
scipy.sparse.csc_matrix.tanh	A										<section class="prog__container"><p>Element-wise tanh.</p><pre><code>csc_matrix.tanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.tanh.html
scipy sparse csc_matrix tanh	R	scipy.sparse.csc_matrix.tanh										
scipy sparse.csc_matrix.tanh	R	scipy.sparse.csc_matrix.tanh										
scipy sparse csc_matrix tan	R	scipy.sparse.csc_matrix.tan										
scipy sparse.csc_matrix.tan	R	scipy.sparse.csc_matrix.tan										
scipy.sparse.csc_matrix.toarray	A										<section class="prog__container"><p>See the docstring for spmatrix.toarray.</p><pre><code>csc_matrix.toarray(order=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.toarray.html
scipy sparse csc_matrix toarray	R	scipy.sparse.csc_matrix.toarray										
scipy sparse.csc_matrix.toarray	R	scipy.sparse.csc_matrix.toarray										
scipy.sparse.csc_matrix.tobsr	A										<section class="prog__container"><p>Convert this matrix to Block Sparse Row format.</p><pre><code>csc_matrix.tobsr(blocksize=None, copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.tobsr.html
scipy sparse csc_matrix tobsr	R	scipy.sparse.csc_matrix.tobsr										
scipy sparse.csc_matrix.tobsr	R	scipy.sparse.csc_matrix.tobsr										
scipy.sparse.csc_matrix.tocoo	A										<section class="prog__container"><p>Convert this matrix to COOrdinate format.</p><pre><code>csc_matrix.tocoo(copy=True)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.tocoo.html
scipy sparse csc_matrix tocoo	R	scipy.sparse.csc_matrix.tocoo										
scipy sparse.csc_matrix.tocoo	R	scipy.sparse.csc_matrix.tocoo										
scipy.sparse.csc_matrix.tocsc	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Column format.</p><pre><code>csc_matrix.tocsc(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.tocsc.html
scipy sparse csc_matrix tocsc	R	scipy.sparse.csc_matrix.tocsc										
scipy sparse.csc_matrix.tocsc	R	scipy.sparse.csc_matrix.tocsc										
scipy.sparse.csc_matrix.tocsr	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Row format.</p><pre><code>csc_matrix.tocsr(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.tocsr.html
scipy sparse csc_matrix tocsr	R	scipy.sparse.csc_matrix.tocsr										
scipy sparse.csc_matrix.tocsr	R	scipy.sparse.csc_matrix.tocsr										
scipy.sparse.csc_matrix.todense	A										<section class="prog__container"><p>Return a dense matrix representation of this matrix.</p><pre><code>csc_matrix.todense(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array (or numpy.matrix) as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : numpy.matrix, 2-dimensional\n    A NumPy matrix object with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed and was an array (rather than a numpy.matrix), it will be filled with the appropriate values and returned wrapped in a numpy.matrix object that shares the same memory.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.todense.html
scipy sparse csc_matrix todense	R	scipy.sparse.csc_matrix.todense										
scipy sparse.csc_matrix.todense	R	scipy.sparse.csc_matrix.todense										
scipy.sparse.csc_matrix.todia	A										<section class="prog__container"><p>Convert this matrix to sparse DIAgonal format.</p><pre><code>csc_matrix.todia(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.todia.html
scipy sparse csc_matrix todia	R	scipy.sparse.csc_matrix.todia										
scipy sparse.csc_matrix.todia	R	scipy.sparse.csc_matrix.todia										
scipy.sparse.csc_matrix.todok	A										<section class="prog__container"><p>Convert this matrix to Dictionary Of Keys format.</p><pre><code>csc_matrix.todok(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.todok.html
scipy sparse csc_matrix todok	R	scipy.sparse.csc_matrix.todok										
scipy sparse.csc_matrix.todok	R	scipy.sparse.csc_matrix.todok										
scipy.sparse.csc_matrix.tolil	A										<section class="prog__container"><p>Convert this matrix to LInked List format.</p><pre><code>csc_matrix.tolil(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.tolil.html
scipy sparse csc_matrix tolil	R	scipy.sparse.csc_matrix.tolil										
scipy sparse.csc_matrix.tolil	R	scipy.sparse.csc_matrix.tolil										
scipy.sparse.csc_matrix.transpose	A										<section class="prog__container"><p>Reverses the dimensions of the sparse matrix.</p><pre><code>csc_matrix.transpose(axes=None, copy=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value. \ncopy : bool, optional\n    Indicates whether or not attributes of self should be copied whenever possible. The degree to which attributes are copied varies depending on the type of sparse matrix being used.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : self with the dimensions reversed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.transpose.html
scipy sparse csc_matrix transpose	R	scipy.sparse.csc_matrix.transpose										
scipy sparse.csc_matrix.transpose	R	scipy.sparse.csc_matrix.transpose										
scipy.sparse.csc_matrix.trunc	A										<section class="prog__container"><p>Element-wise trunc.</p><pre><code>csc_matrix.trunc()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.trunc.html
scipy sparse csc_matrix trunc	R	scipy.sparse.csc_matrix.trunc										
scipy sparse.csc_matrix.trunc	R	scipy.sparse.csc_matrix.trunc										
scipy.sparse.csgraph.bellman_ford	A										<section class="prog__container"><p>Compute the shortest path lengths using the Bellman-Ford algorithm.</p><pre><code>scipy.sparse.csgraph.bellman_ford(csgraph, directed=True, indices=None, return_predecessors=False, unweighted=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array, matrix, or sparse matrix, 2 dimensions\n    The N x N array of distances representing the input graph. \ndirected : bool, optional\n    If True (default), then find the shortest path on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i] \nindices : array_like or int, optional\n    if specified, only compute the paths for the points at the given indices. \nreturn_predecessors : bool, optional\n    If True, return the size (N, N) predecesor matrix \nunweighted : bool, optional\n    If True, then find unweighted distances.  That is, rather than finding the path between each point such that the sum of weights is minimized, find the path such that the number of edges is minimized.</code></pre><span class="prog__sub">Returns:</span><pre><code>dist_matrix : ndarray\n    The N x N matrix of distances between graph nodes. dist_matrix[i,j] gives the shortest distance from point i to point j along the graph. \npredecessors : ndarray\n    Returned only if return_predecessors == True. The N x N matrix of predecessors, which can be used to reconstruct the shortest paths.  Row i of the predecessor matrix contains information on the shortest paths from point i: each entry predecessors[i, j] gives the index of the previous node in the path from point i to point j.  If no path exists between point i and j, then predecessors[i, j] = -9999</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.bellman_ford.html
scipy sparse csgraph bellman_ford	R	scipy.sparse.csgraph.bellman_ford										
scipy sparse.csgraph.bellman_ford	R	scipy.sparse.csgraph.bellman_ford										
scipy.sparse.csgraph.breadth_first_order	A										<section class="prog__container"><p>Return a breadth-first ordering starting with specified node.</p><pre><code>scipy.sparse.csgraph.breadth_first_order(csgraph, i_start, directed=True, return_predecessors=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array_like or sparse matrix\n    The N x N compressed sparse graph.  The input csgraph will be converted to csr format for the calculation. \ni_start : int\n    The index of starting node. \ndirected : bool, optional\n    If True (default), then operate on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i]. \nreturn_predecessors : bool, optional\n    If True (default), then return the predecesor array (see below).</code></pre><span class="prog__sub">Returns:</span><pre><code>node_array : ndarray, one dimension\n    The breadth-first list of nodes, starting with specified node.  The length of node_array is the number of nodes reachable from the specified node. \npredecessors : ndarray, one dimension\n    Returned only if return_predecessors is True. The length-N list of predecessors of each node in a breadth-first tree.  If node i is in the tree, then its parent is given by predecessors[i]. If node i is not in the tree (and for the parent node) then predecessors[i] = -9999.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.breadth_first_order.html
scipy sparse csgraph breadth_first_order	R	scipy.sparse.csgraph.breadth_first_order										
scipy sparse.csgraph.breadth_first_order	R	scipy.sparse.csgraph.breadth_first_order										
scipy.sparse.csgraph.breadth_first_tree	A										<section class="prog__container"><p>Return the tree generated by a breadth-first search</p><pre><code>scipy.sparse.csgraph.breadth_first_tree(csgraph, i_start, directed=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array_like or sparse matrix\n    The N x N matrix representing the compressed sparse graph.  The input csgraph will be converted to csr format for the calculation. \ni_start : int\n    The index of starting node. \ndirected : bool, optional\n    If True (default), then operate on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i].</code></pre><span class="prog__sub">Returns:</span><pre><code>cstree : csr matrix\n    The N x N directed compressed-sparse representation of the breadth- first tree drawn from csgraph, starting at the specified node.</code></pre><span class="prog__sub">Examples:</span><pre><code>input graph          breadth first tree from (0)\n\n     (0)                         (0)\n    /   \                       /   \\n   3     8                     3     8\n  /       \                   /       \\n(3)---5---(1)               (3)       (1)\n  \       /                           /\n   6     2                           2\n    \   /                           /\n     (2)                         (2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.breadth_first_tree.html
scipy sparse csgraph breadth_first_tree	R	scipy.sparse.csgraph.breadth_first_tree										
scipy sparse.csgraph.breadth_first_tree	R	scipy.sparse.csgraph.breadth_first_tree										
scipy.sparse.csgraph.connected_components	A										<section class="prog__container"><p>Analyze the connected components of a sparse graph</p><pre><code>scipy.sparse.csgraph.connected_components(csgraph, directed=True, connection='weak', return_labels=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array_like or sparse matrix\n    The N x N matrix representing the compressed sparse graph.  The input csgraph will be converted to csr format for the calculation. \ndirected : bool, optional\n    If True (default), then operate on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i]. \nconnection : str, optional\n    [‘weak’|’strong’].  For directed graphs, the type of connection to use.  Nodes i and j are strongly connected if a path exists both from i to j and from j to i.  Nodes i and j are weakly connected if only one of these paths exists.  If directed == False, this keyword is not referenced. \nreturn_labels : bool, optional\n    If True (default), then return the labels for each of the connected components.</code></pre><span class="prog__sub">Returns:</span><pre><code>n_components: int\n    The number of connected components. \nlabels: ndarray\n    The length-N array of labels of the connected components.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.connected_components.html
scipy sparse csgraph connected_components	R	scipy.sparse.csgraph.connected_components										
scipy sparse.csgraph.connected_components	R	scipy.sparse.csgraph.connected_components										
scipy.sparse.csgraph.construct_dist_matrix	A										<section class="prog__container"><p>Construct distance matrix from a predecessor matrix</p><pre><code>scipy.sparse.csgraph.construct_dist_matrix(graph, predecessors, directed=True, null_value=np.inf)</code></pre><span class="prog__sub">Parameters:</span><pre><code>graph : array_like or sparse\n    The N x N matrix representation of a directed or undirected graph. If dense, then non-edges are indicated by zeros or infinities. \npredecessors : array_like\n    The N x N matrix of predecessors of each node (see Notes below). \ndirected : bool, optional\n    If True (default), then operate on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then operate on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i]. \nnull_value : bool, optional\n    value to use for distances between unconnected nodes.  Default is np.inf</code></pre><span class="prog__sub">Returns:</span><pre><code>dist_matrix : ndarray\n    The N x N matrix of distances between nodes along the path specified by the predecessor matrix.  If no path exists, the distance is zero.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.construct_dist_matrix.html
scipy sparse csgraph construct_dist_matrix	R	scipy.sparse.csgraph.construct_dist_matrix										
scipy sparse.csgraph.construct_dist_matrix	R	scipy.sparse.csgraph.construct_dist_matrix										
scipy.sparse.csgraph.csgraph_from_dense	A										<section class="prog__container"><p>Construct a CSR-format sparse graph from a dense matrix.</p><pre><code>scipy.sparse.csgraph.csgraph_from_dense(graph, null_value=0, nan_null=True, infinity_null=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>graph : array_like\n    Input graph.  Shape should be (n_nodes, n_nodes). \nnull_value : float or None (optional)\n    Value that denotes non-edges in the graph.  Default is zero. \ninfinity_null : bool\n    If True (default), then infinite entries (both positive and negative) are treated as null edges. \nnan_null : bool\n    If True (default), then NaN entries are treated as non-edges</code></pre><span class="prog__sub">Returns:</span><pre><code>csgraph : csr_matrix\n    Compressed sparse representation of graph,</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.csgraph_from_dense.html
scipy sparse csgraph csgraph_from_dense	R	scipy.sparse.csgraph.csgraph_from_dense										
scipy sparse.csgraph.csgraph_from_dense	R	scipy.sparse.csgraph.csgraph_from_dense										
scipy.sparse.csgraph.csgraph_from_masked	A										<section class="prog__container"><p>Construct a CSR-format graph from a masked array.</p><pre><code>scipy.sparse.csgraph.csgraph_from_masked(graph)</code></pre><span class="prog__sub">Parameters:</span><pre><code>graph : MaskedArray\n    Input graph.  Shape should be (n_nodes, n_nodes).</code></pre><span class="prog__sub">Returns:</span><pre><code>csgraph : csr_matrix\n    Compressed sparse representation of graph,</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.csgraph_from_masked.html
scipy sparse csgraph csgraph_from_masked	R	scipy.sparse.csgraph.csgraph_from_masked										
scipy sparse.csgraph.csgraph_from_masked	R	scipy.sparse.csgraph.csgraph_from_masked										
scipy.sparse.csgraph.csgraph_masked_from_dense	A										<section class="prog__container"><p>Construct a masked array graph representation from a dense matrix.</p><pre><code>scipy.sparse.csgraph.csgraph_masked_from_dense(graph, null_value=0, nan_null=True, infinity_null=True, copy=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>graph : array_like\n    Input graph.  Shape should be (n_nodes, n_nodes). \nnull_value : float or None (optional)\n    Value that denotes non-edges in the graph.  Default is zero. \ninfinity_null : bool\n    If True (default), then infinite entries (both positive and negative) are treated as null edges. \nnan_null : bool\n    If True (default), then NaN entries are treated as non-edges</code></pre><span class="prog__sub">Returns:</span><pre><code>csgraph : MaskedArray\n    masked array representation of graph</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.csgraph_masked_from_dense.html
scipy sparse csgraph csgraph_masked_from_dense	R	scipy.sparse.csgraph.csgraph_masked_from_dense										
scipy sparse.csgraph.csgraph_masked_from_dense	R	scipy.sparse.csgraph.csgraph_masked_from_dense										
scipy.sparse.csgraph.csgraph_to_dense	A										<section class="prog__container"><p>Convert a sparse graph representation to a dense representation</p><pre><code>scipy.sparse.csgraph.csgraph_to_dense(csgraph, null_value=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : csr_matrix, csc_matrix, or lil_matrix\n    Sparse representation of a graph. \nnull_value : float, optional\n    The value used to indicate null edges in the dense representation. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>graph : ndarray\n    The dense representation of the sparse graph.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix, csgraph\n>>> data = np.array([2, 3])\n>>> indices = np.array([1, 1])\n>>> indptr = np.array([0, 2, 2])\n>>> M = csr_matrix((data, indices, indptr), shape=(2, 2))\n>>> M.toarray()\narray([[0, 5],\n       [0, 0]])\n>>> csgraph.csgraph_to_dense(M)\narray([[0., 2.],\n       [0., 0.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.csgraph_to_dense.html
scipy sparse csgraph csgraph_to_dense	R	scipy.sparse.csgraph.csgraph_to_dense										
scipy sparse.csgraph.csgraph_to_dense	R	scipy.sparse.csgraph.csgraph_to_dense										
scipy.sparse.csgraph.csgraph_to_masked	A										<section class="prog__container"><p>Convert a sparse graph representation to a masked array representation</p><pre><code>scipy.sparse.csgraph.csgraph_to_masked(csgraph)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : csr_matrix, csc_matrix, or lil_matrix\n    Sparse representation of a graph.</code></pre><span class="prog__sub">Returns:</span><pre><code>graph : MaskedArray\n    The masked dense representation of the sparse graph.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.csgraph_to_masked.html
scipy sparse csgraph csgraph_to_masked	R	scipy.sparse.csgraph.csgraph_to_masked										
scipy sparse.csgraph.csgraph_to_masked	R	scipy.sparse.csgraph.csgraph_to_masked										
scipy.sparse.csgraph.depth_first_order	A										<section class="prog__container"><p>Return a depth-first ordering starting with specified node.</p><pre><code>scipy.sparse.csgraph.depth_first_order(csgraph, i_start, directed=True, return_predecessors=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array_like or sparse matrix\n    The N x N compressed sparse graph.  The input csgraph will be converted to csr format for the calculation. \ni_start : int\n    The index of starting node. \ndirected : bool, optional\n    If True (default), then operate on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i]. \nreturn_predecessors : bool, optional\n    If True (default), then return the predecesor array (see below).</code></pre><span class="prog__sub">Returns:</span><pre><code>node_array : ndarray, one dimension\n    The breadth-first list of nodes, starting with specified node.  The length of node_array is the number of nodes reachable from the specified node. \npredecessors : ndarray, one dimension\n    Returned only if return_predecessors is True. The length-N list of predecessors of each node in a breadth-first tree.  If node i is in the tree, then its parent is given by predecessors[i]. If node i is not in the tree (and for the parent node) then predecessors[i] = -9999.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.depth_first_order.html
scipy sparse csgraph depth_first_order	R	scipy.sparse.csgraph.depth_first_order										
scipy sparse.csgraph.depth_first_order	R	scipy.sparse.csgraph.depth_first_order										
scipy.sparse.csgraph.depth_first_tree	A										<section class="prog__container"><p>Return a tree generated by a depth-first search.</p><pre><code>scipy.sparse.csgraph.depth_first_tree(csgraph, i_start, directed=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array_like or sparse matrix\n    The N x N matrix representing the compressed sparse graph.  The input csgraph will be converted to csr format for the calculation. \ni_start : int\n    The index of starting node. \ndirected : bool, optional\n    If True (default), then operate on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i].</code></pre><span class="prog__sub">Returns:</span><pre><code>cstree : csr matrix\n    The N x N directed compressed-sparse representation of the depth- first tree drawn from csgraph, starting at the specified node.</code></pre><span class="prog__sub">Examples:</span><pre><code>input graph           depth first tree from (0)\n\n     (0)                         (0)\n    /   \                           \\n   3     8                           8\n  /       \                           \\n(3)---5---(1)               (3)       (1)\n  \       /                   \       /\n   6     2                     6     2\n    \   /                       \   /\n     (2)                         (2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.depth_first_tree.html
scipy sparse csgraph depth_first_tree	R	scipy.sparse.csgraph.depth_first_tree										
scipy sparse.csgraph.depth_first_tree	R	scipy.sparse.csgraph.depth_first_tree										
scipy.sparse.csgraph.dijkstra	A										<section class="prog__container"><p>Dijkstra algorithm using Fibonacci Heaps</p><pre><code>scipy.sparse.csgraph.dijkstra(csgraph, directed=True, indices=None, return_predecessors=False, unweighted=False, limit=np.inf)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array, matrix, or sparse matrix, 2 dimensions\n    The N x N array of non-negative distances representing the input graph. \ndirected : bool, optional\n    If True (default), then find the shortest path on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i] \nindices : array_like or int, optional\n    if specified, only compute the paths for the points at the given indices. \nreturn_predecessors : bool, optional\n    If True, return the size (N, N) predecesor matrix \nunweighted : bool, optional\n    If True, then find unweighted distances.  That is, rather than finding the path between each point such that the sum of weights is minimized, find the path such that the number of edges is minimized. \nlimit : float, optional\n    The maximum distance to calculate, must be >= 0. Using a smaller limit will decrease computation time by aborting calculations between pairs that are separated by a distance > limit. For such pairs, the distance will be equal to np.inf (i.e., not connected).  New in version 0.14.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>dist_matrix : ndarray\n    The matrix of distances between graph nodes. dist_matrix[i,j] gives the shortest distance from point i to point j along the graph. \npredecessors : ndarray\n    Returned only if return_predecessors == True. The matrix of predecessors, which can be used to reconstruct the shortest paths.  Row i of the predecessor matrix contains information on the shortest paths from point i: each entry predecessors[i, j] gives the index of the previous node in the path from point i to point j.  If no path exists between point i and j, then predecessors[i, j] = -9999</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.dijkstra.html
scipy sparse csgraph dijkstra	R	scipy.sparse.csgraph.dijkstra										
scipy sparse.csgraph.dijkstra	R	scipy.sparse.csgraph.dijkstra										
scipy.sparse.csgraph.floyd_warshall	A										<section class="prog__container"><p>Compute the shortest path lengths using the Floyd-Warshall algorithm</p><pre><code>scipy.sparse.csgraph.floyd_warshall(csgraph, directed=True, return_predecessors=False, unweighted=False, overwrite=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array, matrix, or sparse matrix, 2 dimensions\n    The N x N array of distances representing the input graph. \ndirected : bool, optional\n    If True (default), then find the shortest path on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i] \nreturn_predecessors : bool, optional\n    If True, return the size (N, N) predecesor matrix \nunweighted : bool, optional\n    If True, then find unweighted distances.  That is, rather than finding the path between each point such that the sum of weights is minimized, find the path such that the number of edges is minimized. \noverwrite : bool, optional\n    If True, overwrite csgraph with the result.  This applies only if csgraph is a dense, c-ordered array with dtype=float64.</code></pre><span class="prog__sub">Returns:</span><pre><code>dist_matrix : ndarray\n    The N x N matrix of distances between graph nodes. dist_matrix[i,j] gives the shortest distance from point i to point j along the graph. \npredecessors : ndarray\n    Returned only if return_predecessors == True. The N x N matrix of predecessors, which can be used to reconstruct the shortest paths.  Row i of the predecessor matrix contains information on the shortest paths from point i: each entry predecessors[i, j] gives the index of the previous node in the path from point i to point j.  If no path exists between point i and j, then predecessors[i, j] = -9999</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.floyd_warshall.html
scipy sparse csgraph floyd_warshall	R	scipy.sparse.csgraph.floyd_warshall										
scipy sparse.csgraph.floyd_warshall	R	scipy.sparse.csgraph.floyd_warshall										
scipy.sparse.csgraph.johnson	A										<section class="prog__container"><p>Compute the shortest path lengths using Johnson’s algorithm.</p><pre><code>scipy.sparse.csgraph.johnson(csgraph, directed=True, indices=None, return_predecessors=False, unweighted=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array, matrix, or sparse matrix, 2 dimensions\n    The N x N array of distances representing the input graph. \ndirected : bool, optional\n    If True (default), then find the shortest path on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i] \nindices : array_like or int, optional\n    if specified, only compute the paths for the points at the given indices. \nreturn_predecessors : bool, optional\n    If True, return the size (N, N) predecesor matrix \nunweighted : bool, optional\n    If True, then find unweighted distances.  That is, rather than finding the path between each point such that the sum of weights is minimized, find the path such that the number of edges is minimized.</code></pre><span class="prog__sub">Returns:</span><pre><code>dist_matrix : ndarray\n    The N x N matrix of distances between graph nodes. dist_matrix[i,j] gives the shortest distance from point i to point j along the graph. \npredecessors : ndarray\n    Returned only if return_predecessors == True. The N x N matrix of predecessors, which can be used to reconstruct the shortest paths.  Row i of the predecessor matrix contains information on the shortest paths from point i: each entry predecessors[i, j] gives the index of the previous node in the path from point i to point j.  If no path exists between point i and j, then predecessors[i, j] = -9999</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.johnson.html
scipy sparse csgraph johnson	R	scipy.sparse.csgraph.johnson										
scipy sparse.csgraph.johnson	R	scipy.sparse.csgraph.johnson										
scipy.sparse.csgraph.laplacian	A										<section class="prog__container"><p>Return the Laplacian matrix of a directed graph.</p><pre><code>scipy.sparse.csgraph.laplacian(csgraph, normed=False, return_diag=False, use_out_degree=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array_like or sparse matrix, 2 dimensions\n    compressed-sparse graph, with shape (N, N). \nnormed : bool, optional\n    If True, then compute normalized Laplacian. \nreturn_diag : bool, optional\n    If True, then also return an array related to vertex degrees. \nuse_out_degree : bool, optional\n    If True, then use out-degree instead of in-degree. This distinction matters only if the graph is asymmetric. Default: False.</code></pre><span class="prog__sub">Returns:</span><pre><code>lap : ndarray or sparse matrix\n    The N x N laplacian matrix of csgraph. It will be a numpy array (dense) if the input was dense, or a sparse matrix otherwise. \ndiag : ndarray, optional\n    The length-N diagonal of the Laplacian matrix. For the normalized Laplacian, this is the array of square roots of vertex degrees or 1 if the degree is zero.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csgraph\n>>> G = np.arange(5) * np.arange(5)[:, np.newaxis]\n>>> G\narray([[ 0,  0,  0,  0,  0],\n       [ 0,  1,  2,  3,  4],\n       [ 0,  2,  4,  6,  8],\n       [ 0,  3,  6,  9, 12],\n       [ 0,  4,  8, 12, 16]])\n>>> csgraph.laplacian(G, normed=False)\narray([[  0,   0,   0,   0,   0],\n       [  0,   9,  -2,  -3,  -4],\n       [  0,  -2,  16,  -6,  -8],\n       [  0,  -3,  -6,  21, -12],\n       [  0,  -4,  -8, -12,  24]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.laplacian.html
scipy sparse csgraph laplacian	R	scipy.sparse.csgraph.laplacian										
scipy sparse.csgraph.laplacian	R	scipy.sparse.csgraph.laplacian										
scipy.sparse.csgraph.maximum_bipartite_matching	A										<section class="prog__container"><p>Returns an array of row or column permutations that makes\nthe diagonal of a nonsingular square CSC sparse matrix zero free.</p><pre><code>scipy.sparse.csgraph.maximum_bipartite_matching()</code></pre><span class="prog__sub">Parameters:</span><pre><code>graph : sparse matrix\n    Input sparse in CSC format \nperm_type : str, {‘row’, ‘column’}\n    Type of permutation to generate.</code></pre><span class="prog__sub">Returns:</span><pre><code>perm : ndarray\n    Array of row or column permutations.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.maximum_bipartite_matching.html
scipy sparse csgraph maximum_bipartite_matching	R	scipy.sparse.csgraph.maximum_bipartite_matching										
scipy sparse.csgraph.maximum_bipartite_matching	R	scipy.sparse.csgraph.maximum_bipartite_matching										
scipy.sparse.csgraph.minimum_spanning_tree	A										<section class="prog__container"><p>Return a minimum spanning tree of an undirected graph</p><pre><code>scipy.sparse.csgraph.minimum_spanning_tree(csgraph, overwrite=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array_like or sparse matrix, 2 dimensions\n    The N x N matrix representing an undirected graph over N nodes (see notes below). \noverwrite : bool, optional\n    if true, then parts of the input graph will be overwritten for efficiency.</code></pre><span class="prog__sub">Returns:</span><pre><code>span_tree : csr matrix\n    The N x N compressed-sparse representation of the undirected minimum spanning tree over the input (see notes below).</code></pre><span class="prog__sub">Examples:</span><pre><code>input graph             minimum spanning tree\n\n     (0)                         (0)\n    /   \                       /\n   3     8                     3\n  /       \                   /\n(3)---5---(1)               (3)---5---(1)\n  \       /                           /\n   6     2                           2\n    \   /                           /\n     (2)                         (2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.minimum_spanning_tree.html
scipy sparse csgraph minimum_spanning_tree	R	scipy.sparse.csgraph.minimum_spanning_tree										
scipy sparse.csgraph.minimum_spanning_tree	R	scipy.sparse.csgraph.minimum_spanning_tree										
scipy.sparse.csgraph.reconstruct_path	A										<section class="prog__container"><p>Construct a tree from a graph and a predecessor list.</p><pre><code>scipy.sparse.csgraph.reconstruct_path(csgraph, predecessors, directed=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array_like or sparse matrix\n    The N x N matrix representing the directed or undirected graph from which the predecessors are drawn. \npredecessors : array_like, one dimension\n    The length-N array of indices of predecessors for the tree.  The index of the parent of node i is given by predecessors[i]. \ndirected : bool, optional\n    If True (default), then operate on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then operate on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i].</code></pre><span class="prog__sub">Returns:</span><pre><code>cstree : csr matrix\n    The N x N directed compressed-sparse representation of the tree drawn from csgraph which is encoded by the predecessor list.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.reconstruct_path.html
scipy sparse csgraph reconstruct_path	R	scipy.sparse.csgraph.reconstruct_path										
scipy sparse.csgraph.reconstruct_path	R	scipy.sparse.csgraph.reconstruct_path										
scipy.sparse.csgraph.reverse_cuthill_mckee	A										<section class="prog__container"><p>Returns the permutation array that orders a sparse CSR or CSC matrix\nin Reverse-Cuthill McKee ordering.</p><pre><code>scipy.sparse.csgraph.reverse_cuthill_mckee()</code></pre><span class="prog__sub">Parameters:</span><pre><code>graph : sparse matrix\n    Input sparse in CSC or CSR sparse matrix format. \nsymmetric_mode : bool, optional\n    Is input matrix guaranteed to be symmetric.</code></pre><span class="prog__sub">Returns:</span><pre><code>perm : ndarray\n    Array of permuted row and column indices.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.reverse_cuthill_mckee.html
scipy sparse csgraph reverse_cuthill_mckee	R	scipy.sparse.csgraph.reverse_cuthill_mckee										
scipy sparse.csgraph.reverse_cuthill_mckee	R	scipy.sparse.csgraph.reverse_cuthill_mckee										
scipy.sparse.csgraph.shortest_path	A										<section class="prog__container"><p>Perform a shortest-path graph search on a positive directed or\nundirected graph.</p><pre><code>scipy.sparse.csgraph.shortest_path(csgraph, method='auto', directed=True, return_predecessors=False, unweighted=False, overwrite=False, indices=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>csgraph : array, matrix, or sparse matrix, 2 dimensions\n    The N x N array of distances representing the input graph. \nmethod : string [‘auto’|’FW’|’D’], optional\n    Algorithm to use for shortest paths.  Options are:   ‘auto’ – (default) select the best among ‘FW’, ‘D’, ‘BF’, or ‘J’ based on the input data.  ‘FW’   – Floyd-Warshall algorithm.  Computational cost is approximately O[N^3].  The input csgraph will be converted to a dense representation.  ‘D’    – Dijkstra’s algorithm with Fibonacci heaps.  Computational cost is approximately O[N(N*k + N*log(N))], where k is the average number of connected edges per node. The input csgraph will be converted to a csr representation.  ‘BF’   – Bellman-Ford algorithm.  This algorithm can be used when weights are negative.  If a negative cycle is encountered, an error will be raised.  Computational cost is approximately O[N(N^2 k)], where k is the average number of connected edges per node. The input csgraph will be converted to a csr representation.  ‘J’    – Johnson’s algorithm.  Like the Bellman-Ford algorithm, Johnson’s algorithm is designed for use when the weights are negative.  It combines the Bellman-Ford algorithm with Dijkstra’s algorithm for faster computation.    \ndirected : bool, optional\n    If True (default), then find the shortest path on a directed graph: only move from point i to point j along paths csgraph[i, j]. If False, then find the shortest path on an undirected graph: the algorithm can progress from point i to j along csgraph[i, j] or csgraph[j, i] \nreturn_predecessors : bool, optional\n    If True, return the size (N, N) predecesor matrix \nunweighted : bool, optional\n    If True, then find unweighted distances.  That is, rather than finding the path between each point such that the sum of weights is minimized, find the path such that the number of edges is minimized. \noverwrite : bool, optional\n    If True, overwrite csgraph with the result.  This applies only if method == ‘FW’ and csgraph is a dense, c-ordered array with dtype=float64. \nindices : array_like or int, optional\n    If specified, only compute the paths for the points at the given indices. Incompatible with method == ‘FW’.</code></pre><span class="prog__sub">Returns:</span><pre><code>dist_matrix : ndarray\n    The N x N matrix of distances between graph nodes. dist_matrix[i,j] gives the shortest distance from point i to point j along the graph. \npredecessors : ndarray\n    Returned only if return_predecessors == True. The N x N matrix of predecessors, which can be used to reconstruct the shortest paths.  Row i of the predecessor matrix contains information on the shortest paths from point i: each entry predecessors[i, j] gives the index of the previous node in the path from point i to point j.  If no path exists between point i and j, then predecessors[i, j] = -9999</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csgraph.shortest_path.html
scipy sparse csgraph shortest_path	R	scipy.sparse.csgraph.shortest_path										
scipy sparse.csgraph.shortest_path	R	scipy.sparse.csgraph.shortest_path										
scipy.sparse.csr_matrix.arcsin	A										<section class="prog__container"><p>Element-wise arcsin.</p><pre><code>csr_matrix.arcsin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.arcsin.html
scipy.sparse.csr_matrix.arcsinh	A										<section class="prog__container"><p>Element-wise arcsinh.</p><pre><code>csr_matrix.arcsinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.arcsinh.html
scipy sparse csr_matrix arcsinh	R	scipy.sparse.csr_matrix.arcsinh										
scipy sparse.csr_matrix.arcsinh	R	scipy.sparse.csr_matrix.arcsinh										
scipy sparse csr_matrix arcsin	R	scipy.sparse.csr_matrix.arcsin										
scipy sparse.csr_matrix.arcsin	R	scipy.sparse.csr_matrix.arcsin										
scipy.sparse.csr_matrix.arctan	A										<section class="prog__container"><p>Element-wise arctan.</p><pre><code>csr_matrix.arctan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.arctan.html
scipy.sparse.csr_matrix.arctanh	A										<section class="prog__container"><p>Element-wise arctanh.</p><pre><code>csr_matrix.arctanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.arctanh.html
scipy sparse csr_matrix arctanh	R	scipy.sparse.csr_matrix.arctanh										
scipy sparse.csr_matrix.arctanh	R	scipy.sparse.csr_matrix.arctanh										
scipy sparse csr_matrix arctan	R	scipy.sparse.csr_matrix.arctan										
scipy sparse.csr_matrix.arctan	R	scipy.sparse.csr_matrix.arctan										
scipy.sparse.csr_matrix	A										<section class="prog__container"><p>Compressed Sparse Row matrix</p><pre><code>class scipy.sparse.csr_matrix(arg1, shape=None, dtype=None, copy=False)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> csr_matrix((3, 4), dtype=np.int8).toarray()\narray([[0, 0, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 0]], dtype=int8)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html
scipy.sparse.csr_matrix.asformat	A										<section class="prog__container"><p>Return this matrix in a given sparse format</p><pre><code>csr_matrix.asformat(format)</code></pre><span class="prog__sub">Parameters:</span><pre><code>format : {string, None}\n    desired sparse matrix format  None for no format conversion “csr” for csr_matrix format “csc” for csc_matrix format “lil” for lil_matrix format “dok” for dok_matrix format and so on</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.asformat.html
scipy sparse csr_matrix asformat	R	scipy.sparse.csr_matrix.asformat										
scipy sparse.csr_matrix.asformat	R	scipy.sparse.csr_matrix.asformat										
scipy.sparse.csr_matrix.asfptype	A										<section class="prog__container"><p>Upcast matrix to a floating point format (if necessary)</p><pre><code>csr_matrix.asfptype()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.asfptype.html
scipy sparse csr_matrix asfptype	R	scipy.sparse.csr_matrix.asfptype										
scipy sparse.csr_matrix.asfptype	R	scipy.sparse.csr_matrix.asfptype										
scipy.sparse.csr_matrix.ceil	A										<section class="prog__container"><p>Element-wise ceil.</p><pre><code>csr_matrix.ceil()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.ceil.html
scipy sparse csr_matrix ceil	R	scipy.sparse.csr_matrix.ceil										
scipy sparse.csr_matrix.ceil	R	scipy.sparse.csr_matrix.ceil										
scipy.sparse.csr_matrix.check_format	A										<section class="prog__container"><p>check whether the matrix format is valid</p><pre><code>csr_matrix.check_format(full_check=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>full_check : bool, optional\n    If True, rigorous check, O(N) operations. Otherwise basic check, O(1) operations (default True).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.check_format.html
scipy sparse csr_matrix check_format	R	scipy.sparse.csr_matrix.check_format										
scipy sparse.csr_matrix.check_format	R	scipy.sparse.csr_matrix.check_format										
scipy.sparse.csr_matrix.count_nonzero	A										<section class="prog__container"><p>Number of non-zero entries, equivalent to</p><pre><code>csr_matrix.count_nonzero()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.count_nonzero.html
scipy sparse csr_matrix count_nonzero	R	scipy.sparse.csr_matrix.count_nonzero										
scipy sparse.csr_matrix.count_nonzero	R	scipy.sparse.csr_matrix.count_nonzero										
scipy.sparse.csr_matrix.deg2rad	A										<section class="prog__container"><p>Element-wise deg2rad.</p><pre><code>csr_matrix.deg2rad()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.deg2rad.html
scipy sparse csr_matrix deg2rad	R	scipy.sparse.csr_matrix.deg2rad										
scipy sparse.csr_matrix.deg2rad	R	scipy.sparse.csr_matrix.deg2rad										
scipy.sparse.csr_matrix.diagonal	A										<section class="prog__container"><p>Returns the main diagonal of the matrix</p><pre><code>csr_matrix.diagonal()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.diagonal.html
scipy sparse csr_matrix diagonal	R	scipy.sparse.csr_matrix.diagonal										
scipy sparse.csr_matrix.diagonal	R	scipy.sparse.csr_matrix.diagonal										
scipy.sparse.csr_matrix.dot	A										<section class="prog__container"><p>Ordinary dot product</p><pre><code>csr_matrix.dot(other)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.dot.html
scipy sparse csr_matrix dot	R	scipy.sparse.csr_matrix.dot										
scipy sparse.csr_matrix.dot	R	scipy.sparse.csr_matrix.dot										
scipy.sparse.csr_matrix.eliminate_zeros	A										<section class="prog__container"><p>Remove zero entries from the matrix</p><pre><code>csr_matrix.eliminate_zeros()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.eliminate_zeros.html
scipy sparse csr_matrix eliminate_zeros	R	scipy.sparse.csr_matrix.eliminate_zeros										
scipy sparse.csr_matrix.eliminate_zeros	R	scipy.sparse.csr_matrix.eliminate_zeros										
scipy.sparse.csr_matrix.expm1	A										<section class="prog__container"><p>Element-wise expm1.</p><pre><code>csr_matrix.expm1()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.expm1.html
scipy sparse csr_matrix expm1	R	scipy.sparse.csr_matrix.expm1										
scipy sparse.csr_matrix.expm1	R	scipy.sparse.csr_matrix.expm1										
scipy.sparse.csr_matrix.floor	A										<section class="prog__container"><p>Element-wise floor.</p><pre><code>csr_matrix.floor()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.floor.html
scipy sparse csr_matrix floor	R	scipy.sparse.csr_matrix.floor										
scipy sparse.csr_matrix.floor	R	scipy.sparse.csr_matrix.floor										
scipy.sparse.csr_matrix.getcol	A										<section class="prog__container"><p>Returns a copy of column i of the matrix, as a (m x 1)\nCSR matrix (column vector).</p><pre><code>csr_matrix.getcol(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.getcol.html
scipy sparse csr_matrix getcol	R	scipy.sparse.csr_matrix.getcol										
scipy sparse.csr_matrix.getcol	R	scipy.sparse.csr_matrix.getcol										
scipy.sparse.csr_matrix.getnnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>csr_matrix.getnnz(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None, 0, or 1\n    Select between the number of values across the whole matrix, in each column, or in each row.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.getnnz.html
scipy sparse csr_matrix getnnz	R	scipy.sparse.csr_matrix.getnnz										
scipy sparse.csr_matrix.getnnz	R	scipy.sparse.csr_matrix.getnnz										
scipy.sparse.csr_matrix.getrow	A										<section class="prog__container"><p>Returns a copy of row i of the matrix, as a (1 x n)\nCSR matrix (row vector).</p><pre><code>csr_matrix.getrow(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.getrow.html
scipy sparse csr_matrix getrow	R	scipy.sparse.csr_matrix.getrow										
scipy sparse.csr_matrix.getrow	R	scipy.sparse.csr_matrix.getrow										
scipy.sparse.csr_matrix.has_canonical_format	A										<section class="prog__container"><p>Determine whether the matrix has sorted indices and no duplicates</p><pre><code>csr_matrix.has_canonical_format</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.has_canonical_format.html
scipy sparse csr_matrix has_canonical_format	R	scipy.sparse.csr_matrix.has_canonical_format										
scipy sparse.csr_matrix.has_canonical_format	R	scipy.sparse.csr_matrix.has_canonical_format										
scipy.sparse.csr_matrix.has_sorted_indices	A										<section class="prog__container"><p>Determine whether the matrix has sorted indices</p><pre><code>csr_matrix.has_sorted_indices</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.has_sorted_indices.html
scipy sparse csr_matrix has_sorted_indices	R	scipy.sparse.csr_matrix.has_sorted_indices										
scipy sparse.csr_matrix.has_sorted_indices	R	scipy.sparse.csr_matrix.has_sorted_indices										
scipy.sparse.csr_matrix.log1p	A										<section class="prog__container"><p>Element-wise log1p.</p><pre><code>csr_matrix.log1p()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.log1p.html
scipy sparse csr_matrix log1p	R	scipy.sparse.csr_matrix.log1p										
scipy sparse.csr_matrix.log1p	R	scipy.sparse.csr_matrix.log1p										
scipy.sparse.csr_matrix.max	A										<section class="prog__container"><p>Return the maximum of the matrix or maximum along an axis.\nThis takes all elements into account, not just the non-zero ones.</p><pre><code>csr_matrix.max(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the maximum over all the matrix elements, returning a scalar (i.e. axis = None). \nout : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>amax : coo_matrix or scalar\n    Maximum of a. If axis is None, the result is a scalar value. If axis is given, the result is a sparse.coo_matrix of dimension a.ndim - 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.max.html
scipy sparse csr_matrix max	R	scipy.sparse.csr_matrix.max										
scipy sparse.csr_matrix.max	R	scipy.sparse.csr_matrix.max										
scipy.sparse.csr_matrix.mean	A										<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>csr_matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the mean is computed. The default is to compute the mean of all elements in the matrix (i.e. axis = None). \ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : np.matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.mean.html
scipy sparse csr_matrix mean	R	scipy.sparse.csr_matrix.mean										
scipy sparse.csr_matrix.mean	R	scipy.sparse.csr_matrix.mean										
scipy.sparse.csr_matrix.min	A										<section class="prog__container"><p>Return the minimum of the matrix or maximum along an axis.\nThis takes all elements into account, not just the non-zero ones.</p><pre><code>csr_matrix.min(axis=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the minimum over all the matrix elements, returning a scalar (i.e. axis = None). \nout : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>amin : coo_matrix or scalar\n    Minimum of a. If axis is None, the result is a scalar value. If axis is given, the result is a sparse.coo_matrix of dimension a.ndim - 1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.min.html
scipy sparse csr_matrix min	R	scipy.sparse.csr_matrix.min										
scipy sparse.csr_matrix.min	R	scipy.sparse.csr_matrix.min										
scipy.sparse.csr_matrix.multiply	A										<section class="prog__container"><p>Point-wise multiplication by another matrix, vector, or\nscalar.</p><pre><code>csr_matrix.multiply(other)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.multiply.html
scipy sparse csr_matrix multiply	R	scipy.sparse.csr_matrix.multiply										
scipy sparse.csr_matrix.multiply	R	scipy.sparse.csr_matrix.multiply										
scipy.sparse.csr_matrix.nnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>csr_matrix.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.nnz.html
scipy sparse csr_matrix nnz	R	scipy.sparse.csr_matrix.nnz										
scipy sparse.csr_matrix.nnz	R	scipy.sparse.csr_matrix.nnz										
scipy.sparse.csr_matrix.nonzero	A										<section class="prog__container"><p>nonzero indices</p><pre><code>csr_matrix.nonzero()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])\n>>> A.nonzero()\n(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.nonzero.html
scipy sparse csr_matrix nonzero	R	scipy.sparse.csr_matrix.nonzero										
scipy sparse.csr_matrix.nonzero	R	scipy.sparse.csr_matrix.nonzero										
scipy.sparse.csr_matrix.power	A										<section class="prog__container"><p>This function performs element-wise power.</p><pre><code>csr_matrix.power(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : n is a scalar\ndtype : If dtype is not specified, the current dtype will be preserved.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.power.html
scipy sparse csr_matrix power	R	scipy.sparse.csr_matrix.power										
scipy sparse.csr_matrix.power	R	scipy.sparse.csr_matrix.power										
scipy.sparse.csr_matrix.prune	A										<section class="prog__container"><p>Remove empty space after all non-zero elements.</p><pre><code>csr_matrix.prune()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.prune.html
scipy sparse csr_matrix prune	R	scipy.sparse.csr_matrix.prune										
scipy sparse.csr_matrix.prune	R	scipy.sparse.csr_matrix.prune										
scipy.sparse.csr_matrix.rad2deg	A										<section class="prog__container"><p>Element-wise rad2deg.</p><pre><code>csr_matrix.rad2deg()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.rad2deg.html
scipy sparse csr_matrix rad2deg	R	scipy.sparse.csr_matrix.rad2deg										
scipy sparse.csr_matrix.rad2deg	R	scipy.sparse.csr_matrix.rad2deg										
scipy.sparse.csr_matrix.reshape	A										<section class="prog__container"><p>Gives a new shape to a sparse matrix without changing its data.</p><pre><code>csr_matrix.reshape(shape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : length-2 tuple of ints\n    The new shape should be compatible with the original shape. \norder : ‘C’, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_matrix : self with the new dimensions of shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.reshape.html
scipy sparse csr_matrix reshape	R	scipy.sparse.csr_matrix.reshape										
scipy sparse.csr_matrix.reshape	R	scipy.sparse.csr_matrix.reshape										
scipy.sparse.csr_matrix.rint	A										<section class="prog__container"><p>Element-wise rint.</p><pre><code>csr_matrix.rint()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.rint.html
scipy sparse csr_matrix rint	R	scipy.sparse.csr_matrix.rint										
scipy sparse.csr_matrix.rint	R	scipy.sparse.csr_matrix.rint										
scipy sparse csr_matrix	R	scipy.sparse.csr_matrix										
scipy sparse.csr_matrix	R	scipy.sparse.csr_matrix										
scipy.sparse.csr_matrix.setdiag	A										<section class="prog__container"><p>Set diagonal or off-diagonal elements of the array.</p><pre><code>csr_matrix.setdiag(values, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    New values of the diagonal elements. Values may have any length.  If the diagonal is longer than values, then the remaining diagonal entries will not be set.  If values if longer than the diagonal, then the remaining values are ignored. If a scalar value is given, all of the diagonal is set to it. \nk : int, optional\n    Which off-diagonal to set, corresponding to elements a[i,i+k]. Default: 0 (the main diagonal).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.setdiag.html
scipy sparse csr_matrix setdiag	R	scipy.sparse.csr_matrix.setdiag										
scipy sparse.csr_matrix.setdiag	R	scipy.sparse.csr_matrix.setdiag										
scipy.sparse.csr_matrix.sign	A										<section class="prog__container"><p>Element-wise sign.</p><pre><code>csr_matrix.sign()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sign.html
scipy sparse csr_matrix sign	R	scipy.sparse.csr_matrix.sign										
scipy sparse.csr_matrix.sign	R	scipy.sparse.csr_matrix.sign										
scipy.sparse.csr_matrix.sin	A										<section class="prog__container"><p>Element-wise sin.</p><pre><code>csr_matrix.sin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sin.html
scipy.sparse.csr_matrix.sinh	A										<section class="prog__container"><p>Element-wise sinh.</p><pre><code>csr_matrix.sinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sinh.html
scipy sparse csr_matrix sinh	R	scipy.sparse.csr_matrix.sinh										
scipy sparse.csr_matrix.sinh	R	scipy.sparse.csr_matrix.sinh										
scipy sparse csr_matrix sin	R	scipy.sparse.csr_matrix.sin										
scipy sparse.csr_matrix.sin	R	scipy.sparse.csr_matrix.sin										
scipy.sparse.csr_matrix.sorted_indices	A										<section class="prog__container"><p>Return a copy of this matrix with sorted indices</p><pre><code>csr_matrix.sorted_indices()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sorted_indices.html
scipy sparse csr_matrix sorted_indices	R	scipy.sparse.csr_matrix.sorted_indices										
scipy sparse.csr_matrix.sorted_indices	R	scipy.sparse.csr_matrix.sorted_indices										
scipy.sparse.csr_matrix.sort_indices	A										<section class="prog__container"><p>Sort the indices of this matrix in place</p><pre><code>csr_matrix.sort_indices()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sort_indices.html
scipy sparse csr_matrix sort_indices	R	scipy.sparse.csr_matrix.sort_indices										
scipy sparse.csr_matrix.sort_indices	R	scipy.sparse.csr_matrix.sort_indices										
scipy.sparse.csr_matrix.sqrt	A										<section class="prog__container"><p>Element-wise sqrt.</p><pre><code>csr_matrix.sqrt()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sqrt.html
scipy sparse csr_matrix sqrt	R	scipy.sparse.csr_matrix.sqrt										
scipy sparse.csr_matrix.sqrt	R	scipy.sparse.csr_matrix.sqrt										
scipy.sparse.csr_matrix.sum	A										<section class="prog__container"><p>Sum the matrix elements over a given axis.</p><pre><code>csr_matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the sum of all the matrix elements, returning a scalar (i.e. axis = None). \ndtype : dtype, optional\n    The type of the returned matrix and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : np.matrix\n    A matrix with the same shape as self, with the specified axis removed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sum.html
scipy.sparse.csr_matrix.sum_duplicates	A										<section class="prog__container"><p>Eliminate duplicate matrix entries by adding them together</p><pre><code>csr_matrix.sum_duplicates()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.sum_duplicates.html
scipy sparse csr_matrix sum_duplicates	R	scipy.sparse.csr_matrix.sum_duplicates										
scipy sparse.csr_matrix.sum_duplicates	R	scipy.sparse.csr_matrix.sum_duplicates										
scipy sparse csr_matrix sum	R	scipy.sparse.csr_matrix.sum										
scipy sparse.csr_matrix.sum	R	scipy.sparse.csr_matrix.sum										
scipy.sparse.csr_matrix.tan	A										<section class="prog__container"><p>Element-wise tan.</p><pre><code>csr_matrix.tan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.tan.html
scipy.sparse.csr_matrix.tanh	A										<section class="prog__container"><p>Element-wise tanh.</p><pre><code>csr_matrix.tanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.tanh.html
scipy sparse csr_matrix tanh	R	scipy.sparse.csr_matrix.tanh										
scipy sparse.csr_matrix.tanh	R	scipy.sparse.csr_matrix.tanh										
scipy sparse csr_matrix tan	R	scipy.sparse.csr_matrix.tan										
scipy sparse.csr_matrix.tan	R	scipy.sparse.csr_matrix.tan										
scipy.sparse.csr_matrix.toarray	A										<section class="prog__container"><p>See the docstring for spmatrix.toarray.</p><pre><code>csr_matrix.toarray(order=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.toarray.html
scipy sparse csr_matrix toarray	R	scipy.sparse.csr_matrix.toarray										
scipy sparse.csr_matrix.toarray	R	scipy.sparse.csr_matrix.toarray										
scipy.sparse.csr_matrix.tobsr	A										<section class="prog__container"><p>Convert this matrix to Block Sparse Row format.</p><pre><code>csr_matrix.tobsr(blocksize=None, copy=True)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.tobsr.html
scipy sparse csr_matrix tobsr	R	scipy.sparse.csr_matrix.tobsr										
scipy sparse.csr_matrix.tobsr	R	scipy.sparse.csr_matrix.tobsr										
scipy.sparse.csr_matrix.tocoo	A										<section class="prog__container"><p>Convert this matrix to COOrdinate format.</p><pre><code>csr_matrix.tocoo(copy=True)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.tocoo.html
scipy sparse csr_matrix tocoo	R	scipy.sparse.csr_matrix.tocoo										
scipy sparse.csr_matrix.tocoo	R	scipy.sparse.csr_matrix.tocoo										
scipy.sparse.csr_matrix.tocsr	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Row format.</p><pre><code>csr_matrix.tocsr(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.tocsr.html
scipy sparse csr_matrix tocsr	R	scipy.sparse.csr_matrix.tocsr										
scipy sparse.csr_matrix.tocsr	R	scipy.sparse.csr_matrix.tocsr										
scipy.sparse.csr_matrix.todense	A										<section class="prog__container"><p>Return a dense matrix representation of this matrix.</p><pre><code>csr_matrix.todense(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array (or numpy.matrix) as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : numpy.matrix, 2-dimensional\n    A NumPy matrix object with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed and was an array (rather than a numpy.matrix), it will be filled with the appropriate values and returned wrapped in a numpy.matrix object that shares the same memory.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.todense.html
scipy sparse csr_matrix todense	R	scipy.sparse.csr_matrix.todense										
scipy sparse.csr_matrix.todense	R	scipy.sparse.csr_matrix.todense										
scipy.sparse.csr_matrix.todia	A										<section class="prog__container"><p>Convert this matrix to sparse DIAgonal format.</p><pre><code>csr_matrix.todia(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.todia.html
scipy sparse csr_matrix todia	R	scipy.sparse.csr_matrix.todia										
scipy sparse.csr_matrix.todia	R	scipy.sparse.csr_matrix.todia										
scipy.sparse.csr_matrix.todok	A										<section class="prog__container"><p>Convert this matrix to Dictionary Of Keys format.</p><pre><code>csr_matrix.todok(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.todok.html
scipy sparse csr_matrix todok	R	scipy.sparse.csr_matrix.todok										
scipy sparse.csr_matrix.todok	R	scipy.sparse.csr_matrix.todok										
scipy.sparse.csr_matrix.tolil	A										<section class="prog__container"><p>Convert this matrix to LInked List format.</p><pre><code>csr_matrix.tolil(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.tolil.html
scipy sparse csr_matrix tolil	R	scipy.sparse.csr_matrix.tolil										
scipy sparse.csr_matrix.tolil	R	scipy.sparse.csr_matrix.tolil										
scipy.sparse.csr_matrix.transpose	A										<section class="prog__container"><p>Reverses the dimensions of the sparse matrix.</p><pre><code>csr_matrix.transpose(axes=None, copy=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value. \ncopy : bool, optional\n    Indicates whether or not attributes of self should be copied whenever possible. The degree to which attributes are copied varies depending on the type of sparse matrix being used.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : self with the dimensions reversed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.transpose.html
scipy sparse csr_matrix transpose	R	scipy.sparse.csr_matrix.transpose										
scipy sparse.csr_matrix.transpose	R	scipy.sparse.csr_matrix.transpose										
scipy.sparse.csr_matrix.trunc	A										<section class="prog__container"><p>Element-wise trunc.</p><pre><code>csr_matrix.trunc()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.trunc.html
scipy sparse csr_matrix trunc	R	scipy.sparse.csr_matrix.trunc										
scipy sparse.csr_matrix.trunc	R	scipy.sparse.csr_matrix.trunc										
scipy.sparse.diags	A										<section class="prog__container"><p>Construct a sparse matrix from diagonals.</p><pre><code>scipy.sparse.diags(diagonals, offsets=0, shape=None, format=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>diagonals : sequence of array_like\n    Sequence of arrays containing the matrix diagonals, corresponding to offsets. \noffsets : sequence of int or an int, optional\n    Diagonals to set:  k = 0  the main diagonal (default) k > 0  the k-th upper diagonal k < 0  the k-th lower diagonal    \nshape : tuple of int, optional\n    Shape of the result. If omitted, a square matrix large enough to contain the diagonals is returned. \nformat : {“dia”, “csr”, “csc”, “lil”, ...}, optional\n    Matrix format of the result.  By default (format=None) an appropriate sparse matrix format is returned.  This choice is subject to change. \ndtype : dtype, optional\n    Data type of the matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>np.diag(diagonals[0], offsets[0])\n+ ...\n+ np.diag(diagonals[k], offsets[k])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.diags.html
scipy sparse diags	R	scipy.sparse.diags										
scipy sparse.diags	R	scipy.sparse.diags										
scipy.sparse.dia_matrix.arcsin	A										<section class="prog__container"><p>Element-wise arcsin.</p><pre><code>dia_matrix.arcsin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.arcsin.html
scipy.sparse.dia_matrix.arcsinh	A										<section class="prog__container"><p>Element-wise arcsinh.</p><pre><code>dia_matrix.arcsinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.arcsinh.html
scipy sparse dia_matrix arcsinh	R	scipy.sparse.dia_matrix.arcsinh										
scipy sparse.dia_matrix.arcsinh	R	scipy.sparse.dia_matrix.arcsinh										
scipy sparse dia_matrix arcsin	R	scipy.sparse.dia_matrix.arcsin										
scipy sparse.dia_matrix.arcsin	R	scipy.sparse.dia_matrix.arcsin										
scipy.sparse.dia_matrix.arctan	A										<section class="prog__container"><p>Element-wise arctan.</p><pre><code>dia_matrix.arctan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.arctan.html
scipy.sparse.dia_matrix.arctanh	A										<section class="prog__container"><p>Element-wise arctanh.</p><pre><code>dia_matrix.arctanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.arctanh.html
scipy sparse dia_matrix arctanh	R	scipy.sparse.dia_matrix.arctanh										
scipy sparse.dia_matrix.arctanh	R	scipy.sparse.dia_matrix.arctanh										
scipy sparse dia_matrix arctan	R	scipy.sparse.dia_matrix.arctan										
scipy sparse.dia_matrix.arctan	R	scipy.sparse.dia_matrix.arctan										
scipy.sparse.dia_matrix	A										<section class="prog__container"><p>Sparse matrix with DIAgonal storage</p><pre><code>class scipy.sparse.dia_matrix(arg1, shape=None, dtype=None, copy=False)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import dia_matrix\n>>> dia_matrix((3, 4), dtype=np.int8).toarray()\narray([[0, 0, 0, 0],\n       [0, 0, 0, 0],\n       [0, 0, 0, 0]], dtype=int8)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.html
scipy.sparse.dia_matrix.asformat	A										<section class="prog__container"><p>Return this matrix in a given sparse format</p><pre><code>dia_matrix.asformat(format)</code></pre><span class="prog__sub">Parameters:</span><pre><code>format : {string, None}\n    desired sparse matrix format  None for no format conversion “csr” for csr_matrix format “csc” for csc_matrix format “lil” for lil_matrix format “dok” for dok_matrix format and so on</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.asformat.html
scipy sparse dia_matrix asformat	R	scipy.sparse.dia_matrix.asformat										
scipy sparse.dia_matrix.asformat	R	scipy.sparse.dia_matrix.asformat										
scipy.sparse.dia_matrix.asfptype	A										<section class="prog__container"><p>Upcast matrix to a floating point format (if necessary)</p><pre><code>dia_matrix.asfptype()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.asfptype.html
scipy sparse dia_matrix asfptype	R	scipy.sparse.dia_matrix.asfptype										
scipy sparse.dia_matrix.asfptype	R	scipy.sparse.dia_matrix.asfptype										
scipy.sparse.dia_matrix.ceil	A										<section class="prog__container"><p>Element-wise ceil.</p><pre><code>dia_matrix.ceil()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.ceil.html
scipy sparse dia_matrix ceil	R	scipy.sparse.dia_matrix.ceil										
scipy sparse.dia_matrix.ceil	R	scipy.sparse.dia_matrix.ceil										
scipy.sparse.dia_matrix.count_nonzero	A										<section class="prog__container"><p>Number of non-zero entries, equivalent to</p><pre><code>dia_matrix.count_nonzero()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.count_nonzero.html
scipy sparse dia_matrix count_nonzero	R	scipy.sparse.dia_matrix.count_nonzero										
scipy sparse.dia_matrix.count_nonzero	R	scipy.sparse.dia_matrix.count_nonzero										
scipy.sparse.dia_matrix.deg2rad	A										<section class="prog__container"><p>Element-wise deg2rad.</p><pre><code>dia_matrix.deg2rad()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.deg2rad.html
scipy sparse dia_matrix deg2rad	R	scipy.sparse.dia_matrix.deg2rad										
scipy sparse.dia_matrix.deg2rad	R	scipy.sparse.dia_matrix.deg2rad										
scipy.sparse.dia_matrix.diagonal	A										<section class="prog__container"><p>Returns the main diagonal of the matrix</p><pre><code>dia_matrix.diagonal()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.diagonal.html
scipy sparse dia_matrix diagonal	R	scipy.sparse.dia_matrix.diagonal										
scipy sparse.dia_matrix.diagonal	R	scipy.sparse.dia_matrix.diagonal										
scipy.sparse.dia_matrix.dot	A										<section class="prog__container"><p>Ordinary dot product</p><pre><code>dia_matrix.dot(other)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.dot.html
scipy sparse dia_matrix dot	R	scipy.sparse.dia_matrix.dot										
scipy sparse.dia_matrix.dot	R	scipy.sparse.dia_matrix.dot										
scipy.sparse.dia_matrix.expm1	A										<section class="prog__container"><p>Element-wise expm1.</p><pre><code>dia_matrix.expm1()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.expm1.html
scipy sparse dia_matrix expm1	R	scipy.sparse.dia_matrix.expm1										
scipy sparse.dia_matrix.expm1	R	scipy.sparse.dia_matrix.expm1										
scipy.sparse.dia_matrix.floor	A										<section class="prog__container"><p>Element-wise floor.</p><pre><code>dia_matrix.floor()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.floor.html
scipy sparse dia_matrix floor	R	scipy.sparse.dia_matrix.floor										
scipy sparse.dia_matrix.floor	R	scipy.sparse.dia_matrix.floor										
scipy.sparse.dia_matrix.getcol	A										<section class="prog__container"><p>Returns a copy of column j of the matrix, as an (m x 1) sparse\nmatrix (column vector).</p><pre><code>dia_matrix.getcol(j)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.getcol.html
scipy sparse dia_matrix getcol	R	scipy.sparse.dia_matrix.getcol										
scipy sparse.dia_matrix.getcol	R	scipy.sparse.dia_matrix.getcol										
scipy.sparse.dia_matrix.getnnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>dia_matrix.getnnz(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None, 0, or 1\n    Select between the number of values across the whole matrix, in each column, or in each row.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.getnnz.html
scipy sparse dia_matrix getnnz	R	scipy.sparse.dia_matrix.getnnz										
scipy sparse.dia_matrix.getnnz	R	scipy.sparse.dia_matrix.getnnz										
scipy.sparse.dia_matrix.getrow	A										<section class="prog__container"><p>Returns a copy of row i of the matrix, as a (1 x n) sparse\nmatrix (row vector).</p><pre><code>dia_matrix.getrow(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.getrow.html
scipy sparse dia_matrix getrow	R	scipy.sparse.dia_matrix.getrow										
scipy sparse.dia_matrix.getrow	R	scipy.sparse.dia_matrix.getrow										
scipy.sparse.dia_matrix.log1p	A										<section class="prog__container"><p>Element-wise log1p.</p><pre><code>dia_matrix.log1p()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.log1p.html
scipy sparse dia_matrix log1p	R	scipy.sparse.dia_matrix.log1p										
scipy sparse.dia_matrix.log1p	R	scipy.sparse.dia_matrix.log1p										
scipy.sparse.dia_matrix.mean	A										<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>dia_matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the mean is computed. The default is to compute the mean of all elements in the matrix (i.e. axis = None). \ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : np.matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.mean.html
scipy sparse dia_matrix mean	R	scipy.sparse.dia_matrix.mean										
scipy sparse.dia_matrix.mean	R	scipy.sparse.dia_matrix.mean										
scipy.sparse.dia_matrix.multiply	A										<section class="prog__container"><p>Point-wise multiplication by another matrix</p><pre><code>dia_matrix.multiply(other)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.multiply.html
scipy sparse dia_matrix multiply	R	scipy.sparse.dia_matrix.multiply										
scipy sparse.dia_matrix.multiply	R	scipy.sparse.dia_matrix.multiply										
scipy.sparse.dia_matrix.nnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>dia_matrix.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.nnz.html
scipy sparse dia_matrix nnz	R	scipy.sparse.dia_matrix.nnz										
scipy sparse.dia_matrix.nnz	R	scipy.sparse.dia_matrix.nnz										
scipy.sparse.dia_matrix.nonzero	A										<section class="prog__container"><p>nonzero indices</p><pre><code>dia_matrix.nonzero()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])\n>>> A.nonzero()\n(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.nonzero.html
scipy sparse dia_matrix nonzero	R	scipy.sparse.dia_matrix.nonzero										
scipy sparse.dia_matrix.nonzero	R	scipy.sparse.dia_matrix.nonzero										
scipy.sparse.dia_matrix.power	A										<section class="prog__container"><p>This function performs element-wise power.</p><pre><code>dia_matrix.power(n, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : n is a scalar\ndtype : If dtype is not specified, the current dtype will be preserved.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.power.html
scipy sparse dia_matrix power	R	scipy.sparse.dia_matrix.power										
scipy sparse.dia_matrix.power	R	scipy.sparse.dia_matrix.power										
scipy.sparse.dia_matrix.rad2deg	A										<section class="prog__container"><p>Element-wise rad2deg.</p><pre><code>dia_matrix.rad2deg()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.rad2deg.html
scipy sparse dia_matrix rad2deg	R	scipy.sparse.dia_matrix.rad2deg										
scipy sparse.dia_matrix.rad2deg	R	scipy.sparse.dia_matrix.rad2deg										
scipy.sparse.dia_matrix.reshape	A										<section class="prog__container"><p>Gives a new shape to a sparse matrix without changing its data.</p><pre><code>dia_matrix.reshape(shape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : length-2 tuple of ints\n    The new shape should be compatible with the original shape. \norder : ‘C’, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_matrix : self with the new dimensions of shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.reshape.html
scipy sparse dia_matrix reshape	R	scipy.sparse.dia_matrix.reshape										
scipy sparse.dia_matrix.reshape	R	scipy.sparse.dia_matrix.reshape										
scipy.sparse.dia_matrix.rint	A										<section class="prog__container"><p>Element-wise rint.</p><pre><code>dia_matrix.rint()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.rint.html
scipy sparse dia_matrix rint	R	scipy.sparse.dia_matrix.rint										
scipy sparse.dia_matrix.rint	R	scipy.sparse.dia_matrix.rint										
scipy sparse dia_matrix	R	scipy.sparse.dia_matrix										
scipy sparse.dia_matrix	R	scipy.sparse.dia_matrix										
scipy.sparse.dia_matrix.setdiag	A										<section class="prog__container"><p>Set diagonal or off-diagonal elements of the array.</p><pre><code>dia_matrix.setdiag(values, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    New values of the diagonal elements. Values may have any length.  If the diagonal is longer than values, then the remaining diagonal entries will not be set.  If values if longer than the diagonal, then the remaining values are ignored. If a scalar value is given, all of the diagonal is set to it. \nk : int, optional\n    Which off-diagonal to set, corresponding to elements a[i,i+k]. Default: 0 (the main diagonal).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.setdiag.html
scipy sparse dia_matrix setdiag	R	scipy.sparse.dia_matrix.setdiag										
scipy sparse.dia_matrix.setdiag	R	scipy.sparse.dia_matrix.setdiag										
scipy.sparse.dia_matrix.sign	A										<section class="prog__container"><p>Element-wise sign.</p><pre><code>dia_matrix.sign()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.sign.html
scipy sparse dia_matrix sign	R	scipy.sparse.dia_matrix.sign										
scipy sparse.dia_matrix.sign	R	scipy.sparse.dia_matrix.sign										
scipy.sparse.dia_matrix.sin	A										<section class="prog__container"><p>Element-wise sin.</p><pre><code>dia_matrix.sin()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.sin.html
scipy.sparse.dia_matrix.sinh	A										<section class="prog__container"><p>Element-wise sinh.</p><pre><code>dia_matrix.sinh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.sinh.html
scipy sparse dia_matrix sinh	R	scipy.sparse.dia_matrix.sinh										
scipy sparse.dia_matrix.sinh	R	scipy.sparse.dia_matrix.sinh										
scipy sparse dia_matrix sin	R	scipy.sparse.dia_matrix.sin										
scipy sparse.dia_matrix.sin	R	scipy.sparse.dia_matrix.sin										
scipy.sparse.dia_matrix.sqrt	A										<section class="prog__container"><p>Element-wise sqrt.</p><pre><code>dia_matrix.sqrt()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.sqrt.html
scipy sparse dia_matrix sqrt	R	scipy.sparse.dia_matrix.sqrt										
scipy sparse.dia_matrix.sqrt	R	scipy.sparse.dia_matrix.sqrt										
scipy.sparse.dia_matrix.sum	A										<section class="prog__container"><p>Sum the matrix elements over a given axis.</p><pre><code>dia_matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the sum of all the matrix elements, returning a scalar (i.e. axis = None). \ndtype : dtype, optional\n    The type of the returned matrix and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : np.matrix\n    A matrix with the same shape as self, with the specified axis removed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.sum.html
scipy sparse dia_matrix sum	R	scipy.sparse.dia_matrix.sum										
scipy sparse.dia_matrix.sum	R	scipy.sparse.dia_matrix.sum										
scipy.sparse.dia_matrix.tan	A										<section class="prog__container"><p>Element-wise tan.</p><pre><code>dia_matrix.tan()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.tan.html
scipy.sparse.dia_matrix.tanh	A										<section class="prog__container"><p>Element-wise tanh.</p><pre><code>dia_matrix.tanh()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.tanh.html
scipy sparse dia_matrix tanh	R	scipy.sparse.dia_matrix.tanh										
scipy sparse.dia_matrix.tanh	R	scipy.sparse.dia_matrix.tanh										
scipy sparse dia_matrix tan	R	scipy.sparse.dia_matrix.tan										
scipy sparse.dia_matrix.tan	R	scipy.sparse.dia_matrix.tan										
scipy.sparse.dia_matrix.toarray	A										<section class="prog__container"><p>Return a dense ndarray representation of this matrix.</p><pre><code>dia_matrix.toarray(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method. For most sparse types, out is required to be memory contiguous (either C or Fortran ordered).</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : ndarray, 2-dimensional\n    An array with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed, the same object is returned after being modified in-place to contain the appropriate values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.toarray.html
scipy sparse dia_matrix toarray	R	scipy.sparse.dia_matrix.toarray										
scipy sparse.dia_matrix.toarray	R	scipy.sparse.dia_matrix.toarray										
scipy.sparse.dia_matrix.tobsr	A										<section class="prog__container"><p>Convert this matrix to Block Sparse Row format.</p><pre><code>dia_matrix.tobsr(blocksize=None, copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.tobsr.html
scipy sparse dia_matrix tobsr	R	scipy.sparse.dia_matrix.tobsr										
scipy sparse.dia_matrix.tobsr	R	scipy.sparse.dia_matrix.tobsr										
scipy.sparse.dia_matrix.tocoo	A										<section class="prog__container"><p>Convert this matrix to COOrdinate format.</p><pre><code>dia_matrix.tocoo(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.tocoo.html
scipy sparse dia_matrix tocoo	R	scipy.sparse.dia_matrix.tocoo										
scipy sparse.dia_matrix.tocoo	R	scipy.sparse.dia_matrix.tocoo										
scipy.sparse.dia_matrix.tocsc	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Column format.</p><pre><code>dia_matrix.tocsc(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.tocsc.html
scipy sparse dia_matrix tocsc	R	scipy.sparse.dia_matrix.tocsc										
scipy sparse.dia_matrix.tocsc	R	scipy.sparse.dia_matrix.tocsc										
scipy.sparse.dia_matrix.tocsr	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Row format.</p><pre><code>dia_matrix.tocsr(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.tocsr.html
scipy sparse dia_matrix tocsr	R	scipy.sparse.dia_matrix.tocsr										
scipy sparse.dia_matrix.tocsr	R	scipy.sparse.dia_matrix.tocsr										
scipy.sparse.dia_matrix.todense	A										<section class="prog__container"><p>Return a dense matrix representation of this matrix.</p><pre><code>dia_matrix.todense(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array (or numpy.matrix) as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : numpy.matrix, 2-dimensional\n    A NumPy matrix object with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed and was an array (rather than a numpy.matrix), it will be filled with the appropriate values and returned wrapped in a numpy.matrix object that shares the same memory.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.todense.html
scipy sparse dia_matrix todense	R	scipy.sparse.dia_matrix.todense										
scipy sparse.dia_matrix.todense	R	scipy.sparse.dia_matrix.todense										
scipy.sparse.dia_matrix.todia	A										<section class="prog__container"><p>Convert this matrix to sparse DIAgonal format.</p><pre><code>dia_matrix.todia(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.todia.html
scipy sparse dia_matrix todia	R	scipy.sparse.dia_matrix.todia										
scipy sparse.dia_matrix.todia	R	scipy.sparse.dia_matrix.todia										
scipy.sparse.dia_matrix.todok	A										<section class="prog__container"><p>Convert this matrix to Dictionary Of Keys format.</p><pre><code>dia_matrix.todok(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.todok.html
scipy sparse dia_matrix todok	R	scipy.sparse.dia_matrix.todok										
scipy sparse.dia_matrix.todok	R	scipy.sparse.dia_matrix.todok										
scipy.sparse.dia_matrix.tolil	A										<section class="prog__container"><p>Convert this matrix to LInked List format.</p><pre><code>dia_matrix.tolil(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.tolil.html
scipy sparse dia_matrix tolil	R	scipy.sparse.dia_matrix.tolil										
scipy sparse.dia_matrix.tolil	R	scipy.sparse.dia_matrix.tolil										
scipy.sparse.dia_matrix.transpose	A										<section class="prog__container"><p>Reverses the dimensions of the sparse matrix.</p><pre><code>dia_matrix.transpose(axes=None, copy=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value. \ncopy : bool, optional\n    Indicates whether or not attributes of self should be copied whenever possible. The degree to which attributes are copied varies depending on the type of sparse matrix being used.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : self with the dimensions reversed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.transpose.html
scipy sparse dia_matrix transpose	R	scipy.sparse.dia_matrix.transpose										
scipy sparse.dia_matrix.transpose	R	scipy.sparse.dia_matrix.transpose										
scipy.sparse.dia_matrix.trunc	A										<section class="prog__container"><p>Element-wise trunc.</p><pre><code>dia_matrix.trunc()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.trunc.html
scipy sparse dia_matrix trunc	R	scipy.sparse.dia_matrix.trunc										
scipy sparse.dia_matrix.trunc	R	scipy.sparse.dia_matrix.trunc										
scipy.sparse.dok_matrix	A										<section class="prog__container"><p>Dictionary Of Keys based sparse matrix.</p><pre><code>class scipy.sparse.dok_matrix(arg1, shape=None, dtype=None, copy=False)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import dok_matrix\n>>> S = dok_matrix((5, 5), dtype=np.float32)\n>>> for i in range(5):\n...     for j in range(5):\n...         S[i, j] = i + j    # Update element</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.html
scipy.sparse.dok_matrix.asformat	A										<section class="prog__container"><p>Return this matrix in a given sparse format</p><pre><code>dok_matrix.asformat(format)</code></pre><span class="prog__sub">Parameters:</span><pre><code>format : {string, None}\n    desired sparse matrix format  None for no format conversion “csr” for csr_matrix format “csc” for csc_matrix format “lil” for lil_matrix format “dok” for dok_matrix format and so on</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.asformat.html
scipy sparse dok_matrix asformat	R	scipy.sparse.dok_matrix.asformat										
scipy sparse.dok_matrix.asformat	R	scipy.sparse.dok_matrix.asformat										
scipy.sparse.dok_matrix.asfptype	A										<section class="prog__container"><p>Upcast matrix to a floating point format (if necessary)</p><pre><code>dok_matrix.asfptype()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.asfptype.html
scipy sparse dok_matrix asfptype	R	scipy.sparse.dok_matrix.asfptype										
scipy sparse.dok_matrix.asfptype	R	scipy.sparse.dok_matrix.asfptype										
scipy.sparse.dok_matrix.conjtransp	A										<section class="prog__container"><p>Return the conjugate transpose</p><pre><code>dok_matrix.conjtransp()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.conjtransp.html
scipy sparse dok_matrix conjtransp	R	scipy.sparse.dok_matrix.conjtransp										
scipy sparse.dok_matrix.conjtransp	R	scipy.sparse.dok_matrix.conjtransp										
scipy.sparse.dok_matrix.copy	A										<section class="prog__container"><p>Returns a copy of this matrix.</p><pre><code>dok_matrix.copy()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.copy.html
scipy sparse dok_matrix copy	R	scipy.sparse.dok_matrix.copy										
scipy sparse.dok_matrix.copy	R	scipy.sparse.dok_matrix.copy										
scipy.sparse.dok_matrix.count_nonzero	A										<section class="prog__container"><p>Number of non-zero entries, equivalent to</p><pre><code>dok_matrix.count_nonzero()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.count_nonzero.html
scipy sparse dok_matrix count_nonzero	R	scipy.sparse.dok_matrix.count_nonzero										
scipy sparse.dok_matrix.count_nonzero	R	scipy.sparse.dok_matrix.count_nonzero										
scipy.sparse.dok_matrix.diagonal	A										<section class="prog__container"><p>Returns the main diagonal of the matrix</p><pre><code>dok_matrix.diagonal()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.diagonal.html
scipy sparse dok_matrix diagonal	R	scipy.sparse.dok_matrix.diagonal										
scipy sparse.dok_matrix.diagonal	R	scipy.sparse.dok_matrix.diagonal										
scipy.sparse.dok_matrix.dot	A										<section class="prog__container"><p>Ordinary dot product</p><pre><code>dok_matrix.dot(other)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.dot.html
scipy sparse dok_matrix dot	R	scipy.sparse.dok_matrix.dot										
scipy sparse.dok_matrix.dot	R	scipy.sparse.dok_matrix.dot										
scipy.sparse.dok_matrix.fromkeys	A										<section class="prog__container"><p>v defaults to None.</p><pre><code>static dok_matrix.fromkeys(S[, v]) → New dict with keys from S and values equal to v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.fromkeys.html
scipy sparse dok_matrix fromkeys	R	scipy.sparse.dok_matrix.fromkeys										
scipy sparse.dok_matrix.fromkeys	R	scipy.sparse.dok_matrix.fromkeys										
scipy.sparse.dok_matrix.get	A										<section class="prog__container"><p>This overrides the dict.get method, providing type checking\nbut otherwise equivalent functionality.</p><pre><code>dok_matrix.get(key, default=0.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.get.html
scipy.sparse.dok_matrix.getcol	A										<section class="prog__container"><p>Returns a copy of column j of the matrix as a (m x 1)\nDOK matrix.</p><pre><code>dok_matrix.getcol(j)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.getcol.html
scipy sparse dok_matrix getcol	R	scipy.sparse.dok_matrix.getcol										
scipy sparse.dok_matrix.getcol	R	scipy.sparse.dok_matrix.getcol										
scipy.sparse.dok_matrix.getnnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>dok_matrix.getnnz(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None, 0, or 1\n    Select between the number of values across the whole matrix, in each column, or in each row.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.getnnz.html
scipy sparse dok_matrix getnnz	R	scipy.sparse.dok_matrix.getnnz										
scipy sparse.dok_matrix.getnnz	R	scipy.sparse.dok_matrix.getnnz										
scipy.sparse.dok_matrix.getrow	A										<section class="prog__container"><p>Returns a copy of row i of the matrix as a (1 x n)\nDOK matrix.</p><pre><code>dok_matrix.getrow(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.getrow.html
scipy sparse dok_matrix getrow	R	scipy.sparse.dok_matrix.getrow										
scipy sparse.dok_matrix.getrow	R	scipy.sparse.dok_matrix.getrow										
scipy sparse dok_matrix get	R	scipy.sparse.dok_matrix.get										
scipy sparse.dok_matrix.get	R	scipy.sparse.dok_matrix.get										
scipy.sparse.dok_matrix.mean	A										<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>dok_matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the mean is computed. The default is to compute the mean of all elements in the matrix (i.e. axis = None). \ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : np.matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.mean.html
scipy sparse dok_matrix mean	R	scipy.sparse.dok_matrix.mean										
scipy sparse.dok_matrix.mean	R	scipy.sparse.dok_matrix.mean										
scipy.sparse.dok_matrix.multiply	A										<section class="prog__container"><p>Point-wise multiplication by another matrix</p><pre><code>dok_matrix.multiply(other)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.multiply.html
scipy sparse dok_matrix multiply	R	scipy.sparse.dok_matrix.multiply										
scipy sparse.dok_matrix.multiply	R	scipy.sparse.dok_matrix.multiply										
scipy.sparse.dok_matrix.nnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>dok_matrix.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.nnz.html
scipy sparse dok_matrix nnz	R	scipy.sparse.dok_matrix.nnz										
scipy sparse.dok_matrix.nnz	R	scipy.sparse.dok_matrix.nnz										
scipy.sparse.dok_matrix.nonzero	A										<section class="prog__container"><p>nonzero indices</p><pre><code>dok_matrix.nonzero()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])\n>>> A.nonzero()\n(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.nonzero.html
scipy sparse dok_matrix nonzero	R	scipy.sparse.dok_matrix.nonzero										
scipy sparse.dok_matrix.nonzero	R	scipy.sparse.dok_matrix.nonzero										
scipy.sparse.dok_matrix.pop	A										<section class="prog__container"><p>If key is not found, d is returned if given, otherwise KeyError is raised</p><pre><code>dok_matrix.pop(k[, d]) → v, remove specified key and return the corresponding value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.pop.html
scipy.sparse.dok_matrix.popitem	A										<section class="prog__container"><p>2-tuple; but raise KeyError if D is empty.</p><pre><code>dok_matrix.popitem() → (k, v), remove and return some (key, value) pair as a</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.popitem.html
scipy sparse dok_matrix popitem	R	scipy.sparse.dok_matrix.popitem										
scipy sparse.dok_matrix.popitem	R	scipy.sparse.dok_matrix.popitem										
scipy sparse dok_matrix pop	R	scipy.sparse.dok_matrix.pop										
scipy sparse.dok_matrix.pop	R	scipy.sparse.dok_matrix.pop										
scipy.sparse.dok_matrix.reshape	A										<section class="prog__container"><p>Gives a new shape to a sparse matrix without changing its data.</p><pre><code>dok_matrix.reshape(shape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : length-2 tuple of ints\n    The new shape should be compatible with the original shape. \norder : ‘C’, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_matrix : self with the new dimensions of shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.reshape.html
scipy sparse dok_matrix reshape	R	scipy.sparse.dok_matrix.reshape										
scipy sparse.dok_matrix.reshape	R	scipy.sparse.dok_matrix.reshape										
scipy.sparse.dok_matrix.resize	A										<section class="prog__container"><p>Resize the matrix in-place to dimensions given by ‘shape’.</p><pre><code>dok_matrix.resize(shape)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.resize.html
scipy sparse dok_matrix resize	R	scipy.sparse.dok_matrix.resize										
scipy sparse.dok_matrix.resize	R	scipy.sparse.dok_matrix.resize										
scipy sparse dok_matrix	R	scipy.sparse.dok_matrix										
scipy sparse.dok_matrix	R	scipy.sparse.dok_matrix										
scipy.sparse.dok_matrix.setdiag	A										<section class="prog__container"><p>Set diagonal or off-diagonal elements of the array.</p><pre><code>dok_matrix.setdiag(values, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    New values of the diagonal elements. Values may have any length.  If the diagonal is longer than values, then the remaining diagonal entries will not be set.  If values if longer than the diagonal, then the remaining values are ignored. If a scalar value is given, all of the diagonal is set to it. \nk : int, optional\n    Which off-diagonal to set, corresponding to elements a[i,i+k]. Default: 0 (the main diagonal).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.setdiag.html
scipy sparse dok_matrix setdiag	R	scipy.sparse.dok_matrix.setdiag										
scipy sparse.dok_matrix.setdiag	R	scipy.sparse.dok_matrix.setdiag										
scipy.sparse.dok_matrix.sum	A										<section class="prog__container"><p>Sum the matrix elements over a given axis.</p><pre><code>dok_matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the sum of all the matrix elements, returning a scalar (i.e. axis = None). \ndtype : dtype, optional\n    The type of the returned matrix and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : np.matrix\n    A matrix with the same shape as self, with the specified axis removed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.sum.html
scipy sparse dok_matrix sum	R	scipy.sparse.dok_matrix.sum										
scipy sparse.dok_matrix.sum	R	scipy.sparse.dok_matrix.sum										
scipy.sparse.dok_matrix.toarray	A										<section class="prog__container"><p>Return a dense ndarray representation of this matrix.</p><pre><code>dok_matrix.toarray(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method. For most sparse types, out is required to be memory contiguous (either C or Fortran ordered).</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : ndarray, 2-dimensional\n    An array with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed, the same object is returned after being modified in-place to contain the appropriate values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.toarray.html
scipy sparse dok_matrix toarray	R	scipy.sparse.dok_matrix.toarray										
scipy sparse.dok_matrix.toarray	R	scipy.sparse.dok_matrix.toarray										
scipy.sparse.dok_matrix.tobsr	A										<section class="prog__container"><p>Convert this matrix to Block Sparse Row format.</p><pre><code>dok_matrix.tobsr(blocksize=None, copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.tobsr.html
scipy sparse dok_matrix tobsr	R	scipy.sparse.dok_matrix.tobsr										
scipy sparse.dok_matrix.tobsr	R	scipy.sparse.dok_matrix.tobsr										
scipy.sparse.dok_matrix.tocoo	A										<section class="prog__container"><p>Convert this matrix to COOrdinate format.</p><pre><code>dok_matrix.tocoo(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.tocoo.html
scipy sparse dok_matrix tocoo	R	scipy.sparse.dok_matrix.tocoo										
scipy sparse.dok_matrix.tocoo	R	scipy.sparse.dok_matrix.tocoo										
scipy.sparse.dok_matrix.tocsc	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Column format.</p><pre><code>dok_matrix.tocsc(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.tocsc.html
scipy sparse dok_matrix tocsc	R	scipy.sparse.dok_matrix.tocsc										
scipy sparse.dok_matrix.tocsc	R	scipy.sparse.dok_matrix.tocsc										
scipy.sparse.dok_matrix.tocsr	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Row format.</p><pre><code>dok_matrix.tocsr(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.tocsr.html
scipy sparse dok_matrix tocsr	R	scipy.sparse.dok_matrix.tocsr										
scipy sparse.dok_matrix.tocsr	R	scipy.sparse.dok_matrix.tocsr										
scipy.sparse.dok_matrix.todense	A										<section class="prog__container"><p>Return a dense matrix representation of this matrix.</p><pre><code>dok_matrix.todense(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array (or numpy.matrix) as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : numpy.matrix, 2-dimensional\n    A NumPy matrix object with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed and was an array (rather than a numpy.matrix), it will be filled with the appropriate values and returned wrapped in a numpy.matrix object that shares the same memory.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.todense.html
scipy sparse dok_matrix todense	R	scipy.sparse.dok_matrix.todense										
scipy sparse.dok_matrix.todense	R	scipy.sparse.dok_matrix.todense										
scipy.sparse.dok_matrix.todia	A										<section class="prog__container"><p>Convert this matrix to sparse DIAgonal format.</p><pre><code>dok_matrix.todia(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.todia.html
scipy sparse dok_matrix todia	R	scipy.sparse.dok_matrix.todia										
scipy sparse.dok_matrix.todia	R	scipy.sparse.dok_matrix.todia										
scipy.sparse.dok_matrix.todok	A										<section class="prog__container"><p>Convert this matrix to Dictionary Of Keys format.</p><pre><code>dok_matrix.todok(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.todok.html
scipy sparse dok_matrix todok	R	scipy.sparse.dok_matrix.todok										
scipy sparse.dok_matrix.todok	R	scipy.sparse.dok_matrix.todok										
scipy.sparse.dok_matrix.tolil	A										<section class="prog__container"><p>Convert this matrix to LInked List format.</p><pre><code>dok_matrix.tolil(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.tolil.html
scipy sparse dok_matrix tolil	R	scipy.sparse.dok_matrix.tolil										
scipy sparse.dok_matrix.tolil	R	scipy.sparse.dok_matrix.tolil										
scipy.sparse.dok_matrix.transpose	A										<section class="prog__container"><p>Reverses the dimensions of the sparse matrix.</p><pre><code>dok_matrix.transpose(axes=None, copy=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value. \ncopy : bool, optional\n    Indicates whether or not attributes of self should be copied whenever possible. The degree to which attributes are copied varies depending on the type of sparse matrix being used.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : self with the dimensions reversed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.transpose.html
scipy sparse dok_matrix transpose	R	scipy.sparse.dok_matrix.transpose										
scipy sparse.dok_matrix.transpose	R	scipy.sparse.dok_matrix.transpose										
scipy.sparse.dok_matrix.update	A										<section class="prog__container"><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]\nIf E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\nIn either case, this is followed by: for k in F: D[k] = F[k]</p><pre><code>dok_matrix.update([E, ]**F) → None.  Update D from dict/iterable E and F.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.update.html
scipy sparse dok_matrix update	R	scipy.sparse.dok_matrix.update										
scipy sparse.dok_matrix.update	R	scipy.sparse.dok_matrix.update										
scipy.sparse.eye	A										<section class="prog__container"><p>Sparse matrix with ones on diagonal</p><pre><code>scipy.sparse.eye(m, n=None, k=0, dtype=<type 'float'>, format=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : int\n    Number of rows in the matrix. \nn : int, optional\n    Number of columns. Default: m. \nk : int, optional\n    Diagonal to place ones on. Default: 0 (main diagonal). \ndtype : dtype, optional\n    Data type of the matrix. \nformat : str, optional\n    Sparse format of the result, e.g. format=”csr”, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import sparse\n>>> sparse.eye(3).toarray()\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> sparse.eye(3, dtype=np.int8)\n<3x3 sparse matrix of type '<type 'numpy.int8'>'\n    with 3 stored elements (1 diagonals) in DIAgonal format></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.eye.html
scipy sparse eye	R	scipy.sparse.eye										
scipy sparse.eye	R	scipy.sparse.eye										
scipy.sparse.find	A										<section class="prog__container"><p>Return the indices and values of the nonzero elements of a matrix</p><pre><code>scipy.sparse.find(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : dense or sparse matrix\n    Matrix whose nonzero elements are desired.</code></pre><span class="prog__sub">Returns:</span><pre><code>(I,J,V) : tuple of arrays\n    I,J, and V contain the row indices, column indices, and values of the nonzero matrix entries.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix, find\n>>> A = csr_matrix([[7.0, 8.0, 0],[0, 0, 9.0]])\n>>> find(A)\n(array([0, 0, 1], dtype=int32), array([0, 1, 2], dtype=int32), array([ 7.,  8.,  9.]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.find.html
scipy sparse find	R	scipy.sparse.find										
scipy sparse.find	R	scipy.sparse.find										
scipy.sparse.hstack	A										<section class="prog__container"><p>Stack sparse matrices horizontally (column wise)</p><pre><code>scipy.sparse.hstack(blocks, format=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>blocks\n    sequence of sparse matrices with compatible shapes \nformat : str\n    sparse format of the result (e.g. “csr”) by default an appropriate sparse matrix format is returned. This choice is subject to change. \ndtype : dtype, optional\n    The data-type of the output matrix.  If not given, the dtype is determined from that of blocks.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import coo_matrix, hstack\n>>> A = coo_matrix([[1, 2], [3, 4]])\n>>> B = coo_matrix([[5], [6]])\n>>> hstack([A,B]).toarray()\narray([[1, 2, 5],\n       [3, 4, 6]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.hstack.html
scipy sparse hstack	R	scipy.sparse.hstack										
scipy sparse.hstack	R	scipy.sparse.hstack										
scipy.sparse.identity	A										<section class="prog__container"><p>Identity matrix in sparse format</p><pre><code>scipy.sparse.identity(n, dtype='d', format=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Shape of the identity matrix. \ndtype : dtype, optional\n    Data type of the matrix \nformat : str, optional\n    Sparse format of the result, e.g. format=”csr”, etc.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import identity\n>>> identity(3).toarray()\narray([[ 1.,  0.,  0.],\n       [ 0.,  1.,  0.],\n       [ 0.,  0.,  1.]])\n>>> identity(3, dtype='int8', format='dia')\n<3x3 sparse matrix of type '<type 'numpy.int8'>'\n        with 3 stored elements (1 diagonals) in DIAgonal format></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.identity.html
scipy sparse identity	R	scipy.sparse.identity										
scipy sparse.identity	R	scipy.sparse.identity										
scipy.sparse.kron	A										<section class="prog__container"><p>kronecker product of sparse matrices A and B</p><pre><code>scipy.sparse.kron(A, B, format=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : sparse or dense matrix\n    first matrix of the product \nB : sparse or dense matrix\n    second matrix of the product \nformat : str, optional\n    format of the result (e.g. “csr”)</code></pre><span class="prog__sub">Returns:</span><pre><code>kronecker product in a sparse matrix format</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import sparse\n>>> A = sparse.csr_matrix(np.array([[0, 2], [5, 0]]))\n>>> B = sparse.csr_matrix(np.array([[1, 2], [3, 4]]))\n>>> sparse.kron(A, B).toarray()\narray([[ 0,  0,  2,  4],\n       [ 0,  0,  6,  8],\n       [ 5, 10,  0,  0],\n       [15, 20,  0,  0]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.kron.html
scipy sparse kron	R	scipy.sparse.kron										
scipy sparse.kron	R	scipy.sparse.kron										
scipy.sparse.kronsum	A										<section class="prog__container"><p>kronecker sum of sparse matrices A and B</p><pre><code>scipy.sparse.kronsum(A, B, format=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A\n    square matrix \nB\n    square matrix \nformat : str\n    format of the result (e.g. “csr”)</code></pre><span class="prog__sub">Returns:</span><pre><code>kronecker sum in a sparse matrix format</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.kronsum.html
scipy sparse kronsum	R	scipy.sparse.kronsum										
scipy sparse.kronsum	R	scipy.sparse.kronsum										
scipy.sparse.lil_matrix	A										<section class="prog__container"><p>Row-based linked list sparse matrix</p><pre><code>class scipy.sparse.lil_matrix(arg1, shape=None, dtype=None, copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.html
scipy.sparse.lil_matrix.asformat	A										<section class="prog__container"><p>Return this matrix in a given sparse format</p><pre><code>lil_matrix.asformat(format)</code></pre><span class="prog__sub">Parameters:</span><pre><code>format : {string, None}\n    desired sparse matrix format  None for no format conversion “csr” for csr_matrix format “csc” for csc_matrix format “lil” for lil_matrix format “dok” for dok_matrix format and so on</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.asformat.html
scipy sparse lil_matrix asformat	R	scipy.sparse.lil_matrix.asformat										
scipy sparse.lil_matrix.asformat	R	scipy.sparse.lil_matrix.asformat										
scipy.sparse.lil_matrix.asfptype	A										<section class="prog__container"><p>Upcast matrix to a floating point format (if necessary)</p><pre><code>lil_matrix.asfptype()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.asfptype.html
scipy sparse lil_matrix asfptype	R	scipy.sparse.lil_matrix.asfptype										
scipy sparse.lil_matrix.asfptype	R	scipy.sparse.lil_matrix.asfptype										
scipy.sparse.lil_matrix.copy	A										<section class="prog__container"><p>Returns a copy of this matrix.</p><pre><code>lil_matrix.copy()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.copy.html
scipy sparse lil_matrix copy	R	scipy.sparse.lil_matrix.copy										
scipy sparse.lil_matrix.copy	R	scipy.sparse.lil_matrix.copy										
scipy.sparse.lil_matrix.count_nonzero	A										<section class="prog__container"><p>Number of non-zero entries, equivalent to</p><pre><code>lil_matrix.count_nonzero()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.count_nonzero.html
scipy sparse lil_matrix count_nonzero	R	scipy.sparse.lil_matrix.count_nonzero										
scipy sparse.lil_matrix.count_nonzero	R	scipy.sparse.lil_matrix.count_nonzero										
scipy.sparse.lil_matrix.diagonal	A										<section class="prog__container"><p>Returns the main diagonal of the matrix</p><pre><code>lil_matrix.diagonal()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.diagonal.html
scipy sparse lil_matrix diagonal	R	scipy.sparse.lil_matrix.diagonal										
scipy sparse.lil_matrix.diagonal	R	scipy.sparse.lil_matrix.diagonal										
scipy.sparse.lil_matrix.dot	A										<section class="prog__container"><p>Ordinary dot product</p><pre><code>lil_matrix.dot(other)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.dot.html
scipy sparse lil_matrix dot	R	scipy.sparse.lil_matrix.dot										
scipy sparse.lil_matrix.dot	R	scipy.sparse.lil_matrix.dot										
scipy.sparse.lil_matrix.getcol	A										<section class="prog__container"><p>Returns a copy of column j of the matrix, as an (m x 1) sparse\nmatrix (column vector).</p><pre><code>lil_matrix.getcol(j)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.getcol.html
scipy sparse lil_matrix getcol	R	scipy.sparse.lil_matrix.getcol										
scipy sparse.lil_matrix.getcol	R	scipy.sparse.lil_matrix.getcol										
scipy.sparse.lil_matrix.getnnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>lil_matrix.getnnz(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None, 0, or 1\n    Select between the number of values across the whole matrix, in each column, or in each row.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.getnnz.html
scipy sparse lil_matrix getnnz	R	scipy.sparse.lil_matrix.getnnz										
scipy sparse.lil_matrix.getnnz	R	scipy.sparse.lil_matrix.getnnz										
scipy.sparse.lil_matrix.getrow	A										<section class="prog__container"><p>Returns a copy of the ‘i’th row.</p><pre><code>lil_matrix.getrow(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.getrow.html
scipy sparse lil_matrix getrow	R	scipy.sparse.lil_matrix.getrow										
scipy sparse.lil_matrix.getrow	R	scipy.sparse.lil_matrix.getrow										
scipy.sparse.lil_matrix.getrowview	A										<section class="prog__container"><p>Returns a view of the ‘i’th row (without copying).</p><pre><code>lil_matrix.getrowview(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.getrowview.html
scipy sparse lil_matrix getrowview	R	scipy.sparse.lil_matrix.getrowview										
scipy sparse.lil_matrix.getrowview	R	scipy.sparse.lil_matrix.getrowview										
scipy.sparse.lil_matrix.mean	A										<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>lil_matrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the mean is computed. The default is to compute the mean of all elements in the matrix (i.e. axis = None). \ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : np.matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.mean.html
scipy sparse lil_matrix mean	R	scipy.sparse.lil_matrix.mean										
scipy sparse.lil_matrix.mean	R	scipy.sparse.lil_matrix.mean										
scipy.sparse.lil_matrix.multiply	A										<section class="prog__container"><p>Point-wise multiplication by another matrix</p><pre><code>lil_matrix.multiply(other)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.multiply.html
scipy sparse lil_matrix multiply	R	scipy.sparse.lil_matrix.multiply										
scipy sparse.lil_matrix.multiply	R	scipy.sparse.lil_matrix.multiply										
scipy.sparse.lil_matrix.nnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>lil_matrix.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.nnz.html
scipy sparse lil_matrix nnz	R	scipy.sparse.lil_matrix.nnz										
scipy sparse.lil_matrix.nnz	R	scipy.sparse.lil_matrix.nnz										
scipy.sparse.lil_matrix.nonzero	A										<section class="prog__container"><p>nonzero indices</p><pre><code>lil_matrix.nonzero()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])\n>>> A.nonzero()\n(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.nonzero.html
scipy sparse lil_matrix nonzero	R	scipy.sparse.lil_matrix.nonzero										
scipy sparse.lil_matrix.nonzero	R	scipy.sparse.lil_matrix.nonzero										
scipy.sparse.lil_matrix.reshape	A										<section class="prog__container"><p>Gives a new shape to a sparse matrix without changing its data.</p><pre><code>lil_matrix.reshape(shape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : length-2 tuple of ints\n    The new shape should be compatible with the original shape. \norder : ‘C’, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_matrix : self with the new dimensions of shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.reshape.html
scipy sparse lil_matrix reshape	R	scipy.sparse.lil_matrix.reshape										
scipy sparse.lil_matrix.reshape	R	scipy.sparse.lil_matrix.reshape										
scipy sparse lil_matrix	R	scipy.sparse.lil_matrix										
scipy sparse.lil_matrix	R	scipy.sparse.lil_matrix										
scipy.sparse.lil_matrix.setdiag	A										<section class="prog__container"><p>Set diagonal or off-diagonal elements of the array.</p><pre><code>lil_matrix.setdiag(values, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    New values of the diagonal elements. Values may have any length.  If the diagonal is longer than values, then the remaining diagonal entries will not be set.  If values if longer than the diagonal, then the remaining values are ignored. If a scalar value is given, all of the diagonal is set to it. \nk : int, optional\n    Which off-diagonal to set, corresponding to elements a[i,i+k]. Default: 0 (the main diagonal).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.setdiag.html
scipy sparse lil_matrix setdiag	R	scipy.sparse.lil_matrix.setdiag										
scipy sparse.lil_matrix.setdiag	R	scipy.sparse.lil_matrix.setdiag										
scipy.sparse.lil_matrix.sum	A										<section class="prog__container"><p>Sum the matrix elements over a given axis.</p><pre><code>lil_matrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the sum of all the matrix elements, returning a scalar (i.e. axis = None). \ndtype : dtype, optional\n    The type of the returned matrix and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : np.matrix\n    A matrix with the same shape as self, with the specified axis removed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.sum.html
scipy sparse lil_matrix sum	R	scipy.sparse.lil_matrix.sum										
scipy sparse.lil_matrix.sum	R	scipy.sparse.lil_matrix.sum										
scipy.sparse.lil_matrix.toarray	A										<section class="prog__container"><p>See the docstring for spmatrix.toarray.</p><pre><code>lil_matrix.toarray(order=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.toarray.html
scipy sparse lil_matrix toarray	R	scipy.sparse.lil_matrix.toarray										
scipy sparse.lil_matrix.toarray	R	scipy.sparse.lil_matrix.toarray										
scipy.sparse.lil_matrix.tobsr	A										<section class="prog__container"><p>Convert this matrix to Block Sparse Row format.</p><pre><code>lil_matrix.tobsr(blocksize=None, copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.tobsr.html
scipy sparse lil_matrix tobsr	R	scipy.sparse.lil_matrix.tobsr										
scipy sparse.lil_matrix.tobsr	R	scipy.sparse.lil_matrix.tobsr										
scipy.sparse.lil_matrix.tocoo	A										<section class="prog__container"><p>Convert this matrix to COOrdinate format.</p><pre><code>lil_matrix.tocoo(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.tocoo.html
scipy sparse lil_matrix tocoo	R	scipy.sparse.lil_matrix.tocoo										
scipy sparse.lil_matrix.tocoo	R	scipy.sparse.lil_matrix.tocoo										
scipy.sparse.lil_matrix.tocsc	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Column format.</p><pre><code>lil_matrix.tocsc(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.tocsc.html
scipy sparse lil_matrix tocsc	R	scipy.sparse.lil_matrix.tocsc										
scipy sparse.lil_matrix.tocsc	R	scipy.sparse.lil_matrix.tocsc										
scipy.sparse.lil_matrix.tocsr	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Row format.</p><pre><code>lil_matrix.tocsr(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.tocsr.html
scipy sparse lil_matrix tocsr	R	scipy.sparse.lil_matrix.tocsr										
scipy sparse.lil_matrix.tocsr	R	scipy.sparse.lil_matrix.tocsr										
scipy.sparse.lil_matrix.todense	A										<section class="prog__container"><p>Return a dense matrix representation of this matrix.</p><pre><code>lil_matrix.todense(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array (or numpy.matrix) as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : numpy.matrix, 2-dimensional\n    A NumPy matrix object with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed and was an array (rather than a numpy.matrix), it will be filled with the appropriate values and returned wrapped in a numpy.matrix object that shares the same memory.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.todense.html
scipy sparse lil_matrix todense	R	scipy.sparse.lil_matrix.todense										
scipy sparse.lil_matrix.todense	R	scipy.sparse.lil_matrix.todense										
scipy.sparse.lil_matrix.todia	A										<section class="prog__container"><p>Convert this matrix to sparse DIAgonal format.</p><pre><code>lil_matrix.todia(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.todia.html
scipy sparse lil_matrix todia	R	scipy.sparse.lil_matrix.todia										
scipy sparse.lil_matrix.todia	R	scipy.sparse.lil_matrix.todia										
scipy.sparse.lil_matrix.todok	A										<section class="prog__container"><p>Convert this matrix to Dictionary Of Keys format.</p><pre><code>lil_matrix.todok(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.todok.html
scipy sparse lil_matrix todok	R	scipy.sparse.lil_matrix.todok										
scipy sparse.lil_matrix.todok	R	scipy.sparse.lil_matrix.todok										
scipy.sparse.lil_matrix.tolil	A										<section class="prog__container"><p>Convert this matrix to LInked List format.</p><pre><code>lil_matrix.tolil(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.tolil.html
scipy sparse lil_matrix tolil	R	scipy.sparse.lil_matrix.tolil										
scipy sparse.lil_matrix.tolil	R	scipy.sparse.lil_matrix.tolil										
scipy.sparse.linalg.ArpackError	A										<section class="prog__container"><p>ARPACK error</p><pre><code>exception scipy.sparse.linalg.ArpackError(info, infodict={'c': {0: 'Normal exit.', 1: 'Maximum number of iterations taken. All possible eigenvalues of OP has been found. IPARAM(5) returns the number of wanted converged Ritz values.', 2: 'No longer an informational error. Deprecated starting with release 2 of ARPACK.', 3: 'No shifts could be applied during a cycle of the Implicitly restarted Arnoldi iteration. One possibility is to increase the size of NCV relative to NEV. ', -9999: 'Could not build an Arnoldi factorization. IPARAM(5) returns the size of the current Arnoldi factorization. The user is advised to check that enough workspace and array storage has been allocated.', -13: "NEV and WHICH = 'BE' are incompatible.", -12: 'IPARAM(1) must be equal to 0 or 1.', -1: 'N must be positive.', -10: 'IPARAM(7) must be 1, 2, 3.', -9: 'Starting vector is zero.', -8: 'Error return from LAPACK eigenvalue calculation;', -7: 'Length of private work array WORKL is not sufficient.', -6: "BMAT must be one of 'I' or 'G'.", -5: " WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'", -4: 'The maximum number of Arnoldi update iterations allowed must be greater than zero.', -3: 'NCV-NEV >= 2 and less than or equal to N.', -2: 'NEV must be positive.', -11: "IPARAM(7) = 1 and BMAT = 'G' are incompatible."}, 's': {0: 'Normal exit.', 1: 'Maximum number of iterations taken. All possible eigenvalues of OP has been found. IPARAM(5) returns the number of wanted converged Ritz values.', 2: 'No longer an informational error. Deprecated starting with release 2 of ARPACK.', 3: 'No shifts could be applied during a cycle of the Implicitly restarted Arnoldi iteration. One possibility is to increase the size of NCV relative to NEV. ', -9999: 'Could not build an Arnoldi factorization. IPARAM(5) returns the size of the current Arnoldi factorization. The user is advised to check that enough workspace and array storage has been allocated.', -13: "NEV and WHICH = 'BE' are incompatible.", -12: 'IPARAM(1) must be equal to 0 or 1.', -2: 'NEV must be positive.', -10: 'IPARAM(7) must be 1, 2, 3, 4.', -9: 'Starting vector is zero.', -8: 'Error return from LAPACK eigenvalue calculation;', -7: 'Length of private work array WORKL is not sufficient.', -6: "BMAT must be one of 'I' or 'G'.", -5: " WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'", -4: 'The maximum number of Arnoldi update iterations allowed must be greater than zero.', -3: 'NCV-NEV >= 2 and less than or equal to N.', -1: 'N must be positive.', -11: "IPARAM(7) = 1 and BMAT = 'G' are incompatible."}, 'z': {0: 'Normal exit.', 1: 'Maximum number of iterations taken. All possible eigenvalues of OP has been found. IPARAM(5) returns the number of wanted converged Ritz values.', 2: 'No longer an informational error. Deprecated starting with release 2 of ARPACK.', 3: 'No shifts could be applied during a cycle of the Implicitly restarted Arnoldi iteration. One possibility is to increase the size of NCV relative to NEV. ', -9999: 'Could not build an Arnoldi factorization. IPARAM(5) returns the size of the current Arnoldi factorization. The user is advised to check that enough workspace and array storage has been allocated.', -13: "NEV and WHICH = 'BE' are incompatible.", -12: 'IPARAM(1) must be equal to 0 or 1.', -1: 'N must be positive.', -10: 'IPARAM(7) must be 1, 2, 3.', -9: 'Starting vector is zero.', -8: 'Error return from LAPACK eigenvalue calculation;', -7: 'Length of private work array WORKL is not sufficient.', -6: "BMAT must be one of 'I' or 'G'.", -5: " WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'", -4: 'The maximum number of Arnoldi update iterations allowed must be greater than zero.', -3: 'NCV-NEV >= 2 and less than or equal to N.', -2: 'NEV must be positive.', -11: "IPARAM(7) = 1 and BMAT = 'G' are incompatible."}, 'd': {0: 'Normal exit.', 1: 'Maximum number of iterations taken. All possible eigenvalues of OP has been found. IPARAM(5) returns the number of wanted converged Ritz values.', 2: 'No longer an informational error. Deprecated starting with release 2 of ARPACK.', 3: 'No shifts could be applied during a cycle of the Implicitly restarted Arnoldi iteration. One possibility is to increase the size of NCV relative to NEV. ', -9999: 'Could not build an Arnoldi factorization. IPARAM(5) returns the size of the current Arnoldi factorization. The user is advised to check that enough workspace and array storage has been allocated.', -13: "NEV and WHICH = 'BE' are incompatible.", -12: 'IPARAM(1) must be equal to 0 or 1.', -2: 'NEV must be positive.', -10: 'IPARAM(7) must be 1, 2, 3, 4.', -9: 'Starting vector is zero.', -8: 'Error return from LAPACK eigenvalue calculation;', -7: 'Length of private work array WORKL is not sufficient.', -6: "BMAT must be one of 'I' or 'G'.", -5: " WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'", -4: 'The maximum number of Arnoldi update iterations allowed must be greater than zero.', -3: 'NCV-NEV >= 2 and less than or equal to N.', -1: 'N must be positive.', -11: "IPARAM(7) = 1 and BMAT = 'G' are incompatible."}})</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.ArpackError.html
scipy sparse linalg ArpackError	R	scipy.sparse.linalg.ArpackError										
scipy sparse.linalg.ArpackError	R	scipy.sparse.linalg.ArpackError										
scipy.sparse.linalg.ArpackNoConvergence	A										<section class="prog__container"><p>ARPACK iteration did not converge</p><pre><code>exception scipy.sparse.linalg.ArpackNoConvergence(msg, eigenvalues, eigenvectors)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.ArpackNoConvergence.html
scipy sparse linalg ArpackNoConvergence	R	scipy.sparse.linalg.ArpackNoConvergence										
scipy sparse.linalg.ArpackNoConvergence	R	scipy.sparse.linalg.ArpackNoConvergence										
scipy.sparse.linalg.aslinearoperator	A										<section class="prog__container"><p>Return A as a LinearOperator.</p><pre><code>scipy.sparse.linalg.aslinearoperator(A)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse.linalg import aslinearoperator\n>>> M = np.array([[1,2,3],[4,5,6]], dtype=np.int32)\n>>> aslinearoperator(M)\n<2x3 MatrixLinearOperator with dtype=int32></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.aslinearoperator.html
scipy sparse linalg aslinearoperator	R	scipy.sparse.linalg.aslinearoperator										
scipy sparse.linalg.aslinearoperator	R	scipy.sparse.linalg.aslinearoperator										
scipy.sparse.linalg.bicg	A										<section class="prog__container"><p>Use BIConjugate Gradient iteration to solve A x = b</p><pre><code>scipy.sparse.linalg.bicg(A, b, x0=None, tol=1e-05, maxiter=None, xtype=None, M=None, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The real or complex N-by-N matrix of the linear system It is required that the linear operator can produce Ax and A^T x. \nb : {array, matrix}\n    Right hand side of the linear system. Has shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {array, matrix}\n    The converged solution. \ninfo : integer\n    Provides convergence information: 0  : successful exit >0 : convergence to tolerance not achieved, number of iterations <0 : illegal input or breakdown</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.bicg.html
scipy sparse linalg bicg	R	scipy.sparse.linalg.bicg										
scipy sparse.linalg.bicg	R	scipy.sparse.linalg.bicg										
scipy.sparse.linalg.bicgstab	A										<section class="prog__container"><p>Use BIConjugate Gradient STABilized iteration to solve A x = b</p><pre><code>scipy.sparse.linalg.bicgstab(A, b, x0=None, tol=1e-05, maxiter=None, xtype=None, M=None, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The real or complex N-by-N matrix of the linear system A must represent a hermitian, positive definite matrix \nb : {array, matrix}\n    Right hand side of the linear system. Has shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {array, matrix}\n    The converged solution. \ninfo : integer\n    Provides convergence information: 0  : successful exit >0 : convergence to tolerance not achieved, number of iterations <0 : illegal input or breakdown</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.bicgstab.html
scipy sparse linalg bicgstab	R	scipy.sparse.linalg.bicgstab										
scipy sparse.linalg.bicgstab	R	scipy.sparse.linalg.bicgstab										
scipy.sparse.linalg.cg	A										<section class="prog__container"><p>Use Conjugate Gradient iteration to solve A x = b</p><pre><code>scipy.sparse.linalg.cg(A, b, x0=None, tol=1e-05, maxiter=None, xtype=None, M=None, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The real or complex N-by-N matrix of the linear system A must represent a hermitian, positive definite matrix \nb : {array, matrix}\n    Right hand side of the linear system. Has shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {array, matrix}\n    The converged solution. \ninfo : integer\n    Provides convergence information: 0  : successful exit >0 : convergence to tolerance not achieved, number of iterations <0 : illegal input or breakdown</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cg.html
scipy sparse linalg cg	R	scipy.sparse.linalg.cg										
scipy sparse.linalg.cg	R	scipy.sparse.linalg.cg										
scipy.sparse.linalg.cgs	A										<section class="prog__container"><p>Use Conjugate Gradient Squared iteration to solve A x = b</p><pre><code>scipy.sparse.linalg.cgs(A, b, x0=None, tol=1e-05, maxiter=None, xtype=None, M=None, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The real-valued N-by-N matrix of the linear system \nb : {array, matrix}\n    Right hand side of the linear system. Has shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {array, matrix}\n    The converged solution. \ninfo : integer\n    Provides convergence information: 0  : successful exit >0 : convergence to tolerance not achieved, number of iterations <0 : illegal input or breakdown</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cgs.html
scipy sparse linalg cgs	R	scipy.sparse.linalg.cgs										
scipy sparse.linalg.cgs	R	scipy.sparse.linalg.cgs										
scipy.sparse.linalg.eigs	A										<section class="prog__container"><p>Find k eigenvalues and eigenvectors of the square matrix A.</p><pre><code>scipy.sparse.linalg.eigs(A, k=6, M=None, sigma=None, which='LM', v0=None, ncv=None, maxiter=None, tol=0, return_eigenvectors=True, Minv=None, OPinv=None, OPpart=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : ndarray, sparse matrix or LinearOperator\n    An array, sparse matrix, or LinearOperator representing the operation A * x, where A is a real or complex square matrix. \nk : int, optional\n    The number of eigenvalues and eigenvectors desired. k must be smaller than N. It is not possible to compute all eigenvectors of a matrix. \nM : ndarray, sparse matrix or LinearOperator, optional\n    An array, sparse matrix, or LinearOperator representing the operation M*x for the generalized eigenvalue problem  A * x = w * M * x.  M must represent a real, symmetric matrix if A is real, and must represent a complex, hermitian matrix if A is complex. For best results, the data type of M should be the same as that of A. Additionally:  If sigma is None, M is positive definite If sigma is specified, M is positive semi-definite  If sigma is None, eigs requires an operator to compute the solution of the linear equation M * x = b.  This is done internally via a (sparse) LU decomposition for an explicit matrix M, or via an iterative solver for a general linear operator.  Alternatively, the user can supply the matrix or operator Minv, which gives x = Minv * b = M^-1 * b. \nsigma : real or complex, optional\n    Find eigenvalues near sigma using shift-invert mode.  This requires an operator to compute the solution of the linear system [A - sigma * M] * x = b, where M is the identity matrix if unspecified. This is computed internally via a (sparse) LU decomposition for explicit matrices A & M, or via an iterative solver if either A or M is a general linear operator. Alternatively, the user can supply the matrix or operator OPinv, which gives x = OPinv * b = [A - sigma * M]^-1 * b. For a real matrix A, shift-invert can either be done in imaginary mode or real mode, specified by the parameter OPpart (‘r’ or ‘i’). Note that when sigma is specified, the keyword ‘which’ (below) refers to the shifted eigenvalues w'[i] where:   If A is real and OPpart == ‘r’ (default), w'[i] = 1/2 * [1/(w[i]-sigma) + 1/(w[i]-conj(sigma))].  If A is real and OPpart == ‘i’, w'[i] = 1/2i * [1/(w[i]-sigma) - 1/(w[i]-conj(sigma))].   If A is complex, w'[i] = 1/(w[i]-sigma).  \nv0 : ndarray, optional\n    Starting vector for iteration. Default: random \nncv : int, optional\n    The number of Lanczos vectors generated ncv must be greater than k; it is recommended that ncv > 2*k. Default: min(n, max(2*k + 1, 20)) \nwhich : str, [‘LM’ | ‘SM’ | ‘LR’ | ‘SR’ | ‘LI’ | ‘SI’], optional\n    Which k eigenvectors and eigenvalues to find:  ‘LM’ : largest magnitude ‘SM’ : smallest magnitude ‘LR’ : largest real part ‘SR’ : smallest real part ‘LI’ : largest imaginary part ‘SI’ : smallest imaginary part  When sigma != None, ‘which’ refers to the shifted eigenvalues w’[i] (see discussion in ‘sigma’, above).  ARPACK is generally better at finding large values than small values.  If small eigenvalues are desired, consider using shift-invert mode for better performance. \nmaxiter : int, optional\n    Maximum number of Arnoldi update iterations allowed Default: n*10 \ntol : float, optional\n    Relative accuracy for eigenvalues (stopping criterion) The default value of 0 implies machine precision. \nreturn_eigenvectors : bool, optional\n    Return eigenvectors (True) in addition to eigenvalues \nMinv : ndarray, sparse matrix or LinearOperator, optional\n    See notes in M, above. \nOPinv : ndarray, sparse matrix or LinearOperator, optional\n    See notes in sigma, above. \nOPpart : {‘r’ or ‘i’}, optional\n    See notes in sigma, above</code></pre><span class="prog__sub">Returns:</span><pre><code>w : ndarray\n    Array of k eigenvalues. \nv : ndarray\n    An array of k eigenvectors. v[:, i] is the eigenvector corresponding to the eigenvalue w[i].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import scipy.sparse as sparse\n>>> id = np.eye(13)\n>>> vals, vecs = sparse.linalg.eigs(id, k=6)\n>>> vals\narray([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])\n>>> vecs.shape\n(13, 6)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigs.html
scipy.sparse.linalg.eigsh	A										<section class="prog__container"><p>Find k eigenvalues and eigenvectors of the real symmetric square matrix\nor complex hermitian matrix A.</p><pre><code>scipy.sparse.linalg.eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None, ncv=None, maxiter=None, tol=0, return_eigenvectors=True, Minv=None, OPinv=None, mode='normal')</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : An N x N matrix, array, sparse matrix, or LinearOperator representing\n    the operation A * x, where A is a real symmetric matrix For buckling mode (see below) A must additionally be positive-definite \nk : int, optional\n    The number of eigenvalues and eigenvectors desired. k must be smaller than N. It is not possible to compute all eigenvectors of a matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : array\n    Array of k eigenvalues \nv : array\n    An array representing the k eigenvectors.  The column v[:, i] is the eigenvector corresponding to the eigenvalue w[i].</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import scipy.sparse as sparse\n>>> id = np.eye(13)\n>>> vals, vecs = sparse.linalg.eigsh(id, k=6)\n>>> vals\narray([ 1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])\n>>> vecs.shape\n(13, 6)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html
scipy sparse linalg eigsh	R	scipy.sparse.linalg.eigsh										
scipy sparse.linalg.eigsh	R	scipy.sparse.linalg.eigsh										
scipy sparse linalg eigs	R	scipy.sparse.linalg.eigs										
scipy sparse.linalg.eigs	R	scipy.sparse.linalg.eigs										
scipy.sparse.linalg.expm	A										<section class="prog__container"><p>Compute the matrix exponential using Pade approximation.</p><pre><code>scipy.sparse.linalg.expm(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (M,M) array_like or sparse matrix\n    2D Array or Matrix (sparse or dense) to be exponentiated</code></pre><span class="prog__sub">Returns:</span><pre><code>expA : (M,M) ndarray\n    Matrix exponential of A</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.expm.html
scipy.sparse.linalg.expm_multiply	A										<section class="prog__container"><p>Compute the action of the matrix exponential of A on B.</p><pre><code>scipy.sparse.linalg.expm_multiply(A, B, start=None, stop=None, num=None, endpoint=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : transposable linear operator\n    The operator whose exponential is of interest. \nB : ndarray\n    The matrix or vector to be multiplied by the matrix exponential of A. \nstart : scalar, optional\n    The starting time point of the sequence. \nstop : scalar, optional\n    The end time point of the sequence, unless endpoint is set to False. In that case, the sequence consists of all but the last of num + 1 evenly spaced time points, so that stop is excluded. Note that the step size changes when endpoint is False. \nnum : int, optional\n    Number of time points to use. \nendpoint : bool, optional\n    If True, stop is the last time point.  Otherwise, it is not included.</code></pre><span class="prog__sub">Returns:</span><pre><code>expm_A_B : ndarray\n    The result of the action \(e^{t_k A} B\).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.expm_multiply.html
scipy sparse linalg expm_multiply	R	scipy.sparse.linalg.expm_multiply										
scipy sparse.linalg.expm_multiply	R	scipy.sparse.linalg.expm_multiply										
scipy sparse linalg expm	R	scipy.sparse.linalg.expm										
scipy sparse.linalg.expm	R	scipy.sparse.linalg.expm										
scipy.sparse.linalg.factorized	A										<section class="prog__container"><p>Return a fuction for solving a sparse linear system, with A pre-factorized.</p><pre><code>scipy.sparse.linalg.factorized(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Input.</code></pre><span class="prog__sub">Returns:</span><pre><code>solve : callable\n    To solve the linear system of equations given in A, the solve callable should be passed an ndarray of shape (N,).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse.linalg import factorized\n>>> A = np.array([[ 3. ,  2. , -1. ],\n...               [ 2. , -2. ,  4. ],\n...               [-1. ,  0.5, -1. ]])\n>>> solve = factorized(A) # Makes LU decomposition.\n>>> rhs1 = np.array([1, -2, 0])\n>>> solve(rhs1) # Uses the LU factors.\narray([ 1., -2., -2.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.factorized.html
scipy sparse linalg factorized	R	scipy.sparse.linalg.factorized										
scipy sparse.linalg.factorized	R	scipy.sparse.linalg.factorized										
scipy.sparse.linalg.gmres	A					[[scipy.sparse.linalg.LinearOperator]]					<section class="prog__container"><p>Use Generalized Minimal RESidual iteration to solve A x = b.</p><pre><code>scipy.sparse.linalg.gmres(A, b, x0=None, tol=1e-05, restart=None, maxiter=None, xtype=None, M=None, callback=None, restrt=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The real or complex N-by-N matrix of the linear system. \nb : {array, matrix}\n    Right hand side of the linear system. Has shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {array, matrix}\n    The converged solution. \ninfo : int\n    Provides convergence information:  0  : successful exit >0 : convergence to tolerance not achieved, number of iterations <0 : illegal input or breakdown</code></pre><span class="prog__sub">Examples:</span><pre><code># Construct a linear operator that computes P^-1 * x.\nimport scipy.sparse.linalg as spla\nM_x = lambda x: spla.spsolve(P, x)\nM = spla.LinearOperator((n, n), M_x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.gmres.html
scipy sparse linalg gmres	R	scipy.sparse.linalg.gmres										
scipy sparse.linalg.gmres	R	scipy.sparse.linalg.gmres										
scipy.sparse.linalg.inv	A										<section class="prog__container"><p>Compute the inverse of a sparse matrix</p><pre><code>scipy.sparse.linalg.inv(A)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (M,M) ndarray or sparse matrix\n    square matrix to be inverted</code></pre><span class="prog__sub">Returns:</span><pre><code>Ainv : (M,M) ndarray or sparse matrix\n    inverse of A</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.inv.html
scipy sparse linalg inv	R	scipy.sparse.linalg.inv										
scipy sparse.linalg.inv	R	scipy.sparse.linalg.inv										
scipy.sparse.linalg.lgmres	A										<section class="prog__container"><p>Solve a matrix equation using the LGMRES algorithm.</p><pre><code>scipy.sparse.linalg.lgmres(A, b, x0=None, tol=1e-05, maxiter=1000, M=None, callback=None, inner_m=30, outer_k=3, outer_v=None, store_outer_Av=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The real or complex N-by-N matrix of the linear system. \nb : {array, matrix}\n    Right hand side of the linear system. Has shape (N,) or (N,1). \nx0 : {array, matrix}\n    Starting guess for the solution. \ntol : float, optional\n    Tolerance to achieve. The algorithm terminates when either the relative or the absolute residual is below tol. \nmaxiter : int, optional\n    Maximum number of iterations.  Iteration will stop after maxiter steps even if the specified tolerance has not been achieved. \nM : {sparse matrix, dense matrix, LinearOperator}, optional\n    Preconditioner for A.  The preconditioner should approximate the inverse of A.  Effective preconditioning dramatically improves the rate of convergence, which implies that fewer iterations are needed to reach a given error tolerance. \ncallback : function, optional\n    User-supplied function to call after each iteration.  It is called as callback(xk), where xk is the current solution vector. \ninner_m : int, optional\n    Number of inner GMRES iterations per each outer iteration. \nouter_k : int, optional\n    Number of vectors to carry between inner GMRES iterations. According to [R292], good values are in the range of 1...3. However, note that if you want to use the additional vectors to accelerate solving multiple similar problems, larger values may be beneficial. \nouter_v : list of tuples, optional\n    List containing tuples (v, Av) of vectors and corresponding matrix-vector products, used to augment the Krylov subspace, and carried between inner GMRES iterations. The element Av can be None if the matrix-vector product should be re-evaluated. This parameter is modified in-place by lgmres, and can be used to pass “guess” vectors in and out of the algorithm when solving similar problems. \nstore_outer_Av : bool, optional\n    Whether LGMRES should store also A*v in addition to vectors v in the outer_v list. Default is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array or matrix\n    The converged solution. \ninfo : int\n    Provides convergence information:   0  : successful exit >0 : convergence to tolerance not achieved, number of iterations <0 : illegal input or breakdown</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lgmres.html
scipy sparse linalg lgmres	R	scipy.sparse.linalg.lgmres										
scipy sparse.linalg.lgmres	R	scipy.sparse.linalg.lgmres										
scipy.sparse.linalg.LinearOperator.adjoint	A										<section class="prog__container"><p>Hermitian adjoint.</p><pre><code>LinearOperator.adjoint()</code></pre><span class="prog__sub">Parameters:</span><pre><code>A_H : LinearOperator\n    Hermitian adjoint of self.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.adjoint.html
scipy sparse linalg LinearOperator adjoint	R	scipy.sparse.linalg.LinearOperator.adjoint										
scipy sparse.linalg.LinearOperator.adjoint	R	scipy.sparse.linalg.LinearOperator.adjoint										
scipy.sparse.linalg.LinearOperator	A										<section class="prog__container"><p>Common interface for performing matrix vector products</p><pre><code>class scipy.sparse.linalg.LinearOperator(dtype, shape)</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : tuple\n    Matrix dimensions (M,N). \nmatvec : callable f(v)\n    Returns returns A * v. \nrmatvec : callable f(v)\n    Returns A^H * v, where A^H is the conjugate transpose of A. \nmatmat : callable f(V)\n    Returns A * V, where V is a dense matrix with dimensions (N,K). \ndtype : dtype\n    Data type of the matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse.linalg import LinearOperator\n>>> def mv(v):\n...     return np.array([2*v[0], 3*v[1]])\n...\n>>> A = LinearOperator((2,2), matvec=mv)\n>>> A\n<2x2 _CustomLinearOperator with dtype=float64>\n>>> A.matvec(np.ones(2))\narray([ 2.,  3.])\n>>> A * np.ones(2)\narray([ 2.,  3.])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.html
scipy.sparse.linalg.LinearOperator.dot	A										<section class="prog__container"><p>Matrix-matrix or matrix-vector multiplication.</p><pre><code>LinearOperator.dot(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    1-d or 2-d array, representing a vector or matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>Ax : array\n    1-d or 2-d array (depending on the shape of x) that represents the result of applying this linear operator on x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.dot.html
scipy sparse linalg LinearOperator dot	R	scipy.sparse.linalg.LinearOperator.dot										
scipy sparse.linalg.LinearOperator.dot	R	scipy.sparse.linalg.LinearOperator.dot										
scipy.sparse.linalg.LinearOperator.H	A										<section class="prog__container"><p>Hermitian adjoint.</p><pre><code>LinearOperator.H</code></pre><span class="prog__sub">Parameters:</span><pre><code>A_H : LinearOperator\n    Hermitian adjoint of self.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.H.html
scipy sparse linalg LinearOperator H	R	scipy.sparse.linalg.LinearOperator.H										
scipy sparse.linalg.LinearOperator.H	R	scipy.sparse.linalg.LinearOperator.H										
scipy.sparse.linalg.LinearOperator.matmat	A										<section class="prog__container"><p>Matrix-matrix multiplication.</p><pre><code>LinearOperator.matmat(X)</code></pre><span class="prog__sub">Parameters:</span><pre><code>X : {matrix, ndarray}\n    An array with shape (N,K).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : {matrix, ndarray}\n    A matrix or ndarray with shape (M,K) depending on the type of the X argument.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.matmat.html
scipy sparse linalg LinearOperator matmat	R	scipy.sparse.linalg.LinearOperator.matmat										
scipy sparse.linalg.LinearOperator.matmat	R	scipy.sparse.linalg.LinearOperator.matmat										
scipy.sparse.linalg.LinearOperator.matvec	A										<section class="prog__container"><p>Matrix-vector multiplication.</p><pre><code>LinearOperator.matvec(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : {matrix, ndarray}\n    An array with shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : {matrix, ndarray}\n    A matrix or ndarray with shape (M,) or (M,1) depending on the type and shape of the x argument.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.matvec.html
scipy sparse linalg LinearOperator matvec	R	scipy.sparse.linalg.LinearOperator.matvec										
scipy sparse.linalg.LinearOperator.matvec	R	scipy.sparse.linalg.LinearOperator.matvec										
scipy.sparse.linalg.LinearOperator.rmatvec	A										<section class="prog__container"><p>Adjoint matrix-vector multiplication.</p><pre><code>LinearOperator.rmatvec(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : {matrix, ndarray}\n    An array with shape (M,) or (M,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : {matrix, ndarray}\n    A matrix or ndarray with shape (N,) or (N,1) depending on the type and shape of the x argument.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.rmatvec.html
scipy sparse linalg LinearOperator rmatvec	R	scipy.sparse.linalg.LinearOperator.rmatvec										
scipy sparse.linalg.LinearOperator.rmatvec	R	scipy.sparse.linalg.LinearOperator.rmatvec										
scipy sparse linalg LinearOperator	R	scipy.sparse.linalg.LinearOperator										
scipy sparse.linalg.LinearOperator	R	scipy.sparse.linalg.LinearOperator										
scipy.sparse.linalg.LinearOperator.T	A										<section class="prog__container"><p>Transpose this linear operator.</p><pre><code>LinearOperator.T</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.T.html
scipy.sparse.linalg.LinearOperator.transpose	A										<section class="prog__container"><p>Transpose this linear operator.</p><pre><code>LinearOperator.transpose()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.LinearOperator.transpose.html
scipy sparse linalg LinearOperator transpose	R	scipy.sparse.linalg.LinearOperator.transpose										
scipy sparse.linalg.LinearOperator.transpose	R	scipy.sparse.linalg.LinearOperator.transpose										
scipy sparse linalg LinearOperator T	R	scipy.sparse.linalg.LinearOperator.T										
scipy sparse.linalg.LinearOperator.T	R	scipy.sparse.linalg.LinearOperator.T										
scipy.sparse.linalg.lobpcg	A										<section class="prog__container"><p>Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)</p><pre><code>scipy.sparse.linalg.lobpcg(A, X, B=None, M=None, Y=None, tol=None, maxiter=20, largest=True, verbosityLevel=0, retLambdaHistory=False, retResidualNormsHistory=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The symmetric linear operator of the problem, usually a sparse matrix.  Often called the “stiffness matrix”. \nX : array_like\n    Initial approximation to the k eigenvectors. If A has shape=(n,n) then X should have shape shape=(n,k). \nB : {dense matrix, sparse matrix, LinearOperator}, optional\n    the right hand side operator in a generalized eigenproblem. by default, B = Identity often called the “mass matrix” \nM : {dense matrix, sparse matrix, LinearOperator}, optional\n    preconditioner to A; by default M = Identity M should approximate the inverse of A \nY : array_like, optional\n    n-by-sizeY matrix of constraints, sizeY < n The iterations will be performed in the B-orthogonal complement of the column-space of Y. Y must be full rank.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : array\n    Array of k eigenvalues \nv : array\n    An array of k eigenvectors.  V has the same shape as X.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import spdiags, issparse\n>>> from scipy.sparse.linalg import lobpcg, LinearOperator\n>>> n = 100\n>>> vals = [np.arange(n, dtype=np.float64) + 1]\n>>> A = spdiags(vals, 0, n, n)\n>>> A.toarray()\narray([[   1.,    0.,    0., ...,    0.,    0.,    0.],\n       [   0.,    2.,    0., ...,    0.,    0.,    0.],\n       [   0.,    0.,    3., ...,    0.,    0.,    0.],\n       ..., \n       [   0.,    0.,    0., ...,   98.,    0.,    0.],\n       [   0.,    0.,    0., ...,    0.,   99.,    0.],\n       [   0.,    0.,    0., ...,    0.,    0.,  100.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lobpcg.html
scipy sparse linalg lobpcg	R	scipy.sparse.linalg.lobpcg										
scipy sparse.linalg.lobpcg	R	scipy.sparse.linalg.lobpcg										
scipy.sparse.linalg.lsmr	A										<section class="prog__container"><p>Iterative solver for least-squares problems.</p><pre><code>scipy.sparse.linalg.lsmr(A, b, damp=0.0, atol=1e-06, btol=1e-06, conlim=100000000.0, maxiter=None, show=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {matrix, sparse matrix, ndarray, LinearOperator}\n    Matrix A in the linear system. \nb : array_like, shape (m,)\n    Vector b in the linear system. \ndamp : float\n    Damping factor for regularized least-squares. lsmr solves the regularized least-squares problem: min ||(b) - (  A   )x||     ||(0)   (damp*I) ||_2   where damp is a scalar.  If damp is None or 0, the system is solved without regularization. \natol, btol : float, optional\n    Stopping tolerances. lsmr continues iterations until a certain backward error estimate is smaller than some quantity depending on atol and btol.  Let r = b - Ax be the residual vector for the current approximate solution x. If Ax = b seems to be consistent, lsmr terminates when norm(r) <= atol * norm(A) * norm(x) + btol * norm(b). Otherwise, lsmr terminates when norm(A^{T} r) <= atol * norm(A) * norm(r).  If both tolerances are 1.0e-6 (say), the final norm(r) should be accurate to about 6 digits. (The final x will usually have fewer correct digits, depending on cond(A) and the size of LAMBDA.)  If atol or btol is None, a default value of 1.0e-6 will be used. Ideally, they should be estimates of the relative error in the entries of A and B respectively.  For example, if the entries of A have 7 correct digits, set atol = 1e-7. This prevents the algorithm from doing unnecessary work beyond the uncertainty of the input data. \nconlim : float, optional\n    lsmr terminates if an estimate of cond(A) exceeds conlim.  For compatible systems Ax = b, conlim could be as large as 1.0e+12 (say).  For least-squares problems, conlim should be less than 1.0e+8. If conlim is None, the default value is 1e+8.  Maximum precision can be obtained by setting atol = btol = conlim = 0, but the number of iterations may then be excessive. \nmaxiter : int, optional\n    lsmr terminates if the number of iterations reaches maxiter.  The default is maxiter = min(m, n).  For ill-conditioned systems, a larger value of maxiter may be needed. \nshow : bool, optional\n    Print iterations logs if show=True.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray of float\n    Least-square solution returned. \nistop : int\n    istop gives the reason for stopping: istop   = 0 means x=0 is a solution.         = 1 means x is an approximate solution to A*x = B,             according to atol and btol.         = 2 means x approximately solves the least-squares problem             according to atol.         = 3 means COND(A) seems to be greater than CONLIM.         = 4 is the same as 1 with atol = btol = eps (machine             precision)         = 5 is the same as 2 with atol = eps.         = 6 is the same as 3 with CONLIM = 1/eps.         = 7 means ITN reached maxiter before the other stopping             conditions were satisfied.   \nitn : int\n    Number of iterations used. \nnormr : float\n    norm(b-Ax) \nnormar : float\n    norm(A^T (b - Ax)) \nnorma : float\n    norm(A) \nconda : float\n    Condition number of A. \nnormx : float\n    norm(x)</code></pre><span class="prog__sub">Examples:</span><pre><code>min ||(b) - (  A   )x||\n    ||(0)   (damp*I) ||_2</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lsmr.html
scipy sparse linalg lsmr	R	scipy.sparse.linalg.lsmr										
scipy sparse.linalg.lsmr	R	scipy.sparse.linalg.lsmr										
scipy.sparse.linalg.lsqr	A										<section class="prog__container"><p>Find the least-squares solution to a large, sparse, linear system\nof equations.</p><pre><code>scipy.sparse.linalg.lsqr(A, b, damp=0.0, atol=1e-08, btol=1e-08, conlim=100000000.0, iter_lim=None, show=False, calc_var=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, ndarray, LinearOperator}\n    Representation of an m-by-n matrix.  It is required that the linear operator can produce Ax and A^T x. \nb : array_like, shape (m,)\n    Right-hand side vector b. \ndamp : float\n    Damping coefficient. \natol, btol : float, optional\n    Stopping tolerances. If both are 1.0e-9 (say), the final residual norm should be accurate to about 9 digits.  (The final x will usually have fewer correct digits, depending on cond(A) and the size of damp.) \nconlim : float, optional\n    Another stopping tolerance.  lsqr terminates if an estimate of cond(A) exceeds conlim.  For compatible systems Ax = b, conlim could be as large as 1.0e+12 (say).  For least-squares problems, conlim should be less than 1.0e+8. Maximum precision can be obtained by setting atol = btol = conlim = zero, but the number of iterations may then be excessive. \niter_lim : int, optional\n    Explicit limitation on number of iterations (for safety). \nshow : bool, optional\n    Display an iteration log. \ncalc_var : bool, optional\n    Whether to estimate diagonals of (A'A + damp^2*I)^{-1}.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray of float\n    The final solution. \nistop : int\n    Gives the reason for termination. 1 means x is an approximate solution to Ax = b. 2 means x approximately solves the least-squares problem. \nitn : int\n    Iteration number upon termination. \nr1norm : float\n    norm(r), where r = b - Ax. \nr2norm : float\n    sqrt( norm(r)^2  +  damp^2 * norm(x)^2 ).  Equal to r1norm if damp == 0. \nanorm : float\n    Estimate of Frobenius norm of Abar = [[A]; [damp*I]]. \nacond : float\n    Estimate of cond(Abar). \narnorm : float\n    Estimate of norm(A'*r - damp^2*x). \nxnorm : float\n    norm(x) \nvar : ndarray of float\n    If calc_var is True, estimates all diagonals of (A'A)^{-1} (if damp == 0) or more generally (A'A + damp^2*I)^{-1}.  This is well defined if A has full column rank or damp > 0.  (Not sure what var means if rank(A) < n and damp = 0.)</code></pre><span class="prog__sub">Examples:</span><pre><code>1. Unsymmetric equations --    solve  A*x = b\n\n2. Linear least squares  --    solve  A*x = b\n                               in the least-squares sense\n\n3. Damped least squares  --    solve  (   A    )*x = ( b )\n                                      ( damp*I )     ( 0 )\n                               in the least-squares sense</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lsqr.html
scipy sparse linalg lsqr	R	scipy.sparse.linalg.lsqr										
scipy sparse.linalg.lsqr	R	scipy.sparse.linalg.lsqr										
scipy.sparse.linalg.minres	A										<section class="prog__container"><p>Use MINimum RESidual iteration to solve Ax=b</p><pre><code>scipy.sparse.linalg.minres(A, b, x0=None, shift=0.0, tol=1e-05, maxiter=None, xtype=None, M=None, callback=None, show=False, check=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The real symmetric N-by-N matrix of the linear system \nb : {array, matrix}\n    Right hand side of the linear system. Has shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {array, matrix}\n    The converged solution. \ninfo : integer\n    Provides convergence information: 0  : successful exit >0 : convergence to tolerance not achieved, number of iterations <0 : illegal input or breakdown</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.minres.html
scipy sparse linalg minres	R	scipy.sparse.linalg.minres										
scipy sparse.linalg.minres	R	scipy.sparse.linalg.minres										
scipy.sparse.linalg.norm	A										<section class="prog__container"><p>Norm of a sparse matrix</p><pre><code>scipy.sparse.linalg.norm(x, ord=None, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : a sparse matrix\n    Input sparse matrix. \nord : {non-zero int, inf, -inf, ‘fro’}, optional\n    Order of the norm (see table under Notes). inf means numpy’s inf object. \naxis : {int, 2-tuple of ints, None}, optional\n    If axis is an integer, it specifies the axis of x along which to compute the vector norms.  If axis is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed.  If axis is None then either a vector norm (when x is 1-D) or a matrix norm (when x is 2-D) is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>n : float or ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import *\n>>> import numpy as np\n>>> from scipy.sparse.linalg import norm\n>>> a = np.arange(9) - 4\n>>> a\narray([-4, -3, -2, -1, 0, 1, 2, 3, 4])\n>>> b = a.reshape((3, 3))\n>>> b\narray([[-4, -3, -2],\n       [-1, 0, 1],\n       [ 2, 3, 4]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.norm.html
scipy sparse linalg norm	R	scipy.sparse.linalg.norm										
scipy sparse.linalg.norm	R	scipy.sparse.linalg.norm										
scipy.sparse.linalg.onenormest	A										<section class="prog__container"><p>Compute a lower bound of the 1-norm of a sparse matrix.</p><pre><code>scipy.sparse.linalg.onenormest(A, t=2, itmax=5, compute_v=False, compute_w=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : ndarray or other linear operator\n    A linear operator that can be transposed and that can produce matrix products. \nt : int, optional\n    A positive parameter controlling the tradeoff between accuracy versus time and memory usage. Larger values take longer and use more memory but give more accurate output. \nitmax : int, optional\n    Use at most this many iterations. \ncompute_v : bool, optional\n    Request a norm-maximizing linear operator input vector if True. \ncompute_w : bool, optional\n    Request a norm-maximizing linear operator output vector if True.</code></pre><span class="prog__sub">Returns:</span><pre><code>est : float\n    An underestimate of the 1-norm of the sparse matrix. \nv : ndarray, optional\n    The vector such that ||Av||_1 == est*||v||_1. It can be thought of as an input to the linear operator that gives an output with particularly large norm. \nw : ndarray, optional\n    The vector Av which has relatively large 1-norm. It can be thought of as an output of the linear operator that is relatively large in norm compared to the input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.onenormest.html
scipy sparse linalg onenormest	R	scipy.sparse.linalg.onenormest										
scipy sparse.linalg.onenormest	R	scipy.sparse.linalg.onenormest										
scipy.sparse.linalg.qmr	A					[[scipy.sparse.linalg.LinearOperator]]					<section class="prog__container"><p>Use Quasi-Minimal Residual iteration to solve A x = b</p><pre><code>scipy.sparse.linalg.qmr(A, b, x0=None, tol=1e-05, maxiter=None, xtype=None, M1=None, M2=None, callback=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, dense matrix, LinearOperator}\n    The real-valued N-by-N matrix of the linear system. It is required that the linear operator can produce Ax and A^T x. \nb : {array, matrix}\n    Right hand side of the linear system. Has shape (N,) or (N,1).</code></pre><span class="prog__sub">Returns:</span><pre><code>x : {array, matrix}\n    The converged solution. \ninfo : integer\n    Provides convergence information: 0  : successful exit >0 : convergence to tolerance not achieved, number of iterations <0 : illegal input or breakdown</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.qmr.html
scipy sparse linalg qmr	R	scipy.sparse.linalg.qmr										
scipy sparse.linalg.qmr	R	scipy.sparse.linalg.qmr										
scipy.sparse.linalg.spilu	A										<section class="prog__container"><p>Compute an incomplete LU decomposition for a sparse, square matrix.</p><pre><code>scipy.sparse.linalg.spilu(A, drop_tol=None, fill_factor=None, drop_rule=None, permc_spec=None, diag_pivot_thresh=None, relax=None, panel_size=None, options=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : (N, N) array_like\n    Sparse matrix to factorize \ndrop_tol : float, optional\n    Drop tolerance (0 <= tol <= 1) for an incomplete LU decomposition. (default: 1e-4) \nfill_factor : float, optional\n    Specifies the fill ratio upper bound (>= 1.0) for ILU. (default: 10) \ndrop_rule : str, optional\n    Comma-separated string of drop rules to use. Available rules: basic, prows, column, area, secondary, dynamic, interp. (Default: basic,area) See SuperLU documentation for details. \nRemaining other options\n    Same as for splu</code></pre><span class="prog__sub">Returns:</span><pre><code>invA_approx : scipy.sparse.linalg.SuperLU\n    Object, which has a solve method.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.spilu.html
scipy sparse linalg spilu	R	scipy.sparse.linalg.spilu										
scipy sparse.linalg.spilu	R	scipy.sparse.linalg.spilu										
scipy.sparse.linalg.splu	A										<section class="prog__container"><p>Compute the LU decomposition of a sparse, square matrix.</p><pre><code>scipy.sparse.linalg.splu(A, permc_spec=None, diag_pivot_thresh=None, drop_tol=None, relax=None, panel_size=None, options={})</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : sparse matrix\n    Sparse matrix to factorize. Should be in CSR or CSC format. \npermc_spec : str, optional\n    How to permute the columns of the matrix for sparsity preservation. (default: ‘COLAMD’)  NATURAL: natural ordering. MMD_ATA: minimum degree ordering on the structure of A^T A. MMD_AT_PLUS_A: minimum degree ordering on the structure of A^T+A. COLAMD: approximate minimum degree column ordering  \ndiag_pivot_thresh : float, optional\n    Threshold used for a diagonal entry to be an acceptable pivot. See SuperLU user’s guide for details [R307] \ndrop_tol : float, optional\n    (deprecated) No effect. \nrelax : int, optional\n    Expert option for customizing the degree of relaxing supernodes. See SuperLU user’s guide for details [R307] \npanel_size : int, optional\n    Expert option for customizing the panel size. See SuperLU user’s guide for details [R307] \noptions : dict, optional\n    Dictionary containing additional expert options to SuperLU. See SuperLU user guide [R307] (section 2.4 on the ‘Options’ argument) for more details. For example, you can specify options=dict(Equil=False, IterRefine='SINGLE')) to turn equilibration off and perform a single iterative refinement.</code></pre><span class="prog__sub">Returns:</span><pre><code>invA : scipy.sparse.linalg.SuperLU\n    Object, which has a solve method.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.splu.html
scipy sparse linalg splu	R	scipy.sparse.linalg.splu										
scipy sparse.linalg.splu	R	scipy.sparse.linalg.splu										
scipy.sparse.linalg.spsolve	A										<section class="prog__container"><p>Solve the sparse linear system Ax=b, where b may be a vector or a matrix.</p><pre><code>scipy.sparse.linalg.spsolve(A, b, permc_spec=None, use_umfpack=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : ndarray or sparse matrix\n    The square matrix A will be converted into CSC or CSR form \nb : ndarray or sparse matrix\n    The matrix or vector representing the right hand side of the equation. If a vector, b.shape must be (n,) or (n, 1). \npermc_spec : str, optional\n    How to permute the columns of the matrix for sparsity preservation. (default: ‘COLAMD’)  NATURAL: natural ordering. MMD_ATA: minimum degree ordering on the structure of A^T A. MMD_AT_PLUS_A: minimum degree ordering on the structure of A^T+A. COLAMD: approximate minimum degree column ordering  \nuse_umfpack : bool, optional\n    if True (default) then use umfpack for the solution.  This is only referenced if b is a vector and scikit-umfpack is installed.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray or sparse matrix\n    the solution of the sparse linear equation. If b is a vector, then x is a vector of size A.shape[1] If b is a matrix, then x is a matrix of size (A.shape[1], b.shape[1])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.spsolve.html
scipy sparse linalg spsolve	R	scipy.sparse.linalg.spsolve										
scipy sparse.linalg.spsolve	R	scipy.sparse.linalg.spsolve										
scipy.sparse.linalg.SuperLU	A										<section class="prog__container"><p>LU factorization of a sparse matrix.</p><pre><code>class scipy.sparse.linalg.SuperLU</code></pre><span class="prog__sub">Examples:</span><pre><code>Pr * A * Pc = L * U</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.html
scipy.sparse.linalg.SuperLU.L	A										<section class="prog__container"><p>Lower triangular factor with unit diagonal as a\nscipy.sparse.csc_matrix.</p><pre><code>SuperLU.L</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.L.html
scipy sparse linalg SuperLU L	R	scipy.sparse.linalg.SuperLU.L										
scipy sparse.linalg.SuperLU.L	R	scipy.sparse.linalg.SuperLU.L										
scipy.sparse.linalg.SuperLU.nnz	A										<section class="prog__container"><p>Number of nonzero elements in the matrix.</p><pre><code>SuperLU.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.nnz.html
scipy sparse linalg SuperLU nnz	R	scipy.sparse.linalg.SuperLU.nnz										
scipy sparse.linalg.SuperLU.nnz	R	scipy.sparse.linalg.SuperLU.nnz										
scipy.sparse.linalg.SuperLU.perm_c	A										<section class="prog__container"><p>Permutation Pc represented as an array of indices.</p><pre><code>SuperLU.perm_c</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> Pc = np.zeros((n, n))\n>>> Pc[np.arange(n), perm_c] = 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.perm_c.html
scipy sparse linalg SuperLU perm_c	R	scipy.sparse.linalg.SuperLU.perm_c										
scipy sparse.linalg.SuperLU.perm_c	R	scipy.sparse.linalg.SuperLU.perm_c										
scipy.sparse.linalg.SuperLU.perm_r	A										<section class="prog__container"><p>Permutation Pr represented as an array of indices.</p><pre><code>SuperLU.perm_r</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> Pr = np.zeros((n, n))\n>>> Pr[perm_r, np.arange(n)] = 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.perm_r.html
scipy sparse linalg SuperLU perm_r	R	scipy.sparse.linalg.SuperLU.perm_r										
scipy sparse.linalg.SuperLU.perm_r	R	scipy.sparse.linalg.SuperLU.perm_r										
scipy sparse linalg SuperLU	R	scipy.sparse.linalg.SuperLU										
scipy sparse.linalg.SuperLU	R	scipy.sparse.linalg.SuperLU										
scipy.sparse.linalg.SuperLU.shape	A										<section class="prog__container"><p>Shape of the original matrix as a tuple of ints.</p><pre><code>SuperLU.shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.shape.html
scipy sparse linalg SuperLU shape	R	scipy.sparse.linalg.SuperLU.shape										
scipy sparse.linalg.SuperLU.shape	R	scipy.sparse.linalg.SuperLU.shape										
scipy.sparse.linalg.SuperLU.solve	A										<section class="prog__container"><p>Solves linear system of equations with one or several right-hand sides.</p><pre><code>SuperLU.solve(rhs[, trans])</code></pre><span class="prog__sub">Parameters:</span><pre><code>rhs : ndarray, shape (n,) or (n, k)\n    Right hand side(s) of equation \ntrans : {‘N’, ‘T’, ‘H’}, optional\n    Type of system to solve: 'N':   A   * x == rhs  (default) 'T':   A^T * x == rhs 'H':   A^H * x == rhs   i.e., normal, transposed, and hermitian conjugate.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray, shape rhs.shape\n    Solution vector(s)</code></pre><span class="prog__sub">Examples:</span><pre><code>'N':   A   * x == rhs  (default)\n'T':   A^T * x == rhs\n'H':   A^H * x == rhs</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.solve.html
scipy sparse linalg SuperLU solve	R	scipy.sparse.linalg.SuperLU.solve										
scipy sparse.linalg.SuperLU.solve	R	scipy.sparse.linalg.SuperLU.solve										
scipy.sparse.linalg.SuperLU.U	A										<section class="prog__container"><p>Upper triangular factor as a scipy.sparse.csc_matrix.</p><pre><code>SuperLU.U</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.U.html
scipy sparse linalg SuperLU U	R	scipy.sparse.linalg.SuperLU.U										
scipy sparse.linalg.SuperLU.U	R	scipy.sparse.linalg.SuperLU.U										
scipy.sparse.linalg.svds	A										<section class="prog__container"><p>Compute the largest k singular values/vectors for a sparse matrix.</p><pre><code>scipy.sparse.linalg.svds(A, k=6, ncv=None, tol=0, which='LM', v0=None, maxiter=None, return_singular_vectors=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : {sparse matrix, LinearOperator}\n    Array to compute the SVD on, of shape (M, N) \nk : int, optional\n    Number of singular values and vectors to compute. Must be 1 <= k < min(A.shape). \nncv : int, optional\n    The number of Lanczos vectors generated ncv must be greater than k+1 and smaller than n; it is recommended that ncv > 2*k Default: min(n, max(2*k + 1, 20)) \ntol : float, optional\n    Tolerance for singular values. Zero (default) means machine precision. \nwhich : str, [‘LM’ | ‘SM’], optional\n    Which k singular values to find:   ‘LM’ : largest singular values ‘SM’ : smallest singular values    New in version 0.12.0.  \nv0 : ndarray, optional\n    Starting vector for iteration, of length min(A.shape). Should be an (approximate) left singular vector if N > M and a right singular vector otherwise. Default: random  New in version 0.12.0.  \nmaxiter : int, optional\n    Maximum number of iterations.  New in version 0.12.0.  \nreturn_singular_vectors : bool or str, optional\n    True: return singular vectors (True) in addition to singular values.   New in version 0.12.0.   “u”: only return the u matrix, without computing vh (if N > M). “vh”: only return the vh matrix, without computing u (if N <= M).   New in version 0.16.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>u : ndarray, shape=(M, k)\n    Unitary matrix having left singular vectors as columns. If return_singular_vectors is “vh”, this variable is not computed, and None is returned instead. \ns : ndarray, shape=(k,)\n    The singular values. \nvt : ndarray, shape=(k, N)\n    Unitary matrix having right singular vectors as rows. If return_singular_vectors is “u”, this variable is not computed, and None is returned instead.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.svds.html
scipy sparse linalg svds	R	scipy.sparse.linalg.svds										
scipy sparse.linalg.svds	R	scipy.sparse.linalg.svds										
scipy.sparse.linalg.use_solver	A										<section class="prog__container"><p>Select default sparse direct solver to be used.</p><pre><code>scipy.sparse.linalg.use_solver(**kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>useUmfpack : bool, optional\n    Use UMFPACK over SuperLU. Has effect only if scikits.umfpack is installed. Default: True</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.use_solver.html
scipy sparse linalg use_solver	R	scipy.sparse.linalg.use_solver										
scipy sparse.linalg.use_solver	R	scipy.sparse.linalg.use_solver										
scipy.sparse.rand	A										<section class="prog__container"><p>Generate a sparse matrix of the given shape and density with uniformly\ndistributed values.</p><pre><code>scipy.sparse.rand(m, n, density=0.01, format='coo', dtype=None, random_state=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m, n : int\n    shape of the matrix \ndensity : real, optional\n    density of the generated matrix: density equal to one means a full matrix, density of 0 means a matrix with no non-zero items. \nformat : str, optional\n    sparse matrix format. \ndtype : dtype, optional\n    type of the returned matrix values. \nrandom_state : {numpy.random.RandomState, int}, optional\n    Random number generator or random seed. If not given, the singleton numpy.random will be used.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.rand.html
scipy.sparse.random	A										<section class="prog__container"><p>Generate a sparse matrix of the given shape and density with randomly\ndistributed values.</p><pre><code>scipy.sparse.random(m, n, density=0.01, format='coo', dtype=None, random_state=None, data_rvs=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m, n : int\n    shape of the matrix \ndensity : real, optional\n    density of the generated matrix: density equal to one means a full matrix, density of 0 means a matrix with no non-zero items. \nformat : str, optional\n    sparse matrix format. \ndtype : dtype, optional\n    type of the returned matrix values. \nrandom_state : {numpy.random.RandomState, int}, optional\n    Random number generator or random seed. If not given, the singleton numpy.random will be used.  This random state will be used for sampling the sparsity structure, but not necessarily for sampling the values of the structurally nonzero entries of the matrix. \ndata_rvs : callable, optional\n    Samples a requested number of random values. This function should take a single argument specifying the length of the ndarray that it will return.  The structurally nonzero entries of the sparse random matrix will be taken from the array sampled by this function.  By default, uniform [0, 1) random values will be sampled using the same random state as is used for sampling the sparsity structure.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import random\n>>> from scipy import stats\n>>> class CustomRandomState(object):\n...     def randint(self, k):\n...         i = np.random.randint(k)\n...         return i - i % 2\n>>> rs = CustomRandomState()\n>>> rvs = stats.poisson(25, loc=10).rvs\n>>> S = random(3, 4, density=0.25, random_state=rs, data_rvs=rvs)\n>>> S.A\narray([[ 36.,   0.,  33.,   0.],   # random\n       [  0.,   0.,   0.,   0.],\n       [  0.,   0.,  36.,   0.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.random.html
scipy sparse random	R	scipy.sparse.random										
scipy sparse.random	R	scipy.sparse.random										
scipy sparse rand	R	scipy.sparse.rand										
scipy sparse.rand	R	scipy.sparse.rand										
scipy.sparse.spdiags	A										<section class="prog__container"><p>Return a sparse matrix from diagonals.</p><pre><code>scipy.sparse.spdiags(data, diags, m, n, format=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    matrix diagonals stored row-wise \ndiags : diagonals to set\n    k = 0  the main diagonal k > 0  the k-th upper diagonal k < 0  the k-th lower diagonal  \nm, n : int\n    shape of the result \nformat : str, optional\n    Format of the result. By default (format=None) an appropriate sparse matrix format is returned.  This choice is subject to change.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import spdiags\n>>> data = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])\n>>> diags = np.array([0, -1, 2])\n>>> spdiags(data, diags, 4, 4).toarray()\narray([[1, 0, 3, 0],\n       [1, 2, 0, 4],\n       [0, 2, 3, 0],\n       [0, 0, 3, 4]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spdiags.html
scipy sparse spdiags	R	scipy.sparse.spdiags										
scipy sparse.spdiags	R	scipy.sparse.spdiags										
scipy.sparse.spmatrix	A										<section class="prog__container"><p>This class provides a base class for all sparse matrices.  It\ncannot be instantiated.  Most of the work is provided by subclasses.</p><pre><code>class scipy.sparse.spmatrix(maxprint=50)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.html
scipy.sparse.spmatrix.asformat	A										<section class="prog__container"><p>Return this matrix in a given sparse format</p><pre><code>spmatrix.asformat(format)</code></pre><span class="prog__sub">Parameters:</span><pre><code>format : {string, None}\n    desired sparse matrix format  None for no format conversion “csr” for csr_matrix format “csc” for csc_matrix format “lil” for lil_matrix format “dok” for dok_matrix format and so on</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.asformat.html
scipy sparse spmatrix asformat	R	scipy.sparse.spmatrix.asformat										
scipy sparse.spmatrix.asformat	R	scipy.sparse.spmatrix.asformat										
scipy.sparse.spmatrix.asfptype	A										<section class="prog__container"><p>Upcast matrix to a floating point format (if necessary)</p><pre><code>spmatrix.asfptype()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.asfptype.html
scipy sparse spmatrix asfptype	R	scipy.sparse.spmatrix.asfptype										
scipy sparse.spmatrix.asfptype	R	scipy.sparse.spmatrix.asfptype										
scipy.sparse.spmatrix.copy	A										<section class="prog__container"><p>Returns a copy of this matrix.</p><pre><code>spmatrix.copy()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.copy.html
scipy sparse spmatrix copy	R	scipy.sparse.spmatrix.copy										
scipy sparse.spmatrix.copy	R	scipy.sparse.spmatrix.copy										
scipy.sparse.spmatrix.count_nonzero	A										<section class="prog__container"><p>Number of non-zero entries, equivalent to</p><pre><code>spmatrix.count_nonzero()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.count_nonzero.html
scipy sparse spmatrix count_nonzero	R	scipy.sparse.spmatrix.count_nonzero										
scipy sparse.spmatrix.count_nonzero	R	scipy.sparse.spmatrix.count_nonzero										
scipy.sparse.spmatrix.diagonal	A										<section class="prog__container"><p>Returns the main diagonal of the matrix</p><pre><code>spmatrix.diagonal()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.diagonal.html
scipy sparse spmatrix diagonal	R	scipy.sparse.spmatrix.diagonal										
scipy sparse.spmatrix.diagonal	R	scipy.sparse.spmatrix.diagonal										
scipy.sparse.spmatrix.dot	A										<section class="prog__container"><p>Ordinary dot product</p><pre><code>spmatrix.dot(other)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import numpy as np\n>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1, 2, 0], [0, 0, 3], [4, 0, 5]])\n>>> v = np.array([1, 0, -1])\n>>> A.dot(v)\narray([ 1, -3, -1], dtype=int64)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.dot.html
scipy sparse spmatrix dot	R	scipy.sparse.spmatrix.dot										
scipy sparse.spmatrix.dot	R	scipy.sparse.spmatrix.dot										
scipy.sparse.spmatrix.getcol	A										<section class="prog__container"><p>Returns a copy of column j of the matrix, as an (m x 1) sparse\nmatrix (column vector).</p><pre><code>spmatrix.getcol(j)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.getcol.html
scipy sparse spmatrix getcol	R	scipy.sparse.spmatrix.getcol										
scipy sparse.spmatrix.getcol	R	scipy.sparse.spmatrix.getcol										
scipy.sparse.spmatrix.getnnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>spmatrix.getnnz(axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : None, 0, or 1\n    Select between the number of values across the whole matrix, in each column, or in each row.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.getnnz.html
scipy sparse spmatrix getnnz	R	scipy.sparse.spmatrix.getnnz										
scipy sparse.spmatrix.getnnz	R	scipy.sparse.spmatrix.getnnz										
scipy.sparse.spmatrix.getrow	A										<section class="prog__container"><p>Returns a copy of row i of the matrix, as a (1 x n) sparse\nmatrix (row vector).</p><pre><code>spmatrix.getrow(i)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.getrow.html
scipy sparse spmatrix getrow	R	scipy.sparse.spmatrix.getrow										
scipy sparse.spmatrix.getrow	R	scipy.sparse.spmatrix.getrow										
scipy.sparse.spmatrix.mean	A										<section class="prog__container"><p>Compute the arithmetic mean along the specified axis.</p><pre><code>spmatrix.mean(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the mean is computed. The default is to compute the mean of all elements in the matrix (i.e. axis = None). \ndtype : data-type, optional\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>m : np.matrix</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.mean.html
scipy sparse spmatrix mean	R	scipy.sparse.spmatrix.mean										
scipy sparse.spmatrix.mean	R	scipy.sparse.spmatrix.mean										
scipy.sparse.spmatrix.multiply	A										<section class="prog__container"><p>Point-wise multiplication by another matrix</p><pre><code>spmatrix.multiply(other)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.multiply.html
scipy sparse spmatrix multiply	R	scipy.sparse.spmatrix.multiply										
scipy sparse.spmatrix.multiply	R	scipy.sparse.spmatrix.multiply										
scipy.sparse.spmatrix.nnz	A										<section class="prog__container"><p>Number of stored values, including explicit zeros.</p><pre><code>spmatrix.nnz</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.nnz.html
scipy sparse spmatrix nnz	R	scipy.sparse.spmatrix.nnz										
scipy sparse.spmatrix.nnz	R	scipy.sparse.spmatrix.nnz										
scipy.sparse.spmatrix.nonzero	A										<section class="prog__container"><p>nonzero indices</p><pre><code>spmatrix.nonzero()</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix\n>>> A = csr_matrix([[1,2,0],[0,0,3],[4,0,5]])\n>>> A.nonzero()\n(array([0, 0, 1, 2, 2]), array([0, 1, 2, 0, 2]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.nonzero.html
scipy sparse spmatrix nonzero	R	scipy.sparse.spmatrix.nonzero										
scipy sparse.spmatrix.nonzero	R	scipy.sparse.spmatrix.nonzero										
scipy.sparse.spmatrix.reshape	A										<section class="prog__container"><p>Gives a new shape to a sparse matrix without changing its data.</p><pre><code>spmatrix.reshape(shape, order='C')</code></pre><span class="prog__sub">Parameters:</span><pre><code>shape : length-2 tuple of ints\n    The new shape should be compatible with the original shape. \norder : ‘C’, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value, as this argument is not used.</code></pre><span class="prog__sub">Returns:</span><pre><code>reshaped_matrix : self with the new dimensions of shape</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.reshape.html
scipy sparse spmatrix reshape	R	scipy.sparse.spmatrix.reshape										
scipy sparse.spmatrix.reshape	R	scipy.sparse.spmatrix.reshape										
scipy sparse spmatrix	R	scipy.sparse.spmatrix										
scipy sparse.spmatrix	R	scipy.sparse.spmatrix										
scipy.sparse.spmatrix.setdiag	A										<section class="prog__container"><p>Set diagonal or off-diagonal elements of the array.</p><pre><code>spmatrix.setdiag(values, k=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>values : array_like\n    New values of the diagonal elements. Values may have any length.  If the diagonal is longer than values, then the remaining diagonal entries will not be set.  If values if longer than the diagonal, then the remaining values are ignored. If a scalar value is given, all of the diagonal is set to it. \nk : int, optional\n    Which off-diagonal to set, corresponding to elements a[i,i+k]. Default: 0 (the main diagonal).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.setdiag.html
scipy sparse spmatrix setdiag	R	scipy.sparse.spmatrix.setdiag										
scipy sparse.spmatrix.setdiag	R	scipy.sparse.spmatrix.setdiag										
scipy.sparse.spmatrix.sum	A										<section class="prog__container"><p>Sum the matrix elements over a given axis.</p><pre><code>spmatrix.sum(axis=None, dtype=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axis : {-2, -1, 0, 1, None} optional\n    Axis along which the sum is computed. The default is to compute the sum of all the matrix elements, returning a scalar (i.e. axis = None). \ndtype : dtype, optional\n    The type of the returned matrix and of the accumulator in which the elements are summed.  The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer.  In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used. \nout : np.matrix, optional\n    Alternative output matrix in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</code></pre><span class="prog__sub">Returns:</span><pre><code>sum_along_axis : np.matrix\n    A matrix with the same shape as self, with the specified axis removed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.sum.html
scipy sparse spmatrix sum	R	scipy.sparse.spmatrix.sum										
scipy sparse.spmatrix.sum	R	scipy.sparse.spmatrix.sum										
scipy.sparse.spmatrix.toarray	A										<section class="prog__container"><p>Return a dense ndarray representation of this matrix.</p><pre><code>spmatrix.toarray(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method. For most sparse types, out is required to be memory contiguous (either C or Fortran ordered).</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : ndarray, 2-dimensional\n    An array with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed, the same object is returned after being modified in-place to contain the appropriate values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.toarray.html
scipy sparse spmatrix toarray	R	scipy.sparse.spmatrix.toarray										
scipy sparse.spmatrix.toarray	R	scipy.sparse.spmatrix.toarray										
scipy.sparse.spmatrix.tobsr	A										<section class="prog__container"><p>Convert this matrix to Block Sparse Row format.</p><pre><code>spmatrix.tobsr(blocksize=None, copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.tobsr.html
scipy sparse spmatrix tobsr	R	scipy.sparse.spmatrix.tobsr										
scipy sparse.spmatrix.tobsr	R	scipy.sparse.spmatrix.tobsr										
scipy.sparse.spmatrix.tocoo	A										<section class="prog__container"><p>Convert this matrix to COOrdinate format.</p><pre><code>spmatrix.tocoo(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.tocoo.html
scipy sparse spmatrix tocoo	R	scipy.sparse.spmatrix.tocoo										
scipy sparse.spmatrix.tocoo	R	scipy.sparse.spmatrix.tocoo										
scipy.sparse.spmatrix.tocsc	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Column format.</p><pre><code>spmatrix.tocsc(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.tocsc.html
scipy sparse spmatrix tocsc	R	scipy.sparse.spmatrix.tocsc										
scipy sparse.spmatrix.tocsc	R	scipy.sparse.spmatrix.tocsc										
scipy.sparse.spmatrix.tocsr	A										<section class="prog__container"><p>Convert this matrix to Compressed Sparse Row format.</p><pre><code>spmatrix.tocsr(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.tocsr.html
scipy sparse spmatrix tocsr	R	scipy.sparse.spmatrix.tocsr										
scipy sparse.spmatrix.tocsr	R	scipy.sparse.spmatrix.tocsr										
scipy.sparse.spmatrix.todense	A										<section class="prog__container"><p>Return a dense matrix representation of this matrix.</p><pre><code>spmatrix.todense(order=None, out=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>order : {‘C’, ‘F’}, optional\n    Whether to store multi-dimensional data in C (row-major) or Fortran (column-major) order in memory. The default is ‘None’, indicating the NumPy default of C-ordered. Cannot be specified in conjunction with the out argument. \nout : ndarray, 2-dimensional, optional\n    If specified, uses this array (or numpy.matrix) as the output buffer instead of allocating a new array to return. The provided array must have the same shape and dtype as the sparse matrix on which you are calling the method.</code></pre><span class="prog__sub">Returns:</span><pre><code>arr : numpy.matrix, 2-dimensional\n    A NumPy matrix object with the same shape and containing the same data represented by the sparse matrix, with the requested memory order. If out was passed and was an array (rather than a numpy.matrix), it will be filled with the appropriate values and returned wrapped in a numpy.matrix object that shares the same memory.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.todense.html
scipy sparse spmatrix todense	R	scipy.sparse.spmatrix.todense										
scipy sparse.spmatrix.todense	R	scipy.sparse.spmatrix.todense										
scipy.sparse.spmatrix.todia	A										<section class="prog__container"><p>Convert this matrix to sparse DIAgonal format.</p><pre><code>spmatrix.todia(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.todia.html
scipy sparse spmatrix todia	R	scipy.sparse.spmatrix.todia										
scipy sparse.spmatrix.todia	R	scipy.sparse.spmatrix.todia										
scipy.sparse.spmatrix.todok	A										<section class="prog__container"><p>Convert this matrix to Dictionary Of Keys format.</p><pre><code>spmatrix.todok(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.todok.html
scipy sparse spmatrix todok	R	scipy.sparse.spmatrix.todok										
scipy sparse.spmatrix.todok	R	scipy.sparse.spmatrix.todok										
scipy.sparse.spmatrix.tolil	A										<section class="prog__container"><p>Convert this matrix to LInked List format.</p><pre><code>spmatrix.tolil(copy=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.tolil.html
scipy sparse spmatrix tolil	R	scipy.sparse.spmatrix.tolil										
scipy sparse.spmatrix.tolil	R	scipy.sparse.spmatrix.tolil										
scipy.sparse.spmatrix.transpose	A										<section class="prog__container"><p>Reverses the dimensions of the sparse matrix.</p><pre><code>spmatrix.transpose(axes=None, copy=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>axes : None, optional\n    This argument is in the signature solely for NumPy compatibility reasons. Do not pass in anything except for the default value. \ncopy : bool, optional\n    Indicates whether or not attributes of self should be copied whenever possible. The degree to which attributes are copied varies depending on the type of sparse matrix being used.</code></pre><span class="prog__sub">Returns:</span><pre><code>p : self with the dimensions reversed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.transpose.html
scipy sparse spmatrix transpose	R	scipy.sparse.spmatrix.transpose										
scipy sparse.spmatrix.transpose	R	scipy.sparse.spmatrix.transpose										
scipy.sparse.tril	A										<section class="prog__container"><p>Return the lower triangular portion of a matrix in sparse format</p><pre><code>scipy.sparse.tril(A, k=0, format=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : dense or sparse matrix\n    Matrix whose lower trianglar portion is desired. \nk : integer\n    The top-most diagonal of the lower triangle. \nformat : string\n    Sparse format of the result, e.g. format=”csr”, etc.</code></pre><span class="prog__sub">Returns:</span><pre><code>L : sparse matrix\n    Lower triangular portion of A in sparse format.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix, tril\n>>> A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],\n...                dtype='int32')\n>>> A.toarray()\narray([[1, 2, 0, 0, 3],\n       [4, 5, 0, 6, 7],\n       [0, 0, 8, 9, 0]])\n>>> tril(A).toarray()\narray([[1, 0, 0, 0, 0],\n       [4, 5, 0, 0, 0],\n       [0, 0, 8, 0, 0]])\n>>> tril(A).nnz\n4\n>>> tril(A, k=1).toarray()\narray([[1, 2, 0, 0, 0],\n       [4, 5, 0, 0, 0],\n       [0, 0, 8, 9, 0]])\n>>> tril(A, k=-1).toarray()\narray([[0, 0, 0, 0, 0],\n       [4, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0]])\n>>> tril(A, format='csc')\n<3x5 sparse matrix of type '<type 'numpy.int32'>'\n        with 4 stored elements in Compressed Sparse Column format></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.tril.html
scipy sparse tril	R	scipy.sparse.tril										
scipy sparse.tril	R	scipy.sparse.tril										
scipy.sparse.triu	A										<section class="prog__container"><p>Return the upper triangular portion of a matrix in sparse format</p><pre><code>scipy.sparse.triu(A, k=0, format=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>A : dense or sparse matrix\n    Matrix whose upper trianglar portion is desired. \nk : integer\n    The bottom-most diagonal of the upper triangle. \nformat : string\n    Sparse format of the result, e.g. format=”csr”, etc.</code></pre><span class="prog__sub">Returns:</span><pre><code>L : sparse matrix\n    Upper triangular portion of A in sparse format.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import csr_matrix, triu\n>>> A = csr_matrix([[1, 2, 0, 0, 3], [4, 5, 0, 6, 7], [0, 0, 8, 9, 0]],\n...                dtype='int32')\n>>> A.toarray()\narray([[1, 2, 0, 0, 3],\n       [4, 5, 0, 6, 7],\n       [0, 0, 8, 9, 0]])\n>>> triu(A).toarray()\narray([[1, 2, 0, 0, 3],\n       [0, 5, 0, 6, 7],\n       [0, 0, 8, 9, 0]])\n>>> triu(A).nnz\n8\n>>> triu(A, k=1).toarray()\narray([[0, 2, 0, 0, 3],\n       [0, 0, 0, 6, 7],\n       [0, 0, 0, 9, 0]])\n>>> triu(A, k=-1).toarray()\narray([[1, 2, 0, 0, 3],\n       [4, 5, 0, 6, 7],\n       [0, 0, 8, 9, 0]])\n>>> triu(A, format='csc')\n<3x5 sparse matrix of type '<type 'numpy.int32'>'\n        with 8 stored elements in Compressed Sparse Column format></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.triu.html
scipy sparse triu	R	scipy.sparse.triu										
scipy sparse.triu	R	scipy.sparse.triu										
scipy.sparse.vstack	A										<section class="prog__container"><p>Stack sparse matrices vertically (row wise)</p><pre><code>scipy.sparse.vstack(blocks, format=None, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>blocks\n    sequence of sparse matrices with compatible shapes \nformat : str, optional\n    sparse format of the result (e.g. “csr”) by default an appropriate sparse matrix format is returned. This choice is subject to change. \ndtype : dtype, optional\n    The data-type of the output matrix.  If not given, the dtype is determined from that of blocks.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.sparse import coo_matrix, vstack\n>>> A = coo_matrix([[1, 2], [3, 4]])\n>>> B = coo_matrix([[5, 6]])\n>>> vstack([A, B]).toarray()\narray([[1, 2],\n       [3, 4],\n       [5, 6]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.vstack.html
scipy sparse vstack	R	scipy.sparse.vstack										
scipy sparse.vstack	R	scipy.sparse.vstack										
scipy.spatial.cKDTree	A										<section class="prog__container"><p>kd-tree for quick nearest-neighbor lookup</p><pre><code>class scipy.spatial.cKDTree</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like, shape (n,m)\n    The n data points of dimension m to be indexed. This array is  not copied unless this is necessary to produce a contiguous  array of doubles, and so modifying this data will result in  bogus results. The data are also copied if the kd-tree is built with copy_data=True. \nleafsize : positive int, optional\n    The number of points at which the algorithm switches over to brute-force. Default: 16. \ncompact_nodes : bool, optional\n    If True, the kd-tree is built to shrink the hyperrectangles to the actual data range. This usually gives a more compact tree and  faster queries at the expense of longer build time. Default: True. \ncopy_data : bool, optional\n    If True the data is always copied to protect the kd-tree against  data corruption. Default: False. \nbalanced_tree : bool, optional\n    If True, the median is used to split the hyperrectangles instead of  the midpoint. This usually gives a more compact tree and  faster queries at the expense of longer build time. Default: True. \nboxsize : array_like or scalar, optional\n    Apply a m-d toroidal topology to the KDTree.. The topology is generated  by \(x_i + n_i L_i\) where \(n_i\) are integers and \(L_i\) is the boxsize along i-th dimension. The input data shall be wrapped  into \([0, L_i)\). A ValueError is raised if any of the data is outside of this bound.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.html
scipy.spatial.cKDTree.count_neighbors	A										<section class="prog__container"><p>Count how many nearby pairs can be formed.</p><pre><code>cKDTree.count_neighbors(self, other, r, p=2.)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : cKDTree instance\n    The other tree to draw points from. \nr : float or one-dimensional array of floats\n    The radius to produce a count for. Multiple radii are searched with a single tree traversal. \np : float, optional\n    1<=p<=infinity, default 2.0 Which Minkowski p-norm to use</code></pre><span class="prog__sub">Returns:</span><pre><code>result : int or 1-D array of ints\n    The number of pairs.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.count_neighbors.html
scipy spatial cKDTree count_neighbors	R	scipy.spatial.cKDTree.count_neighbors										
scipy spatial.cKDTree.count_neighbors	R	scipy.spatial.cKDTree.count_neighbors										
scipy.spatial.cKDTree.query	A										<section class="prog__container"><p>Query the kd-tree for nearest neighbors</p><pre><code>cKDTree.query(self, x, k=1, eps=0, p=2, distance_upper_bound=np.inf, n_jobs=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, last dimension self.m\n    An array of points to query. \nk : list of integer or integer\n    The list of k-th nearest neighbors to return. If k is an  integer it is treated as a list of [1, ... k] (range(1, k+1)). Note that the counting starts from 1. \neps : non-negative float\n    Return approximate nearest neighbors; the k-th returned value  is guaranteed to be no further than (1+eps) times the  distance to the real k-th nearest neighbor. \np : float, 1<=p<=infinity\n    Which Minkowski p-norm to use.  1 is the sum-of-absolute-values “Manhattan” distance 2 is the usual Euclidean distance infinity is the maximum-coordinate-difference distance \ndistance_upper_bound : nonnegative float\n    Return only neighbors within this distance.  This is used to prune tree searches, so if you are doing a series of nearest-neighbor queries, it may help to supply the distance to the nearest neighbor of the most recent point. \nn_jobs : int, optional\n    Number of jobs to schedule for parallel processing. If -1 is given all processors are used. Default: 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>d : array of floats\n    The distances to the nearest neighbors.  If x has shape tuple+(self.m,), then d has shape tuple+(len(k),). When k == 1, the last dimension of the output is squeezed. Missing neighbors are indicated with infinite distances. \ni : ndarray of ints\n    The locations of the neighbors in self.data. If x has shape tuple+(self.m,), then i has shape tuple+(len(k),). When k == 1, the last dimension of the output is squeezed. Missing neighbors are indicated with self.n.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> tree = cKDTree(data)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query.html
scipy.spatial.cKDTree.query_ball_point	A										<section class="prog__container"><p>Find all points within distance r of point(s) x.</p><pre><code>cKDTree.query_ball_point(self, x, r, p=2., eps=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape tuple + (self.m,)\n    The point or points to search for neighbors of. \nr : positive float\n    The radius of points to return. \np : float, optional\n    Which Minkowski p-norm to use.  Should be in the range [1, inf]. \neps : nonnegative float, optional\n    Approximate search. Branches of the tree are not explored if their nearest points are further than r / (1 + eps), and branches are added in bulk if their furthest points are nearer than r * (1 + eps). \nn_jobs : int, optional\n    Number of jobs to schedule for parallel processing. If -1 is given all processors are used. Default: 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>results : list or array of lists\n    If x is a single point, returns a list of the indices of the neighbors of x. If x is an array of points, returns an object array of shape tuple containing lists of neighbors.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import spatial\n>>> x, y = np.mgrid[0:4, 0:4]\n>>> points = zip(x.ravel(), y.ravel())\n>>> tree = spatial.cKDTree(points)\n>>> tree.query_ball_point([2, 0], 1)\n[4, 8, 9, 12]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query_ball_point.html
scipy spatial cKDTree query_ball_point	R	scipy.spatial.cKDTree.query_ball_point										
scipy spatial.cKDTree.query_ball_point	R	scipy.spatial.cKDTree.query_ball_point										
scipy.spatial.cKDTree.query_ball_tree	A										<section class="prog__container"><p>Find all pairs of points whose distance is at most r</p><pre><code>cKDTree.query_ball_tree(self, other, r, p=2., eps=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : cKDTree instance\n    The tree containing points to search against. \nr : float\n    The maximum distance, has to be positive. \np : float, optional\n    Which Minkowski norm to use.  p has to meet the condition 1 <= p <= infinity. \neps : float, optional\n    Approximate search.  Branches of the tree are not explored if their nearest points are further than r/(1+eps), and branches are added in bulk if their furthest points are nearer than r * (1+eps).  eps has to be non-negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>results : list of lists\n    For each element self.data[i] of this tree, results[i] is a list of the indices of its neighbors in other.data.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query_ball_tree.html
scipy spatial cKDTree query_ball_tree	R	scipy.spatial.cKDTree.query_ball_tree										
scipy spatial.cKDTree.query_ball_tree	R	scipy.spatial.cKDTree.query_ball_tree										
scipy.spatial.cKDTree.query_pairs	A										<section class="prog__container"><p>Find all pairs of points whose distance is at most r.</p><pre><code>cKDTree.query_pairs(self, r, p=2., eps=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>r : positive float\n    The maximum distance. \np : float, optional\n    Which Minkowski norm to use.  p has to meet the condition 1 <= p <= infinity. \neps : float, optional\n    Approximate search.  Branches of the tree are not explored if their nearest points are further than r/(1+eps), and branches are added in bulk if their furthest points are nearer than r * (1+eps).  eps has to be non-negative. \noutput_type : string, optional\n    Choose the output container, ‘set’ or ‘ndarray’. Default: ‘set’</code></pre><span class="prog__sub">Returns:</span><pre><code>results : set or ndarray\n    Set of pairs (i,j), with i < j, for which the corresponding positions are close. If output_type is ‘ndarray’, an ndarry is  returned instead of a set.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query_pairs.html
scipy spatial cKDTree query_pairs	R	scipy.spatial.cKDTree.query_pairs										
scipy spatial.cKDTree.query_pairs	R	scipy.spatial.cKDTree.query_pairs										
scipy spatial cKDTree query	R	scipy.spatial.cKDTree.query										
scipy spatial.cKDTree.query	R	scipy.spatial.cKDTree.query										
scipy spatial cKDTree	R	scipy.spatial.cKDTree										
scipy spatial.cKDTree	R	scipy.spatial.cKDTree										
scipy.spatial.cKDTree.sparse_distance_matrix	A										<section class="prog__container"><p>Compute a sparse distance matrix</p><pre><code>cKDTree.sparse_distance_matrix(self, other, max_distance, p=2.)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : cKDTree\nmax_distance : positive float\np : float, 1<=p<=infinity\n    Which Minkowski p-norm to use. \noutput_type : string, optional\n    Which container to use for output data. Options: ‘dok_matrix’, ‘coo_matrix’, ‘dict’, or ‘ndarray’. Default: ‘dok_matrix’.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : dok_matrix, coo_matrix, dict or ndarray\n    Sparse matrix representing the results in “dictionary of keys”  format. If a dict is returned the keys are (i,j) tuples of indices. If output_type is ‘ndarray’ a record array with fields ‘i’, ‘j’, and ‘k’ is returned,</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.sparse_distance_matrix.html
scipy spatial cKDTree sparse_distance_matrix	R	scipy.spatial.cKDTree.sparse_distance_matrix										
scipy spatial.cKDTree.sparse_distance_matrix	R	scipy.spatial.cKDTree.sparse_distance_matrix										
scipy.spatial.ConvexHull.add_points	A					[[scipy.spatial.ConvexHull.close]]					<section class="prog__container"><p>Process a set of additional new points.</p><pre><code>ConvexHull.add_points(points, restart=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray\n    New points to add. The dimensionality should match that of the initial points. \nrestart : bool, optional\n    Whether to restart processing from scratch, rather than adding points incrementally.</code></pre><span class="prog__sub">Returns:</span><pre><code>QhullError\n    Raised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.add_points.html
scipy spatial ConvexHull add_points	R	scipy.spatial.ConvexHull.add_points										
scipy spatial.ConvexHull.add_points	R	scipy.spatial.ConvexHull.add_points										
scipy.spatial.ConvexHull	A										<section class="prog__container"><p>Convex hulls in N dimensions.</p><pre><code>class scipy.spatial.ConvexHull(points, incremental=False, qhull_options=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray of floats, shape (npoints, ndim)\n    Coordinates of points to construct a convex hull from \nincremental : bool, optional\n    Allow adding new points incrementally. This takes up some additional resources. \nqhull_options : str, optional\n    Additional options to pass to Qhull. See Qhull manual for details. (Default: “Qx” for ndim > 4 and “” otherwise) Option “Qt” is always enabled.</code></pre><span class="prog__sub">Returns:</span><pre><code>QhullError\n    Raised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled. \nValueError\n    Raised if an incompatible array is given as input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.spatial import ConvexHull\n>>> points = np.random.rand(30, 2)   # 30 random points in 2-D\n>>> hull = ConvexHull(points)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html
scipy.spatial.ConvexHull.close	A										<section class="prog__container"><p>Finish incremental processing.</p><pre><code>ConvexHull.close()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.close.html
scipy spatial ConvexHull close	R	scipy.spatial.ConvexHull.close										
scipy spatial.ConvexHull.close	R	scipy.spatial.ConvexHull.close										
scipy.spatial.convex_hull_plot_2d	A					[[scipy.spatial.ConvexHull]]					<section class="prog__container"><p>Plot the given convex hull diagram in 2-D</p><pre><code>scipy.spatial.convex_hull_plot_2d(hull, ax=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>hull : scipy.spatial.ConvexHull instance\n    Convex hull to plot \nax : matplotlib.axes.Axes instance, optional\n    Axes to plot on</code></pre><span class="prog__sub">Returns:</span><pre><code>fig : matplotlib.figure.Figure instance\n    Figure for the plot</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.convex_hull_plot_2d.html
scipy spatial convex_hull_plot_2d	R	scipy.spatial.convex_hull_plot_2d										
scipy spatial.convex_hull_plot_2d	R	scipy.spatial.convex_hull_plot_2d										
scipy spatial ConvexHull	R	scipy.spatial.ConvexHull										
scipy spatial.ConvexHull	R	scipy.spatial.ConvexHull										
scipy.spatial.Delaunay.add_points	A					[[scipy.spatial.Delaunay.close]]					<section class="prog__container"><p>Process a set of additional new points.</p><pre><code>Delaunay.add_points(points, restart=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray\n    New points to add. The dimensionality should match that of the initial points. \nrestart : bool, optional\n    Whether to restart processing from scratch, rather than adding points incrementally.</code></pre><span class="prog__sub">Returns:</span><pre><code>QhullError\n    Raised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.add_points.html
scipy spatial Delaunay add_points	R	scipy.spatial.Delaunay.add_points										
scipy spatial.Delaunay.add_points	R	scipy.spatial.Delaunay.add_points										
scipy.spatial.Delaunay	A										<section class="prog__container"><p>Delaunay tesselation in N dimensions.</p><pre><code>class scipy.spatial.Delaunay(points, furthest_site=False, incremental=False, qhull_options=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray of floats, shape (npoints, ndim)\n    Coordinates of points to triangulate \nfurthest_site : bool, optional\n    Whether to compute a furthest-site Delaunay triangulation. Default: False  New in version 0.12.0.  \nincremental : bool, optional\n    Allow adding new points incrementally. This takes up some additional resources. \nqhull_options : str, optional\n    Additional options to pass to Qhull. See Qhull manual for details. Option “Qt” is always enabled. Default:”Qbb Qc Qz Qx Q12” for ndim > 4 and “Qbb Qc Qz Q12” otherwise. Incremental mode omits “Qz”.  New in version 0.12.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>QhullError\n    Raised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled. \nValueError\n    Raised if an incompatible array is given as input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> points = np.array([[0, 0], [0, 1.1], [1, 0], [1, 1]])\n>>> from scipy.spatial import Delaunay\n>>> tri = Delaunay(points)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.html
scipy.spatial.Delaunay.close	A										<section class="prog__container"><p>Finish incremental processing.</p><pre><code>Delaunay.close()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.close.html
scipy spatial Delaunay close	R	scipy.spatial.Delaunay.close										
scipy spatial.Delaunay.close	R	scipy.spatial.Delaunay.close										
scipy.spatial.Delaunay.convex_hull	A										<section class="prog__container"><p>Vertices of facets forming the convex hull of the point set.</p><pre><code>Delaunay.convex_hull</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.convex_hull.html
scipy spatial Delaunay convex_hull	R	scipy.spatial.Delaunay.convex_hull										
scipy spatial.Delaunay.convex_hull	R	scipy.spatial.Delaunay.convex_hull										
scipy.spatial.Delaunay.find_simplex	A										<section class="prog__container"><p>Find the simplices containing the given points.</p><pre><code>Delaunay.find_simplex(self, xi, bruteforce=False, tol=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tri : DelaunayInfo\n    Delaunay triangulation \nxi : ndarray of double, shape (..., ndim)\n    Points to locate \nbruteforce : bool, optional\n    Whether to only perform a brute-force search \ntol : float, optional\n    Tolerance allowed in the inside-triangle check. Default is 100*eps.</code></pre><span class="prog__sub">Returns:</span><pre><code>i : ndarray of int, same shape as xi\n    Indices of simplices containing each point. Points outside the triangulation get the value -1.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.find_simplex.html
scipy spatial Delaunay find_simplex	R	scipy.spatial.Delaunay.find_simplex										
scipy spatial.Delaunay.find_simplex	R	scipy.spatial.Delaunay.find_simplex										
scipy.spatial.Delaunay.lift_points	A										<section class="prog__container"><p>Lift points to the Qhull paraboloid.</p><pre><code>Delaunay.lift_points(self, x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.lift_points.html
scipy spatial Delaunay lift_points	R	scipy.spatial.Delaunay.lift_points										
scipy spatial.Delaunay.lift_points	R	scipy.spatial.Delaunay.lift_points										
scipy.spatial.Delaunay.plane_distance	A										<section class="prog__container"><p>Compute hyperplane distances to the point xi from all simplices.</p><pre><code>Delaunay.plane_distance(self, xi)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.plane_distance.html
scipy spatial Delaunay plane_distance	R	scipy.spatial.Delaunay.plane_distance										
scipy spatial.Delaunay.plane_distance	R	scipy.spatial.Delaunay.plane_distance										
scipy.spatial.delaunay_plot_2d	A					[[scipy.spatial.Delaunay]]					<section class="prog__container"><p>Plot the given Delaunay triangulation in 2-D</p><pre><code>scipy.spatial.delaunay_plot_2d(tri, ax=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>tri : scipy.spatial.Delaunay instance\n    Triangulation to plot \nax : matplotlib.axes.Axes instance, optional\n    Axes to plot on</code></pre><span class="prog__sub">Returns:</span><pre><code>fig : matplotlib.figure.Figure instance\n    Figure for the plot</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.delaunay_plot_2d.html
scipy spatial delaunay_plot_2d	R	scipy.spatial.delaunay_plot_2d										
scipy spatial.delaunay_plot_2d	R	scipy.spatial.delaunay_plot_2d										
scipy spatial Delaunay	R	scipy.spatial.Delaunay										
scipy spatial.Delaunay	R	scipy.spatial.Delaunay										
scipy.spatial.Delaunay.transform	A										<section class="prog__container"><p>Affine transform from x to the barycentric coordinates c.</p><pre><code>Delaunay.transform</code></pre><span class="prog__sub">Examples:</span><pre><code>T c = x - r</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.transform.html
scipy spatial Delaunay transform	R	scipy.spatial.Delaunay.transform										
scipy spatial.Delaunay.transform	R	scipy.spatial.Delaunay.transform										
scipy.spatial.Delaunay.vertex_neighbor_vertices	A										<section class="prog__container"><p>Neighboring vertices of vertices.</p><pre><code>Delaunay.vertex_neighbor_vertices</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.vertex_neighbor_vertices.html
scipy spatial Delaunay vertex_neighbor_vertices	R	scipy.spatial.Delaunay.vertex_neighbor_vertices										
scipy spatial.Delaunay.vertex_neighbor_vertices	R	scipy.spatial.Delaunay.vertex_neighbor_vertices										
scipy.spatial.Delaunay.vertex_to_simplex	A										<section class="prog__container"><p>Lookup array, from a vertex, to some simplex which it is a part of.</p><pre><code>Delaunay.vertex_to_simplex</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.vertex_to_simplex.html
scipy spatial Delaunay vertex_to_simplex	R	scipy.spatial.Delaunay.vertex_to_simplex										
scipy spatial.Delaunay.vertex_to_simplex	R	scipy.spatial.Delaunay.vertex_to_simplex										
scipy.spatial.distance.braycurtis	A										<section class="prog__container"><p>Computes the Bray-Curtis distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.braycurtis(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>braycurtis : double\n    The Bray-Curtis distance between 1-D arrays u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.braycurtis.html
scipy spatial distance braycurtis	R	scipy.spatial.distance.braycurtis										
scipy spatial.distance.braycurtis	R	scipy.spatial.distance.braycurtis										
scipy.spatial.distance.canberra	A										<section class="prog__container"><p>Computes the Canberra distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.canberra(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>canberra : double\n    The Canberra distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.canberra.html
scipy spatial distance canberra	R	scipy.spatial.distance.canberra										
scipy spatial.distance.canberra	R	scipy.spatial.distance.canberra										
scipy.spatial.distance.cdist	A										<section class="prog__container"><p>Computes distance between each pair of the two collections of inputs.</p><pre><code>scipy.spatial.distance.cdist(XA, XB, metric='euclidean', p=2, V=None, VI=None, w=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>XA : ndarray\n    An \(m_A\) by \(n\) array of \(m_A\) original observations in an \(n\)-dimensional space. Inputs are converted to float type. \nXB : ndarray\n    An \(m_B\) by \(n\) array of \(m_B\) original observations in an \(n\)-dimensional space. Inputs are converted to float type. \nmetric : str or callable, optional\n    The distance metric to use.  If a string, the distance function can be ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘cityblock’, ‘correlation’, ‘cosine’, ‘dice’, ‘euclidean’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘wminkowski’, ‘yule’. \nw : ndarray, optional\n    The weight vector (for weighted Minkowski). \np : scalar, optional\n    The p-norm to apply (for Minkowski, weighted and unweighted) \nV : ndarray, optional\n    The variance vector (for standardized Euclidean). \nVI : ndarray, optional\n    The inverse of the covariance matrix (for Mahalanobis).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : ndarray\n    A \(m_A\) by \(m_B\) distance matrix is returned. For each \(i\) and \(j\), the metric dist(u=XA[i], v=XB[j]) is computed and stored in the \(ij\) th entry.</code></pre><span class="prog__sub">Examples:</span><pre><code>dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html
scipy spatial distance cdist	R	scipy.spatial.distance.cdist										
scipy spatial.distance.cdist	R	scipy.spatial.distance.cdist										
scipy.spatial.distance.chebyshev	A										<section class="prog__container"><p>Computes the Chebyshev distance.</p><pre><code>scipy.spatial.distance.chebyshev(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input vector. \nv : (N,) array_like\n    Input vector.</code></pre><span class="prog__sub">Returns:</span><pre><code>chebyshev : double\n    The Chebyshev distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.chebyshev.html
scipy spatial distance chebyshev	R	scipy.spatial.distance.chebyshev										
scipy spatial.distance.chebyshev	R	scipy.spatial.distance.chebyshev										
scipy.spatial.distance.cityblock	A										<section class="prog__container"><p>Computes the City Block (Manhattan) distance.</p><pre><code>scipy.spatial.distance.cityblock(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>cityblock : double\n    The City Block (Manhattan) distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cityblock.html
scipy spatial distance cityblock	R	scipy.spatial.distance.cityblock										
scipy spatial.distance.cityblock	R	scipy.spatial.distance.cityblock										
scipy.spatial.distance.correlation	A										<section class="prog__container"><p>Computes the correlation distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.correlation(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>correlation : double\n    The correlation distance between 1-D array u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.correlation.html
scipy spatial distance correlation	R	scipy.spatial.distance.correlation										
scipy spatial.distance.correlation	R	scipy.spatial.distance.correlation										
scipy.spatial.distance.cosine	A										<section class="prog__container"><p>Computes the Cosine distance between 1-D arrays.</p><pre><code>scipy.spatial.distance.cosine(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>cosine : double\n    The Cosine distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cosine.html
scipy spatial distance cosine	R	scipy.spatial.distance.cosine										
scipy spatial.distance.cosine	R	scipy.spatial.distance.cosine										
scipy.spatial.distance.dice	A										<section class="prog__container"><p>Computes the Dice dissimilarity between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.dice(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) ndarray, bool\n    Input 1-D array. \nv : (N,) ndarray, bool\n    Input 1-D array.</code></pre><span class="prog__sub">Returns:</span><pre><code>dice : double\n    The Dice dissimilarity between 1-D arrays u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.dice.html
scipy spatial distance dice	R	scipy.spatial.distance.dice										
scipy spatial.distance.dice	R	scipy.spatial.distance.dice										
scipy.spatial.distance.euclidean	A										<section class="prog__container"><p>Computes the Euclidean distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.euclidean(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>euclidean : double\n    The Euclidean distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.euclidean.html
scipy spatial distance euclidean	R	scipy.spatial.distance.euclidean										
scipy spatial.distance.euclidean	R	scipy.spatial.distance.euclidean										
scipy.spatial.distance.hamming	A										<section class="prog__container"><p>Computes the Hamming distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.hamming(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>hamming : double\n    The Hamming distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.hamming.html
scipy spatial distance hamming	R	scipy.spatial.distance.hamming										
scipy spatial.distance.hamming	R	scipy.spatial.distance.hamming										
scipy.spatial.distance.is_valid_dm	A										<section class="prog__container"><p>Returns True if input array is a valid distance matrix.</p><pre><code>scipy.spatial.distance.is_valid_dm(D, tol=0.0, throw=False, name='D', warning=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>D : ndarray\n    The candidate object to test for validity. \ntol : float, optional\n    The distance matrix should be symmetric. tol is the maximum difference between entries ij and ji for the distance metric to be considered symmetric. \nthrow : bool, optional\n    An exception is thrown if the distance matrix passed is not valid. \nname : str, optional\n    The name of the variable to checked. This is useful if throw is set to True so the offending variable can be identified in the exception message when an exception is thrown. \nwarning : bool, optional\n    Instead of throwing an exception, a warning message is raised.</code></pre><span class="prog__sub">Returns:</span><pre><code>valid : bool\n    True if the variable D passed is a valid distance matrix.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.is_valid_dm.html
scipy spatial distance is_valid_dm	R	scipy.spatial.distance.is_valid_dm										
scipy spatial.distance.is_valid_dm	R	scipy.spatial.distance.is_valid_dm										
scipy.spatial.distance.is_valid_y	A										<section class="prog__container"><p>Returns True if the input array is a valid condensed distance matrix.</p><pre><code>scipy.spatial.distance.is_valid_y(y, warning=False, throw=False, name=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : ndarray\n    The condensed distance matrix. \nwarning : bool, optional\n    Invokes a warning if the variable passed is not a valid condensed distance matrix. The warning message explains why the distance matrix is not valid.  name is used when referencing the offending variable. \nthrow : bool, optional\n    Throws an exception if the variable passed is not a valid condensed distance matrix. \nname : bool, optional\n    Used when referencing the offending variable in the warning or exception message.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.is_valid_y.html
scipy spatial distance is_valid_y	R	scipy.spatial.distance.is_valid_y										
scipy spatial.distance.is_valid_y	R	scipy.spatial.distance.is_valid_y										
scipy.spatial.distance.jaccard	A										<section class="prog__container"><p>Computes the Jaccard-Needham dissimilarity between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.jaccard(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like, bool\n    Input array. \nv : (N,) array_like, bool\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>jaccard : double\n    The Jaccard distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.jaccard.html
scipy spatial distance jaccard	R	scipy.spatial.distance.jaccard										
scipy spatial.distance.jaccard	R	scipy.spatial.distance.jaccard										
scipy.spatial.distance.kulsinski	A										<section class="prog__container"><p>Computes the Kulsinski dissimilarity between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.kulsinski(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like, bool\n    Input array. \nv : (N,) array_like, bool\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>kulsinski : double\n    The Kulsinski distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.kulsinski.html
scipy spatial distance kulsinski	R	scipy.spatial.distance.kulsinski										
scipy spatial.distance.kulsinski	R	scipy.spatial.distance.kulsinski										
scipy.spatial.distance.mahalanobis	A										<section class="prog__container"><p>Computes the Mahalanobis distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.mahalanobis(u, v, VI)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array. \nVI : ndarray\n    The inverse of the covariance matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>mahalanobis : double\n    The Mahalanobis distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.mahalanobis.html
scipy spatial distance mahalanobis	R	scipy.spatial.distance.mahalanobis										
scipy spatial.distance.mahalanobis	R	scipy.spatial.distance.mahalanobis										
scipy.spatial.distance.matching	A										<section class="prog__container"><p>Computes the Hamming distance between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.matching(u, v)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.matching.html
scipy spatial distance matching	R	scipy.spatial.distance.matching										
scipy spatial.distance.matching	R	scipy.spatial.distance.matching										
scipy.spatial.distance_matrix	A										<section class="prog__container"><p>Compute the distance matrix.</p><pre><code>scipy.spatial.distance_matrix(x, y, p=2, threshold=1000000)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (M, K) array_like\n    TODO: description needed \ny : (N, K) array_like\n    TODO: description needed \np : float, 1 <= p <= infinity\n    Which Minkowski p-norm to use. \nthreshold : positive int\n    If M * N * K > threshold, algorithm uses a Python loop instead of large temporary arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : (M, N) ndarray\n    Distance matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.spatial import distance_matrix\n>>> distance_matrix([[0,0],[0,1]], [[1,0],[1,1]])\narray([[ 1.        ,  1.41421356],\n       [ 1.41421356,  1.        ]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance_matrix.html
scipy spatial distance_matrix	R	scipy.spatial.distance_matrix										
scipy spatial.distance_matrix	R	scipy.spatial.distance_matrix										
scipy.spatial.distance.minkowski	A										<section class="prog__container"><p>Computes the Minkowski distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.minkowski(u, v, p)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array. \np : int\n    The order of the norm of the difference \({||u-v||}_p\).</code></pre><span class="prog__sub">Returns:</span><pre><code>d : double\n    The Minkowski distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.minkowski.html
scipy spatial distance minkowski	R	scipy.spatial.distance.minkowski										
scipy spatial.distance.minkowski	R	scipy.spatial.distance.minkowski										
scipy.spatial.distance.num_obs_dm	A										<section class="prog__container"><p>Returns the number of original observations that correspond to a\nsquare, redundant distance matrix.</p><pre><code>scipy.spatial.distance.num_obs_dm(d)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d : ndarray\n    The target distance matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>num_obs_dm : int\n    The number of observations in the redundant distance matrix.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.num_obs_dm.html
scipy spatial distance num_obs_dm	R	scipy.spatial.distance.num_obs_dm										
scipy spatial.distance.num_obs_dm	R	scipy.spatial.distance.num_obs_dm										
scipy.spatial.distance.num_obs_y	A										<section class="prog__container"><p>Returns the number of original observations that correspond to a\ncondensed distance matrix.</p><pre><code>scipy.spatial.distance.num_obs_y(Y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>Y : ndarray\n    Condensed distance matrix.</code></pre><span class="prog__sub">Returns:</span><pre><code>n : int\n    The number of observations in the condensed distance matrix Y.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.num_obs_y.html
scipy spatial distance num_obs_y	R	scipy.spatial.distance.num_obs_y										
scipy spatial.distance.num_obs_y	R	scipy.spatial.distance.num_obs_y										
scipy.spatial.distance.pdist	A										<section class="prog__container"><p>Pairwise distances between observations in n-dimensional space.</p><pre><code>scipy.spatial.distance.pdist(X, metric='euclidean', p=2, w=None, V=None, VI=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>X : ndarray\n    An m by n array of m original observations in an n-dimensional space. \nmetric : str or function, optional\n    The distance metric to use. The distance function can be ‘braycurtis’, ‘canberra’, ‘chebyshev’, ‘cityblock’, ‘correlation’, ‘cosine’, ‘dice’, ‘euclidean’, ‘hamming’, ‘jaccard’, ‘kulsinski’, ‘mahalanobis’, ‘matching’, ‘minkowski’, ‘rogerstanimoto’, ‘russellrao’, ‘seuclidean’, ‘sokalmichener’, ‘sokalsneath’, ‘sqeuclidean’, ‘yule’. \nw : ndarray, optional\n    The weight vector (for weighted Minkowski). \np : double, optional\n    The p-norm to apply (for Minkowski, weighted and unweighted) \nV : ndarray, optional\n    The variance vector (for standardized Euclidean). \nVI : ndarray, optional\n    The inverse of the covariance matrix (for Mahalanobis).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : ndarray\n    Returns a condensed distance matrix Y.  For each \(i\) and \(j\) (where \(i<j<n\)), the metric dist(u=X[i], v=X[j]) is computed and stored in entry ij.</code></pre><span class="prog__sub">Examples:</span><pre><code>dm = pdist(X, lambda u, v: np.sqrt(((u-v)**2).sum()))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html
scipy spatial distance pdist	R	scipy.spatial.distance.pdist										
scipy spatial.distance.pdist	R	scipy.spatial.distance.pdist										
scipy.spatial.distance.rogerstanimoto	A										<section class="prog__container"><p>Computes the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.rogerstanimoto(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like, bool\n    Input array. \nv : (N,) array_like, bool\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>rogerstanimoto : double\n    The Rogers-Tanimoto dissimilarity between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.rogerstanimoto.html
scipy spatial distance rogerstanimoto	R	scipy.spatial.distance.rogerstanimoto										
scipy spatial.distance.rogerstanimoto	R	scipy.spatial.distance.rogerstanimoto										
scipy.spatial.distance.russellrao	A										<section class="prog__container"><p>Computes the Russell-Rao dissimilarity between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.russellrao(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like, bool\n    Input array. \nv : (N,) array_like, bool\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>russellrao : double\n    The Russell-Rao dissimilarity between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.russellrao.html
scipy spatial distance russellrao	R	scipy.spatial.distance.russellrao										
scipy spatial.distance.russellrao	R	scipy.spatial.distance.russellrao										
scipy.spatial.distance.seuclidean	A										<section class="prog__container"><p>Returns the standardized Euclidean distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.seuclidean(u, v, V)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array. \nV : (N,) array_like\n    V is an 1-D array of component variances. It is usually computed among a larger collection vectors.</code></pre><span class="prog__sub">Returns:</span><pre><code>seuclidean : double\n    The standardized Euclidean distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.seuclidean.html
scipy spatial distance seuclidean	R	scipy.spatial.distance.seuclidean										
scipy spatial.distance.seuclidean	R	scipy.spatial.distance.seuclidean										
scipy.spatial.distance.sokalmichener	A										<section class="prog__container"><p>Computes the Sokal-Michener dissimilarity between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.sokalmichener(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like, bool\n    Input array. \nv : (N,) array_like, bool\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>sokalmichener : double\n    The Sokal-Michener dissimilarity between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.sokalmichener.html
scipy spatial distance sokalmichener	R	scipy.spatial.distance.sokalmichener										
scipy spatial.distance.sokalmichener	R	scipy.spatial.distance.sokalmichener										
scipy.spatial.distance.sokalsneath	A										<section class="prog__container"><p>Computes the Sokal-Sneath dissimilarity between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.sokalsneath(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like, bool\n    Input array. \nv : (N,) array_like, bool\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>sokalsneath : double\n    The Sokal-Sneath dissimilarity between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.sokalsneath.html
scipy spatial distance sokalsneath	R	scipy.spatial.distance.sokalsneath										
scipy spatial.distance.sokalsneath	R	scipy.spatial.distance.sokalsneath										
scipy.spatial.distance.sqeuclidean	A										<section class="prog__container"><p>Computes the squared Euclidean distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.sqeuclidean(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>sqeuclidean : double\n    The squared Euclidean distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.sqeuclidean.html
scipy spatial distance sqeuclidean	R	scipy.spatial.distance.sqeuclidean										
scipy spatial.distance.sqeuclidean	R	scipy.spatial.distance.sqeuclidean										
scipy.spatial.distance.squareform	A										<section class="prog__container"><p>Converts a vector-form distance vector to a square-form distance\nmatrix, and vice-versa.</p><pre><code>scipy.spatial.distance.squareform(X, force='no', checks=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>X : ndarray\n    Either a condensed or redundant distance matrix. \nforce : str, optional\n    As with MATLAB(TM), if force is equal to ‘tovector’ or ‘tomatrix’, the input will be treated as a distance matrix or distance vector respectively. \nchecks : bool, optional\n    If checks is set to False, no checks will be made for matrix symmetry nor zero diagonals. This is useful if it is known that X - X.T1 is small and diag(X) is close to zero. These values are ignored any way so they do not disrupt the squareform transformation.</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : ndarray\n    If a condensed distance matrix is passed, a redundant one is returned, or if a redundant one is passed, a condensed distance matrix is returned.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.squareform.html
scipy spatial distance squareform	R	scipy.spatial.distance.squareform										
scipy spatial.distance.squareform	R	scipy.spatial.distance.squareform										
scipy.spatial.distance.wminkowski	A										<section class="prog__container"><p>Computes the weighted Minkowski distance between two 1-D arrays.</p><pre><code>scipy.spatial.distance.wminkowski(u, v, p, w)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like\n    Input array. \nv : (N,) array_like\n    Input array. \np : int\n    The order of the norm of the difference \({||u-v||}_p\). \nw : (N,) array_like\n    The weight vector.</code></pre><span class="prog__sub">Returns:</span><pre><code>wminkowski : double\n    The weighted Minkowski distance between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.wminkowski.html
scipy spatial distance wminkowski	R	scipy.spatial.distance.wminkowski										
scipy spatial.distance.wminkowski	R	scipy.spatial.distance.wminkowski										
scipy.spatial.distance.yule	A										<section class="prog__container"><p>Computes the Yule dissimilarity between two boolean 1-D arrays.</p><pre><code>scipy.spatial.distance.yule(u, v)</code></pre><span class="prog__sub">Parameters:</span><pre><code>u : (N,) array_like, bool\n    Input array. \nv : (N,) array_like, bool\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>yule : double\n    The Yule dissimilarity between vectors u and v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.yule.html
scipy spatial distance yule	R	scipy.spatial.distance.yule										
scipy spatial.distance.yule	R	scipy.spatial.distance.yule										
scipy.spatial.KDTree	A										<section class="prog__container"><p>kd-tree for quick nearest-neighbor lookup</p><pre><code>class scipy.spatial.KDTree(data, leafsize=10)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : (N,K) array_like\n    The data points to be indexed. This array is not copied, and so modifying this data will result in bogus results. \nleafsize : int, optional\n    The number of points at which the algorithm switches over to brute-force.  Has to be positive.</code></pre><span class="prog__sub">Returns:</span><pre><code>RuntimeError\n    The maximum recursion limit can be exceeded for large data sets.  If this happens, either increase the value for the leafsize parameter or increase the recursion limit by: >>> import sys >>> sys.setrecursionlimit(10000)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import sys\n>>> sys.setrecursionlimit(10000)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.html
scipy.spatial.KDTree.count_neighbors	A										<section class="prog__container"><p>Count how many nearby pairs can be formed.</p><pre><code>KDTree.count_neighbors(other, r, p=2.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : KDTree instance\n    The other tree to draw points from. \nr : float or one-dimensional array of floats\n    The radius to produce a count for. Multiple radii are searched with a single tree traversal. \np : float, 1<=p<=infinity, optional\n    Which Minkowski p-norm to use</code></pre><span class="prog__sub">Returns:</span><pre><code>result : int or 1-D array of ints\n    The number of pairs. Note that this is internally stored in a numpy int, and so may overflow if very large (2e9).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.count_neighbors.html
scipy spatial KDTree count_neighbors	R	scipy.spatial.KDTree.count_neighbors										
scipy spatial.KDTree.count_neighbors	R	scipy.spatial.KDTree.count_neighbors										
scipy.spatial.KDTree.query	A										<section class="prog__container"><p>Query the kd-tree for nearest neighbors</p><pre><code>KDTree.query(x, k=1, eps=0, p=2, distance_upper_bound=inf)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, last dimension self.m\n    An array of points to query. \nk : int, optional\n    The number of nearest neighbors to return. \neps : nonnegative float, optional\n    Return approximate nearest neighbors; the kth returned value is guaranteed to be no further than (1+eps) times the distance to the real kth nearest neighbor. \np : float, 1<=p<=infinity, optional\n    Which Minkowski p-norm to use. 1 is the sum-of-absolute-values “Manhattan” distance 2 is the usual Euclidean distance infinity is the maximum-coordinate-difference distance \ndistance_upper_bound : nonnegative float, optional\n    Return only neighbors within this distance. This is used to prune tree searches, so if you are doing a series of nearest-neighbor queries, it may help to supply the distance to the nearest neighbor of the most recent point.</code></pre><span class="prog__sub">Returns:</span><pre><code>d : float or array of floats\n    The distances to the nearest neighbors. If x has shape tuple+(self.m,), then d has shape tuple if k is one, or tuple+(k,) if k is larger than one. Missing neighbors (e.g. when k > n or distance_upper_bound is given) are indicated with infinite distances.  If k is None, then d is an object array of shape tuple, containing lists of distances. In either case the hits are sorted by distance (nearest first). \ni : integer or array of integers\n    The locations of the neighbors in self.data. i is the same shape as d.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import spatial\n>>> x, y = np.mgrid[0:5, 2:8]\n>>> tree = spatial.KDTree(list(zip(x.ravel(), y.ravel())))\n>>> tree.data\narray([[0, 2],\n       [0, 3],\n       [0, 4],\n       [0, 5],\n       [0, 6],\n       [0, 7],\n       [1, 2],\n       [1, 3],\n       [1, 4],\n       [1, 5],\n       [1, 6],\n       [1, 7],\n       [2, 2],\n       [2, 3],\n       [2, 4],\n       [2, 5],\n       [2, 6],\n       [2, 7],\n       [3, 2],\n       [3, 3],\n       [3, 4],\n       [3, 5],\n       [3, 6],\n       [3, 7],\n       [4, 2],\n       [4, 3],\n       [4, 4],\n       [4, 5],\n       [4, 6],\n       [4, 7]])\n>>> pts = np.array([[0, 0], [2.1, 2.9]])\n>>> tree.query(pts)\n(array([ 2.        ,  0.14142136]), array([ 0, 13]))\n>>> tree.query(pts[0])\n(2.0, 0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query.html
scipy.spatial.KDTree.query_ball_point	A										<section class="prog__container"><p>Find all points within distance r of point(s) x.</p><pre><code>KDTree.query_ball_point(x, r, p=2.0, eps=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, shape tuple + (self.m,)\n    The point or points to search for neighbors of. \nr : positive float\n    The radius of points to return. \np : float, optional\n    Which Minkowski p-norm to use.  Should be in the range [1, inf]. \neps : nonnegative float, optional\n    Approximate search. Branches of the tree are not explored if their nearest points are further than r / (1 + eps), and branches are added in bulk if their furthest points are nearer than r * (1 + eps).</code></pre><span class="prog__sub">Returns:</span><pre><code>results : list or array of lists\n    If x is a single point, returns a list of the indices of the neighbors of x. If x is an array of points, returns an object array of shape tuple containing lists of neighbors.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import spatial\n>>> x, y = np.mgrid[0:5, 0:5]\n>>> points = zip(x.ravel(), y.ravel())\n>>> tree = spatial.KDTree(points)\n>>> tree.query_ball_point([2, 0], 1)\n[5, 10, 11, 15]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query_ball_point.html
scipy spatial KDTree query_ball_point	R	scipy.spatial.KDTree.query_ball_point										
scipy spatial.KDTree.query_ball_point	R	scipy.spatial.KDTree.query_ball_point										
scipy.spatial.KDTree.query_ball_tree	A										<section class="prog__container"><p>Find all pairs of points whose distance is at most r</p><pre><code>KDTree.query_ball_tree(other, r, p=2.0, eps=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : KDTree instance\n    The tree containing points to search against. \nr : float\n    The maximum distance, has to be positive. \np : float, optional\n    Which Minkowski norm to use.  p has to meet the condition 1 <= p <= infinity. \neps : float, optional\n    Approximate search.  Branches of the tree are not explored if their nearest points are further than r/(1+eps), and branches are added in bulk if their furthest points are nearer than r * (1+eps).  eps has to be non-negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>results : list of lists\n    For each element self.data[i] of this tree, results[i] is a list of the indices of its neighbors in other.data.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query_ball_tree.html
scipy spatial KDTree query_ball_tree	R	scipy.spatial.KDTree.query_ball_tree										
scipy spatial.KDTree.query_ball_tree	R	scipy.spatial.KDTree.query_ball_tree										
scipy.spatial.KDTree.query_pairs	A										<section class="prog__container"><p>Find all pairs of points within a distance.</p><pre><code>KDTree.query_pairs(r, p=2.0, eps=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>r : positive float\n    The maximum distance. \np : float, optional\n    Which Minkowski norm to use.  p has to meet the condition 1 <= p <= infinity. \neps : float, optional\n    Approximate search.  Branches of the tree are not explored if their nearest points are further than r/(1+eps), and branches are added in bulk if their furthest points are nearer than r * (1+eps).  eps has to be non-negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>results : set\n    Set of pairs (i,j), with i < j, for which the corresponding positions are close.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.query_pairs.html
scipy spatial KDTree query_pairs	R	scipy.spatial.KDTree.query_pairs										
scipy spatial.KDTree.query_pairs	R	scipy.spatial.KDTree.query_pairs										
scipy spatial KDTree query	R	scipy.spatial.KDTree.query										
scipy spatial.KDTree.query	R	scipy.spatial.KDTree.query										
scipy spatial KDTree	R	scipy.spatial.KDTree										
scipy spatial.KDTree	R	scipy.spatial.KDTree										
scipy.spatial.KDTree.sparse_distance_matrix	A										<section class="prog__container"><p>Compute a sparse distance matrix</p><pre><code>KDTree.sparse_distance_matrix(other, max_distance, p=2.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : KDTree\nmax_distance : positive float\np : float, optional</code></pre><span class="prog__sub">Returns:</span><pre><code>result : dok_matrix\n    Sparse matrix representing the results in “dictionary of keys” format.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.KDTree.sparse_distance_matrix.html
scipy spatial KDTree sparse_distance_matrix	R	scipy.spatial.KDTree.sparse_distance_matrix										
scipy spatial.KDTree.sparse_distance_matrix	R	scipy.spatial.KDTree.sparse_distance_matrix										
scipy.spatial.minkowski_distance	A										<section class="prog__container"><p>Compute the L**p distance between two arrays.</p><pre><code>scipy.spatial.minkowski_distance(x, y, p=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (M, K) array_like\n    Input array. \ny : (N, K) array_like\n    Input array. \np : float, 1 <= p <= infinity\n    Which Minkowski p-norm to use.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.spatial import minkowski_distance\n>>> minkowski_distance([[0,0],[0,0]], [[1,1],[0,1]])\narray([ 1.41421356,  1.        ])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.minkowski_distance.html
scipy.spatial.minkowski_distance_p	A										<section class="prog__container"><p>Compute the p-th power of the L**p distance between two arrays.</p><pre><code>scipy.spatial.minkowski_distance_p(x, y, p=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (M, K) array_like\n    Input array. \ny : (N, K) array_like\n    Input array. \np : float, 1 <= p <= infinity\n    Which Minkowski p-norm to use.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.spatial import minkowski_distance_p\n>>> minkowski_distance_p([[0,0],[0,0]], [[1,1],[0,1]])\narray([2, 1])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.minkowski_distance_p.html
scipy spatial minkowski_distance_p	R	scipy.spatial.minkowski_distance_p										
scipy spatial.minkowski_distance_p	R	scipy.spatial.minkowski_distance_p										
scipy spatial minkowski_distance	R	scipy.spatial.minkowski_distance										
scipy spatial.minkowski_distance	R	scipy.spatial.minkowski_distance										
scipy.spatial.procrustes	A					[[scipy.linalg.orthogonal_procrustes]]					<section class="prog__container"><p>Procrustes analysis, a similarity test for two data sets.</p><pre><code>scipy.spatial.procrustes(data1, data2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data1 : array_like\n    Matrix, n rows represent points in k (columns) space data1 is the reference data, after it is standardised, the data from data2 will be transformed to fit the pattern in data1 (must have >1 unique points). \ndata2 : array_like\n    n rows of data in k space to be fit to data1.  Must be the  same shape (numrows, numcols) as data1 (must have >1 unique points).</code></pre><span class="prog__sub">Returns:</span><pre><code>mtx1 : array_like\n    A standardized version of data1. \nmtx2 : array_like\n    The orientation of data2 that best fits data1. Centered, but not necessarily \(tr(AA^{T}) = 1\). \ndisparity : float\n    \(M^{2}\) as defined above.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.spatial import procrustes</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.procrustes.html
scipy spatial procrustes	R	scipy.spatial.procrustes										
scipy spatial.procrustes	R	scipy.spatial.procrustes										
scipy.spatial.Rectangle	A										<section class="prog__container"><p>Hyperrectangle class.</p><pre><code>class scipy.spatial.Rectangle(maxes, mins)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Rectangle.html
scipy.spatial.Rectangle.max_distance_point	A										<section class="prog__container"><p>Return the maximum distance between input and points in the hyperrectangle.</p><pre><code>Rectangle.max_distance_point(x, p=2.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \np : float, optional\n    Input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Rectangle.max_distance_point.html
scipy spatial Rectangle max_distance_point	R	scipy.spatial.Rectangle.max_distance_point										
scipy spatial.Rectangle.max_distance_point	R	scipy.spatial.Rectangle.max_distance_point										
scipy.spatial.Rectangle.max_distance_rectangle	A										<section class="prog__container"><p>Compute the maximum distance between points in the two hyperrectangles.</p><pre><code>Rectangle.max_distance_rectangle(other, p=2.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : hyperrectangle\n    Input. \np : float, optional\n    Input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Rectangle.max_distance_rectangle.html
scipy spatial Rectangle max_distance_rectangle	R	scipy.spatial.Rectangle.max_distance_rectangle										
scipy spatial.Rectangle.max_distance_rectangle	R	scipy.spatial.Rectangle.max_distance_rectangle										
scipy.spatial.Rectangle.min_distance_point	A										<section class="prog__container"><p>Return the minimum distance between input and points in the hyperrectangle.</p><pre><code>Rectangle.min_distance_point(x, p=2.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input. \np : float, optional\n    Input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Rectangle.min_distance_point.html
scipy spatial Rectangle min_distance_point	R	scipy.spatial.Rectangle.min_distance_point										
scipy spatial.Rectangle.min_distance_point	R	scipy.spatial.Rectangle.min_distance_point										
scipy.spatial.Rectangle.min_distance_rectangle	A										<section class="prog__container"><p>Compute the minimum distance between points in the two hyperrectangles.</p><pre><code>Rectangle.min_distance_rectangle(other, p=2.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : hyperrectangle\n    Input. \np : float\n    Input.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Rectangle.min_distance_rectangle.html
scipy spatial Rectangle min_distance_rectangle	R	scipy.spatial.Rectangle.min_distance_rectangle										
scipy spatial.Rectangle.min_distance_rectangle	R	scipy.spatial.Rectangle.min_distance_rectangle										
scipy spatial Rectangle	R	scipy.spatial.Rectangle										
scipy spatial.Rectangle	R	scipy.spatial.Rectangle										
scipy.spatial.Rectangle.split	A										<section class="prog__container"><p>Produce two hyperrectangles by splitting.</p><pre><code>Rectangle.split(d, split)</code></pre><span class="prog__sub">Parameters:</span><pre><code>d : int\n    Axis to split hyperrectangle along. \nsplit : float\n    Position along axis d to split at.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Rectangle.split.html
scipy spatial Rectangle split	R	scipy.spatial.Rectangle.split										
scipy spatial.Rectangle.split	R	scipy.spatial.Rectangle.split										
scipy.spatial.Rectangle.volume	A										<section class="prog__container"><p>Total volume.</p><pre><code>Rectangle.volume()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Rectangle.volume.html
scipy spatial Rectangle volume	R	scipy.spatial.Rectangle.volume										
scipy spatial.Rectangle.volume	R	scipy.spatial.Rectangle.volume										
scipy.spatial.SphericalVoronoi	A										<section class="prog__container"><p>Voronoi diagrams on the surface of a sphere.</p><pre><code>class scipy.spatial.SphericalVoronoi(points, radius=None, center=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray of floats, shape (npoints, 3)\n    Coordinates of points to construct a spherical Voronoi diagram from \nradius : float, optional\n    Radius of the sphere (Default: 1) \ncenter : ndarray of floats, shape (3,)\n    Center of sphere (Default: origin)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from matplotlib import colors\n>>> from mpl_toolkits.mplot3d.art3d import Poly3DCollection\n>>> import matplotlib.pyplot as plt\n>>> from scipy.spatial import SphericalVoronoi\n>>> from mpl_toolkits.mplot3d import proj3d\n>>> # set input data\n>>> points = np.array([[0, 0, 1], [0, 0, -1], [1, 0, 0],\n...                    [0, 1, 0], [0, -1, 0], [-1, 0, 0], ])\n>>> center = np.array([0, 0, 0])\n>>> radius = 1\n>>> # calculate spherical Voronoi diagram\n>>> sv = SphericalVoronoi(points, radius, center)\n>>> # sort vertices (optional, helpful for plotting)\n>>> sv.sort_vertices_of_regions()\n>>> # generate plot\n>>> fig = plt.figure()\n>>> ax = fig.add_subplot(111, projection='3d')\n>>> # plot the unit sphere for reference (optional)\n>>> u = np.linspace(0, 2 * np.pi, 100)\n>>> v = np.linspace(0, np.pi, 100)\n>>> x = np.outer(np.cos(u), np.sin(v))\n>>> y = np.outer(np.sin(u), np.sin(v))\n>>> z = np.outer(np.ones(np.size(u)), np.cos(v))\n>>> ax.plot_surface(x, y, z, color='y', alpha=0.1)\n>>> # plot generator points\n>>> ax.scatter(points[:, 0], points[:, 1], points[:, 2], c='b')\n>>> # plot Voronoi vertices\n>>> ax.scatter(sv.vertices[:, 0], sv.vertices[:, 1], sv.vertices[:, 2],\n...                    c='g')\n>>> # indicate Voronoi regions (as Euclidean polygons)\n>>> for region in sv.regions:\n...    random_color = colors.rgb2hex(np.random.rand(3))\n...    polygon = Poly3DCollection([sv.vertices[region]], alpha=1.0)\n...    polygon.set_color(random_color)\n...    ax.add_collection3d(polygon)\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.SphericalVoronoi.html
scipy spatial SphericalVoronoi	R	scipy.spatial.SphericalVoronoi										
scipy spatial.SphericalVoronoi	R	scipy.spatial.SphericalVoronoi										
scipy.spatial.SphericalVoronoi.sort_vertices_of_regions	A										<section class="prog__container"><p>For each region in regions, it sorts the indices of the Voronoi\nvertices such that the resulting points are in a clockwise or\ncounterclockwise order around the generator point.</p><pre><code>SphericalVoronoi.sort_vertices_of_regions()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.SphericalVoronoi.sort_vertices_of_regions.html
scipy spatial SphericalVoronoi sort_vertices_of_regions	R	scipy.spatial.SphericalVoronoi.sort_vertices_of_regions										
scipy spatial.SphericalVoronoi.sort_vertices_of_regions	R	scipy.spatial.SphericalVoronoi.sort_vertices_of_regions										
scipy.spatial.tsearch	A					[[scipy.spatial.Delaunay.find_simplex]]					<section class="prog__container"><p>Find simplices containing the given points. This function does the\nsame thing as Delaunay.find_simplex.</p><pre><code>scipy.spatial.tsearch(tri, xi)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.tsearch.html
scipy spatial tsearch	R	scipy.spatial.tsearch										
scipy spatial.tsearch	R	scipy.spatial.tsearch										
scipy.spatial.Voronoi.add_points	A					[[scipy.spatial.Voronoi.close]]					<section class="prog__container"><p>Process a set of additional new points.</p><pre><code>Voronoi.add_points(points, restart=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray\n    New points to add. The dimensionality should match that of the initial points. \nrestart : bool, optional\n    Whether to restart processing from scratch, rather than adding points incrementally.</code></pre><span class="prog__sub">Returns:</span><pre><code>QhullError\n    Raised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Voronoi.add_points.html
scipy spatial Voronoi add_points	R	scipy.spatial.Voronoi.add_points										
scipy spatial.Voronoi.add_points	R	scipy.spatial.Voronoi.add_points										
scipy.spatial.Voronoi	A										<section class="prog__container"><p>Voronoi diagrams in N dimensions.</p><pre><code>class scipy.spatial.Voronoi(points, furthest_site=False, incremental=False, qhull_options=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : ndarray of floats, shape (npoints, ndim)\n    Coordinates of points to construct a convex hull from \nfurthest_site : bool, optional\n    Whether to compute a furthest-site Voronoi diagram. Default: False \nincremental : bool, optional\n    Allow adding new points incrementally. This takes up some additional resources. \nqhull_options : str, optional\n    Additional options to pass to Qhull. See Qhull manual for details. (Default: “Qbb Qc Qz Qx” for ndim > 4 and “Qbb Qc Qz” otherwise. Incremental mode omits “Qz”.)</code></pre><span class="prog__sub">Returns:</span><pre><code>QhullError\n    Raised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled. \nValueError\n    Raised if an incompatible array is given as input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> points = np.array([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2],\n...                    [2, 0], [2, 1], [2, 2]])\n>>> from scipy.spatial import Voronoi, voronoi_plot_2d\n>>> vor = Voronoi(points)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Voronoi.html
scipy.spatial.Voronoi.close	A										<section class="prog__container"><p>Finish incremental processing.</p><pre><code>Voronoi.close()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Voronoi.close.html
scipy spatial Voronoi close	R	scipy.spatial.Voronoi.close										
scipy spatial.Voronoi.close	R	scipy.spatial.Voronoi.close										
scipy.spatial.voronoi_plot_2d	A					[[scipy.spatial.Voronoi]]					<section class="prog__container"><p>Plot the given Voronoi diagram in 2-D</p><pre><code>scipy.spatial.voronoi_plot_2d(vor, ax=None, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>vor : scipy.spatial.Voronoi instance\n    Diagram to plot \nax : matplotlib.axes.Axes instance, optional\n    Axes to plot on \nshow_points: bool, optional\n    Add the Voronoi points to the plot. \nshow_vertices : bool, optional\n    Add the Voronoi vertices to the plot. \nline_colors : string, optional\n    Specifies the line color for polygon boundaries \nline_width : float, optional\n    Specifies the line width for polygon boundaries \nline_alpha: float, optional\n    Specifies the line alpha for polygon boundaries</code></pre><span class="prog__sub">Returns:</span><pre><code>fig : matplotlib.figure.Figure instance\n    Figure for the plot</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.voronoi_plot_2d.html
scipy spatial voronoi_plot_2d	R	scipy.spatial.voronoi_plot_2d										
scipy spatial.voronoi_plot_2d	R	scipy.spatial.voronoi_plot_2d										
scipy spatial Voronoi	R	scipy.spatial.Voronoi										
scipy spatial.Voronoi	R	scipy.spatial.Voronoi										
scipy.special.agm	A										<section class="prog__container"><p>Arithmetic, Geometric Mean.</p><pre><code>scipy.special.agm(a, b)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.agm.html
scipy special agm	R	scipy.special.agm										
scipy special.agm	R	scipy.special.agm										
scipy.special.airy	A										<section class="prog__container"><p>Airy functions and their derivatives.</p><pre><code>scipy.special.airy(z) = <ufunc 'airy'></code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    Real or complex argument.</code></pre><span class="prog__sub">Returns:</span><pre><code>Ai, Aip, Bi, Bip : ndarrays\n    Airy functions Ai and Bi, and their derivatives Aip and Bip.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.airy.html
scipy.special.airye	A					[[scipy.special.airy]]					<section class="prog__container"><p>Exponentially scaled Airy functions and their derivatives.</p><pre><code>scipy.special.airye(z) = <ufunc 'airye'></code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    Real or complex argument.</code></pre><span class="prog__sub">Returns:</span><pre><code>eAi, eAip, eBi, eBip : array_like\n    Airy functions Ai and Bi, and their derivatives Aip and Bip</code></pre><span class="prog__sub">Examples:</span><pre><code>eAi  = Ai  * exp(2.0/3.0*z*sqrt(z))\neAip = Aip * exp(2.0/3.0*z*sqrt(z))\neBi  = Bi  * exp(-abs((2.0/3.0*z*sqrt(z)).real))\neBip = Bip * exp(-abs((2.0/3.0*z*sqrt(z)).real))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.airye.html
scipy special airye	R	scipy.special.airye										
scipy special.airye	R	scipy.special.airye										
scipy special airy	R	scipy.special.airy										
scipy special.airy	R	scipy.special.airy										
scipy.special.ai_zeros	A										<section class="prog__container"><p>Compute nt zeros and values of the Airy function Ai and its derivative.</p><pre><code>scipy.special.ai_zeros(nt)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nt : int\n    Number of zeros to compute</code></pre><span class="prog__sub">Returns:</span><pre><code>a : ndarray\n    First nt zeros of Ai(x) \nap : ndarray\n    First nt zeros of Ai’(x) \nai : ndarray\n    Values of Ai(x) evaluated at first nt zeros of Ai’(x) \naip : ndarray\n    Values of Ai’(x) evaluated at first nt zeros of Ai(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ai_zeros.html
scipy special ai_zeros	R	scipy.special.ai_zeros										
scipy special.ai_zeros	R	scipy.special.ai_zeros										
scipy.special.assoc_laguerre	A										<section class="prog__container"><p>Compute the generalized (associated) Laguerre polynomial of degree n and order k.</p><pre><code>scipy.special.assoc_laguerre(x, n, k=0.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.assoc_laguerre.html
scipy special assoc_laguerre	R	scipy.special.assoc_laguerre										
scipy special.assoc_laguerre	R	scipy.special.assoc_laguerre										
scipy.special.bdtr	A										<section class="prog__container"><p>Binomial distribution cumulative distribution function.</p><pre><code>scipy.special.bdtr(k, n, p) = <ufunc 'bdtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    Number of successes (int). \nn : array_like\n    Number of events (int). \np : array_like\n    Probability of success in a single event (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Probability of k or fewer successes in n independent events with success probabilities of p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bdtr.html
scipy.special.bdtrc	A					[[scipy.special.bdtr]]\\n[[scipy.special.betainc]]					<section class="prog__container"><p>Binomial distribution survival function.</p><pre><code>scipy.special.bdtrc(k, n, p) = <ufunc 'bdtrc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    Number of successes (int). \nn : array_like\n    Number of events (int) \np : array_like\n    Probability of success in a single event.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    Probability of k + 1 or more successes in n independent events with success probabilities of p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bdtrc.html
scipy special bdtrc	R	scipy.special.bdtrc										
scipy special.bdtrc	R	scipy.special.bdtrc										
scipy.special.bdtri	A					[[scipy.special.bdtr]]\\n[[scipy.special.betaincinv]]					<section class="prog__container"><p>Inverse function to bdtr with respect to p.</p><pre><code>scipy.special.bdtri(k, n, y) = <ufunc 'bdtri'></code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    Number of successes (float). \nn : array_like\n    Number of events (float) \ny : array_like\n    Cumulative probability (probability of k or fewer successes in n events).</code></pre><span class="prog__sub">Returns:</span><pre><code>p : ndarray\n    The event probability such that bdtr(k, n, p) = y.</code></pre><span class="prog__sub">Examples:</span><pre><code>1 - p = betaincinv(n - k, k + 1, y).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bdtri.html
scipy.special.bdtrik	A					[[scipy.special.bdtr]]					<section class="prog__container"><p>Inverse function to bdtr with respect to k.</p><pre><code>scipy.special.bdtrik(y, n, p) = <ufunc 'bdtrik'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Cumulative probability (probability of k or fewer successes in n events). \nn : array_like\n    Number of events (float). \np : array_like\n    Success probability (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>k : ndarray\n    The number of successes k such that bdtr(k, n, p) = y.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bdtrik.html
scipy special bdtrik	R	scipy.special.bdtrik										
scipy special.bdtrik	R	scipy.special.bdtrik										
scipy.special.bdtrin	A					[[scipy.special.bdtr]]					<section class="prog__container"><p>Inverse function to bdtr with respect to n.</p><pre><code>scipy.special.bdtrin(k, y, p) = <ufunc 'bdtrin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    Number of successes (float). \ny : array_like\n    Cumulative probability (probability of k or fewer successes in n events). \np : array_like\n    Success probability (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>n : ndarray\n    The number of events n such that bdtr(k, n, p) = y.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bdtrin.html
scipy special bdtrin	R	scipy.special.bdtrin										
scipy special.bdtrin	R	scipy.special.bdtrin										
scipy special bdtri	R	scipy.special.bdtri										
scipy special.bdtri	R	scipy.special.bdtri										
scipy special bdtr	R	scipy.special.bdtr										
scipy special.bdtr	R	scipy.special.bdtr										
scipy.special.bei	A										<section class="prog__container"><p>Kelvin function bei</p><pre><code>scipy.special.bei(x) = <ufunc 'bei'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bei.html
scipy.special.beip	A										<section class="prog__container"><p>Derivative of the Kelvin function bei</p><pre><code>scipy.special.beip(x) = <ufunc 'beip'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.beip.html
scipy special beip	R	scipy.special.beip										
scipy special.beip	R	scipy.special.beip										
scipy.special.beip_zeros	A										<section class="prog__container"><p>Compute nt zeros of the Kelvin function bei’(x).</p><pre><code>scipy.special.beip_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.beip_zeros.html
scipy special beip_zeros	R	scipy.special.beip_zeros										
scipy special.beip_zeros	R	scipy.special.beip_zeros										
scipy special bei	R	scipy.special.bei										
scipy special.bei	R	scipy.special.bei										
scipy.special.bei_zeros	A										<section class="prog__container"><p>Compute nt zeros of the Kelvin function bei(x).</p><pre><code>scipy.special.bei_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bei_zeros.html
scipy special bei_zeros	R	scipy.special.bei_zeros										
scipy special.bei_zeros	R	scipy.special.bei_zeros										
scipy.special.ber	A										<section class="prog__container"><p>Kelvin function ber.</p><pre><code>scipy.special.ber(x) = <ufunc 'ber'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ber.html
scipy.special.bernoulli	A										<section class="prog__container"><p>Bernoulli numbers B0..Bn (inclusive).</p><pre><code>scipy.special.bernoulli(n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bernoulli.html
scipy special bernoulli	R	scipy.special.bernoulli										
scipy special.bernoulli	R	scipy.special.bernoulli										
scipy.special.berp	A										<section class="prog__container"><p>Derivative of the Kelvin function ber</p><pre><code>scipy.special.berp(x) = <ufunc 'berp'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.berp.html
scipy special berp	R	scipy.special.berp										
scipy special.berp	R	scipy.special.berp										
scipy.special.berp_zeros	A										<section class="prog__container"><p>Compute nt zeros of the Kelvin function ber’(x).</p><pre><code>scipy.special.berp_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.berp_zeros.html
scipy special berp_zeros	R	scipy.special.berp_zeros										
scipy special.berp_zeros	R	scipy.special.berp_zeros										
scipy special ber	R	scipy.special.ber										
scipy special.ber	R	scipy.special.ber										
scipy.special.ber_zeros	A										<section class="prog__container"><p>Compute nt zeros of the Kelvin function ber(x).</p><pre><code>scipy.special.ber_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ber_zeros.html
scipy special ber_zeros	R	scipy.special.ber_zeros										
scipy special.ber_zeros	R	scipy.special.ber_zeros										
scipy.special.besselpoly	A										<section class="prog__container"><p>Weighted integral of a Bessel function.</p><pre><code>scipy.special.besselpoly(a, lmb, nu) = <ufunc 'besselpoly'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.besselpoly.html
scipy special besselpoly	R	scipy.special.besselpoly										
scipy special.besselpoly	R	scipy.special.besselpoly										
scipy.special.beta	A										<section class="prog__container"><p>Beta function.</p><pre><code>scipy.special.beta(a, b) = <ufunc 'beta'></code></pre><span class="prog__sub">Examples:</span><pre><code>beta(a, b) =  gamma(a) * gamma(b) / gamma(a+b)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.beta.html
scipy.special.betainc	A										<section class="prog__container"><p>Incomplete beta integral.</p><pre><code>scipy.special.betainc(a, b, x) = <ufunc 'betainc'></code></pre><span class="prog__sub">Examples:</span><pre><code>gamma(a+b) / (gamma(a)*gamma(b)) * integral(t**(a-1) (1-t)**(b-1), t=0..x).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.betainc.html
scipy.special.betaincinv	A										<section class="prog__container"><p>Inverse function to beta integral.</p><pre><code>scipy.special.betaincinv(a, b, y) = <ufunc 'betaincinv'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.betaincinv.html
scipy special betaincinv	R	scipy.special.betaincinv										
scipy special.betaincinv	R	scipy.special.betaincinv										
scipy special betainc	R	scipy.special.betainc										
scipy special.betainc	R	scipy.special.betainc										
scipy.special.betaln	A										<section class="prog__container"><p>Natural logarithm of absolute value of beta function.</p><pre><code>scipy.special.betaln(a, b) = <ufunc 'betaln'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.betaln.html
scipy special betaln	R	scipy.special.betaln										
scipy special.betaln	R	scipy.special.betaln										
scipy special beta	R	scipy.special.beta										
scipy special.beta	R	scipy.special.beta										
scipy.special.binom	A										<section class="prog__container"><p>Binomial coefficient</p><pre><code>scipy.special.binom(n, k) = <ufunc 'binom'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.binom.html
scipy special binom	R	scipy.special.binom										
scipy special.binom	R	scipy.special.binom										
scipy.special.bi_zeros	A										<section class="prog__container"><p>Compute nt zeros and values of the Airy function Bi and its derivative.</p><pre><code>scipy.special.bi_zeros(nt)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nt : int\n    Number of zeros to compute</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    First nt zeros of Bi(x) \nbp : ndarray\n    First nt zeros of Bi’(x) \nbi : ndarray\n    Values of Bi(x) evaluated at first nt zeros of Bi’(x) \nbip : ndarray\n    Values of Bi’(x) evaluated at first nt zeros of Bi(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.bi_zeros.html
scipy special bi_zeros	R	scipy.special.bi_zeros										
scipy special.bi_zeros	R	scipy.special.bi_zeros										
scipy.special.boxcox1p	A										<section class="prog__container"><p>Compute the Box-Cox transformation of 1 + x.</p><pre><code>scipy.special.boxcox1p(x, lmbda) = <ufunc 'boxcox1p'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Data to be transformed. \nlmbda : array_like\n    Power parameter of the Box-Cox transform.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array\n    Transformed data.</code></pre><span class="prog__sub">Examples:</span><pre><code>y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n    log(1+x)                    if lmbda == 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.boxcox1p.html
scipy special boxcox1p	R	scipy.special.boxcox1p										
scipy special.boxcox1p	R	scipy.special.boxcox1p										
scipy.special.boxcox	A										<section class="prog__container"><p>Compute the Box-Cox transformation.</p><pre><code>scipy.special.boxcox(x, lmbda) = <ufunc 'boxcox'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Data to be transformed. \nlmbda : array_like\n    Power parameter of the Box-Cox transform.</code></pre><span class="prog__sub">Returns:</span><pre><code>y : array\n    Transformed data.</code></pre><span class="prog__sub">Examples:</span><pre><code>y = (x**lmbda - 1) / lmbda  if lmbda != 0\n    log(x)                  if lmbda == 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.boxcox.html
scipy special boxcox	R	scipy.special.boxcox										
scipy special.boxcox	R	scipy.special.boxcox										
scipy.special.btdtr	A					[[scipy.special.betainc]]					<section class="prog__container"><p>Cumulative density function of the beta distribution.</p><pre><code>scipy.special.btdtr(a, b, x) = <ufunc 'btdtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Shape parameter (a > 0). \nb : array_like\n    Shape parameter (b > 0). \nx : array_like\n    Upper limit of integration, in [0, 1].</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray\n    Cumulative density function of the beta distribution with parameters a and b at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.btdtr.html
scipy.special.btdtria	A										<section class="prog__container"><p>Inverse of btdtr with respect to a.</p><pre><code>scipy.special.btdtria(p, b, x) = <ufunc 'btdtria'></code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    Cumulative probability, in [0, 1]. \nb : array_like\n    Shape parameter (b > 0). \nx : array_like\n    The quantile, in [0, 1].</code></pre><span class="prog__sub">Returns:</span><pre><code>a : ndarray\n    The value of the shape parameter a such that btdtr(a, b, x) = p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.btdtria.html
scipy special btdtria	R	scipy.special.btdtria										
scipy special.btdtria	R	scipy.special.btdtria										
scipy.special.btdtri	A					[[scipy.special.betaincinv]]\\n[[scipy.special.btdtr]]					<section class="prog__container"><p>The p-th quantile of the beta distribution.</p><pre><code>scipy.special.btdtri(a, b, p) = <ufunc 'btdtri'></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Shape parameter (a > 0). \nb : array_like\n    Shape parameter (b > 0). \np : array_like\n    Cumulative probability, in [0, 1].</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    The quantile corresponding to p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.btdtri.html
scipy.special.btdtrib	A										<section class="prog__container"><p>Inverse of btdtr with respect to b.</p><pre><code>scipy.special.btdtrib(a, p, x) = <ufunc 'btdtrib'></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Shape parameter (a > 0). \np : array_like\n    Cumulative probability, in [0, 1]. \nx : array_like\n    The quantile, in [0, 1].</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    The value of the shape parameter b such that btdtr(a, b, x) = p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.btdtrib.html
scipy special btdtrib	R	scipy.special.btdtrib										
scipy special.btdtrib	R	scipy.special.btdtrib										
scipy special btdtri	R	scipy.special.btdtri										
scipy special.btdtri	R	scipy.special.btdtri										
scipy special btdtr	R	scipy.special.btdtr										
scipy special.btdtr	R	scipy.special.btdtr										
scipy.special.cbrt	A										<section class="prog__container"><p>Cube root of x</p><pre><code>scipy.special.cbrt(x) = <ufunc 'cbrt'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.cbrt.html
scipy special cbrt	R	scipy.special.cbrt										
scipy special.cbrt	R	scipy.special.cbrt										
scipy.special.cg_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Gegenbauer quadrature.</p><pre><code>scipy.special.cg_roots(n, alpha, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nalpha : float\n    alpha must be > -0.5 \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.cg_roots.html
scipy special cg_roots	R	scipy.special.cg_roots										
scipy special.cg_roots	R	scipy.special.cg_roots										
scipy.special.chdtr	A										<section class="prog__container"><p>Chi square cumulative distribution function</p><pre><code>scipy.special.chdtr(v, x) = <ufunc 'chdtr'></code></pre><span class="prog__sub">Examples:</span><pre><code>1/(2**(v/2) * gamma(v/2)) * integral(t**(v/2-1) * exp(-t/2), t=0..x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chdtr.html
scipy.special.chdtrc	A										<section class="prog__container"><p>Chi square survival function</p><pre><code>scipy.special.chdtrc(v, x) = <ufunc 'chdtrc'></code></pre><span class="prog__sub">Examples:</span><pre><code>1/(2**(v/2) * gamma(v/2)) * integral(t**(v/2-1) * exp(-t/2), t=x..inf)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chdtrc.html
scipy special chdtrc	R	scipy.special.chdtrc										
scipy special.chdtrc	R	scipy.special.chdtrc										
scipy.special.chdtri	A										<section class="prog__container"><p>Inverse to chdtrc</p><pre><code>scipy.special.chdtri(v, p) = <ufunc 'chdtri'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chdtri.html
scipy special chdtri	R	scipy.special.chdtri										
scipy special.chdtri	R	scipy.special.chdtri										
scipy.special.chdtriv	A										<section class="prog__container"><p>Inverse to chdtr vs v</p><pre><code>scipy.special.chdtriv(p, x) = <ufunc 'chdtriv'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chdtriv.html
scipy special chdtriv	R	scipy.special.chdtriv										
scipy special.chdtriv	R	scipy.special.chdtriv										
scipy special chdtr	R	scipy.special.chdtr										
scipy special.chdtr	R	scipy.special.chdtr										
scipy.special.chebyc	A										<section class="prog__container"><p>Return n-th order Chebyshev polynomial of first kind, \(C_n(x)\). \nOrthogonal over \([-2, 2]\) with weight function\n\(f(x) = 1/\sqrt{1 - (x/2)^2}\)</p><pre><code>scipy.special.chebyc(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chebyc.html
scipy special chebyc	R	scipy.special.chebyc										
scipy special.chebyc	R	scipy.special.chebyc										
scipy.special.chebys	A										<section class="prog__container"><p>Return nth order Chebyshev polynomial of second kind, \(S_n(x)\).\nOrthogonal over \([-2, 2]\) with weight function\n\(f(x) = \sqrt{1 - (x/2)^2}\).</p><pre><code>scipy.special.chebys(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chebys.html
scipy special chebys	R	scipy.special.chebys										
scipy special.chebys	R	scipy.special.chebys										
scipy.special.chebyt	A										<section class="prog__container"><p>Return nth order Chebyshev polynomial of first kind, Tn(x).  Orthogonal\nover [-1,1] with weight function (1-x**2)**(-1/2).</p><pre><code>scipy.special.chebyt(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chebyt.html
scipy special chebyt	R	scipy.special.chebyt										
scipy special.chebyt	R	scipy.special.chebyt										
scipy.special.chebyu	A										<section class="prog__container"><p>Return nth order Chebyshev polynomial of second kind, Un(x).  Orthogonal\nover [-1,1] with weight function (1-x**2)**(1/2).</p><pre><code>scipy.special.chebyu(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chebyu.html
scipy special chebyu	R	scipy.special.chebyu										
scipy special.chebyu	R	scipy.special.chebyu										
scipy.special.chndtr	A										<section class="prog__container"><p>Non-central chi square cumulative distribution function</p><pre><code>scipy.special.chndtr(x, df, nc) = <ufunc 'chndtr'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chndtr.html
scipy.special.chndtridf	A										<section class="prog__container"><p>Inverse to chndtr vs df</p><pre><code>scipy.special.chndtridf(x, p, nc) = <ufunc 'chndtridf'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chndtridf.html
scipy special chndtridf	R	scipy.special.chndtridf										
scipy special.chndtridf	R	scipy.special.chndtridf										
scipy.special.chndtrinc	A										<section class="prog__container"><p>Inverse to chndtr vs nc</p><pre><code>scipy.special.chndtrinc(x, df, p) = <ufunc 'chndtrinc'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chndtrinc.html
scipy special chndtrinc	R	scipy.special.chndtrinc										
scipy special.chndtrinc	R	scipy.special.chndtrinc										
scipy.special.chndtrix	A										<section class="prog__container"><p>Inverse to chndtr vs x</p><pre><code>scipy.special.chndtrix(p, df, nc) = <ufunc 'chndtrix'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.chndtrix.html
scipy special chndtrix	R	scipy.special.chndtrix										
scipy special.chndtrix	R	scipy.special.chndtrix										
scipy special chndtr	R	scipy.special.chndtr										
scipy special.chndtr	R	scipy.special.chndtr										
scipy.special.clpmn	A										<section class="prog__container"><p>Associated Legendre function of the first kind, Pmn(z).</p><pre><code>scipy.special.clpmn(m, n, z, type=3)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : int\n    |m| <= n; the order of the Legendre function. \nn : int\n    where n >= 0; the degree of the Legendre function.  Often called l (lower case L) in descriptions of the associated Legendre function \nz : float or complex\n    Input value. \ntype : int, optional\n    takes values 2 or 3 2: cut on the real axis |x| > 1 3: cut on the real axis -1 < x < 1 (default)</code></pre><span class="prog__sub">Returns:</span><pre><code>Pmn_z : (m+1, n+1) array\n    Values for all orders 0..m and degrees 0..n \nPmn_d_z : (m+1, n+1) array\n    Derivatives for all orders 0..m and degrees 0..n</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.clpmn.html
scipy special clpmn	R	scipy.special.clpmn										
scipy special.clpmn	R	scipy.special.clpmn										
scipy.special.comb	A										<section class="prog__container"><p>The number of combinations of N things taken k at a time.</p><pre><code>scipy.special.comb(N, k, exact=False, repetition=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int, ndarray\n    Number of things. \nk : int, ndarray\n    Number of elements taken. \nexact : bool, optional\n    If exact is False, then floating point precision is used, otherwise exact long integer is computed. \nrepetition : bool, optional\n    If repetition is True, then the number of combinations with repetition is computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : int, ndarray\n    The total number of combinations.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import comb\n>>> k = np.array([3, 4])\n>>> n = np.array([10, 10])\n>>> comb(n, k, exact=False)\narray([ 120.,  210.])\n>>> comb(10, 3, exact=True)\n120L\n>>> comb(10, 3, exact=True, repetition=True)\n220L</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html
scipy special comb	R	scipy.special.comb										
scipy special.comb	R	scipy.special.comb										
scipy.special.cosdg	A										<section class="prog__container"><p>Cosine of the angle x given in degrees.</p><pre><code>scipy.special.cosdg(x) = <ufunc 'cosdg'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.cosdg.html
scipy special cosdg	R	scipy.special.cosdg										
scipy special.cosdg	R	scipy.special.cosdg										
scipy.special.cosm1	A										<section class="prog__container"><p>cos(x) - 1 for use when x is near zero.</p><pre><code>scipy.special.cosm1(x) = <ufunc 'cosm1'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.cosm1.html
scipy special cosm1	R	scipy.special.cosm1										
scipy special.cosm1	R	scipy.special.cosm1										
scipy.special.cotdg	A										<section class="prog__container"><p>Cotangent of the angle x given in degrees.</p><pre><code>scipy.special.cotdg(x) = <ufunc 'cotdg'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.cotdg.html
scipy special cotdg	R	scipy.special.cotdg										
scipy special.cotdg	R	scipy.special.cotdg										
scipy.special.c_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Chebyshev (first kind) quadrature.</p><pre><code>scipy.special.c_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.c_roots.html
scipy special c_roots	R	scipy.special.c_roots										
scipy special.c_roots	R	scipy.special.c_roots										
scipy.special.dawsn	A					[[scipy.special.wofz]]\\n[[scipy.special.erf]]\\n[[scipy.special.erfc]]\\n[[scipy.special.erfcx]]\\n[[scipy.special.erfi]]					<section class="prog__container"><p>Dawson’s integral.</p><pre><code>scipy.special.dawsn(x) = <ufunc 'dawsn'></code></pre><span class="prog__sub">Examples:</span><pre><code>exp(-x**2) * integral(exp(t**2), t=0..x).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.dawsn.html
scipy special dawsn	R	scipy.special.dawsn										
scipy special.dawsn	R	scipy.special.dawsn										
scipy.special.digamma	A										<section class="prog__container"><p>The digamma function.</p><pre><code>scipy.special.digamma(z, out=None) = <ufunc 'psi'></code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    Real or complex argument. \nout : ndarray, optional\n    Array for the computed values of psi.</code></pre><span class="prog__sub">Returns:</span><pre><code>digamma : ndarray\n    Computed values of psi.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.digamma.html
scipy special digamma	R	scipy.special.digamma										
scipy special.digamma	R	scipy.special.digamma										
scipy.special.diric	A										<section class="prog__container"><p>Periodic sinc function, also called the Dirichlet function.</p><pre><code>scipy.special.diric(x, n)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input data \nn : int\n    Integer defining the periodicity.</code></pre><span class="prog__sub">Returns:</span><pre><code>diric : ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>diric(x) = sin(x * n/2) / (n * sin(x / 2)),</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.diric.html
scipy special diric	R	scipy.special.diric										
scipy special.diric	R	scipy.special.diric										
scipy.special.ellipe	A										<section class="prog__container"><p>Complete elliptic integral of the second kind</p><pre><code>scipy.special.ellipe(m) = <ufunc 'ellipe'></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Defines the parameter of the elliptic integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>E : ndarray\n    Value of the elliptic integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellipe.html
scipy.special.ellipeinc	A										<section class="prog__container"><p>Incomplete elliptic integral of the second kind</p><pre><code>scipy.special.ellipeinc(phi, m) = <ufunc 'ellipeinc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>phi : array_like\n    amplitude of the elliptic integral. \nm : array_like\n    parameter of the elliptic integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>E : ndarray\n    Value of the elliptic integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellipeinc.html
scipy special ellipeinc	R	scipy.special.ellipeinc										
scipy special.ellipeinc	R	scipy.special.ellipeinc										
scipy special ellipe	R	scipy.special.ellipe										
scipy special.ellipe	R	scipy.special.ellipe										
scipy.special.ellip_harm_2	A					[[scipy.special.ellip_harm]]\\n[[scipy.special.ellip_normal]]					<section class="prog__container"><p>Ellipsoidal harmonic functions F^p_n(l)</p><pre><code>scipy.special.ellip_harm_2(h2, k2, n, p, s)</code></pre><span class="prog__sub">Parameters:</span><pre><code>h2 : float\n    h**2 \nk2 : float\n    k**2; should be larger than h**2 \nn : int\n    Degree. \np : int\n    Order, can range between [1,2n+1]. \ns : float\n    Coordinate</code></pre><span class="prog__sub">Returns:</span><pre><code>F : float\n    The harmonic \(F^p_n(s)\)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import ellip_harm_2\n>>> w = ellip_harm_2(5,8,2,1,10)\n>>> w\n0.00108056853382</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellip_harm_2.html
scipy special ellip_harm_2	R	scipy.special.ellip_harm_2										
scipy special.ellip_harm_2	R	scipy.special.ellip_harm_2										
scipy.special.ellip_harm	A					[[scipy.special.ellip_harm_2]]\\n[[scipy.special.ellip_normal]]					<section class="prog__container"><p>Ellipsoidal harmonic functions E^p_n(l)</p><pre><code>scipy.special.ellip_harm(h2, k2, n, p, s, signm=1, signn=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>h2 : float\n    h**2 \nk2 : float\n    k**2; should be larger than h**2 \nn : int\n    Degree \ns : float\n    Coordinate \np : int\n    Order, can range between [1,2n+1] \nsignm : {1, -1}, optional\n    Sign of prefactor of functions. Can be +/-1. See Notes. \nsignn : {1, -1}, optional\n    Sign of prefactor of functions. Can be +/-1. See Notes.</code></pre><span class="prog__sub">Returns:</span><pre><code>E : float\n    the harmonic \(E^p_n(s)\)</code></pre><span class="prog__sub">Examples:</span><pre><code>K : +1\nL : signm\nM : signn\nN : signm*signn</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellip_harm.html
scipy special ellip_harm	R	scipy.special.ellip_harm										
scipy special.ellip_harm	R	scipy.special.ellip_harm										
scipy.special.ellipj	A										<section class="prog__container"><p>Jacobian elliptic functions</p><pre><code>scipy.special.ellipj(u, m) = <ufunc 'ellipj'></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    Parameter. \nu : array_like\n    Argument.</code></pre><span class="prog__sub">Returns:</span><pre><code>sn, cn, dn, ph : ndarrays\n    The returned functions: sn(u|m), cn(u|m), dn(u|m)   The value ph is such that if u = ellipk(ph, m), then sn(u|m) = sin(ph) and cn(u|m) = cos(ph).</code></pre><span class="prog__sub">Examples:</span><pre><code>sn(u|m), cn(u|m), dn(u|m)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellipj.html
scipy special ellipj	R	scipy.special.ellipj										
scipy special.ellipj	R	scipy.special.ellipj										
scipy.special.ellipk	A										<section class="prog__container"><p>Complete elliptic integral of the first kind.</p><pre><code>scipy.special.ellipk(m)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : array_like\n    The parameter of the elliptic integral.</code></pre><span class="prog__sub">Returns:</span><pre><code>K : array_like\n    Value of the elliptic integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellipk.html
scipy.special.ellipkinc	A										<section class="prog__container"><p>Incomplete elliptic integral of the first kind</p><pre><code>scipy.special.ellipkinc(phi, m) = <ufunc 'ellipkinc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>phi : array_like\n    amplitude of the elliptic integral \nm : array_like\n    parameter of the elliptic integral</code></pre><span class="prog__sub">Returns:</span><pre><code>K : ndarray\n    Value of the elliptic integral</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellipkinc.html
scipy special ellipkinc	R	scipy.special.ellipkinc										
scipy special.ellipkinc	R	scipy.special.ellipkinc										
scipy.special.ellipkm1	A										<section class="prog__container"><p>Complete elliptic integral of the first kind around m = 1</p><pre><code>scipy.special.ellipkm1(p) = <ufunc 'ellipkm1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    Defines the parameter of the elliptic integral as m = 1 - p.</code></pre><span class="prog__sub">Returns:</span><pre><code>K : ndarray\n    Value of the elliptic integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellipkm1.html
scipy special ellipkm1	R	scipy.special.ellipkm1										
scipy special.ellipkm1	R	scipy.special.ellipkm1										
scipy special ellipk	R	scipy.special.ellipk										
scipy special.ellipk	R	scipy.special.ellipk										
scipy.special.ellip_normal	A					[[scipy.special.ellip_harm]]\\n[[scipy.special.ellip_harm_2]]					<section class="prog__container"><p>Ellipsoidal harmonic normalization constants gamma^p_n</p><pre><code>scipy.special.ellip_normal(h2, k2, n, p)</code></pre><span class="prog__sub">Parameters:</span><pre><code>h2 : float\n    h**2 \nk2 : float\n    k**2; should be larger than h**2 \nn : int\n    Degree. \np : int\n    Order, can range between [1,2n+1].</code></pre><span class="prog__sub">Returns:</span><pre><code>gamma : float\n    The normalization constant \(\gamma^p_n\)</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import ellip_normal\n>>> w = ellip_normal(5,8,3,7)\n>>> w\n1723.38796997</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ellip_normal.html
scipy special ellip_normal	R	scipy.special.ellip_normal										
scipy special.ellip_normal	R	scipy.special.ellip_normal										
scipy.special.entr	A					[[scipy.special.kl_div]]\\n[[scipy.special.rel_entr]]					<section class="prog__container"><p>Elementwise function for computing entropy.</p><pre><code>scipy.special.entr(x) = <ufunc 'entr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    The value of the elementwise entropy function at the given points x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.entr.html
scipy special entr	R	scipy.special.entr										
scipy special.entr	R	scipy.special.entr										
scipy.special.erf	A					[[scipy.special.erfc]]\\n[[scipy.special.erfinv]]\\n[[scipy.special.erfcinv]]\\n[[scipy.special.wofz]]\\n[[scipy.special.erfcx]]\\n[[scipy.special.erfi]]					<section class="prog__container"><p>Returns the error function of complex argument.</p><pre><code>scipy.special.erf(z) = <ufunc 'erf'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    The values of the error function at the given points x.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import special\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-3, 3)\n>>> plt.plot(x, special.erf(x))\n>>> plt.xlabel('$x$')\n>>> plt.ylabel('$erf(x)$')\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.erf.html
scipy.special.erfc	A					[[scipy.special.erf]]\\n[[scipy.special.erfi]]\\n[[scipy.special.erfcx]]\\n[[scipy.special.dawsn]]\\n[[scipy.special.wofz]]					<section class="prog__container"><p>Complementary error function, 1 - erf(x).</p><pre><code>scipy.special.erfc(x) = <ufunc 'erfc'></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import special\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-3, 3)\n>>> plt.plot(x, special.erfc(x))\n>>> plt.xlabel('$x$')\n>>> plt.ylabel('$erfc(x)$')\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.erfc.html
scipy.special.erfcinv	A										<section class="prog__container"><p>Inverse function for erfc.</p><pre><code>scipy.special.erfcinv(y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.erfcinv.html
scipy special erfcinv	R	scipy.special.erfcinv										
scipy special.erfcinv	R	scipy.special.erfcinv										
scipy special erfc	R	scipy.special.erfc										
scipy special.erfc	R	scipy.special.erfc										
scipy.special.erfcx	A					[[scipy.special.erf]]\\n[[scipy.special.erfc]]\\n[[scipy.special.erfi]]\\n[[scipy.special.dawsn]]\\n[[scipy.special.wofz]]					<section class="prog__container"><p>Scaled complementary error function, exp(x**2) * erfc(x).</p><pre><code>scipy.special.erfcx(x) = <ufunc 'erfcx'></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import special\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-3, 3)\n>>> plt.plot(x, special.erfcx(x))\n>>> plt.xlabel('$x$')\n>>> plt.ylabel('$erfcx(x)$')\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.erfcx.html
scipy special erfcx	R	scipy.special.erfcx										
scipy special.erfcx	R	scipy.special.erfcx										
scipy.special.erfi	A					[[scipy.special.erf]]\\n[[scipy.special.erfc]]\\n[[scipy.special.erfcx]]\\n[[scipy.special.dawsn]]\\n[[scipy.special.wofz]]					<section class="prog__container"><p>Imaginary error function, -i erf(i z).</p><pre><code>scipy.special.erfi(z) = <ufunc 'erfi'></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import special\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-3, 3)\n>>> plt.plot(x, special.erfi(x))\n>>> plt.xlabel('$x$')\n>>> plt.ylabel('$erfi(x)$')\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.erfi.html
scipy.special.erfinv	A										<section class="prog__container"><p>Inverse function for erf.</p><pre><code>scipy.special.erfinv(y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.erfinv.html
scipy special erfinv	R	scipy.special.erfinv										
scipy special.erfinv	R	scipy.special.erfinv										
scipy special erfi	R	scipy.special.erfi										
scipy special.erfi	R	scipy.special.erfi										
scipy special erf	R	scipy.special.erf										
scipy special.erf	R	scipy.special.erf										
scipy.special.erf_zeros	A										<section class="prog__container"><p>Compute nt complex zeros of error function erf(z).</p><pre><code>scipy.special.erf_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.erf_zeros.html
scipy special erf_zeros	R	scipy.special.erf_zeros										
scipy special.erf_zeros	R	scipy.special.erf_zeros										
scipy.special.errprint	A										<section class="prog__container"><p>Sets or returns the error printing flag for special functions.</p><pre><code>scipy.special.errprint(inflag=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>inflag : bool, optional\n    Whether warnings concerning evaluation of special functions in scipy.special are shown. If omitted, no change is made to the current setting.</code></pre><span class="prog__sub">Returns:</span><pre><code>old_flag\n    Previous value of the error flag</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.errprint.html
scipy special errprint	R	scipy.special.errprint										
scipy special.errprint	R	scipy.special.errprint										
scipy.special.euler	A										<section class="prog__container"><p>Euler numbers E0..En (inclusive).</p><pre><code>scipy.special.euler(n)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.euler.html
scipy special euler	R	scipy.special.euler										
scipy special.euler	R	scipy.special.euler										
scipy.special.eval_chebyc	A										<section class="prog__container"><p>Evaluate Chebyshev C polynomial at a point.</p><pre><code>scipy.special.eval_chebyc(n, x, out=None) = <ufunc 'eval_chebyc'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_chebyc.html
scipy special eval_chebyc	R	scipy.special.eval_chebyc										
scipy special.eval_chebyc	R	scipy.special.eval_chebyc										
scipy.special.eval_chebys	A										<section class="prog__container"><p>Evaluate Chebyshev S polynomial at a point.</p><pre><code>scipy.special.eval_chebys(n, x, out=None) = <ufunc 'eval_chebys'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_chebys.html
scipy special eval_chebys	R	scipy.special.eval_chebys										
scipy special.eval_chebys	R	scipy.special.eval_chebys										
scipy.special.eval_chebyt	A										<section class="prog__container"><p>Evaluate Chebyshev T polynomial at a point.</p><pre><code>scipy.special.eval_chebyt(n, x, out=None) = <ufunc 'eval_chebyt'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_chebyt.html
scipy special eval_chebyt	R	scipy.special.eval_chebyt										
scipy special.eval_chebyt	R	scipy.special.eval_chebyt										
scipy.special.eval_chebyu	A										<section class="prog__container"><p>Evaluate Chebyshev U polynomial at a point.</p><pre><code>scipy.special.eval_chebyu(n, x, out=None) = <ufunc 'eval_chebyu'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_chebyu.html
scipy special eval_chebyu	R	scipy.special.eval_chebyu										
scipy special.eval_chebyu	R	scipy.special.eval_chebyu										
scipy.special.eval_gegenbauer	A										<section class="prog__container"><p>Evaluate Gegenbauer polynomial at a point.</p><pre><code>scipy.special.eval_gegenbauer(n, alpha, x, out=None) = <ufunc 'eval_gegenbauer'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_gegenbauer.html
scipy special eval_gegenbauer	R	scipy.special.eval_gegenbauer										
scipy special.eval_gegenbauer	R	scipy.special.eval_gegenbauer										
scipy.special.eval_genlaguerre	A										<section class="prog__container"><p>Evaluate generalized Laguerre polynomial at a point.</p><pre><code>scipy.special.eval_genlaguerre(n, alpha, x, out=None) = <ufunc 'eval_genlaguerre'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_genlaguerre.html
scipy special eval_genlaguerre	R	scipy.special.eval_genlaguerre										
scipy special.eval_genlaguerre	R	scipy.special.eval_genlaguerre										
scipy.special.eval_hermite	A										<section class="prog__container"><p>Evaluate Hermite polynomial at a point.</p><pre><code>scipy.special.eval_hermite(n, x, out=None) = <ufunc 'eval_hermite'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_hermite.html
scipy.special.eval_hermitenorm	A										<section class="prog__container"><p>Evaluate normalized Hermite polynomial at a point.</p><pre><code>scipy.special.eval_hermitenorm(n, x, out=None) = <ufunc 'eval_hermitenorm'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_hermitenorm.html
scipy special eval_hermitenorm	R	scipy.special.eval_hermitenorm										
scipy special.eval_hermitenorm	R	scipy.special.eval_hermitenorm										
scipy special eval_hermite	R	scipy.special.eval_hermite										
scipy special.eval_hermite	R	scipy.special.eval_hermite										
scipy.special.eval_jacobi	A										<section class="prog__container"><p>Evaluate Jacobi polynomial at a point.</p><pre><code>scipy.special.eval_jacobi(n, alpha, beta, x, out=None) = <ufunc 'eval_jacobi'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_jacobi.html
scipy special eval_jacobi	R	scipy.special.eval_jacobi										
scipy special.eval_jacobi	R	scipy.special.eval_jacobi										
scipy.special.eval_laguerre	A										<section class="prog__container"><p>Evaluate Laguerre polynomial at a point.</p><pre><code>scipy.special.eval_laguerre(n, x, out=None) = <ufunc 'eval_laguerre'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_laguerre.html
scipy special eval_laguerre	R	scipy.special.eval_laguerre										
scipy special.eval_laguerre	R	scipy.special.eval_laguerre										
scipy.special.eval_legendre	A										<section class="prog__container"><p>Evaluate Legendre polynomial at a point.</p><pre><code>scipy.special.eval_legendre(n, x, out=None) = <ufunc 'eval_legendre'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_legendre.html
scipy special eval_legendre	R	scipy.special.eval_legendre										
scipy special.eval_legendre	R	scipy.special.eval_legendre										
scipy.special.eval_sh_chebyt	A										<section class="prog__container"><p>Evaluate shifted Chebyshev T polynomial at a point.</p><pre><code>scipy.special.eval_sh_chebyt(n, x, out=None) = <ufunc 'eval_sh_chebyt'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_sh_chebyt.html
scipy special eval_sh_chebyt	R	scipy.special.eval_sh_chebyt										
scipy special.eval_sh_chebyt	R	scipy.special.eval_sh_chebyt										
scipy.special.eval_sh_chebyu	A										<section class="prog__container"><p>Evaluate shifted Chebyshev U polynomial at a point.</p><pre><code>scipy.special.eval_sh_chebyu(n, x, out=None) = <ufunc 'eval_sh_chebyu'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_sh_chebyu.html
scipy special eval_sh_chebyu	R	scipy.special.eval_sh_chebyu										
scipy special.eval_sh_chebyu	R	scipy.special.eval_sh_chebyu										
scipy.special.eval_sh_jacobi	A										<section class="prog__container"><p>Evaluate shifted Jacobi polynomial at a point.</p><pre><code>scipy.special.eval_sh_jacobi(n, p, q, x, out=None) = <ufunc 'eval_sh_jacobi'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_sh_jacobi.html
scipy special eval_sh_jacobi	R	scipy.special.eval_sh_jacobi										
scipy special.eval_sh_jacobi	R	scipy.special.eval_sh_jacobi										
scipy.special.eval_sh_legendre	A										<section class="prog__container"><p>Evaluate shifted Legendre polynomial at a point.</p><pre><code>scipy.special.eval_sh_legendre(n, x, out=None) = <ufunc 'eval_sh_legendre'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.eval_sh_legendre.html
scipy special eval_sh_legendre	R	scipy.special.eval_sh_legendre										
scipy special.eval_sh_legendre	R	scipy.special.eval_sh_legendre										
scipy.special.exp10	A										<section class="prog__container"><p>10**x</p><pre><code>scipy.special.exp10(x) = <ufunc 'exp10'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.exp10.html
scipy special exp10	R	scipy.special.exp10										
scipy special.exp10	R	scipy.special.exp10										
scipy.special.exp1	A										<section class="prog__container"><p>Exponential integral E_1 of complex argument z</p><pre><code>scipy.special.exp1(z) = <ufunc 'exp1'></code></pre><span class="prog__sub">Examples:</span><pre><code>integral(exp(-z*t)/t, t=1..inf).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.exp1.html
scipy special exp1	R	scipy.special.exp1										
scipy special.exp1	R	scipy.special.exp1										
scipy.special.exp2	A										<section class="prog__container"><p>2**x</p><pre><code>scipy.special.exp2(x) = <ufunc 'exp2'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.exp2.html
scipy special exp2	R	scipy.special.exp2										
scipy special.exp2	R	scipy.special.exp2										
scipy.special.expi	A										<section class="prog__container"><p>Exponential integral Ei</p><pre><code>scipy.special.expi(x) = <ufunc 'expi'></code></pre><span class="prog__sub">Examples:</span><pre><code>integral(exp(t)/t, t=-inf..x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.expi.html
scipy special expi	R	scipy.special.expi										
scipy special.expi	R	scipy.special.expi										
scipy.special.expit	A										<section class="prog__container"><p>Expit ufunc for ndarrays.</p><pre><code>scipy.special.expit(x) = <ufunc 'expit'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    The ndarray to apply expit to element-wise.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    An ndarray of the same shape as x. Its entries are expit of the corresponding entry of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.expit.html
scipy special expit	R	scipy.special.expit										
scipy special.expit	R	scipy.special.expit										
scipy.special.expm1	A										<section class="prog__container"><p>exp(x) - 1 for use when x is near zero.</p><pre><code>scipy.special.expm1(x) = <ufunc 'expm1'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.expm1.html
scipy special expm1	R	scipy.special.expm1										
scipy special.expm1	R	scipy.special.expm1										
scipy.special.expn	A										<section class="prog__container"><p>Exponential integral E_n</p><pre><code>scipy.special.expn(n, x) = <ufunc 'expn'></code></pre><span class="prog__sub">Examples:</span><pre><code>integral(exp(-x*t) / t**n, t=1..inf).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.expn.html
scipy special expn	R	scipy.special.expn										
scipy special.expn	R	scipy.special.expn										
scipy.special.exprel	A					[[scipy.special.expm1]]					<section class="prog__container"><p>Relative error exponential, (exp(x)-1)/x, for use when x is near zero.</p><pre><code>scipy.special.exprel(x) = <ufunc 'exprel'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.exprel.html
scipy special exprel	R	scipy.special.exprel										
scipy special.exprel	R	scipy.special.exprel										
scipy.special.factorial2	A										<section class="prog__container"><p>Double factorial.</p><pre><code>scipy.special.factorial2(n, exact=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like\n    Calculate n!!.  Arrays are only supported with exact set to False.  If n < 0, the return value is 0. \nexact : bool, optional\n    The result can be approximated rapidly using the gamma-formula above (default).  If exact is set to True, calculate the answer exactly using integer arithmetic.</code></pre><span class="prog__sub">Returns:</span><pre><code>nff : float or int\n    Double factorial of n, as an int or a float depending on exact.</code></pre><span class="prog__sub">Examples:</span><pre><code>n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd\n    = 2**(n/2) * (n/2)!                           n even</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.factorial2.html
scipy special factorial2	R	scipy.special.factorial2										
scipy special.factorial2	R	scipy.special.factorial2										
scipy.special.factorial	A										<section class="prog__container"><p>The factorial of a number or array of numbers.</p><pre><code>scipy.special.factorial(n, exact=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int or array_like of ints\n    Input values.  If n < 0, the return value is 0. \nexact : bool, optional\n    If True, calculate the answer exactly using long integer arithmetic. If False, result is approximated in floating point rapidly using the gamma function. Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>nf : float or int or ndarray\n    Factorial of n, as integer or float depending on exact.</code></pre><span class="prog__sub">Examples:</span><pre><code>n! = n * (n - 1) * (n - 2) * ... * 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.factorial.html
scipy.special.factorialk	A										<section class="prog__container"><p>Multifactorial of n of order k, n(!!...!).</p><pre><code>scipy.special.factorialk(n, k, exact=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Calculate multifactorial. If n < 0, the return value is 0. \nk : int\n    Order of multifactorial. \nexact : bool, optional\n    If exact is set to True, calculate the answer exactly using integer arithmetic.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : int\n    Multifactorial of n.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import factorialk\n>>> factorialk(5, 1, exact=True)\n120L\n>>> factorialk(5, 3, exact=True)\n10L</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.factorialk.html
scipy special factorialk	R	scipy.special.factorialk										
scipy special.factorialk	R	scipy.special.factorialk										
scipy special factorial	R	scipy.special.factorial										
scipy special.factorial	R	scipy.special.factorial										
scipy.special.fdtr	A										<section class="prog__container"><p>F cumulative distribution function.</p><pre><code>scipy.special.fdtr(dfn, dfd, x) = <ufunc 'fdtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>dfn : array_like\n    First parameter (positive float). \ndfd : array_like\n    Second parameter (positive float). \nx : array_like\n    Argument (nonnegative float).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The CDF of the F-distribution with parameters dfn and dfd at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.fdtr.html
scipy.special.fdtrc	A					[[scipy.special.fdtr]]					<section class="prog__container"><p>F survival function.</p><pre><code>scipy.special.fdtrc(dfn, dfd, x) = <ufunc 'fdtrc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>dfn : array_like\n    First parameter (positive float). \ndfd : array_like\n    Second parameter (positive float). \nx : array_like\n    Argument (nonnegative float).</code></pre><span class="prog__sub">Returns:</span><pre><code>y : ndarray\n    The complemented F-distribution function with parameters dfn and dfd at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.fdtrc.html
scipy special fdtrc	R	scipy.special.fdtrc										
scipy special.fdtrc	R	scipy.special.fdtrc										
scipy.special.fdtri	A										<section class="prog__container"><p>The p-th quantile of the F-distribution.</p><pre><code>scipy.special.fdtri(dfn, dfd, p) = <ufunc 'fdtri'></code></pre><span class="prog__sub">Parameters:</span><pre><code>dfn : array_like\n    First parameter (positive float). \ndfd : array_like\n    Second parameter (positive float). \np : array_like\n    Cumulative probability, in [0, 1].</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    The quantile corresponding to p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.fdtri.html
scipy.special.fdtridfd	A										<section class="prog__container"><p>Inverse to fdtr vs dfd</p><pre><code>scipy.special.fdtridfd(dfn, p, x) = <ufunc 'fdtridfd'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.fdtridfd.html
scipy special fdtridfd	R	scipy.special.fdtridfd										
scipy special.fdtridfd	R	scipy.special.fdtridfd										
scipy special fdtri	R	scipy.special.fdtri										
scipy special.fdtri	R	scipy.special.fdtri										
scipy special fdtr	R	scipy.special.fdtr										
scipy special.fdtr	R	scipy.special.fdtr										
scipy.special.fresnel	A										<section class="prog__container"><p>Fresnel sin and cos integrals</p><pre><code>scipy.special.fresnel(z) = <ufunc 'fresnel'></code></pre><span class="prog__sub">Parameters:</span><pre><code>z : float or complex array_like\n    Argument</code></pre><span class="prog__sub">Returns:</span><pre><code>ssa, csa\n    Fresnel sin and cos integral values</code></pre><span class="prog__sub">Examples:</span><pre><code>ssa = integral(sin(pi/2 * t**2), t=0..z)\ncsa = integral(cos(pi/2 * t**2), t=0..z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.fresnel.html
scipy.special.fresnelc_zeros	A										<section class="prog__container"><p>Compute nt complex zeros of cosine Fresnel integral C(z).</p><pre><code>scipy.special.fresnelc_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.fresnelc_zeros.html
scipy special fresnelc_zeros	R	scipy.special.fresnelc_zeros										
scipy special.fresnelc_zeros	R	scipy.special.fresnelc_zeros										
scipy special fresnel	R	scipy.special.fresnel										
scipy special.fresnel	R	scipy.special.fresnel										
scipy.special.fresnels_zeros	A										<section class="prog__container"><p>Compute nt complex zeros of sine Fresnel integral S(z).</p><pre><code>scipy.special.fresnels_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.fresnels_zeros.html
scipy special fresnels_zeros	R	scipy.special.fresnels_zeros										
scipy special.fresnels_zeros	R	scipy.special.fresnels_zeros										
scipy.special.fresnel_zeros	A										<section class="prog__container"><p>Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).</p><pre><code>scipy.special.fresnel_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.fresnel_zeros.html
scipy special fresnel_zeros	R	scipy.special.fresnel_zeros										
scipy special.fresnel_zeros	R	scipy.special.fresnel_zeros										
scipy.special.gamma	A										<section class="prog__container"><p>Gamma function.</p><pre><code>scipy.special.gamma(z) = <ufunc 'gamma'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gamma.html
scipy.special.gammainc	A										<section class="prog__container"><p>Incomplete gamma function</p><pre><code>scipy.special.gammainc(a, x) = <ufunc 'gammainc'></code></pre><span class="prog__sub">Examples:</span><pre><code>1 / gamma(a) * integral(exp(-t) * t**(a-1), t=0..x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gammainc.html
scipy.special.gammaincc	A										<section class="prog__container"><p>Complemented incomplete gamma integral</p><pre><code>scipy.special.gammaincc(a, x) = <ufunc 'gammaincc'></code></pre><span class="prog__sub">Examples:</span><pre><code>1 / gamma(a) * integral(exp(-t) * t**(a-1), t=x..inf) = 1 - gammainc(a, x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gammaincc.html
scipy.special.gammainccinv	A										<section class="prog__container"><p>Inverse to gammaincc</p><pre><code>scipy.special.gammainccinv(a, y) = <ufunc 'gammainccinv'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gammainccinv.html
scipy special gammainccinv	R	scipy.special.gammainccinv										
scipy special.gammainccinv	R	scipy.special.gammainccinv										
scipy special gammaincc	R	scipy.special.gammaincc										
scipy special.gammaincc	R	scipy.special.gammaincc										
scipy.special.gammaincinv	A										<section class="prog__container"><p>Inverse to gammainc</p><pre><code>scipy.special.gammaincinv(a, y) = <ufunc 'gammaincinv'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gammaincinv.html
scipy special gammaincinv	R	scipy.special.gammaincinv										
scipy special.gammaincinv	R	scipy.special.gammaincinv										
scipy special gammainc	R	scipy.special.gammainc										
scipy special.gammainc	R	scipy.special.gammainc										
scipy.special.gammaln	A										<section class="prog__container"><p>Logarithm of the absolute value of the Gamma function for real inputs.</p><pre><code>scipy.special.gammaln(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array-like\n    Values on the real line at which to compute gammaln</code></pre><span class="prog__sub">Returns:</span><pre><code>gammaln : ndarray\n    Values of gammaln at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gammaln.html
scipy special gammaln	R	scipy.special.gammaln										
scipy special.gammaln	R	scipy.special.gammaln										
scipy special gamma	R	scipy.special.gamma										
scipy special.gamma	R	scipy.special.gamma										
scipy.special.gammasgn	A					[[scipy.special.gammaln]]\\n[[scipy.special.loggamma]]					<section class="prog__container"><p>Sign of the gamma function.</p><pre><code>scipy.special.gammasgn(x) = <ufunc 'gammasgn'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gammasgn.html
scipy special gammasgn	R	scipy.special.gammasgn										
scipy special.gammasgn	R	scipy.special.gammasgn										
scipy.special.gdtr	A										<section class="prog__container"><p>Gamma distribution cumulative density function.</p><pre><code>scipy.special.gdtr(a, b, x) = <ufunc 'gdtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The rate parameter of the gamma distribution, sometimes denoted \(\beta\) (float).  It is also the reciprocal of the scale parameter \(\theta\). \nb : array_like\n    The shape parameter of the gamma distribution, sometimes denoted \(\alpha\) (float). \nx : array_like\n    The quantile (upper limit of integration; float).</code></pre><span class="prog__sub">Returns:</span><pre><code>F : ndarray\n    The CDF of the gamma distribution with parameters a and b evaluated at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gdtr.html
scipy.special.gdtrc	A					[[scipy.special.gdtr]]					<section class="prog__container"><p>Gamma distribution survival function.</p><pre><code>scipy.special.gdtrc(a, b, x) = <ufunc 'gdtrc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The rate parameter of the gamma distribution, sometimes denoted \(\beta\) (float).  It is also the reciprocal of the scale parameter \(\theta\). \nb : array_like\n    The shape parameter of the gamma distribution, sometimes denoted \(\alpha\) (float). \nx : array_like\n    The quantile (lower limit of integration; float).</code></pre><span class="prog__sub">Returns:</span><pre><code>F : ndarray\n    The survival function of the gamma distribution with parameters a and b evaluated at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gdtrc.html
scipy special gdtrc	R	scipy.special.gdtrc										
scipy special.gdtrc	R	scipy.special.gdtrc										
scipy.special.gdtria	A										<section class="prog__container"><p>Inverse of gdtr vs a.</p><pre><code>scipy.special.gdtria(p, b, x, out=None) = <ufunc 'gdtria'></code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    Probability values. \nb : array_like\n    b parameter values of gdtr(a, b, x).  b is the “shape” parameter of the gamma distribution. \nx : array_like\n    Nonnegative real values, from the domain of the gamma distribution. \nout : ndarray, optional\n    If a fourth argument is given, it must be a numpy.ndarray whose size matches the broadcast result of a, b and x.  out is then the array returned by the function.</code></pre><span class="prog__sub">Returns:</span><pre><code>a : ndarray\n    Values of the a parameter such that p = gdtr(a, b, x).  1/a is the “scale” parameter of the gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import gdtr, gdtria\n>>> p = gdtr(1.2, 3.4, 5.6)\n>>> print(p)\n0.94378087442</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gdtria.html
scipy special gdtria	R	scipy.special.gdtria										
scipy special.gdtria	R	scipy.special.gdtria										
scipy.special.gdtrib	A										<section class="prog__container"><p>Inverse of gdtr vs b.</p><pre><code>scipy.special.gdtrib(a, p, x, out=None) = <ufunc 'gdtrib'></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    a parameter values of gdtr(a, b, x). 1/a is the “scale” parameter of the gamma distribution. \np : array_like\n    Probability values. \nx : array_like\n    Nonnegative real values, from the domain of the gamma distribution. \nout : ndarray, optional\n    If a fourth argument is given, it must be a numpy.ndarray whose size matches the broadcast result of a, b and x.  out is then the array returned by the function.</code></pre><span class="prog__sub">Returns:</span><pre><code>b : ndarray\n    Values of the b parameter such that p = gdtr(a, b, x).  b is the “shape” parameter of the gamma distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import gdtr, gdtrib\n>>> p = gdtr(1.2, 3.4, 5.6)\n>>> print(p)\n0.94378087442</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gdtrib.html
scipy special gdtrib	R	scipy.special.gdtrib										
scipy special.gdtrib	R	scipy.special.gdtrib										
scipy.special.gdtrix	A										<section class="prog__container"><p>Inverse of gdtr vs x.</p><pre><code>scipy.special.gdtrix(a, b, p, out=None) = <ufunc 'gdtrix'></code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    a parameter values of gdtr(a, b, x).  1/a is the “scale” parameter of the gamma distribution. \nb : array_like\n    b parameter values of gdtr(a, b, x).  b is the “shape” parameter of the gamma distribution. \np : array_like\n    Probability values. \nout : ndarray, optional\n    If a fourth argument is given, it must be a numpy.ndarray whose size matches the broadcast result of a, b and x.  out is then the array returned by the function.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Values of the x parameter such that p = gdtr(a, b, x).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import gdtr, gdtrix\n>>> p = gdtr(1.2, 3.4, 5.6)\n>>> print(p)\n0.94378087442</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gdtrix.html
scipy special gdtrix	R	scipy.special.gdtrix										
scipy special.gdtrix	R	scipy.special.gdtrix										
scipy special gdtr	R	scipy.special.gdtr										
scipy special.gdtr	R	scipy.special.gdtr										
scipy.special.gegenbauer	A										<section class="prog__container"><p>Return the nth order Gegenbauer (ultraspherical) polynomial,\nC^(alpha)_n(x), orthogonal over [-1,1] with weighting function\n(1-x**2)**(alpha-1/2) with alpha > -1/2</p><pre><code>scipy.special.gegenbauer(n, alpha, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.gegenbauer.html
scipy special gegenbauer	R	scipy.special.gegenbauer										
scipy special.gegenbauer	R	scipy.special.gegenbauer										
scipy.special.genlaguerre	A										<section class="prog__container"><p>Returns the nth order generalized (associated) Laguerre polynomial,\nL^(alpha)_n(x), orthogonal over [0,inf) with weighting function\nexp(-x) x**alpha with alpha > -1</p><pre><code>scipy.special.genlaguerre(n, alpha, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.genlaguerre.html
scipy special genlaguerre	R	scipy.special.genlaguerre										
scipy special.genlaguerre	R	scipy.special.genlaguerre										
scipy.special.h1vp	A										<section class="prog__container"><p>Compute nth derivative of Hankel function H1v(z) with respect to z.</p><pre><code>scipy.special.h1vp(v, z, n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : float\n    Order of Hankel function \nz : complex\n    Argument at which to evaluate the derivative \nn : int, default 1\n    Order of derivative</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.h1vp.html
scipy special h1vp	R	scipy.special.h1vp										
scipy special.h1vp	R	scipy.special.h1vp										
scipy.special.h2vp	A										<section class="prog__container"><p>Compute nth derivative of Hankel function H2v(z) with respect to z.</p><pre><code>scipy.special.h2vp(v, z, n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : float\n    Order of Hankel function \nz : complex\n    Argument at which to evaluate the derivative \nn : int, default 1\n    Order of derivative</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.h2vp.html
scipy special h2vp	R	scipy.special.h2vp										
scipy special.h2vp	R	scipy.special.h2vp										
scipy.special.hankel1	A										<section class="prog__container"><p>Hankel function of the first kind</p><pre><code>scipy.special.hankel1(v, z) = <ufunc 'hankel1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : Values of the Hankel function of the first kind.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hankel1.html
scipy.special.hankel1e	A										<section class="prog__container"><p>Exponentially scaled Hankel function of the first kind</p><pre><code>scipy.special.hankel1e(v, z) = <ufunc 'hankel1e'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : Values of the exponentially scaled Hankel function.</code></pre><span class="prog__sub">Examples:</span><pre><code>hankel1e(v, z) = hankel1(v, z) * exp(-1j * z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hankel1e.html
scipy special hankel1e	R	scipy.special.hankel1e										
scipy special.hankel1e	R	scipy.special.hankel1e										
scipy special hankel1	R	scipy.special.hankel1										
scipy special.hankel1	R	scipy.special.hankel1										
scipy.special.hankel2	A										<section class="prog__container"><p>Hankel function of the second kind</p><pre><code>scipy.special.hankel2(v, z) = <ufunc 'hankel2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : Values of the Hankel function of the second kind.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hankel2.html
scipy.special.hankel2e	A										<section class="prog__container"><p>Exponentially scaled Hankel function of the second kind</p><pre><code>scipy.special.hankel2e(v, z) = <ufunc 'hankel2e'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : Values of the exponentially scaled Hankel function of the second kind.</code></pre><span class="prog__sub">Examples:</span><pre><code>hankel2e(v, z) = hankel2(v, z) * exp(1j * z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hankel2e.html
scipy special hankel2e	R	scipy.special.hankel2e										
scipy special.hankel2e	R	scipy.special.hankel2e										
scipy special hankel2	R	scipy.special.hankel2										
scipy special.hankel2	R	scipy.special.hankel2										
scipy.special.hermite	A										<section class="prog__container"><p>Return the nth order Hermite polynomial, H_n(x), orthogonal over\n(-inf,inf) with weighting function exp(-x**2)</p><pre><code>scipy.special.hermite(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hermite.html
scipy.special.hermitenorm	A										<section class="prog__container"><p>Return the nth order normalized Hermite polynomial, He_n(x), orthogonal\nover (-inf,inf) with weighting function exp(-(x/2)**2)</p><pre><code>scipy.special.hermitenorm(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hermitenorm.html
scipy special hermitenorm	R	scipy.special.hermitenorm										
scipy special.hermitenorm	R	scipy.special.hermitenorm										
scipy special hermite	R	scipy.special.hermite										
scipy special.hermite	R	scipy.special.hermite										
scipy.special.he_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]\\n[[(in NumPy v1.11)]]					<section class="prog__container"><p>Gauss-Hermite (statistician’s) quadrature.</p><pre><code>scipy.special.he_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.he_roots.html
scipy special he_roots	R	scipy.special.he_roots										
scipy special.he_roots	R	scipy.special.he_roots										
scipy.special.h_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]\\n[[(in NumPy v1.11)]]\\n[[scipy.special.he_roots]]					<section class="prog__container"><p>Gauss-Hermite (physicst’s) quadrature.</p><pre><code>scipy.special.h_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.h_roots.html
scipy special h_roots	R	scipy.special.h_roots										
scipy special.h_roots	R	scipy.special.h_roots										
scipy.special.huber	A										<section class="prog__container"><p>Huber loss function.</p><pre><code>scipy.special.huber(delta, r) = <ufunc 'huber'></code></pre><span class="prog__sub">Parameters:</span><pre><code>delta : ndarray\n    Input array, indicating the quadratic vs. linear loss changepoint. \nr : ndarray\n    Input array, possibly representing residuals.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    The computed Huber loss function values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.huber.html
scipy special huber	R	scipy.special.huber										
scipy special.huber	R	scipy.special.huber										
scipy.special.hyp0f1	A										<section class="prog__container"><p>Confluent hypergeometric limit function 0F1.</p><pre><code>scipy.special.hyp0f1(v, x) = <ufunc 'hyp0f1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v, z : array_like\n    Input values.</code></pre><span class="prog__sub">Returns:</span><pre><code>hyp0f1 : ndarray\n    The confluent hypergeometric limit function.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hyp0f1.html
scipy special hyp0f1	R	scipy.special.hyp0f1										
scipy special.hyp0f1	R	scipy.special.hyp0f1										
scipy.special.hyp1f1	A										<section class="prog__container"><p>Confluent hypergeometric function 1F1(a, b; x)</p><pre><code>scipy.special.hyp1f1(a, b, x) = <ufunc 'hyp1f1'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hyp1f1.html
scipy special hyp1f1	R	scipy.special.hyp1f1										
scipy special.hyp1f1	R	scipy.special.hyp1f1										
scipy.special.hyp1f2	A										<section class="prog__container"><p>Hypergeometric function 1F2 and error estimate</p><pre><code>scipy.special.hyp1f2(a, b, c, x) = <ufunc 'hyp1f2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y\n    Value of the function \nerr\n    Error estimate</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hyp1f2.html
scipy special hyp1f2	R	scipy.special.hyp1f2										
scipy special.hyp1f2	R	scipy.special.hyp1f2										
scipy.special.hyp2f0	A										<section class="prog__container"><p>Hypergeometric function 2F0 in y and an error estimate</p><pre><code>scipy.special.hyp2f0(a, b, x, type) = <ufunc 'hyp2f0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y\n    Value of the function \nerr\n    Error estimate</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hyp2f0.html
scipy special hyp2f0	R	scipy.special.hyp2f0										
scipy special.hyp2f0	R	scipy.special.hyp2f0										
scipy.special.hyp2f1	A										<section class="prog__container"><p>Gauss hypergeometric function 2F1(a, b; c; z).</p><pre><code>scipy.special.hyp2f1(a, b, c, z) = <ufunc 'hyp2f1'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hyp2f1.html
scipy special hyp2f1	R	scipy.special.hyp2f1										
scipy special.hyp2f1	R	scipy.special.hyp2f1										
scipy.special.hyp3f0	A										<section class="prog__container"><p>Hypergeometric function 3F0 in y and an error estimate</p><pre><code>scipy.special.hyp3f0(a, b, c, x) = <ufunc 'hyp3f0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y\n    Value of the function \nerr\n    Error estimate</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hyp3f0.html
scipy special hyp3f0	R	scipy.special.hyp3f0										
scipy special.hyp3f0	R	scipy.special.hyp3f0										
scipy.special.hyperu	A										<section class="prog__container"><p>Confluent hypergeometric function U(a, b, x) of the second kind</p><pre><code>scipy.special.hyperu(a, b, x) = <ufunc 'hyperu'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.hyperu.html
scipy special hyperu	R	scipy.special.hyperu										
scipy special.hyperu	R	scipy.special.hyperu										
scipy.special.i0	A					[[scipy.special.iv]]\\n[[scipy.special.i0e]]					<section class="prog__container"><p>Modified Bessel function of order 0.</p><pre><code>scipy.special.i0(x) = <ufunc 'i0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float)</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray\n    Value of the modified Bessel function of order 0 at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.i0.html
scipy.special.i0e	A					[[scipy.special.iv]]\\n[[scipy.special.i0]]					<section class="prog__container"><p>Exponentially scaled modified Bessel function of order 0.</p><pre><code>scipy.special.i0e(x) = <ufunc 'i0e'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float)</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray\n    Value of the exponentially scaled modified Bessel function of order 0 at x.</code></pre><span class="prog__sub">Examples:</span><pre><code>i0e(x) = exp(-abs(x)) * i0(x).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.i0e.html
scipy special i0e	R	scipy.special.i0e										
scipy special.i0e	R	scipy.special.i0e										
scipy special i0	R	scipy.special.i0										
scipy special.i0	R	scipy.special.i0										
scipy.special.i1	A					[[scipy.special.iv]]\\n[[scipy.special.i1e]]					<section class="prog__container"><p>Modified Bessel function of order 1.</p><pre><code>scipy.special.i1(x) = <ufunc 'i1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float)</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray\n    Value of the modified Bessel function of order 1 at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.i1.html
scipy.special.i1e	A					[[scipy.special.iv]]\\n[[scipy.special.i1]]					<section class="prog__container"><p>Exponentially scaled modified Bessel function of order 1.</p><pre><code>scipy.special.i1e(x) = <ufunc 'i1e'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float)</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray\n    Value of the exponentially scaled modified Bessel function of order 1 at x.</code></pre><span class="prog__sub">Examples:</span><pre><code>i1e(x) = exp(-abs(x)) * i1(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.i1e.html
scipy special i1e	R	scipy.special.i1e										
scipy special.i1e	R	scipy.special.i1e										
scipy special i1	R	scipy.special.i1										
scipy special.i1	R	scipy.special.i1										
scipy.special.inv_boxcox1p	A										<section class="prog__container"><p>Compute the inverse of the Box-Cox transformation.</p><pre><code>scipy.special.inv_boxcox1p(y, lmbda) = <ufunc 'inv_boxcox1p'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Data to be transformed. \nlmbda : array_like\n    Power parameter of the Box-Cox transform.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array\n    Transformed data.</code></pre><span class="prog__sub">Examples:</span><pre><code>y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n    log(1+x)                    if lmbda == 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.inv_boxcox1p.html
scipy special inv_boxcox1p	R	scipy.special.inv_boxcox1p										
scipy special.inv_boxcox1p	R	scipy.special.inv_boxcox1p										
scipy.special.inv_boxcox	A										<section class="prog__container"><p>Compute the inverse of the Box-Cox transformation.</p><pre><code>scipy.special.inv_boxcox(y, lmbda) = <ufunc 'inv_boxcox'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Data to be transformed. \nlmbda : array_like\n    Power parameter of the Box-Cox transform.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array\n    Transformed data.</code></pre><span class="prog__sub">Examples:</span><pre><code>y = (x**lmbda - 1) / lmbda  if lmbda != 0\n    log(x)                  if lmbda == 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.inv_boxcox.html
scipy special inv_boxcox	R	scipy.special.inv_boxcox										
scipy special.inv_boxcox	R	scipy.special.inv_boxcox										
scipy.special.it2i0k0	A										<section class="prog__container"><p>Integrals related to modified Bessel functions of order 0</p><pre><code>scipy.special.it2i0k0(x) = <ufunc 'it2i0k0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>ii0\n    integral((i0(t)-1)/t, t=0..x) \nik0\n    int(k0(t)/t, t=x..inf)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.it2i0k0.html
scipy special it2i0k0	R	scipy.special.it2i0k0										
scipy special.it2i0k0	R	scipy.special.it2i0k0										
scipy.special.it2j0y0	A										<section class="prog__container"><p>Integrals related to Bessel functions of order 0</p><pre><code>scipy.special.it2j0y0(x) = <ufunc 'it2j0y0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>ij0\n    integral((1-j0(t))/t, t=0..x) \niy0\n    integral(y0(t)/t, t=x..inf)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.it2j0y0.html
scipy special it2j0y0	R	scipy.special.it2j0y0										
scipy special.it2j0y0	R	scipy.special.it2j0y0										
scipy.special.it2struve0	A					[[scipy.special.struve]]					<section class="prog__container"><p>Integral related to the Struve function of order 0.</p><pre><code>scipy.special.it2struve0(x) = <ufunc 'it2struve0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Lower limit of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray\n    The value of the integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.it2struve0.html
scipy special it2struve0	R	scipy.special.it2struve0										
scipy special.it2struve0	R	scipy.special.it2struve0										
scipy.special.itairy	A										<section class="prog__container"><p>Integrals of Airy functions</p><pre><code>scipy.special.itairy(x) = <ufunc 'itairy'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x: array_like\n    Upper limit of integration (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>Apt\n    Integral of Ai(t) from 0 to x. \nBpt\n    Integral of Bi(t) from 0 to x. \nAnt\n    Integral of Ai(-t) from 0 to x. \nBnt\n    Integral of Bi(-t) from 0 to x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.itairy.html
scipy special itairy	R	scipy.special.itairy										
scipy special.itairy	R	scipy.special.itairy										
scipy.special.iti0k0	A										<section class="prog__container"><p>Integrals of modified Bessel functions of order 0</p><pre><code>scipy.special.iti0k0(x) = <ufunc 'iti0k0'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.iti0k0.html
scipy special iti0k0	R	scipy.special.iti0k0										
scipy special.iti0k0	R	scipy.special.iti0k0										
scipy.special.itj0y0	A										<section class="prog__container"><p>Integrals of Bessel functions of order 0</p><pre><code>scipy.special.itj0y0(x) = <ufunc 'itj0y0'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.itj0y0.html
scipy special itj0y0	R	scipy.special.itj0y0										
scipy special.itj0y0	R	scipy.special.itj0y0										
scipy.special.itmodstruve0	A										<section class="prog__container"><p>Integral of the modified Struve function of order 0.</p><pre><code>scipy.special.itmodstruve0(x) = <ufunc 'itmodstruve0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Upper limit of integration (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray\n    The integral of \(L_0\) from 0 to x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.itmodstruve0.html
scipy special itmodstruve0	R	scipy.special.itmodstruve0										
scipy special.itmodstruve0	R	scipy.special.itmodstruve0										
scipy.special.itstruve0	A					[[scipy.special.struve]]					<section class="prog__container"><p>Integral of the Struve function of order 0.</p><pre><code>scipy.special.itstruve0(x) = <ufunc 'itstruve0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Upper limit of integration (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>I : ndarray\n    The integral of \(H_0\) from 0 to x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.itstruve0.html
scipy special itstruve0	R	scipy.special.itstruve0										
scipy special.itstruve0	R	scipy.special.itstruve0										
scipy.special.iv	A										<section class="prog__container"><p>Modified Bessel function of the first kind of real order.</p><pre><code>scipy.special.iv(v, z) = <ufunc 'iv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order. If z is of real type and negative, v must be integer valued. \nz : array_like of float or complex\n    Argument.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Values of the modified Bessel function.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.iv.html
scipy.special.ive	A										<section class="prog__container"><p>Exponentially scaled modified Bessel function of the first kind</p><pre><code>scipy.special.ive(v, z) = <ufunc 'ive'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like of float\n    Order. \nz : array_like of float or complex\n    Argument.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Values of the exponentially scaled modified Bessel function.</code></pre><span class="prog__sub">Examples:</span><pre><code>ive(v, z) = iv(v, z) * exp(-abs(z.real))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ive.html
scipy special ive	R	scipy.special.ive										
scipy special.ive	R	scipy.special.ive										
scipy.special.ivp	A										<section class="prog__container"><p>Compute nth derivative of modified Bessel function Iv(z) with respect\nto z.</p><pre><code>scipy.special.ivp(v, z, n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like of float\n    Order of Bessel function \nz : array_like of complex\n    Argument at which to evaluate the derivative \nn : int, default 1\n    Order of derivative</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ivp.html
scipy special ivp	R	scipy.special.ivp										
scipy special.ivp	R	scipy.special.ivp										
scipy special iv	R	scipy.special.iv										
scipy special.iv	R	scipy.special.iv										
scipy.special.j0	A										<section class="prog__container"><p>Bessel function of the first kind of order 0.</p><pre><code>scipy.special.j0(x) = <ufunc 'j0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>J : ndarray\n    Value of the Bessel function of the first kind of order 0 at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.j0.html
scipy special j0	R	scipy.special.j0										
scipy special.j0	R	scipy.special.j0										
scipy.special.j1	A					[[scipy.special.jv]]					<section class="prog__container"><p>Bessel function of the first kind of order 1.</p><pre><code>scipy.special.j1(x) = <ufunc 'j1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>J : ndarray\n    Value of the Bessel function of the first kind of order 1 at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.j1.html
scipy special j1	R	scipy.special.j1										
scipy special.j1	R	scipy.special.j1										
scipy.special.jacobi	A										<section class="prog__container"><p>Returns the nth order Jacobi polynomial, P^(alpha,beta)_n(x)\northogonal over [-1,1] with weighting function\n(1-x)**alpha (1+x)**beta with alpha,beta > -1.</p><pre><code>scipy.special.jacobi(n, alpha, beta, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jacobi.html
scipy special jacobi	R	scipy.special.jacobi										
scipy special.jacobi	R	scipy.special.jacobi										
scipy.special.jn	A										<section class="prog__container"><p>Bessel function of the first kind of real order and complex argument.</p><pre><code>scipy.special.jn(v, z) = <ufunc 'jv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>J : ndarray\n    Value of the Bessel function, \(J_v(z)\).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jn.html
scipy.special.jnjnp_zeros	A					[[scipy.special.jn_zeros]]\\n[[scipy.special.jnp_zeros]]					<section class="prog__container"><p>Compute zeros of integer-order Bessel functions Jn and Jn’.</p><pre><code>scipy.special.jnjnp_zeros(nt)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nt : int\n    Number (<=1200) of zeros to compute</code></pre><span class="prog__sub">Returns:</span><pre><code>zo[l-1] : ndarray\n    Value of the lth zero of Jn(x) and Jn’(x). Of length nt. \nn[l-1] : ndarray\n    Order of the Jn(x) or Jn’(x) associated with lth zero. Of length nt. \nm[l-1] : ndarray\n    Serial number of the zeros of Jn(x) or Jn’(x) associated with lth zero. Of length nt. \nt[l-1] : ndarray\n    0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn’(x). Of length nt.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jnjnp_zeros.html
scipy special jnjnp_zeros	R	scipy.special.jnjnp_zeros										
scipy special.jnjnp_zeros	R	scipy.special.jnjnp_zeros										
scipy.special.jnp_zeros	A										<section class="prog__container"><p>Compute zeros of integer-order Bessel function derivative Jn’(x).</p><pre><code>scipy.special.jnp_zeros(n, nt)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Order of Bessel function \nnt : int\n    Number of zeros to return</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jnp_zeros.html
scipy special jnp_zeros	R	scipy.special.jnp_zeros										
scipy special.jnp_zeros	R	scipy.special.jnp_zeros										
scipy special jn	R	scipy.special.jn										
scipy special.jn	R	scipy.special.jn										
scipy.special.jnyn_zeros	A										<section class="prog__container"><p>Compute nt zeros of Bessel functions Jn(x), Jn’(x), Yn(x), and Yn’(x).</p><pre><code>scipy.special.jnyn_zeros(n, nt)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Order of the Bessel functions \nnt : int\n    Number (<=1200) of zeros to compute \nSee jn_zeros, jnp_zeros, yn_zeros, ynp_zeros to get separate arrays.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jnyn_zeros.html
scipy special jnyn_zeros	R	scipy.special.jnyn_zeros										
scipy special.jnyn_zeros	R	scipy.special.jnyn_zeros										
scipy.special.jn_zeros	A										<section class="prog__container"><p>Compute zeros of integer-order Bessel function Jn(x).</p><pre><code>scipy.special.jn_zeros(n, nt)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Order of Bessel function \nnt : int\n    Number of zeros to return</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jn_zeros.html
scipy special jn_zeros	R	scipy.special.jn_zeros										
scipy special.jn_zeros	R	scipy.special.jn_zeros										
scipy.special.j_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Jacobi quadrature.</p><pre><code>scipy.special.j_roots(n, alpha, beta, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nalpha : float\n    alpha must be > -1 \nbeta : float\n    beta must be > 0 \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.j_roots.html
scipy special j_roots	R	scipy.special.j_roots										
scipy special.j_roots	R	scipy.special.j_roots										
scipy.special.js_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Jacobi (shifted) quadrature.</p><pre><code>scipy.special.js_roots(n, p1, q1, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \np1 : float\n    (p1 - q1) must be > -1 \nq1 : float\n    q1 must be > 0 \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.js_roots.html
scipy special js_roots	R	scipy.special.js_roots										
scipy special.js_roots	R	scipy.special.js_roots										
scipy.special.jv	A										<section class="prog__container"><p>Bessel function of the first kind of real order and complex argument.</p><pre><code>scipy.special.jv(v, z) = <ufunc 'jv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>J : ndarray\n    Value of the Bessel function, \(J_v(z)\).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jv.html
scipy.special.jve	A										<section class="prog__container"><p>Exponentially scaled Bessel function of order v.</p><pre><code>scipy.special.jve(v, z) = <ufunc 'jve'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>J : ndarray\n    Value of the exponentially scaled Bessel function.</code></pre><span class="prog__sub">Examples:</span><pre><code>jve(v, z) = jv(v, z) * exp(-abs(z.imag))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jve.html
scipy special jve	R	scipy.special.jve										
scipy special.jve	R	scipy.special.jve										
scipy.special.jvp	A										<section class="prog__container"><p>Compute nth derivative of Bessel function Jv(z) with respect to z.</p><pre><code>scipy.special.jvp(v, z, n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : float\n    Order of Bessel function \nz : complex\n    Argument at which to evaluate the derivative \nn : int, default 1\n    Order of derivative</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jvp.html
scipy special jvp	R	scipy.special.jvp										
scipy special.jvp	R	scipy.special.jvp										
scipy special jv	R	scipy.special.jv										
scipy special.jv	R	scipy.special.jv										
scipy.special.k0	A					[[scipy.special.kv]]\\n[[scipy.special.k0e]]					<section class="prog__container"><p>Modified Bessel function of the second kind of order 0, \(K_0\).</p><pre><code>scipy.special.k0(x) = <ufunc 'k0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>K : ndarray\n    Value of the modified Bessel function \(K_0\) at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.k0.html
scipy.special.k0e	A					[[scipy.special.kv]]\\n[[scipy.special.k0]]					<section class="prog__container"><p>Exponentially scaled modified Bessel function K of order 0</p><pre><code>scipy.special.k0e(x) = <ufunc 'k0e'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float)</code></pre><span class="prog__sub">Returns:</span><pre><code>K : ndarray\n    Value of the exponentially scaled modified Bessel function K of order 0 at x.</code></pre><span class="prog__sub">Examples:</span><pre><code>k0e(x) = exp(x) * k0(x).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.k0e.html
scipy special k0e	R	scipy.special.k0e										
scipy special.k0e	R	scipy.special.k0e										
scipy special k0	R	scipy.special.k0										
scipy special.k0	R	scipy.special.k0										
scipy.special.k1	A					[[scipy.special.kv]]\\n[[scipy.special.k1e]]					<section class="prog__container"><p>Modified Bessel function of the second kind of order 1, \(K_1(x)\).</p><pre><code>scipy.special.k1(x) = <ufunc 'k1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float)</code></pre><span class="prog__sub">Returns:</span><pre><code>K : ndarray\n    Value of the modified Bessel function K of order 1 at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.k1.html
scipy.special.k1e	A					[[scipy.special.kv]]\\n[[scipy.special.k1]]					<section class="prog__container"><p>Exponentially scaled modified Bessel function K of order 1</p><pre><code>scipy.special.k1e(x) = <ufunc 'k1e'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float)</code></pre><span class="prog__sub">Returns:</span><pre><code>K : ndarray\n    Value of the exponentially scaled modified Bessel function K of order 1 at x.</code></pre><span class="prog__sub">Examples:</span><pre><code>k1e(x) = exp(x) * k1(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.k1e.html
scipy special k1e	R	scipy.special.k1e										
scipy special.k1e	R	scipy.special.k1e										
scipy special k1	R	scipy.special.k1										
scipy special.k1	R	scipy.special.k1										
scipy.special.kei	A										<section class="prog__container"><p>Kelvin function ker</p><pre><code>scipy.special.kei(x) = <ufunc 'kei'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kei.html
scipy.special.keip	A										<section class="prog__container"><p>Derivative of the Kelvin function kei</p><pre><code>scipy.special.keip(x) = <ufunc 'keip'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.keip.html
scipy special keip	R	scipy.special.keip										
scipy special.keip	R	scipy.special.keip										
scipy.special.keip_zeros	A										<section class="prog__container"><p>Compute nt zeros of the Kelvin function kei’(x).</p><pre><code>scipy.special.keip_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.keip_zeros.html
scipy special keip_zeros	R	scipy.special.keip_zeros										
scipy special.keip_zeros	R	scipy.special.keip_zeros										
scipy special kei	R	scipy.special.kei										
scipy special.kei	R	scipy.special.kei										
scipy.special.kei_zeros	A										<section class="prog__container"><p>Compute nt zeros of the Kelvin function kei(x).</p><pre><code>scipy.special.kei_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kei_zeros.html
scipy special kei_zeros	R	scipy.special.kei_zeros										
scipy special.kei_zeros	R	scipy.special.kei_zeros										
scipy.special.kelvin	A										<section class="prog__container"><p>Kelvin functions as complex numbers</p><pre><code>scipy.special.kelvin(x) = <ufunc 'kelvin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>Be, Ke, Bep, Kep\n    The tuple (Be, Ke, Bep, Kep) contains complex numbers representing the real and imaginary Kelvin functions and their derivatives evaluated at x.  For example, kelvin(x)[0].real = ber x and kelvin(x)[0].imag = bei x with similar relationships for ker and kei.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kelvin.html
scipy special kelvin	R	scipy.special.kelvin										
scipy special.kelvin	R	scipy.special.kelvin										
scipy.special.kelvin_zeros	A										<section class="prog__container"><p>Compute nt zeros of all Kelvin functions.</p><pre><code>scipy.special.kelvin_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kelvin_zeros.html
scipy special kelvin_zeros	R	scipy.special.kelvin_zeros										
scipy special.kelvin_zeros	R	scipy.special.kelvin_zeros										
scipy.special.ker	A										<section class="prog__container"><p>Kelvin function ker</p><pre><code>scipy.special.ker(x) = <ufunc 'ker'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ker.html
scipy.special.kerp	A										<section class="prog__container"><p>Derivative of the Kelvin function ker</p><pre><code>scipy.special.kerp(x) = <ufunc 'kerp'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kerp.html
scipy special kerp	R	scipy.special.kerp										
scipy special.kerp	R	scipy.special.kerp										
scipy.special.kerp_zeros	A										<section class="prog__container"><p>Compute nt zeros of the Kelvin function ker’(x).</p><pre><code>scipy.special.kerp_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kerp_zeros.html
scipy special kerp_zeros	R	scipy.special.kerp_zeros										
scipy special.kerp_zeros	R	scipy.special.kerp_zeros										
scipy special ker	R	scipy.special.ker										
scipy special.ker	R	scipy.special.ker										
scipy.special.ker_zeros	A										<section class="prog__container"><p>Compute nt zeros of the Kelvin function ker(x).</p><pre><code>scipy.special.ker_zeros(nt)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ker_zeros.html
scipy special ker_zeros	R	scipy.special.ker_zeros										
scipy special.ker_zeros	R	scipy.special.ker_zeros										
scipy.special.kl_div	A					[[scipy.special.entr]]\\n[[scipy.special.rel_entr]]					<section class="prog__container"><p>Elementwise function for computing Kullback-Leibler divergence.</p><pre><code>scipy.special.kl_div(x, y) = <ufunc 'kl_div'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    First input array. \ny : ndarray\n    Second input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kl_div.html
scipy special kl_div	R	scipy.special.kl_div										
scipy special.kl_div	R	scipy.special.kl_div										
scipy.special.kn	A										<section class="prog__container"><p>Modified Bessel function of the second kind of integer order n</p><pre><code>scipy.special.kn(n, x) = <ufunc 'kn'></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : array_like of int\n    Order of Bessel functions (floats will truncate with a warning) \nz : array_like of float\n    Argument at which to evaluate the Bessel functions</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The results</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import kn\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(0, 5, 1000)\n>>> for N in range(6):\n...     plt.plot(x, kn(N, x), label='$K_{}(x)$'.format(N))\n>>> plt.ylim(0, 10)\n>>> plt.legend()\n>>> plt.title(r'Modified Bessel function of the second kind $K_n(x)$')\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kn.html
scipy special kn	R	scipy.special.kn										
scipy special.kn	R	scipy.special.kn										
scipy.special.kolmogi	A										<section class="prog__container"><p>Inverse function to kolmogorov</p><pre><code>scipy.special.kolmogi(p) = <ufunc 'kolmogi'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kolmogi.html
scipy special kolmogi	R	scipy.special.kolmogi										
scipy special.kolmogi	R	scipy.special.kolmogi										
scipy.special.kolmogorov	A										<section class="prog__container"><p>Complementary cumulative distribution function of Kolmogorov distribution</p><pre><code>scipy.special.kolmogorov(y) = <ufunc 'kolmogorov'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kolmogorov.html
scipy special kolmogorov	R	scipy.special.kolmogorov										
scipy special.kolmogorov	R	scipy.special.kolmogorov										
scipy.special.kv	A										<section class="prog__container"><p>Modified Bessel function of the second kind of real order v</p><pre><code>scipy.special.kv(v, z) = <ufunc 'kv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like of float\n    Order of Bessel functions \nz : array_like of complex\n    Argument at which to evaluate the Bessel functions</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The results. Note that input must be of complex type to get complex output, e.g. kv(3, -2+0j) instead of kv(3, -2).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import kv\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(0, 5, 1000)\n>>> for N in np.linspace(0, 6, 5):\n...     plt.plot(x, kv(N, x), label='$K_{{{}}}(x)$'.format(N))\n>>> plt.ylim(0, 10)\n>>> plt.legend()\n>>> plt.title(r'Modified Bessel function of the second kind $K_\nu(x)$')\n>>> plt.show()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kv.html
scipy.special.kve	A										<section class="prog__container"><p>Exponentially scaled modified Bessel function of the second kind.</p><pre><code>scipy.special.kve(v, z) = <ufunc 'kve'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like of float\n    Order of Bessel functions \nz : array_like of complex\n    Argument at which to evaluate the Bessel functions</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The exponentially scaled modified Bessel function of the second kind.</code></pre><span class="prog__sub">Examples:</span><pre><code>kve(v, z) = kv(v, z) * exp(z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kve.html
scipy special kve	R	scipy.special.kve										
scipy special.kve	R	scipy.special.kve										
scipy.special.kvp	A										<section class="prog__container"><p>Compute nth derivative of real-order modified Bessel function Kv(z)</p><pre><code>scipy.special.kvp(v, z, n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like of float\n    Order of Bessel function \nz : array_like of complex\n    Argument at which to evaluate the derivative \nn : int\n    Order of derivative.  Default is first derivative.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The results</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import kvp\n>>> kvp(5, (1, 2, 3+5j))\narray([-1849.0354+0.j    ,   -25.7735+0.j    ,    -0.0307+0.0875j])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kvp.html
scipy special kvp	R	scipy.special.kvp										
scipy special.kvp	R	scipy.special.kvp										
scipy special kv	R	scipy.special.kv										
scipy special.kv	R	scipy.special.kv										
scipy.special.laguerre	A										<section class="prog__container"><p>Return the nth order Laguerre polynoimal, L_n(x), orthogonal over\n[0,inf) with weighting function exp(-x)</p><pre><code>scipy.special.laguerre(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.laguerre.html
scipy special laguerre	R	scipy.special.laguerre										
scipy special.laguerre	R	scipy.special.laguerre										
scipy.special.lambertw	A										<section class="prog__container"><p>Lambert W function [R420].</p><pre><code>scipy.special.lambertw(z, k=0, tol=1e-8)</code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    Input argument. \nk : int, optional\n    Branch index. \ntol : float, optional\n    Evaluation tolerance.</code></pre><span class="prog__sub">Returns:</span><pre><code>w : array\n    w will have the same shape as z.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import lambertw\n>>> w = lambertw(1)\n>>> w\n(0.56714329040978384+0j)\n>>> w * np.exp(w)\n(1.0+0j)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lambertw.html
scipy special lambertw	R	scipy.special.lambertw										
scipy special.lambertw	R	scipy.special.lambertw										
scipy.special.la_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-generalized Laguerre quadrature.</p><pre><code>scipy.special.la_roots(n, alpha, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nalpha : float\n    alpha must be > -1 \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.la_roots.html
scipy special la_roots	R	scipy.special.la_roots										
scipy special.la_roots	R	scipy.special.la_roots										
scipy.special.legendre	A										<section class="prog__container"><p>Legendre polynomial coefficients</p><pre><code>scipy.special.legendre(n, monic=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n\n    Order of the polynomial \nmonic : bool, optional\n    If True, output is a monic polynomial (normalized so the leading coefficient is 1).  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>P : orthopoly1d\n    The Legendre polynomial object</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import legendre\n>>> legendre(3)\npoly1d([ 2.5,  0. , -1.5,  0. ])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.legendre.html
scipy special legendre	R	scipy.special.legendre										
scipy special.legendre	R	scipy.special.legendre										
scipy.special.lmbda	A										<section class="prog__container"><p>Jahnke-Emden Lambda function, Lambdav(x).</p><pre><code>scipy.special.lmbda(v, x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : float\n    Order of the Lambda function \nx : float\n    Value at which to evaluate the function and derivatives</code></pre><span class="prog__sub">Returns:</span><pre><code>vl : ndarray\n    Values of Lambda_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. \ndl : ndarray\n    Derivatives Lambda_vi’(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lmbda.html
scipy special lmbda	R	scipy.special.lmbda										
scipy special.lmbda	R	scipy.special.lmbda										
scipy.special.log1p	A										<section class="prog__container"><p>Calculates log(1+x) for use when x is near zero</p><pre><code>scipy.special.log1p(x) = <ufunc 'log1p'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.log1p.html
scipy special log1p	R	scipy.special.log1p										
scipy special.log1p	R	scipy.special.log1p										
scipy.special.loggamma	A										<section class="prog__container"><p>Principal branch of the logarithm of the Gamma function.</p><pre><code>scipy.special.loggamma(z, out=None) = <ufunc 'loggamma'></code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array-like\n    Values in the complex plain at which to compute loggamma \nout : ndarray, optional\n    Output array for computed values of loggamma</code></pre><span class="prog__sub">Returns:</span><pre><code>loggamma : ndarray\n    Values of loggamma at z.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.loggamma.html
scipy special loggamma	R	scipy.special.loggamma										
scipy special.loggamma	R	scipy.special.loggamma										
scipy.special.logit	A										<section class="prog__container"><p>Logit ufunc for ndarrays.</p><pre><code>scipy.special.logit(x) = <ufunc 'logit'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    The ndarray to apply logit to element-wise.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    An ndarray of the same shape as x. Its entries are logit of the corresponding entry of x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.logit.html
scipy special logit	R	scipy.special.logit										
scipy special.logit	R	scipy.special.logit										
scipy.special.log_ndtr	A					[[scipy.special.erf]]\\n[[scipy.special.erfc]]\\n[[scipy.stats.norm]]\\n[[scipy.special.ndtr]]					<section class="prog__container"><p>Logarithm of Gaussian cumulative distribution function.</p><pre><code>scipy.special.log_ndtr(x) = <ufunc 'log_ndtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, real or complex\n    Argument</code></pre><span class="prog__sub">Returns:</span><pre><code>ndarray\n    The value of the log of the normal CDF evaluated at x</code></pre><span class="prog__sub">Examples:</span><pre><code>log(1/sqrt(2*pi) * integral(exp(-t**2 / 2), t=-inf..x))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.log_ndtr.html
scipy special log_ndtr	R	scipy.special.log_ndtr										
scipy special.log_ndtr	R	scipy.special.log_ndtr										
scipy.special.lpmn	A										<section class="prog__container"><p>Associated Legendre function of the first kind, Pmn(z).</p><pre><code>scipy.special.lpmn(m, n, z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : int\n    |m| <= n; the order of the Legendre function. \nn : int\n    where n >= 0; the degree of the Legendre function.  Often called l (lower case L) in descriptions of the associated Legendre function \nz : float\n    Input value.</code></pre><span class="prog__sub">Returns:</span><pre><code>Pmn_z : (m+1, n+1) array\n    Values for all orders 0..m and degrees 0..n \nPmn_d_z : (m+1, n+1) array\n    Derivatives for all orders 0..m and degrees 0..n</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lpmn.html
scipy special lpmn	R	scipy.special.lpmn										
scipy special.lpmn	R	scipy.special.lpmn										
scipy.special.lpmv	A										<section class="prog__container"><p>Associated legendre function of integer order.</p><pre><code>scipy.special.lpmv(m, v, x) = <ufunc 'lpmv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : int\n    Order \nv : float\n    Degree. \nx : float\n    Argument. Must be |x| <= 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : float\n    The value of the function.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lpmv.html
scipy special lpmv	R	scipy.special.lpmv										
scipy special.lpmv	R	scipy.special.lpmv										
scipy.special.lpn	A										<section class="prog__container"><p>Legendre functions of the first kind, Pn(z).</p><pre><code>scipy.special.lpn(n, z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lpn.html
scipy special lpn	R	scipy.special.lpn										
scipy special.lpn	R	scipy.special.lpn										
scipy.special.lqmn	A										<section class="prog__container"><p>Associated Legendre function of the second kind, Qmn(z).</p><pre><code>scipy.special.lqmn(m, n, z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : int\n    |m| <= n; the order of the Legendre function. \nn : int\n    where n >= 0; the degree of the Legendre function.  Often called l (lower case L) in descriptions of the associated Legendre function \nz : complex\n    Input value.</code></pre><span class="prog__sub">Returns:</span><pre><code>Qmn_z : (m+1, n+1) array\n    Values for all orders 0..m and degrees 0..n \nQmn_d_z : (m+1, n+1) array\n    Derivatives for all orders 0..m and degrees 0..n</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lqmn.html
scipy special lqmn	R	scipy.special.lqmn										
scipy special.lqmn	R	scipy.special.lqmn										
scipy.special.lqn	A										<section class="prog__container"><p>Legendre functions of the second kind, Qn(z).</p><pre><code>scipy.special.lqn(n, z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lqn.html
scipy special lqn	R	scipy.special.lqn										
scipy special.lqn	R	scipy.special.lqn										
scipy.special.l_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]\\n[[(in NumPy v1.11)]]					<section class="prog__container"><p>Gauss-Laguerre quadrature.</p><pre><code>scipy.special.l_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.l_roots.html
scipy special l_roots	R	scipy.special.l_roots										
scipy special.l_roots	R	scipy.special.l_roots										
scipy.special.mathieu_a	A										<section class="prog__container"><p>Characteristic value of even Mathieu functions</p><pre><code>scipy.special.mathieu_a(m, q) = <ufunc 'mathieu_a'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_a.html
scipy special mathieu_a	R	scipy.special.mathieu_a										
scipy special.mathieu_a	R	scipy.special.mathieu_a										
scipy.special.mathieu_b	A										<section class="prog__container"><p>Characteristic value of odd Mathieu functions</p><pre><code>scipy.special.mathieu_b(m, q) = <ufunc 'mathieu_b'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_b.html
scipy special mathieu_b	R	scipy.special.mathieu_b										
scipy special.mathieu_b	R	scipy.special.mathieu_b										
scipy.special.mathieu_cem	A										<section class="prog__container"><p>Even Mathieu function and its derivative</p><pre><code>scipy.special.mathieu_cem(m, q, x) = <ufunc 'mathieu_cem'></code></pre><span class="prog__sub">Parameters:</span><pre><code>m\n    Order of the function \nq\n    Parameter of the function \nx\n    Argument of the function, given in degrees, not radians</code></pre><span class="prog__sub">Returns:</span><pre><code>y\n    Value of the function \nyp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_cem.html
scipy special mathieu_cem	R	scipy.special.mathieu_cem										
scipy special.mathieu_cem	R	scipy.special.mathieu_cem										
scipy.special.mathieu_even_coef	A										<section class="prog__container"><p>Fourier coefficients for even Mathieu and modified Mathieu functions.</p><pre><code>scipy.special.mathieu_even_coef(m, q)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : int\n    Order of Mathieu functions.  Must be non-negative. \nq : float (>=0)\n    Parameter of Mathieu functions.  Must be non-negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>Ak : ndarray\n    Even or odd Fourier coefficients, corresponding to even or odd m.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_even_coef.html
scipy special mathieu_even_coef	R	scipy.special.mathieu_even_coef										
scipy special.mathieu_even_coef	R	scipy.special.mathieu_even_coef										
scipy.special.mathieu_modcem1	A										<section class="prog__container"><p>Even modified Mathieu function of the first kind and its derivative</p><pre><code>scipy.special.mathieu_modcem1(m, q, x) = <ufunc 'mathieu_modcem1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y\n    Value of the function \nyp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_modcem1.html
scipy special mathieu_modcem1	R	scipy.special.mathieu_modcem1										
scipy special.mathieu_modcem1	R	scipy.special.mathieu_modcem1										
scipy.special.mathieu_modcem2	A										<section class="prog__container"><p>Even modified Mathieu function of the second kind and its derivative</p><pre><code>scipy.special.mathieu_modcem2(m, q, x) = <ufunc 'mathieu_modcem2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y\n    Value of the function \nyp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_modcem2.html
scipy special mathieu_modcem2	R	scipy.special.mathieu_modcem2										
scipy special.mathieu_modcem2	R	scipy.special.mathieu_modcem2										
scipy.special.mathieu_modsem1	A										<section class="prog__container"><p>Odd modified Mathieu function of the first kind and its derivative</p><pre><code>scipy.special.mathieu_modsem1(m, q, x) = <ufunc 'mathieu_modsem1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y\n    Value of the function \nyp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_modsem1.html
scipy special mathieu_modsem1	R	scipy.special.mathieu_modsem1										
scipy special.mathieu_modsem1	R	scipy.special.mathieu_modsem1										
scipy.special.mathieu_modsem2	A										<section class="prog__container"><p>Odd modified Mathieu function of the second kind and its derivative</p><pre><code>scipy.special.mathieu_modsem2(m, q, x) = <ufunc 'mathieu_modsem2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y\n    Value of the function \nyp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_modsem2.html
scipy special mathieu_modsem2	R	scipy.special.mathieu_modsem2										
scipy special.mathieu_modsem2	R	scipy.special.mathieu_modsem2										
scipy.special.mathieu_odd_coef	A										<section class="prog__container"><p>Fourier coefficients for even Mathieu and modified Mathieu functions.</p><pre><code>scipy.special.mathieu_odd_coef(m, q)</code></pre><span class="prog__sub">Parameters:</span><pre><code>m : int\n    Order of Mathieu functions.  Must be non-negative. \nq : float (>=0)\n    Parameter of Mathieu functions.  Must be non-negative.</code></pre><span class="prog__sub">Returns:</span><pre><code>Bk : ndarray\n    Even or odd Fourier coefficients, corresponding to even or odd m.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_odd_coef.html
scipy special mathieu_odd_coef	R	scipy.special.mathieu_odd_coef										
scipy special.mathieu_odd_coef	R	scipy.special.mathieu_odd_coef										
scipy.special.mathieu_sem	A										<section class="prog__container"><p>Odd Mathieu function and its derivative</p><pre><code>scipy.special.mathieu_sem(m, q, x) = <ufunc 'mathieu_sem'></code></pre><span class="prog__sub">Parameters:</span><pre><code>m\n    Order of the function \nq\n    Parameter of the function \nx\n    Argument of the function, given in degrees, not radians.</code></pre><span class="prog__sub">Returns:</span><pre><code>y\n    Value of the function \nyp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.mathieu_sem.html
scipy special mathieu_sem	R	scipy.special.mathieu_sem										
scipy special.mathieu_sem	R	scipy.special.mathieu_sem										
scipy.special.modfresnelm	A										<section class="prog__container"><p>Modified Fresnel negative integrals</p><pre><code>scipy.special.modfresnelm(x) = <ufunc 'modfresnelm'></code></pre><span class="prog__sub">Parameters:</span><pre><code>fm\n    Integral F_-(x): integral(exp(-1j*t*t), t=x..inf) \nkm\n    Integral K_-(x): 1/sqrt(pi)*exp(1j*(x*x+pi/4))*fp</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.modfresnelm.html
scipy special modfresnelm	R	scipy.special.modfresnelm										
scipy special.modfresnelm	R	scipy.special.modfresnelm										
scipy.special.modfresnelp	A										<section class="prog__container"><p>Modified Fresnel positive integrals</p><pre><code>scipy.special.modfresnelp(x) = <ufunc 'modfresnelp'></code></pre><span class="prog__sub">Parameters:</span><pre><code>fp\n    Integral F_+(x): integral(exp(1j*t*t), t=x..inf) \nkp\n    Integral K_+(x): 1/sqrt(pi)*exp(-1j*(x*x+pi/4))*fp</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.modfresnelp.html
scipy special modfresnelp	R	scipy.special.modfresnelp										
scipy special.modfresnelp	R	scipy.special.modfresnelp										
scipy.special.modstruve	A					[[scipy.special.struve]]					<section class="prog__container"><p>Modified Struve function.</p><pre><code>scipy.special.modstruve(v, x) = <ufunc 'modstruve'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order of the modified Struve function (float). \nx : array_like\n    Argument of the Struve function (float; must be positive unless v is an integer).</code></pre><span class="prog__sub">Returns:</span><pre><code>L : ndarray\n    Value of the modified Struve function of order v at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.modstruve.html
scipy special modstruve	R	scipy.special.modstruve										
scipy special.modstruve	R	scipy.special.modstruve										
scipy.special.multigammaln	A										<section class="prog__container"><p>Returns the log of multivariate gamma, also sometimes called the\ngeneralized gamma.</p><pre><code>scipy.special.multigammaln(a, d)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    The multivariate gamma is computed for each item of a. \nd : int\n    The dimension of the space of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    The values of the log multivariate gamma at the given points a.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.multigammaln.html
scipy special multigammaln	R	scipy.special.multigammaln										
scipy special.multigammaln	R	scipy.special.multigammaln										
scipy.special.nbdtr	A					[[scipy.special.nbdtrc]]					<section class="prog__container"><p>Negative binomial cumulative distribution function.</p><pre><code>scipy.special.nbdtr(k, n, p) = <ufunc 'nbdtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    The maximum number of allowed failures (nonnegative int). \nn : array_like\n    The target number of successes (positive int). \np : array_like\n    Probability of success in a single event (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>F : ndarray\n    The probability of k or fewer failures before n successes in a sequence of events with individual success probability p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nbdtr.html
scipy.special.nbdtrc	A										<section class="prog__container"><p>Negative binomial survival function.</p><pre><code>scipy.special.nbdtrc(k, n, p) = <ufunc 'nbdtrc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    The maximum number of allowed failures (nonnegative int). \nn : array_like\n    The target number of successes (positive int). \np : array_like\n    Probability of success in a single event (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>F : ndarray\n    The probability of k + 1 or more failures before n successes in a sequence of events with individual success probability p.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nbdtrc.html
scipy special nbdtrc	R	scipy.special.nbdtrc										
scipy special.nbdtrc	R	scipy.special.nbdtrc										
scipy.special.nbdtri	A										<section class="prog__container"><p>Inverse of nbdtr vs p.</p><pre><code>scipy.special.nbdtri(k, n, y) = <ufunc 'nbdtri'></code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    The maximum number of allowed failures (nonnegative int). \nn : array_like\n    The target number of successes (positive int). \ny : array_like\n    The probability of k or fewer failures before n successes (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>p : ndarray\n    Probability of success in a single event (float) such that nbdtr(k, n, p) = y.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nbdtri.html
scipy.special.nbdtrik	A										<section class="prog__container"><p>Inverse of nbdtr vs k.</p><pre><code>scipy.special.nbdtrik(y, n, p) = <ufunc 'nbdtrik'></code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    The probability of k or fewer failures before n successes (float). \nn : array_like\n    The target number of successes (positive int). \np : array_like\n    Probability of success in a single event (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>k : ndarray\n    The maximum number of allowed failures such that nbdtr(k, n, p) = y.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nbdtrik.html
scipy special nbdtrik	R	scipy.special.nbdtrik										
scipy special.nbdtrik	R	scipy.special.nbdtrik										
scipy.special.nbdtrin	A										<section class="prog__container"><p>Inverse of nbdtr vs n.</p><pre><code>scipy.special.nbdtrin(k, y, p) = <ufunc 'nbdtrin'></code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    The maximum number of allowed failures (nonnegative int). \ny : array_like\n    The probability of k or fewer failures before n successes (float). \np : array_like\n    Probability of success in a single event (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>n : ndarray\n    The number of successes n such that nbdtr(k, n, p) = y.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nbdtrin.html
scipy special nbdtrin	R	scipy.special.nbdtrin										
scipy special.nbdtrin	R	scipy.special.nbdtrin										
scipy special nbdtri	R	scipy.special.nbdtri										
scipy special.nbdtri	R	scipy.special.nbdtri										
scipy special nbdtr	R	scipy.special.nbdtr										
scipy special.nbdtr	R	scipy.special.nbdtr										
scipy.special.ncfdtr	A										<section class="prog__container"><p>Cumulative distribution function of the non-central F distribution.</p><pre><code>scipy.special.ncfdtr(dfn, dfd, nc, f) = <ufunc 'ncfdtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>dfn : array_like\n    Degrees of freedom of the numerator sum of squares.  Range (0, inf). \ndfd : array_like\n    Degrees of freedom of the denominator sum of squares.  Range (0, inf). \nnc : array_like\n    Noncentrality parameter.  Should be in range (0, 1e4). \nf : array_like\n    Quantiles, i.e. the upper limit of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>cdf : float or ndarray\n    The calculated CDF.  If all inputs are scalar, the return will be a float.  Otherwise it will be an array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import special\n>>> from scipy import stats\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ncfdtr.html
scipy.special.ncfdtri	A										<section class="prog__container"><p>Inverse cumulative distribution function of the non-central F distribution.</p><pre><code>scipy.special.ncfdtri(p, dfn, dfd, nc) = <ufunc 'ncfdtri'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ncfdtri.html
scipy.special.ncfdtridfd	A										<section class="prog__container"><p>Calculate degrees of freedom (denominator) for the noncentral F-distribution.</p><pre><code>scipy.special.ncfdtridfd(p, f, dfn, nc) = <ufunc 'ncfdtridfd'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ncfdtridfd.html
scipy special ncfdtridfd	R	scipy.special.ncfdtridfd										
scipy special.ncfdtridfd	R	scipy.special.ncfdtridfd										
scipy.special.ncfdtridfn	A										<section class="prog__container"><p>Calculate degrees of freedom (numerator) for the noncentral F-distribution.</p><pre><code>scipy.special.ncfdtridfn(p, f, dfd, nc) = <ufunc 'ncfdtridfn'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ncfdtridfn.html
scipy special ncfdtridfn	R	scipy.special.ncfdtridfn										
scipy special.ncfdtridfn	R	scipy.special.ncfdtridfn										
scipy.special.ncfdtrinc	A										<section class="prog__container"><p>Calculate non-centrality parameter for non-central F distribution.</p><pre><code>scipy.special.ncfdtrinc(p, f, dfn, dfd) = <ufunc 'ncfdtrinc'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ncfdtrinc.html
scipy special ncfdtrinc	R	scipy.special.ncfdtrinc										
scipy special.ncfdtrinc	R	scipy.special.ncfdtrinc										
scipy special ncfdtri	R	scipy.special.ncfdtri										
scipy special.ncfdtri	R	scipy.special.ncfdtri										
scipy special ncfdtr	R	scipy.special.ncfdtr										
scipy special.ncfdtr	R	scipy.special.ncfdtr										
scipy.special.nctdtr	A										<section class="prog__container"><p>Cumulative distribution function of the non-central t distribution.</p><pre><code>scipy.special.nctdtr(df, nc, t) = <ufunc 'nctdtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>df : array_like\n    Degrees of freedom of the distribution.  Should be in range (0, inf). \nnc : array_like\n    Noncentrality parameter.  Should be in range (-1e6, 1e6). \nt : array_like\n    Quantiles, i.e. the upper limit of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>cdf : float or ndarray\n    The calculated CDF.  If all inputs are scalar, the return will be a float.  Otherwise it will be an array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import special\n>>> from scipy import stats\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nctdtr.html
scipy.special.nctdtridf	A										<section class="prog__container"><p>Calculate degrees of freedom for non-central t distribution.</p><pre><code>scipy.special.nctdtridf(p, nc, t) = <ufunc 'nctdtridf'></code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    CDF values, in range (0, 1]. \nnc : array_like\n    Noncentrality parameter.  Should be in range (-1e6, 1e6). \nt : array_like\n    Quantiles, i.e. the upper limit of integration.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nctdtridf.html
scipy special nctdtridf	R	scipy.special.nctdtridf										
scipy special.nctdtridf	R	scipy.special.nctdtridf										
scipy.special.nctdtrinc	A										<section class="prog__container"><p>Calculate non-centrality parameter for non-central t distribution.</p><pre><code>scipy.special.nctdtrinc(df, p, t) = <ufunc 'nctdtrinc'></code></pre><span class="prog__sub">Parameters:</span><pre><code>df : array_like\n    Degrees of freedom of the distribution.  Should be in range (0, inf). \np : array_like\n    CDF values, in range (0, 1]. \nt : array_like\n    Quantiles, i.e. the upper limit of integration.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nctdtrinc.html
scipy special nctdtrinc	R	scipy.special.nctdtrinc										
scipy special.nctdtrinc	R	scipy.special.nctdtrinc										
scipy.special.nctdtrit	A										<section class="prog__container"><p>Inverse cumulative distribution function of the non-central t distribution.</p><pre><code>scipy.special.nctdtrit(df, nc, p) = <ufunc 'nctdtrit'></code></pre><span class="prog__sub">Parameters:</span><pre><code>df : array_like\n    Degrees of freedom of the distribution.  Should be in range (0, inf). \nnc : array_like\n    Noncentrality parameter.  Should be in range (-1e6, 1e6). \np : array_like\n    CDF values, in range (0, 1].</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nctdtrit.html
scipy special nctdtrit	R	scipy.special.nctdtrit										
scipy special.nctdtrit	R	scipy.special.nctdtrit										
scipy special nctdtr	R	scipy.special.nctdtr										
scipy special.nctdtr	R	scipy.special.nctdtr										
scipy.special.ndtr	A					[[scipy.special.erf]]\\n[[scipy.special.erfc]]\\n[[scipy.stats.norm]]\\n[[scipy.special.log_ndtr]]					<section class="prog__container"><p>Gaussian cumulative distribution function.</p><pre><code>scipy.special.ndtr(x) = <ufunc 'ndtr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like, real or complex\n    Argument</code></pre><span class="prog__sub">Returns:</span><pre><code>ndarray\n    The value of the normal CDF evaluated at x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ndtr.html
scipy.special.ndtri	A										<section class="prog__container"><p>Inverse of ndtr vs x</p><pre><code>scipy.special.ndtri(y) = <ufunc 'ndtri'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ndtri.html
scipy special ndtri	R	scipy.special.ndtri										
scipy special.ndtri	R	scipy.special.ndtri										
scipy special ndtr	R	scipy.special.ndtr										
scipy special.ndtr	R	scipy.special.ndtr										
scipy.special.nrdtrimn	A					[[scipy.special.nrdtrimn]]\\n[[scipy.special.ndtr]]					<section class="prog__container"><p>Calculate mean of normal distribution given other params.</p><pre><code>scipy.special.nrdtrimn(p, x, std) = <ufunc 'nrdtrimn'></code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    CDF values, in range (0, 1]. \nx : array_like\n    Quantiles, i.e. the upper limit of integration. \nstd : array_like\n    Standard deviation.</code></pre><span class="prog__sub">Returns:</span><pre><code>mn : float or ndarray\n    The mean of the normal distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nrdtrimn.html
scipy special nrdtrimn	R	scipy.special.nrdtrimn										
scipy special.nrdtrimn	R	scipy.special.nrdtrimn										
scipy.special.nrdtrisd	A					[[scipy.special.ndtr]]					<section class="prog__container"><p>Calculate standard deviation of normal distribution given other params.</p><pre><code>scipy.special.nrdtrisd(p, x, mn) = <ufunc 'nrdtrisd'></code></pre><span class="prog__sub">Parameters:</span><pre><code>p : array_like\n    CDF values, in range (0, 1]. \nx : array_like\n    Quantiles, i.e. the upper limit of integration. \nmn : float or ndarray\n    The mean of the normal distribution.</code></pre><span class="prog__sub">Returns:</span><pre><code>std : array_like\n    Standard deviation.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.nrdtrisd.html
scipy special nrdtrisd	R	scipy.special.nrdtrisd										
scipy special.nrdtrisd	R	scipy.special.nrdtrisd										
scipy.special.obl_ang1	A										<section class="prog__container"><p>Oblate spheroidal angular function of the first kind and its derivative</p><pre><code>scipy.special.obl_ang1(m, n, c, x) = <ufunc 'obl_ang1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.obl_ang1.html
scipy.special.obl_ang1_cv	A										<section class="prog__container"><p>Oblate spheroidal angular function obl_ang1 for precomputed characteristic value</p><pre><code>scipy.special.obl_ang1_cv(m, n, c, cv, x) = <ufunc 'obl_ang1_cv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.obl_ang1_cv.html
scipy special obl_ang1_cv	R	scipy.special.obl_ang1_cv										
scipy special.obl_ang1_cv	R	scipy.special.obl_ang1_cv										
scipy special obl_ang1	R	scipy.special.obl_ang1										
scipy special.obl_ang1	R	scipy.special.obl_ang1										
scipy.special.obl_cv	A										<section class="prog__container"><p>Characteristic value of oblate spheroidal function</p><pre><code>scipy.special.obl_cv(m, n, c) = <ufunc 'obl_cv'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.obl_cv.html
scipy special obl_cv	R	scipy.special.obl_cv										
scipy special.obl_cv	R	scipy.special.obl_cv										
scipy.special.obl_cv_seq	A										<section class="prog__container"><p>Characteristic values for oblate spheroidal wave functions.</p><pre><code>scipy.special.obl_cv_seq(m, n, c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.obl_cv_seq.html
scipy special obl_cv_seq	R	scipy.special.obl_cv_seq										
scipy special.obl_cv_seq	R	scipy.special.obl_cv_seq										
scipy.special.obl_rad1	A										<section class="prog__container"><p>Oblate spheroidal radial function of the first kind and its derivative</p><pre><code>scipy.special.obl_rad1(m, n, c, x) = <ufunc 'obl_rad1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.obl_rad1.html
scipy.special.obl_rad1_cv	A										<section class="prog__container"><p>Oblate spheroidal radial function obl_rad1 for precomputed characteristic value</p><pre><code>scipy.special.obl_rad1_cv(m, n, c, cv, x) = <ufunc 'obl_rad1_cv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.obl_rad1_cv.html
scipy special obl_rad1_cv	R	scipy.special.obl_rad1_cv										
scipy special.obl_rad1_cv	R	scipy.special.obl_rad1_cv										
scipy special obl_rad1	R	scipy.special.obl_rad1										
scipy special.obl_rad1	R	scipy.special.obl_rad1										
scipy.special.obl_rad2	A										<section class="prog__container"><p>Oblate spheroidal radial function of the second kind and its derivative.</p><pre><code>scipy.special.obl_rad2(m, n, c, x) = <ufunc 'obl_rad2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.obl_rad2.html
scipy.special.obl_rad2_cv	A										<section class="prog__container"><p>Oblate spheroidal radial function obl_rad2 for precomputed characteristic value</p><pre><code>scipy.special.obl_rad2_cv(m, n, c, cv, x) = <ufunc 'obl_rad2_cv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.obl_rad2_cv.html
scipy special obl_rad2_cv	R	scipy.special.obl_rad2_cv										
scipy special.obl_rad2_cv	R	scipy.special.obl_rad2_cv										
scipy special obl_rad2	R	scipy.special.obl_rad2										
scipy special.obl_rad2	R	scipy.special.obl_rad2										
scipy.special.pbdn_seq	A										<section class="prog__container"><p>Parabolic cylinder functions Dn(z) and derivatives.</p><pre><code>scipy.special.pbdn_seq(n, z)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Order of the parabolic cylinder function \nz : complex\n    Value at which to evaluate the function and derivatives</code></pre><span class="prog__sub">Returns:</span><pre><code>dv : ndarray\n    Values of D_i(z), for i=0, ..., i=n. \ndp : ndarray\n    Derivatives D_i’(z), for i=0, ..., i=n.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pbdn_seq.html
scipy special pbdn_seq	R	scipy.special.pbdn_seq										
scipy special.pbdn_seq	R	scipy.special.pbdn_seq										
scipy.special.pbdv	A										<section class="prog__container"><p>Parabolic cylinder function D</p><pre><code>scipy.special.pbdv(v, x) = <ufunc 'pbdv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>d\n    Value of the function \ndp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pbdv.html
scipy special pbdv	R	scipy.special.pbdv										
scipy special.pbdv	R	scipy.special.pbdv										
scipy.special.pbdv_seq	A										<section class="prog__container"><p>Parabolic cylinder functions Dv(x) and derivatives.</p><pre><code>scipy.special.pbdv_seq(v, x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : float\n    Order of the parabolic cylinder function \nx : float\n    Value at which to evaluate the function and derivatives</code></pre><span class="prog__sub">Returns:</span><pre><code>dv : ndarray\n    Values of D_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. \ndp : ndarray\n    Derivatives D_vi’(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pbdv_seq.html
scipy special pbdv_seq	R	scipy.special.pbdv_seq										
scipy special.pbdv_seq	R	scipy.special.pbdv_seq										
scipy.special.pbvv	A										<section class="prog__container"><p>Parabolic cylinder function V</p><pre><code>scipy.special.pbvv(v, x) = <ufunc 'pbvv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v\n    Value of the function \nvp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pbvv.html
scipy special pbvv	R	scipy.special.pbvv										
scipy special.pbvv	R	scipy.special.pbvv										
scipy.special.pbvv_seq	A										<section class="prog__container"><p>Parabolic cylinder functions Vv(x) and derivatives.</p><pre><code>scipy.special.pbvv_seq(v, x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : float\n    Order of the parabolic cylinder function \nx : float\n    Value at which to evaluate the function and derivatives</code></pre><span class="prog__sub">Returns:</span><pre><code>dv : ndarray\n    Values of V_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. \ndp : ndarray\n    Derivatives V_vi’(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pbvv_seq.html
scipy special pbvv_seq	R	scipy.special.pbvv_seq										
scipy special.pbvv_seq	R	scipy.special.pbvv_seq										
scipy.special.pbwa	A										<section class="prog__container"><p>Parabolic cylinder function W</p><pre><code>scipy.special.pbwa(a, x) = <ufunc 'pbwa'></code></pre><span class="prog__sub">Parameters:</span><pre><code>w\n    Value of the function \nwp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pbwa.html
scipy special pbwa	R	scipy.special.pbwa										
scipy special.pbwa	R	scipy.special.pbwa										
scipy.special.pdtr	A										<section class="prog__container"><p>Poisson cumulative distribution function</p><pre><code>scipy.special.pdtr(k, m) = <ufunc 'pdtr'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pdtr.html
scipy.special.pdtrc	A										<section class="prog__container"><p>Poisson survival function</p><pre><code>scipy.special.pdtrc(k, m) = <ufunc 'pdtrc'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pdtrc.html
scipy special pdtrc	R	scipy.special.pdtrc										
scipy special.pdtrc	R	scipy.special.pdtrc										
scipy.special.pdtri	A										<section class="prog__container"><p>Inverse to pdtr vs m</p><pre><code>scipy.special.pdtri(k, y) = <ufunc 'pdtri'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pdtri.html
scipy.special.pdtrik	A										<section class="prog__container"><p>Inverse to pdtr vs k</p><pre><code>scipy.special.pdtrik(p, m) = <ufunc 'pdtrik'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pdtrik.html
scipy special pdtrik	R	scipy.special.pdtrik										
scipy special.pdtrik	R	scipy.special.pdtrik										
scipy special pdtri	R	scipy.special.pdtri										
scipy special.pdtri	R	scipy.special.pdtri										
scipy special pdtr	R	scipy.special.pdtr										
scipy special.pdtr	R	scipy.special.pdtr										
scipy.special.perm	A										<section class="prog__container"><p>Permutations of N things taken k at a time, i.e., k-permutations of N.</p><pre><code>scipy.special.perm(N, k, exact=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>N : int, ndarray\n    Number of things. \nk : int, ndarray\n    Number of elements taken. \nexact : bool, optional\n    If exact is False, then floating point precision is used, otherwise exact long integer is computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>val : int, ndarray\n    The number of k-permutations of N.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.special import perm\n>>> k = np.array([3, 4])\n>>> n = np.array([10, 10])\n>>> perm(n, k)\narray([  720.,  5040.])\n>>> perm(10, 3, exact=True)\n720</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.perm.html
scipy special perm	R	scipy.special.perm										
scipy special.perm	R	scipy.special.perm										
scipy.special.poch	A										<section class="prog__container"><p>Rising factorial (z)_m</p><pre><code>scipy.special.poch(z, m) = <ufunc 'poch'></code></pre><span class="prog__sub">Examples:</span><pre><code>(z)_m = gamma(z + m) / gamma(z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.poch.html
scipy special poch	R	scipy.special.poch										
scipy special.poch	R	scipy.special.poch										
scipy.special.polygamma	A										<section class="prog__container"><p>Polygamma function n.</p><pre><code>scipy.special.polygamma(n, x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : array_like of int\n    The order of the derivative of psi. \nx : array_like\n    Where to evaluate the polygamma function.</code></pre><span class="prog__sub">Returns:</span><pre><code>polygamma : ndarray\n    The result.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import special\n>>> x = [2, 3, 25.5]\n>>> special.polygamma(1, x)\narray([ 0.64493407,  0.39493407,  0.03999467])\n>>> special.polygamma(0, x) == special.psi(x)\narray([ True,  True,  True], dtype=bool)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.polygamma.html
scipy special polygamma	R	scipy.special.polygamma										
scipy special.polygamma	R	scipy.special.polygamma										
scipy.special.pro_ang1	A										<section class="prog__container"><p>Prolate spheroidal angular function of the first kind and its derivative</p><pre><code>scipy.special.pro_ang1(m, n, c, x) = <ufunc 'pro_ang1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pro_ang1.html
scipy.special.pro_ang1_cv	A										<section class="prog__container"><p>Prolate spheroidal angular function pro_ang1 for precomputed characteristic value</p><pre><code>scipy.special.pro_ang1_cv(m, n, c, cv, x) = <ufunc 'pro_ang1_cv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pro_ang1_cv.html
scipy special pro_ang1_cv	R	scipy.special.pro_ang1_cv										
scipy special.pro_ang1_cv	R	scipy.special.pro_ang1_cv										
scipy special pro_ang1	R	scipy.special.pro_ang1										
scipy special.pro_ang1	R	scipy.special.pro_ang1										
scipy.special.pro_cv	A										<section class="prog__container"><p>Characteristic value of prolate spheroidal function</p><pre><code>scipy.special.pro_cv(m, n, c) = <ufunc 'pro_cv'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pro_cv.html
scipy special pro_cv	R	scipy.special.pro_cv										
scipy special.pro_cv	R	scipy.special.pro_cv										
scipy.special.pro_cv_seq	A										<section class="prog__container"><p>Characteristic values for prolate spheroidal wave functions.</p><pre><code>scipy.special.pro_cv_seq(m, n, c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pro_cv_seq.html
scipy special pro_cv_seq	R	scipy.special.pro_cv_seq										
scipy special.pro_cv_seq	R	scipy.special.pro_cv_seq										
scipy.special.p_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]\\n[[(in NumPy v1.11)]]					<section class="prog__container"><p>Gauss-Legendre quadrature.</p><pre><code>scipy.special.p_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.p_roots.html
scipy special p_roots	R	scipy.special.p_roots										
scipy special.p_roots	R	scipy.special.p_roots										
scipy.special.pro_rad1	A										<section class="prog__container"><p>Prolate spheroidal radial function of the first kind and its derivative</p><pre><code>scipy.special.pro_rad1(m, n, c, x) = <ufunc 'pro_rad1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pro_rad1.html
scipy.special.pro_rad1_cv	A										<section class="prog__container"><p>Prolate spheroidal radial function pro_rad1 for precomputed characteristic value</p><pre><code>scipy.special.pro_rad1_cv(m, n, c, cv, x) = <ufunc 'pro_rad1_cv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pro_rad1_cv.html
scipy special pro_rad1_cv	R	scipy.special.pro_rad1_cv										
scipy special.pro_rad1_cv	R	scipy.special.pro_rad1_cv										
scipy special pro_rad1	R	scipy.special.pro_rad1										
scipy special.pro_rad1	R	scipy.special.pro_rad1										
scipy.special.pro_rad2	A										<section class="prog__container"><p>Prolate spheroidal radial function of the secon kind and its derivative</p><pre><code>scipy.special.pro_rad2(m, n, c, x) = <ufunc 'pro_rad2'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pro_rad2.html
scipy.special.pro_rad2_cv	A										<section class="prog__container"><p>Prolate spheroidal radial function pro_rad2 for precomputed characteristic value</p><pre><code>scipy.special.pro_rad2_cv(m, n, c, cv, x) = <ufunc 'pro_rad2_cv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>s\n    Value of the function \nsp\n    Value of the derivative vs x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pro_rad2_cv.html
scipy special pro_rad2_cv	R	scipy.special.pro_rad2_cv										
scipy special.pro_rad2_cv	R	scipy.special.pro_rad2_cv										
scipy special pro_rad2	R	scipy.special.pro_rad2										
scipy special.pro_rad2	R	scipy.special.pro_rad2										
scipy.special.pseudo_huber	A										<section class="prog__container"><p>Pseudo-Huber loss function.</p><pre><code>scipy.special.pseudo_huber(delta, r) = <ufunc 'pseudo_huber'></code></pre><span class="prog__sub">Parameters:</span><pre><code>delta : ndarray\n    Input array, indicating the soft quadratic vs. linear loss changepoint. \nr : ndarray\n    Input array, possibly representing residuals.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    The computed Pseudo-Huber loss function values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.pseudo_huber.html
scipy special pseudo_huber	R	scipy.special.pseudo_huber										
scipy special.pseudo_huber	R	scipy.special.pseudo_huber										
scipy.special.psi	A										<section class="prog__container"><p>The digamma function.</p><pre><code>scipy.special.psi(z, out=None) = <ufunc 'psi'></code></pre><span class="prog__sub">Parameters:</span><pre><code>z : array_like\n    Real or complex argument. \nout : ndarray, optional\n    Array for the computed values of psi.</code></pre><span class="prog__sub">Returns:</span><pre><code>digamma : ndarray\n    Computed values of psi.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.psi.html
scipy special psi	R	scipy.special.psi										
scipy special.psi	R	scipy.special.psi										
scipy.special.ps_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Legendre (shifted) quadrature.</p><pre><code>scipy.special.ps_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ps_roots.html
scipy special ps_roots	R	scipy.special.ps_roots										
scipy special.ps_roots	R	scipy.special.ps_roots										
scipy.special.radian	A										<section class="prog__container"><p>Convert from degrees to radians</p><pre><code>scipy.special.radian(d, m, s) = <ufunc 'radian'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.radian.html
scipy special radian	R	scipy.special.radian										
scipy special.radian	R	scipy.special.radian										
scipy.special.rel_entr	A					[[scipy.special.entr]]\\n[[scipy.special.kl_div]]					<section class="prog__container"><p>Elementwise function for computing relative entropy.</p><pre><code>scipy.special.rel_entr(x, y) = <ufunc 'rel_entr'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    First input array. \ny : ndarray\n    Second input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>res : ndarray\n    Output array.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.rel_entr.html
scipy special rel_entr	R	scipy.special.rel_entr										
scipy special.rel_entr	R	scipy.special.rel_entr										
scipy.special.rgamma	A										<section class="prog__container"><p>Gamma function inverted</p><pre><code>scipy.special.rgamma(z) = <ufunc 'rgamma'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.rgamma.html
scipy special rgamma	R	scipy.special.rgamma										
scipy special.rgamma	R	scipy.special.rgamma										
scipy.special.riccati_jn	A										<section class="prog__container"><p>Compute Ricatti-Bessel function of the first kind and its derivative.</p><pre><code>scipy.special.riccati_jn(n, x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Maximum order of function to compute \nx : float\n    Argument at which to evaluate</code></pre><span class="prog__sub">Returns:</span><pre><code>jn : ndarray\n    Value of j0(x), ..., jn(x) \njnp : ndarray\n    First derivative j0’(x), ..., jn’(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.riccati_jn.html
scipy special riccati_jn	R	scipy.special.riccati_jn										
scipy special.riccati_jn	R	scipy.special.riccati_jn										
scipy.special.riccati_yn	A										<section class="prog__container"><p>Compute Ricatti-Bessel function of the second kind and its derivative.</p><pre><code>scipy.special.riccati_yn(n, x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Maximum order of function to compute \nx : float\n    Argument at which to evaluate</code></pre><span class="prog__sub">Returns:</span><pre><code>yn : ndarray\n    Value of y0(x), ..., yn(x) \nynp : ndarray\n    First derivative y0’(x), ..., yn’(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.riccati_yn.html
scipy special riccati_yn	R	scipy.special.riccati_yn										
scipy special.riccati_yn	R	scipy.special.riccati_yn										
scipy.special.round	A										<section class="prog__container"><p>Round to nearest integer</p><pre><code>scipy.special.round(x) = <ufunc 'round'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.round.html
scipy special round	R	scipy.special.round										
scipy special.round	R	scipy.special.round										
scipy.special.sh_chebyt	A										<section class="prog__container"><p>Return nth order shifted Chebyshev polynomial of first kind, Tn(x).\nOrthogonal over [0,1] with weight function (x-x**2)**(-1/2).</p><pre><code>scipy.special.sh_chebyt(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sh_chebyt.html
scipy special sh_chebyt	R	scipy.special.sh_chebyt										
scipy special.sh_chebyt	R	scipy.special.sh_chebyt										
scipy.special.sh_chebyu	A										<section class="prog__container"><p>Return nth order shifted Chebyshev polynomial of second kind, Un(x).\nOrthogonal over [0,1] with weight function (x-x**2)**(1/2).</p><pre><code>scipy.special.sh_chebyu(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sh_chebyu.html
scipy special sh_chebyu	R	scipy.special.sh_chebyu										
scipy special.sh_chebyu	R	scipy.special.sh_chebyu										
scipy.special.shichi	A										<section class="prog__container"><p>Hyperbolic sine and cosine integrals</p><pre><code>scipy.special.shichi(x) = <ufunc 'shichi'></code></pre><span class="prog__sub">Parameters:</span><pre><code>shi\n    integral(sinh(t)/t, t=0..x) \nchi\n    eul + ln x + integral((cosh(t)-1)/t, t=0..x) where eul is Euler’s constant.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.shichi.html
scipy special shichi	R	scipy.special.shichi										
scipy special.shichi	R	scipy.special.shichi										
scipy.special.sh_jacobi	A										<section class="prog__container"><p>Returns the nth order Jacobi polynomial, G_n(p,q,x)\northogonal over [0,1] with weighting function\n(1-x)**(p-q) (x)**(q-1) with p>q-1 and q > 0.</p><pre><code>scipy.special.sh_jacobi(n, p, q, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sh_jacobi.html
scipy special sh_jacobi	R	scipy.special.sh_jacobi										
scipy special.sh_jacobi	R	scipy.special.sh_jacobi										
scipy.special.sh_legendre	A										<section class="prog__container"><p>Returns the nth order shifted Legendre polynomial, P^*_n(x), orthogonal\nover [0,1] with weighting function 1.</p><pre><code>scipy.special.sh_legendre(n, monic=False)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sh_legendre.html
scipy special sh_legendre	R	scipy.special.sh_legendre										
scipy special.sh_legendre	R	scipy.special.sh_legendre										
scipy.special.sici	A										<section class="prog__container"><p>Sine and cosine integrals</p><pre><code>scipy.special.sici(x) = <ufunc 'sici'></code></pre><span class="prog__sub">Parameters:</span><pre><code>si\n    integral(sin(t)/t, t=0..x) \nci\n    eul + ln x + integral((cos(t) - 1)/t, t=0..x) where eul is Euler’s constant.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sici.html
scipy special sici	R	scipy.special.sici										
scipy special.sici	R	scipy.special.sici										
scipy.special.sinc	A										<section class="prog__container"><p>Return the sinc function.</p><pre><code>scipy.special.sinc(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    Array (possibly multi-dimensional) of values for which to to calculate sinc(x).</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    sinc(x), which has the same shape as the input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = np.linspace(-4, 4, 41)\n>>> np.sinc(x)\narray([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,\n        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n        -4.92362781e-02,  -3.89804309e-17])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sinc.html
scipy special sinc	R	scipy.special.sinc										
scipy special.sinc	R	scipy.special.sinc										
scipy.special.sindg	A										<section class="prog__container"><p>Sine of angle given in degrees</p><pre><code>scipy.special.sindg(x) = <ufunc 'sindg'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sindg.html
scipy special sindg	R	scipy.special.sindg										
scipy special.sindg	R	scipy.special.sindg										
scipy.special.smirnov	A										<section class="prog__container"><p>Kolmogorov-Smirnov complementary cumulative distribution function</p><pre><code>scipy.special.smirnov(n, e) = <ufunc 'smirnov'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.smirnov.html
scipy.special.smirnovi	A										<section class="prog__container"><p>Inverse to smirnov</p><pre><code>scipy.special.smirnovi(n, y) = <ufunc 'smirnovi'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.smirnovi.html
scipy special smirnovi	R	scipy.special.smirnovi										
scipy special.smirnovi	R	scipy.special.smirnovi										
scipy special smirnov	R	scipy.special.smirnov										
scipy special.smirnov	R	scipy.special.smirnov										
scipy.special.SpecialFunctionWarning	A										<section class="prog__container"><p>Warning that can be issued with errprint(True)</p><pre><code>exception scipy.special.SpecialFunctionWarning</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.SpecialFunctionWarning.html
scipy special SpecialFunctionWarning	R	scipy.special.SpecialFunctionWarning										
scipy special.SpecialFunctionWarning	R	scipy.special.SpecialFunctionWarning										
scipy.special.spence	A										<section class="prog__container"><p>Spence’s function, also known as the dilogarithm. It is defined to\nbe</p><pre><code>scipy.special.spence(z) = <ufunc 'spence'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.spence.html
scipy special spence	R	scipy.special.spence										
scipy special.spence	R	scipy.special.spence										
scipy.special.spherical_in	A										<section class="prog__container"><p>Modified spherical Bessel function of the first kind or its derivative.</p><pre><code>scipy.special.spherical_in(n, z, derivative=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, array_like\n    Order of the Bessel function (n >= 0). \nz : complex or float, array_like\n    Argument of the Bessel function. \nderivative : bool, optional\n    If True, the value of the derivative (rather than the function itself) is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>in : ndarray</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.spherical_in.html
scipy special spherical_in	R	scipy.special.spherical_in										
scipy special.spherical_in	R	scipy.special.spherical_in										
scipy.special.spherical_jn	A										<section class="prog__container"><p>Spherical Bessel function of the first kind or its derivative.</p><pre><code>scipy.special.spherical_jn(n, z, derivative=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, array_like\n    Order of the Bessel function (n >= 0). \nz : complex or float, array_like\n    Argument of the Bessel function. \nderivative : bool, optional\n    If True, the value of the derivative (rather than the function itself) is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>jn : ndarray</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.spherical_jn.html
scipy special spherical_jn	R	scipy.special.spherical_jn										
scipy special.spherical_jn	R	scipy.special.spherical_jn										
scipy.special.spherical_kn	A										<section class="prog__container"><p>Modified spherical Bessel function of the second kind or its derivative.</p><pre><code>scipy.special.spherical_kn(n, z, derivative=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, array_like\n    Order of the Bessel function (n >= 0). \nz : complex or float, array_like\n    Argument of the Bessel function. \nderivative : bool, optional\n    If True, the value of the derivative (rather than the function itself) is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>kn : ndarray</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.spherical_kn.html
scipy special spherical_kn	R	scipy.special.spherical_kn										
scipy special.spherical_kn	R	scipy.special.spherical_kn										
scipy.special.spherical_yn	A										<section class="prog__container"><p>Spherical Bessel function of the second kind or its derivative.</p><pre><code>scipy.special.spherical_yn(n, z, derivative=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, array_like\n    Order of the Bessel function (n >= 0). \nz : complex or float, array_like\n    Argument of the Bessel function. \nderivative : bool, optional\n    If True, the value of the derivative (rather than the function itself) is returned.</code></pre><span class="prog__sub">Returns:</span><pre><code>yn : ndarray</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.spherical_yn.html
scipy special spherical_yn	R	scipy.special.spherical_yn										
scipy special.spherical_yn	R	scipy.special.spherical_yn										
scipy.special.sph_harm	A										<section class="prog__container"><p>Compute spherical harmonics.</p><pre><code>scipy.special.sph_harm(m, n, theta, phi) = <ufunc 'sph_harm'></code></pre><span class="prog__sub">Parameters:</span><pre><code>m : int\n    |m| <= n; the order of the harmonic. \nn : int\n    where n >= 0; the degree of the harmonic.  This is often called l (lower case L) in descriptions of spherical harmonics. \ntheta : float\n    [0, 2*pi]; the azimuthal (longitudinal) coordinate. \nphi : float\n    [0, pi]; the polar (colatitudinal) coordinate.</code></pre><span class="prog__sub">Returns:</span><pre><code>y_mn : complex float\n    The harmonic \(Y^m_n\) sampled at theta and phi</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph_harm.html
scipy special sph_harm	R	scipy.special.sph_harm										
scipy special.sph_harm	R	scipy.special.sph_harm										
scipy.special.sph_in	A										<section class="prog__container"><p>sph_in is deprecated!\nscipy.special.sph_in is deprecated in scipy 0.18.0. Use scipy.special.spherical_in instead. Note that the new function has a different signature.</p><pre><code>scipy.special.sph_in(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Maximum order of in to compute   z : complex Argument at which to evaluate</code></pre><span class="prog__sub">Returns:</span><pre><code>in : ndarray\n    Value of i0(z), ..., in(z)   inp : ndarray First derivative i0’(z), ..., in’(z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph_in.html
scipy.special.sph_inkn	A										<section class="prog__container"><p>sph_inkn is deprecated!\nscipy.special.sph_inkn is deprecated in scipy 0.18.0. Use scipy.special.spherical_in and scipy.special.spherical_kn instead. Note that the new function has a different signature.</p><pre><code>scipy.special.sph_inkn(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Maximum order of in and kn to compute   z : complex Argument at which to evaluate</code></pre><span class="prog__sub">Returns:</span><pre><code>in : ndarray\n    Value of i0(z), ..., in(z)   inp : ndarray First derivative i0’(z), ..., in’(z)  kn : ndarray Value of k0(z), ..., kn(z)  knp : ndarray First derivative k0’(z), ..., kn’(z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph_inkn.html
scipy special sph_inkn	R	scipy.special.sph_inkn										
scipy special.sph_inkn	R	scipy.special.sph_inkn										
scipy special sph_in	R	scipy.special.sph_in										
scipy special.sph_in	R	scipy.special.sph_in										
scipy.special.sph_jn	A										<section class="prog__container"><p>sph_jn is deprecated!\nscipy.special.sph_jn is deprecated in scipy 0.18.0. Use scipy.special.spherical_jn instead. Note that the new function has a different signature.</p><pre><code>scipy.special.sph_jn(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Maximum order of jn to compute   z : complex Argument at which to evaluate</code></pre><span class="prog__sub">Returns:</span><pre><code>jn : ndarray\n    Value of j0(z), ..., jn(z)   jnp : ndarray First derivative j0’(z), ..., jn’(z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph_jn.html
scipy special sph_jn	R	scipy.special.sph_jn										
scipy special.sph_jn	R	scipy.special.sph_jn										
scipy.special.sph_jnyn	A										<section class="prog__container"><p>sph_jnyn is deprecated!\nscipy.special.sph_jnyn is deprecated in scipy 0.18.0. Use scipy.special.spherical_jn and scipy.special.spherical_yn instead. Note that the new function has a different signature.</p><pre><code>scipy.special.sph_jnyn(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Maximum order of jn and yn to compute   z : complex Argument at which to evaluate</code></pre><span class="prog__sub">Returns:</span><pre><code>jn : ndarray\n    Value of j0(z), ..., jn(z)   jnp : ndarray First derivative j0’(z), ..., jn’(z)  yn : ndarray Value of y0(z), ..., yn(z)  ynp : ndarray First derivative y0’(z), ..., yn’(z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph_jnyn.html
scipy special sph_jnyn	R	scipy.special.sph_jnyn										
scipy special.sph_jnyn	R	scipy.special.sph_jnyn										
scipy.special.sph_kn	A										<section class="prog__container"><p>sph_kn is deprecated!\nscipy.special.sph_kn is deprecated in scipy 0.18.0. Use scipy.special.spherical_kn instead. Note that the new function has a different signature.</p><pre><code>scipy.special.sph_kn(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Maximum order of kn to compute   z : complex Argument at which to evaluate</code></pre><span class="prog__sub">Returns:</span><pre><code>kn : ndarray\n    Value of k0(z), ..., kn(z)   knp : ndarray First derivative k0’(z), ..., kn’(z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph_kn.html
scipy special sph_kn	R	scipy.special.sph_kn										
scipy special.sph_kn	R	scipy.special.sph_kn										
scipy.special.sph_yn	A										<section class="prog__container"><p>sph_yn is deprecated!\nscipy.special.sph_yn is deprecated in scipy 0.18.0. Use scipy.special.spherical_yn instead. Note that the new function has a different signature.</p><pre><code>scipy.special.sph_yn(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Maximum order of yn to compute   z : complex Argument at which to evaluate</code></pre><span class="prog__sub">Returns:</span><pre><code>yn : ndarray\n    Value of y0(z), ..., yn(z)   ynp : ndarray First derivative y0’(z), ..., yn’(z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.sph_yn.html
scipy special sph_yn	R	scipy.special.sph_yn										
scipy special.sph_yn	R	scipy.special.sph_yn										
scipy.special.s_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Chebyshev (second kind) quadrature.</p><pre><code>scipy.special.s_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.s_roots.html
scipy special s_roots	R	scipy.special.s_roots										
scipy special.s_roots	R	scipy.special.s_roots										
scipy.special.stdtr	A										<section class="prog__container"><p>Student t distribution cumulative density function</p><pre><code>scipy.special.stdtr(df, t) = <ufunc 'stdtr'></code></pre><span class="prog__sub">Examples:</span><pre><code>gamma((df+1)/2)/(sqrt(df*pi)*gamma(df/2)) *\nintegral((1+x**2/df)**(-df/2-1/2), x=-inf..t)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.stdtr.html
scipy.special.stdtridf	A										<section class="prog__container"><p>Inverse of stdtr vs df</p><pre><code>scipy.special.stdtridf(p, t) = <ufunc 'stdtridf'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.stdtridf.html
scipy special stdtridf	R	scipy.special.stdtridf										
scipy special.stdtridf	R	scipy.special.stdtridf										
scipy.special.stdtrit	A										<section class="prog__container"><p>Inverse of stdtr vs t</p><pre><code>scipy.special.stdtrit(df, p) = <ufunc 'stdtrit'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.stdtrit.html
scipy special stdtrit	R	scipy.special.stdtrit										
scipy special.stdtrit	R	scipy.special.stdtrit										
scipy special stdtr	R	scipy.special.stdtr										
scipy special.stdtr	R	scipy.special.stdtr										
scipy.special.struve	A					[[scipy.special.modstruve]]					<section class="prog__container"><p>Struve function.</p><pre><code>scipy.special.struve(v, x) = <ufunc 'struve'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order of the Struve function (float). \nx : array_like\n    Argument of the Struve function (float; must be positive unless v is an integer).</code></pre><span class="prog__sub">Returns:</span><pre><code>H : ndarray\n    Value of the Struve function of order v at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.struve.html
scipy special struve	R	scipy.special.struve										
scipy special.struve	R	scipy.special.struve										
scipy.special.tandg	A										<section class="prog__container"><p>Tangent of angle x given in degrees.</p><pre><code>scipy.special.tandg(x) = <ufunc 'tandg'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.tandg.html
scipy special tandg	R	scipy.special.tandg										
scipy special.tandg	R	scipy.special.tandg										
scipy.special.tklmbda	A										<section class="prog__container"><p>Tukey-Lambda cumulative distribution function</p><pre><code>scipy.special.tklmbda(x, lmbda) = <ufunc 'tklmbda'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.tklmbda.html
scipy special tklmbda	R	scipy.special.tklmbda										
scipy special.tklmbda	R	scipy.special.tklmbda										
scipy.special.t_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]\\n[[(in NumPy v1.11)]]					<section class="prog__container"><p>Gauss-Chebyshev (first kind) quadrature.</p><pre><code>scipy.special.t_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.t_roots.html
scipy special t_roots	R	scipy.special.t_roots										
scipy special.t_roots	R	scipy.special.t_roots										
scipy.special.ts_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Chebyshev (first kind, shifted) quadrature.</p><pre><code>scipy.special.ts_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ts_roots.html
scipy special ts_roots	R	scipy.special.ts_roots										
scipy special.ts_roots	R	scipy.special.ts_roots										
scipy.special.u_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Chebyshev (second kind) quadrature.</p><pre><code>scipy.special.u_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.u_roots.html
scipy special u_roots	R	scipy.special.u_roots										
scipy special.u_roots	R	scipy.special.u_roots										
scipy.special.us_roots	A					[[scipy.integrate.quadrature]]\\n[[scipy.integrate.fixed_quad]]					<section class="prog__container"><p>Gauss-Chebyshev (second kind, shifted) quadrature.</p><pre><code>scipy.special.us_roots(n, mu=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    quadrature order \nmu : bool, optional\n    If True, return the sum of the weights, optional.</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray\n    Sample points \nw : ndarray\n    Weights \nmu : float\n    Sum of the weights</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.us_roots.html
scipy special us_roots	R	scipy.special.us_roots										
scipy special.us_roots	R	scipy.special.us_roots										
scipy.special.wofz	A					[[scipy.special.dawsn]]\\n[[scipy.special.erf]]\\n[[scipy.special.erfc]]\\n[[scipy.special.erfcx]]\\n[[scipy.special.erfi]]					<section class="prog__container"><p>Faddeeva function</p><pre><code>scipy.special.wofz(z) = <ufunc 'wofz'></code></pre><span class="prog__sub">Examples:</span><pre><code>exp(-z**2) * erfc(-i*z)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.wofz.html
scipy special wofz	R	scipy.special.wofz										
scipy special.wofz	R	scipy.special.wofz										
scipy.special.xlog1py	A										<section class="prog__container"><p>Compute x*log1p(y) so that the result is 0 if x = 0.</p><pre><code>scipy.special.xlog1py(x, y) = <ufunc 'xlog1py'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Multiplier \ny : array_like\n    Argument</code></pre><span class="prog__sub">Returns:</span><pre><code>z : array_like\n    Computed x*log1p(y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.xlog1py.html
scipy special xlog1py	R	scipy.special.xlog1py										
scipy special.xlog1py	R	scipy.special.xlog1py										
scipy.special.xlogy	A										<section class="prog__container"><p>Compute x*log(y) so that the result is 0 if x = 0.</p><pre><code>scipy.special.xlogy(x, y) = <ufunc 'xlogy'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Multiplier \ny : array_like\n    Argument</code></pre><span class="prog__sub">Returns:</span><pre><code>z : array_like\n    Computed x*log(y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.xlogy.html
scipy special xlogy	R	scipy.special.xlogy										
scipy special.xlogy	R	scipy.special.xlogy										
scipy.special.y0	A					[[scipy.special.j0]]\\n[[scipy.special.yv]]					<section class="prog__container"><p>Bessel function of the second kind of order 0.</p><pre><code>scipy.special.y0(x) = <ufunc 'y0'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : ndarray\n    Value of the Bessel function of the second kind of order 0 at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.y0.html
scipy special y0	R	scipy.special.y0										
scipy special.y0	R	scipy.special.y0										
scipy.special.y0_zeros	A										<section class="prog__container"><p>Compute nt zeros of Bessel function Y0(z), and derivative at each zero.</p><pre><code>scipy.special.y0_zeros(nt, complex=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nt : int\n    Number of zeros to return \ncomplex : bool, default False\n    Set to False to return only the real zeros; set to True to return only the complex zeros with negative real part and positive imaginary part. Note that the complex conjugates of the latter are also zeros of the function, but are not returned by this routine.</code></pre><span class="prog__sub">Returns:</span><pre><code>z0n : ndarray\n    Location of nth zero of Y0(z) \ny0pz0n : ndarray\n    Value of derivative Y0’(z0) for nth zero</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.y0_zeros.html
scipy special y0_zeros	R	scipy.special.y0_zeros										
scipy special.y0_zeros	R	scipy.special.y0_zeros										
scipy.special.y1	A					[[scipy.special.j1]]\\n[[scipy.special.yn]]\\n[[scipy.special.yv]]					<section class="prog__container"><p>Bessel function of the second kind of order 1.</p><pre><code>scipy.special.y1(x) = <ufunc 'y1'></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Argument (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : ndarray\n    Value of the Bessel function of the second kind of order 1 at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.y1.html
scipy.special.y1p_zeros	A										<section class="prog__container"><p>Compute nt zeros of Bessel derivative Y1’(z), and value at each zero.</p><pre><code>scipy.special.y1p_zeros(nt, complex=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nt : int\n    Number of zeros to return \ncomplex : bool, default False\n    Set to False to return only the real zeros; set to True to return only the complex zeros with negative real part and positive imaginary part. Note that the complex conjugates of the latter are also zeros of the function, but are not returned by this routine.</code></pre><span class="prog__sub">Returns:</span><pre><code>z1pn : ndarray\n    Location of nth zero of Y1’(z) \ny1z1pn : ndarray\n    Value of derivative Y1(z1) for nth zero</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.y1p_zeros.html
scipy special y1p_zeros	R	scipy.special.y1p_zeros										
scipy special.y1p_zeros	R	scipy.special.y1p_zeros										
scipy special y1	R	scipy.special.y1										
scipy special.y1	R	scipy.special.y1										
scipy.special.y1_zeros	A										<section class="prog__container"><p>Compute nt zeros of Bessel function Y1(z), and derivative at each zero.</p><pre><code>scipy.special.y1_zeros(nt, complex=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>nt : int\n    Number of zeros to return \ncomplex : bool, default False\n    Set to False to return only the real zeros; set to True to return only the complex zeros with negative real part and positive imaginary part. Note that the complex conjugates of the latter are also zeros of the function, but are not returned by this routine.</code></pre><span class="prog__sub">Returns:</span><pre><code>z1n : ndarray\n    Location of nth zero of Y1(z) \ny1pz1n : ndarray\n    Value of derivative Y1’(z1) for nth zero</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.y1_zeros.html
scipy special y1_zeros	R	scipy.special.y1_zeros										
scipy special.y1_zeros	R	scipy.special.y1_zeros										
scipy.special.yn	A										<section class="prog__container"><p>Bessel function of the second kind of integer order and real argument.</p><pre><code>scipy.special.yn(n, x) = <ufunc 'yn'></code></pre><span class="prog__sub">Parameters:</span><pre><code>n : array_like\n    Order (integer). \nz : array_like\n    Argument (float).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : ndarray\n    Value of the Bessel function, \(Y_n(x)\).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.yn.html
scipy.special.ynp_zeros	A										<section class="prog__container"><p>Compute zeros of integer-order Bessel function derivative Yn’(x).</p><pre><code>scipy.special.ynp_zeros(n, nt)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Order of Bessel function \nnt : int\n    Number of zeros to return</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.ynp_zeros.html
scipy special ynp_zeros	R	scipy.special.ynp_zeros										
scipy special.ynp_zeros	R	scipy.special.ynp_zeros										
scipy special yn	R	scipy.special.yn										
scipy special.yn	R	scipy.special.yn										
scipy.special.yn_zeros	A										<section class="prog__container"><p>Compute zeros of integer-order Bessel function Yn(x).</p><pre><code>scipy.special.yn_zeros(n, nt)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int\n    Order of Bessel function \nnt : int\n    Number of zeros to return</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.yn_zeros.html
scipy special yn_zeros	R	scipy.special.yn_zeros										
scipy special.yn_zeros	R	scipy.special.yn_zeros										
scipy.special.yv	A										<section class="prog__container"><p>Bessel function of the second kind of real order and complex argument.</p><pre><code>scipy.special.yv(v, z) = <ufunc 'yv'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : ndarray\n    Value of the Bessel function of the second kind, \(Y_v(x)\).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.yv.html
scipy.special.yve	A										<section class="prog__container"><p>Exponentially scaled Bessel function of the second kind of real order.</p><pre><code>scipy.special.yve(v, z) = <ufunc 'yve'></code></pre><span class="prog__sub">Parameters:</span><pre><code>v : array_like\n    Order (float). \nz : array_like\n    Argument (float or complex).</code></pre><span class="prog__sub">Returns:</span><pre><code>Y : ndarray\n    Value of the exponentially scaled Bessel function.</code></pre><span class="prog__sub">Examples:</span><pre><code>yve(v, z) = yv(v, z) * exp(-abs(z.imag))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.yve.html
scipy special yve	R	scipy.special.yve										
scipy special.yve	R	scipy.special.yve										
scipy.special.yvp	A										<section class="prog__container"><p>Compute nth derivative of Bessel function Yv(z) with respect to z.</p><pre><code>scipy.special.yvp(v, z, n=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>v : float\n    Order of Bessel function \nz : complex\n    Argument at which to evaluate the derivative \nn : int, default 1\n    Order of derivative</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.yvp.html
scipy special yvp	R	scipy.special.yvp										
scipy special.yvp	R	scipy.special.yvp										
scipy special yv	R	scipy.special.yv										
scipy special.yv	R	scipy.special.yv										
scipy.special.zeta	A					[[scipy.special.zetac]]					<section class="prog__container"><p>Riemann zeta function.</p><pre><code>scipy.special.zeta(x, q=None, out=None)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.zeta.html
scipy.special.zetac	A					[[scipy.special.zeta]]					<section class="prog__container"><p>Riemann zeta function minus 1.</p><pre><code>scipy.special.zetac(x) = <ufunc 'zetac'></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.zetac.html
scipy special zetac	R	scipy.special.zetac										
scipy special.zetac	R	scipy.special.zetac										
scipy special zeta	R	scipy.special.zeta										
scipy special.zeta	R	scipy.special.zeta										
scipy.stats.alpha	A										<section class="prog__container"><p>An alpha continuous random variable.</p><pre><code>scipy.stats.alpha = <scipy.stats._continuous_distns.alpha_gen object at 0x2aba94e1afd0></code></pre><span class="prog__sub">Examples:</span><pre><code>alpha.pdf(x, a) = 1/(x**2*Phi(a)*sqrt(2*pi)) * exp(-1/2 * (a-1/x)**2),</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.alpha.html
scipy stats alpha	R	scipy.stats.alpha										
scipy stats.alpha	R	scipy.stats.alpha										
scipy.stats.anderson	A										<section class="prog__container"><p>Anderson-Darling test for data coming from a particular distribution</p><pre><code>scipy.stats.anderson(x, dist='norm')</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    array of sample data \ndist : {‘norm’,’expon’,’logistic’,’gumbel’,’extreme1’}, optional\n    the type of distribution to test against.  The default is ‘norm’ and ‘extreme1’ is a synonym for ‘gumbel’</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The Anderson-Darling test statistic \ncritical_values : list\n    The critical values for this distribution \nsignificance_level : list\n    The significance levels for the corresponding critical values in percents.  The function returns critical values for a differing set of significance levels depending on the distribution that is being tested against.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.anderson.html
scipy.stats.anderson_ksamp	A										<section class="prog__container"><p>The Anderson-Darling test for k-samples.</p><pre><code>scipy.stats.anderson_ksamp(samples, midrank=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>samples : sequence of 1-D array_like\n    Array of sample data in arrays. \nmidrank : bool, optional\n    Type of Anderson-Darling test which is computed. Default (True) is the midrank test applicable to continuous and discrete populations. If False, the right side empirical distribution is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    Normalized k-sample Anderson-Darling test statistic. \ncritical_values : array\n    The critical values for significance levels 25%, 10%, 5%, 2.5%, 1%. \nsignificance_level : float\n    An approximate significance level at which the null hypothesis for the provided samples can be rejected.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(314159)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.anderson_ksamp.html
scipy stats anderson_ksamp	R	scipy.stats.anderson_ksamp										
scipy stats.anderson_ksamp	R	scipy.stats.anderson_ksamp										
scipy stats anderson	R	scipy.stats.anderson										
scipy stats.anderson	R	scipy.stats.anderson										
scipy.stats.anglit	A										<section class="prog__container"><p>An anglit continuous random variable.</p><pre><code>scipy.stats.anglit = <scipy.stats._continuous_distns.anglit_gen object at 0x2aba94e2f290></code></pre><span class="prog__sub">Examples:</span><pre><code>anglit.pdf(x) = sin(2*x + pi/2) = cos(2*x),</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.anglit.html
scipy stats anglit	R	scipy.stats.anglit										
scipy stats.anglit	R	scipy.stats.anglit										
scipy.stats.ansari	A										<section class="prog__container"><p>Perform the Ansari-Bradley test for equal scale parameters</p><pre><code>scipy.stats.ansari(x, y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    arrays of sample data</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The Ansari-Bradley test statistic \npvalue : float\n    The p-value of the hypothesis test</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ansari.html
scipy stats ansari	R	scipy.stats.ansari										
scipy stats.ansari	R	scipy.stats.ansari										
scipy.stats.arcsine	A										<section class="prog__container"><p>An arcsine continuous random variable.</p><pre><code>scipy.stats.arcsine = <scipy.stats._continuous_distns.arcsine_gen object at 0x2aba94e2f490></code></pre><span class="prog__sub">Examples:</span><pre><code>arcsine.pdf(x) = 1/(pi*sqrt(x*(1-x)))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.arcsine.html
scipy stats arcsine	R	scipy.stats.arcsine										
scipy stats.arcsine	R	scipy.stats.arcsine										
scipy.stats.bartlett	A										<section class="prog__container"><p>Perform Bartlett’s test for equal variances</p><pre><code>scipy.stats.bartlett(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample1, sample2,... : array_like\n    arrays of sample data.  May be different lengths.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The test statistic. \npvalue : float\n    The p-value of the test.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.bartlett.html
scipy stats bartlett	R	scipy.stats.bartlett										
scipy stats.bartlett	R	scipy.stats.bartlett										
scipy.stats.bayes_mvs	A					[[scipy.stats.mvsdist]]					<section class="prog__container"><p>Bayesian confidence intervals for the mean, var, and std.</p><pre><code>scipy.stats.bayes_mvs(data, alpha=0.9)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data, if multi-dimensional it is flattened to 1-D by bayes_mvs. Requires 2 or more data points. \nalpha : float, optional\n    Probability that the returned confidence interval contains the true parameter.</code></pre><span class="prog__sub">Returns:</span><pre><code>mean_cntr, var_cntr, std_cntr : tuple\n    The three results are for the mean, variance and standard deviation, respectively.  Each result is a tuple of the form: (center, (lower, upper))   with center the mean of the conditional pdf of the value given the data, and (lower, upper) a confidence interval, centered on the median, containing the estimate to a probability alpha.</code></pre><span class="prog__sub">Examples:</span><pre><code>(center, (lower, upper))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.bayes_mvs.html
scipy stats bayes_mvs	R	scipy.stats.bayes_mvs										
scipy stats.bayes_mvs	R	scipy.stats.bayes_mvs										
scipy.stats.bernoulli	A										<section class="prog__container"><p>A Bernoulli discrete random variable.</p><pre><code>scipy.stats.bernoulli = <scipy.stats._discrete_distns.bernoulli_gen object at 0x2aba950889d0></code></pre><span class="prog__sub">Examples:</span><pre><code>bernoulli.pmf(k) = 1-p  if k = 0\n                 = p    if k = 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.bernoulli.html
scipy stats bernoulli	R	scipy.stats.bernoulli										
scipy stats.bernoulli	R	scipy.stats.bernoulli										
scipy.stats.beta	A										<section class="prog__container"><p>A beta continuous random variable.</p><pre><code>scipy.stats.beta = <scipy.stats._continuous_distns.beta_gen object at 0x2aba94e2f710></code></pre><span class="prog__sub">Examples:</span><pre><code>gamma(a+b) * x**(a-1) * (1-x)**(b-1)\nbeta.pdf(x, a, b) = ------------------------------------\n                             gamma(a)*gamma(b)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.beta.html
scipy.stats.betai	A										<section class="prog__container"><p>betai is deprecated!\nstats.betai is deprecated in scipy 0.17.0; use special.betainc instead</p><pre><code>scipy.stats.betai(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like or float > 0\n    b : array_like or float > 0  x : array_like or float x will be clipped to be no greater than 1.0 .</code></pre><span class="prog__sub">Returns:</span><pre><code>betai : ndarray\n    Incomplete beta function.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.betai.html
scipy stats betai	R	scipy.stats.betai										
scipy stats.betai	R	scipy.stats.betai										
scipy.stats.betaprime	A										<section class="prog__container"><p>A beta prime continuous random variable.</p><pre><code>scipy.stats.betaprime = <scipy.stats._continuous_distns.betaprime_gen object at 0x2aba94e2f990></code></pre><span class="prog__sub">Examples:</span><pre><code>betaprime.pdf(x, a, b) = x**(a-1) * (1+x)**(-a-b) / beta(a, b)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.betaprime.html
scipy stats betaprime	R	scipy.stats.betaprime										
scipy stats.betaprime	R	scipy.stats.betaprime										
scipy stats beta	R	scipy.stats.beta										
scipy stats.beta	R	scipy.stats.beta										
scipy.stats.binned_statistic_2d	A					[[(in NumPy v1.11)]]\\n[[(in NumPy v1.11)]]\\n[[scipy.stats.binned_statistic]]\\n[[scipy.stats.binned_statistic_dd]]					<section class="prog__container"><p>Compute a bidimensional binned statistic for one or more sets of data.</p><pre><code>scipy.stats.binned_statistic_2d(x, y, values, statistic='mean', bins=10, range=None, expand_binnumbers=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (N,) array_like\n    A sequence of values to be binned along the first dimension. \ny : (N,) array_like\n    A sequence of values to be binned along the second dimension. \nvalues : (N,) array_like or list of (N,) array_like\n    The data on which the statistic will be computed.  This must be the same shape as x, or a list of sequences - each with the same shape as x.  If values is such a list, the statistic will be computed on each independently. \nstatistic : string or callable, optional\n    The statistic to compute (default is ‘mean’). The following statistics are available:   ‘mean’ : compute the mean of values for points within each bin. Empty bins will be represented by NaN. ‘median’ : compute the median of values for points within each bin. Empty bins will be represented by NaN. ‘count’ : compute the count of points within each bin.  This is identical to an unweighted histogram.  values array is not referenced. ‘sum’ : compute the sum of values for points within each bin. This is identical to a weighted histogram. function : a user-defined function which takes a 1D array of values, and outputs a single numerical statistic. This function will be called on the values in each bin.  Empty bins will be represented by function([]), or NaN if this returns an error.   \nbins : int or [int, int] or array_like or [array, array], optional\n    The bin specification:   the number of bins for the two dimensions (nx = ny = bins), the number of bins in each dimension (nx, ny = bins), the bin edges for the two dimensions (x_edge = y_edge = bins), the bin edges in each dimension (x_edge, y_edge = bins).   If the bin edges are specified, the number of bins will be, (nx = len(x_edge)-1, ny = len(y_edge)-1). \nrange : (2,2) array_like, optional\n    The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the bins parameters): [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be considered outliers and not tallied in the histogram. \nexpand_binnumbers : bool, optional\n    ‘False’ (default): the returned binnumber is a shape (N,) array of linearized bin indices. ‘True’: the returned binnumber is ‘unraveled’ into a shape (2,N) ndarray, where each row gives the bin numbers in the corresponding dimension. See the binnumber returned value, and the Examples section.  New in version 0.17.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : (nx, ny) ndarray\n    The values of the selected statistic in each two-dimensional bin. \nx_edge : (nx + 1) ndarray\n    The bin edges along the first dimension. \ny_edge : (ny + 1) ndarray\n    The bin edges along the second dimension. \nbinnumber : (N,) array of ints or (2,N) ndarray of ints\n    This assigns to each element of sample an integer that represents the bin in which this observation falls.  The representation depends on the expand_binnumbers argument.  See Notes for details.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binned_statistic_2d.html
scipy stats binned_statistic_2d	R	scipy.stats.binned_statistic_2d										
scipy stats.binned_statistic_2d	R	scipy.stats.binned_statistic_2d										
scipy.stats.binned_statistic	A					[[(in NumPy v1.11)]]\\n[[(in NumPy v1.11)]]\\n[[scipy.stats.binned_statistic_2d]]\\n[[scipy.stats.binned_statistic_dd]]					<section class="prog__container"><p>Compute a binned statistic for one or more sets of data.</p><pre><code>scipy.stats.binned_statistic(x, values, statistic='mean', bins=10, range=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (N,) array_like\n    A sequence of values to be binned. \nvalues : (N,) array_like or list of (N,) array_like\n    The data on which the statistic will be computed.  This must be the same shape as x, or a set of sequences - each the same shape as x.  If values is a set of sequences, the statistic will be computed on each independently. \nstatistic : string or callable, optional\n    The statistic to compute (default is ‘mean’). The following statistics are available:   ‘mean’ : compute the mean of values for points within each bin. Empty bins will be represented by NaN. ‘median’ : compute the median of values for points within each bin. Empty bins will be represented by NaN. ‘count’ : compute the count of points within each bin.  This is identical to an unweighted histogram.  values array is not referenced. ‘sum’ : compute the sum of values for points within each bin. This is identical to a weighted histogram. function : a user-defined function which takes a 1D array of values, and outputs a single numerical statistic. This function will be called on the values in each bin.  Empty bins will be represented by function([]), or NaN if this returns an error.   \nbins : int or sequence of scalars, optional\n    If bins is an int, it defines the number of equal-width bins in the given range (10 by default).  If bins is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.  Values in x that are smaller than lowest bin edge are assigned to bin number 0, values beyond the highest bin are assigned to bins[-1].  If the bin edges are specified, the number of bins will be, (nx = len(bins)-1). \nrange : (float, float) or [(float, float)], optional\n    The lower and upper range of the bins.  If not provided, range is simply (x.min(), x.max()).  Values outside the range are ignored.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : array\n    The values of the selected statistic in each bin. \nbin_edges : array of dtype float\n    Return the bin edges (length(statistic)+1). \nbinnumber: 1-D ndarray of ints\n    Indices of the bins (corresponding to bin_edges) in which each value of x belongs.  Same length as values.  A binnumber of i means the corresponding value is between (bin_edges[i-1], bin_edges[i]).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binned_statistic.html
scipy.stats.binned_statistic_dd	A					[[(in NumPy v1.11)]]\\n[[(in NumPy v1.11)]]\\n[[scipy.stats.binned_statistic]]\\n[[scipy.stats.binned_statistic_2d]]					<section class="prog__container"><p>Compute a multidimensional binned statistic for a set of data.</p><pre><code>scipy.stats.binned_statistic_dd(sample, values, statistic='mean', bins=10, range=None, expand_binnumbers=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample : array_like\n    Data to histogram passed as a sequence of D arrays of length N, or as an (N,D) array. \nvalues : (N,) array_like or list of (N,) array_like\n    The data on which the statistic will be computed.  This must be the same shape as x, or a list of sequences - each with the same shape as x.  If values is such a list, the statistic will be computed on each independently. \nstatistic : string or callable, optional\n    The statistic to compute (default is ‘mean’). The following statistics are available:   ‘mean’ : compute the mean of values for points within each bin. Empty bins will be represented by NaN. ‘median’ : compute the median of values for points within each bin. Empty bins will be represented by NaN. ‘count’ : compute the count of points within each bin.  This is identical to an unweighted histogram.  values array is not referenced. ‘sum’ : compute the sum of values for points within each bin. This is identical to a weighted histogram. function : a user-defined function which takes a 1D array of values, and outputs a single numerical statistic. This function will be called on the values in each bin.  Empty bins will be represented by function([]), or NaN if this returns an error.   \nbins : sequence or int, optional\n    The bin specification must be in one of the following forms:   A sequence of arrays describing the bin edges along each dimension. The number of bins for each dimension (nx, ny, ... = bins). The number of bins for all dimensions (nx = ny = ... = bins).   \nrange : sequence, optional\n    A sequence of lower and upper bin edges to be used if the edges are not given explicitely in bins. Defaults to the minimum and maximum values along each dimension. \nexpand_binnumbers : bool, optional\n    ‘False’ (default): the returned binnumber is a shape (N,) array of linearized bin indices. ‘True’: the returned binnumber is ‘unraveled’ into a shape (D,N) ndarray, where each row gives the bin numbers in the corresponding dimension. See the binnumber returned value, and the Examples section of binned_statistic_2d.  New in version 0.17.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : ndarray, shape(nx1, nx2, nx3,...)\n    The values of the selected statistic in each two-dimensional bin. \nbin_edges : list of ndarrays\n    A list of D arrays describing the (nxi + 1) bin edges for each dimension. \nbinnumber : (N,) array of ints or (D,N) ndarray of ints\n    This assigns to each element of sample an integer that represents the bin in which this observation falls.  The representation depends on the expand_binnumbers argument.  See Notes for details.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binned_statistic_dd.html
scipy stats binned_statistic_dd	R	scipy.stats.binned_statistic_dd										
scipy stats.binned_statistic_dd	R	scipy.stats.binned_statistic_dd										
scipy stats binned_statistic	R	scipy.stats.binned_statistic										
scipy stats.binned_statistic	R	scipy.stats.binned_statistic										
scipy.stats.binom	A										<section class="prog__container"><p>A binomial discrete random variable.</p><pre><code>scipy.stats.binom = <scipy.stats._discrete_distns.binom_gen object at 0x2aba950887d0></code></pre><span class="prog__sub">Examples:</span><pre><code>binom.pmf(k) = choose(n, k) * p**k * (1-p)**(n-k)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binom.html
scipy stats binom	R	scipy.stats.binom										
scipy stats.binom	R	scipy.stats.binom										
scipy.stats.binom_test	A										<section class="prog__container"><p>Perform a test that the probability of success is p.</p><pre><code>scipy.stats.binom_test(x, n=None, p=0.5, alternative='two-sided')</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : integer or array_like\n    the number of successes, or if x has length 2, it is the number of successes and the number of failures. \nn : integer\n    the number of trials.  This is ignored if x gives both the number of successes and failures \np : float, optional\n    The hypothesized probability of success.  0 <= p <= 1. The default value is p = 0.5 \nalternative : {‘two-sided’, ‘greater’, ‘less’}, optional\n    Indicates the alternative hypothesis. The default value is ‘two-sided’.</code></pre><span class="prog__sub">Returns:</span><pre><code>p-value : float\n    The p-value of the hypothesis test</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.binom_test.html
scipy stats binom_test	R	scipy.stats.binom_test										
scipy stats.binom_test	R	scipy.stats.binom_test										
scipy.stats.boltzmann	A										<section class="prog__container"><p>A Boltzmann (Truncated Discrete Exponential) random variable.</p><pre><code>scipy.stats.boltzmann = <scipy.stats._discrete_distns.boltzmann_gen object at 0x2aba9510f9d0></code></pre><span class="prog__sub">Examples:</span><pre><code>boltzmann.pmf(k) = (1-exp(-lambda_)*exp(-lambda_*k)/(1-exp(-lambda_*N))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boltzmann.html
scipy stats boltzmann	R	scipy.stats.boltzmann										
scipy stats.boltzmann	R	scipy.stats.boltzmann										
scipy.stats.boxcox	A					[[scipy.stats.probplot]]\\n[[scipy.stats.boxcox_normplot]]\\n[[scipy.stats.boxcox_normmax]]\\n[[scipy.stats.boxcox_llf]]					<section class="prog__container"><p>Return a positive dataset transformed by a Box-Cox power transformation.</p><pre><code>scipy.stats.boxcox(x, lmbda=None, alpha=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : ndarray\n    Input array.  Should be 1-dimensional. \nlmbda : {None, scalar}, optional\n    If lmbda is not None, do the transformation for that value. If lmbda is None, find the lambda that maximizes the log-likelihood function and return it as the second output argument. \nalpha : {None, float}, optional\n    If alpha is not None, return the 100 * (1-alpha)% confidence interval for lmbda as the third output argument. Must be between 0.0 and 1.0.</code></pre><span class="prog__sub">Returns:</span><pre><code>boxcox : ndarray\n    Box-Cox power transformed array. \nmaxlog : float, optional\n    If the lmbda parameter is None, the second returned argument is the lambda that maximizes the log-likelihood function. \n(min_ci, max_ci) : tuple of float, optional\n    If lmbda parameter is None and alpha is not None, this returned tuple of floats represents the minimum and maximum confidence limits given alpha.</code></pre><span class="prog__sub">Examples:</span><pre><code>y = (x**lmbda - 1) / lmbda,  for lmbda > 0\n    log(x),                  for lmbda = 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html
scipy.stats.boxcox_llf	A					[[scipy.stats.boxcox]]\\n[[scipy.stats.probplot]]\\n[[scipy.stats.boxcox_normplot]]\\n[[scipy.stats.boxcox_normmax]]					<section class="prog__container"><p>The boxcox log-likelihood function.</p><pre><code>scipy.stats.boxcox_llf(lmb, data)</code></pre><span class="prog__sub">Parameters:</span><pre><code>lmb : scalar\n    Parameter for Box-Cox transformation.  See boxcox for details. \ndata : array_like\n    Data to calculate Box-Cox log-likelihood for.  If data is multi-dimensional, the log-likelihood is calculated along the first axis.</code></pre><span class="prog__sub">Returns:</span><pre><code>llf : float or ndarray\n    Box-Cox log-likelihood of data given lmb.  A float for 1-D data, an array otherwise.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> import matplotlib.pyplot as plt\n>>> from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n>>> np.random.seed(1245)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox_llf.html
scipy stats boxcox_llf	R	scipy.stats.boxcox_llf										
scipy stats.boxcox_llf	R	scipy.stats.boxcox_llf										
scipy.stats.boxcox_normmax	A					[[scipy.stats.boxcox]]\\n[[scipy.stats.boxcox_llf]]\\n[[scipy.stats.boxcox_normplot]]					<section class="prog__container"><p>Compute optimal Box-Cox transform parameter for input data.</p><pre><code>scipy.stats.boxcox_normmax(x, brack=(-2.0, 2.0), method='pearsonr')</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nbrack : 2-tuple, optional\n    The starting interval for a downhill bracket search with optimize.brent.  Note that this is in most cases not critical; the final result is allowed to be outside this bracket. \nmethod : str, optional\n    The method to determine the optimal transform parameter (boxcox lmbda parameter). Options are:  ‘pearsonr’  (default) Maximizes the Pearson correlation coefficient between y = boxcox(x) and the expected values for y if x would be normally-distributed.  ‘mle’ Minimizes the log-likelihood boxcox_llf.  This is the method used in boxcox.  ‘all’ Use all optimization methods available, and return all results. Useful to compare different methods.</code></pre><span class="prog__sub">Returns:</span><pre><code>maxlog : float or ndarray\n    The optimal transform parameter found.  An array instead of a scalar for method='all'.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> import matplotlib.pyplot as plt\n>>> np.random.seed(1234)  # make this example reproducible</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox_normmax.html
scipy stats boxcox_normmax	R	scipy.stats.boxcox_normmax										
scipy stats.boxcox_normmax	R	scipy.stats.boxcox_normmax										
scipy.stats.boxcox_normplot	A					[[scipy.stats.probplot]]\\n[[scipy.stats.boxcox]]\\n[[scipy.stats.boxcox_normmax]]\\n[[scipy.stats.boxcox_llf]]\\n[[scipy.stats.ppcc_max]]					<section class="prog__container"><p>Compute parameters for a Box-Cox normality plot, optionally show it.</p><pre><code>scipy.stats.boxcox_normplot(x, la, lb, plot=None, N=80)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nla, lb : scalar\n    The lower and upper bounds for the lmbda values to pass to boxcox for Box-Cox transformations.  These are also the limits of the horizontal axis of the plot if that is generated. \nplot : object, optional\n    If given, plots the quantiles and least squares fit. plot is an object that has to have methods “plot” and “text”. The matplotlib.pyplot module or a Matplotlib Axes object can be used, or a custom object with the same methods. Default is None, which means that no plot is created. \nN : int, optional\n    Number of points on the horizontal axis (equally distributed from la to lb).</code></pre><span class="prog__sub">Returns:</span><pre><code>lmbdas : ndarray\n    The lmbda values for which a Box-Cox transform was done. \nppcc : ndarray\n    Probability Plot Correlelation Coefficient, as obtained from probplot when fitting the Box-Cox transformed input x against a normal distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox_normplot.html
scipy stats boxcox_normplot	R	scipy.stats.boxcox_normplot										
scipy stats.boxcox_normplot	R	scipy.stats.boxcox_normplot										
scipy stats boxcox	R	scipy.stats.boxcox										
scipy stats.boxcox	R	scipy.stats.boxcox										
scipy.stats.bradford	A										<section class="prog__container"><p>A Bradford continuous random variable.</p><pre><code>scipy.stats.bradford = <scipy.stats._continuous_distns.bradford_gen object at 0x2aba94e2fc10></code></pre><span class="prog__sub">Examples:</span><pre><code>bradford.pdf(x, c) = c / (k * (1+c*x)),</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.bradford.html
scipy stats bradford	R	scipy.stats.bradford										
scipy stats.bradford	R	scipy.stats.bradford										
scipy.stats.burr12	A										<section class="prog__container"><p>A Burr (Type XII) continuous random variable.</p><pre><code>scipy.stats.burr12 = <scipy.stats._continuous_distns.burr12_gen object at 0x2aba94e3c190></code></pre><span class="prog__sub">Examples:</span><pre><code>burr12.pdf(x, c, d) = c * d * x**(c-1) * (1+x**(c))**(-d-1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.burr12.html
scipy stats burr12	R	scipy.stats.burr12										
scipy stats.burr12	R	scipy.stats.burr12										
scipy.stats.burr	A										<section class="prog__container"><p>A Burr (Type III) continuous random variable.</p><pre><code>scipy.stats.burr = <scipy.stats._continuous_distns.burr_gen object at 0x2aba94e2fed0></code></pre><span class="prog__sub">Examples:</span><pre><code>burr.pdf(x, c, d) = c * d * x**(-c-1) * (1+x**(-c))**(-d-1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.burr.html
scipy stats burr	R	scipy.stats.burr										
scipy stats.burr	R	scipy.stats.burr										
scipy.stats.cauchy	A										<section class="prog__container"><p>A Cauchy continuous random variable.</p><pre><code>scipy.stats.cauchy = <scipy.stats._continuous_distns.cauchy_gen object at 0x2aba94e3c690></code></pre><span class="prog__sub">Examples:</span><pre><code>cauchy.pdf(x) = 1 / (pi * (1 + x**2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.cauchy.html
scipy stats cauchy	R	scipy.stats.cauchy										
scipy stats.cauchy	R	scipy.stats.cauchy										
scipy.stats.chi2	A										<section class="prog__container"><p>A chi-squared continuous random variable.</p><pre><code>scipy.stats.chi2 = <scipy.stats._continuous_distns.chi2_gen object at 0x2aba94e3cb10></code></pre><span class="prog__sub">Examples:</span><pre><code>chi2.pdf(x, df) = 1 / (2*gamma(df/2)) * (x/2)**(df/2-1) * exp(-x/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.chi2.html
scipy.stats.chi2_contingency	A					[[scipy.stats.contingency.expected_freq]]\\n[[scipy.stats.fisher_exact]]\\n[[scipy.stats.chisquare]]\\n[[scipy.stats.power_divergence]]					<section class="prog__container"><p>Chi-square test of independence of variables in a contingency table.</p><pre><code>scipy.stats.chi2_contingency(observed, correction=True, lambda_=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>observed : array_like\n    The contingency table. The table contains the observed frequencies (i.e. number of occurrences) in each category.  In the two-dimensional case, the table is often described as an “R x C table”. \ncorrection : bool, optional\n    If True, and the degrees of freedom is 1, apply Yates’ correction for continuity.  The effect of the correction is to adjust each observed value by 0.5 towards the corresponding expected value. \nlambda_ : float or str, optional.\n    By default, the statistic computed in this test is Pearson’s chi-squared statistic [R503].  lambda_ allows a statistic from the Cressie-Read power divergence family [R504] to be used instead.  See power_divergence for details.</code></pre><span class="prog__sub">Returns:</span><pre><code>chi2 : float\n    The test statistic. \np : float\n    The p-value of the test \ndof : int\n    Degrees of freedom \nexpected : ndarray, same shape as observed\n    The expected frequencies, based on the marginal sums of the table.</code></pre><span class="prog__sub">Examples:</span><pre><code>dof = observed.size - sum(observed.shape) + observed.ndim - 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.chi2_contingency.html
scipy stats chi2_contingency	R	scipy.stats.chi2_contingency										
scipy stats.chi2_contingency	R	scipy.stats.chi2_contingency										
scipy stats chi2	R	scipy.stats.chi2										
scipy stats.chi2	R	scipy.stats.chi2										
scipy.stats.chi	A										<section class="prog__container"><p>A chi continuous random variable.</p><pre><code>scipy.stats.chi = <scipy.stats._continuous_distns.chi_gen object at 0x2aba94e3c8d0></code></pre><span class="prog__sub">Examples:</span><pre><code>chi.pdf(x, df) = x**(df-1) * exp(-x**2/2) / (2**(df/2-1) * gamma(df/2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.chi.html
scipy stats chi	R	scipy.stats.chi										
scipy stats.chi	R	scipy.stats.chi										
scipy.stats.chisqprob	A										<section class="prog__container"><p>chisqprob is deprecated!\nstats.chisqprob is deprecated in scipy 0.17.0; use stats.distributions.chi2.sf instead.</p><pre><code>scipy.stats.chisqprob(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>chisq : array_like or float > 0\n    df : array_like or float, probably int >= 1</code></pre><span class="prog__sub">Returns:</span><pre><code>chisqprob : ndarray\n    The area from chisq to infinity under the Chi^2 probability distribution with degrees of freedom df.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.chisqprob.html
scipy stats chisqprob	R	scipy.stats.chisqprob										
scipy stats.chisqprob	R	scipy.stats.chisqprob										
scipy.stats.chisquare	A					[[scipy.stats.power_divergence]]\\n[[scipy.stats.mstats.chisquare]]					<section class="prog__container"><p>Calculates a one-way chi square test.</p><pre><code>scipy.stats.chisquare(f_obs, f_exp=None, ddof=0, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f_obs : array_like\n    Observed frequencies in each category. \nf_exp : array_like, optional\n    Expected frequencies in each category.  By default the categories are assumed to be equally likely. \nddof : int, optional\n    “Delta degrees of freedom”: adjustment to the degrees of freedom for the p-value.  The p-value is computed using a chi-squared distribution with k - 1 - ddof degrees of freedom, where k is the number of observed frequencies.  The default value of ddof is 0. \naxis : int or None, optional\n    The axis of the broadcast result of f_obs and f_exp along which to apply the test.  If axis is None, all values in f_obs are treated as a single data set.  Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>chisq : float or ndarray\n    The chi-squared test statistic.  The value is a float if axis is None or f_obs and f_exp are 1-D. \np : float or ndarray\n    The p-value of the test.  The value is a float if ddof and the return value chisq are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import chisquare\n>>> chisquare([16, 18, 16, 14, 12, 12])\n(2.0, 0.84914503608460956)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.chisquare.html
scipy stats chisquare	R	scipy.stats.chisquare										
scipy stats.chisquare	R	scipy.stats.chisquare										
scipy.stats.circmean	A										<section class="prog__container"><p>Compute the circular mean for samples in a range.</p><pre><code>scipy.stats.circmean(samples, high=6.283185307179586, low=0, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>samples : array_like\n    Input array. \nhigh : float or int, optional\n    High boundary for circular mean range.  Default is 2*pi. \nlow : float or int, optional\n    Low boundary for circular mean range.  Default is 0. \naxis : int, optional\n    Axis along which means are computed.  The default is to compute the mean of the flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>circmean : float\n    Circular mean.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.circmean.html
scipy stats circmean	R	scipy.stats.circmean										
scipy stats.circmean	R	scipy.stats.circmean										
scipy.stats.circstd	A										<section class="prog__container"><p>Compute the circular standard deviation for samples assumed to be in the\nrange [low to high].</p><pre><code>scipy.stats.circstd(samples, high=6.283185307179586, low=0, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>samples : array_like\n    Input array. \nlow : float or int, optional\n    Low boundary for circular standard deviation range.  Default is 0. \nhigh : float or int, optional\n    High boundary for circular standard deviation range. Default is 2*pi. \naxis : int, optional\n    Axis along which standard deviations are computed.  The default is to compute the standard deviation of the flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>circstd : float\n    Circular standard deviation.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.circstd.html
scipy stats circstd	R	scipy.stats.circstd										
scipy stats.circstd	R	scipy.stats.circstd										
scipy.stats.circvar	A										<section class="prog__container"><p>Compute the circular variance for samples assumed to be in a range</p><pre><code>scipy.stats.circvar(samples, high=6.283185307179586, low=0, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>samples : array_like\n    Input array. \nlow : float or int, optional\n    Low boundary for circular variance range.  Default is 0. \nhigh : float or int, optional\n    High boundary for circular variance range.  Default is 2*pi. \naxis : int, optional\n    Axis along which variances are computed.  The default is to compute the variance of the flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>circvar : float\n    Circular variance.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.circvar.html
scipy stats circvar	R	scipy.stats.circvar										
scipy stats.circvar	R	scipy.stats.circvar										
scipy.stats.combine_pvalues	A										<section class="prog__container"><p>Methods for combining the p-values of independent tests bearing upon the\nsame hypothesis.</p><pre><code>scipy.stats.combine_pvalues(pvalues, method='fisher', weights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pvalues : array_like, 1-D\n    Array of p-values assumed to come from independent tests. \nmethod : {‘fisher’, ‘stouffer’}, optional\n    Name of method to use to combine p-values. The following methods are available:  “fisher”: Fisher’s method (Fisher’s combined probability test), the default. “stouffer”: Stouffer’s Z-score method.  \nweights : array_like, 1-D, optional\n    Optional array of weights used only for Stouffer’s Z-score method.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic: float\n    The statistic calculated by the specified method: - “fisher”: The chi-squared statistic - “stouffer”: The Z-score \npval: float\n    The combined p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.combine_pvalues.html
scipy stats combine_pvalues	R	scipy.stats.combine_pvalues										
scipy stats.combine_pvalues	R	scipy.stats.combine_pvalues										
scipy.stats.contingency.expected_freq	A										<section class="prog__container"><p>Compute the expected frequencies from a contingency table.</p><pre><code>scipy.stats.contingency.expected_freq(observed)</code></pre><span class="prog__sub">Parameters:</span><pre><code>observed : array_like\n    The table of observed frequencies.  (While this function can handle a 1-D array, that case is trivial.  Generally observed is at least 2-D.)</code></pre><span class="prog__sub">Returns:</span><pre><code>expected : ndarray of float64\n    The expected frequencies, based on the marginal sums of the table. Same shape as observed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> observed = np.array([[10, 10, 20],[20, 20, 20]])\n>>> from scipy.stats import expected_freq\n>>> expected_freq(observed)\narray([[ 12.,  12.,  16.],\n       [ 18.,  18.,  24.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.contingency.expected_freq.html
scipy stats contingency expected_freq	R	scipy.stats.contingency.expected_freq										
scipy stats.contingency.expected_freq	R	scipy.stats.contingency.expected_freq										
scipy.stats.contingency.margins	A										<section class="prog__container"><p>Return a list of the marginal sums of the array a.</p><pre><code>scipy.stats.contingency.margins(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    The array for which to compute the marginal sums.</code></pre><span class="prog__sub">Returns:</span><pre><code>margsums : list of ndarrays\n    A list of length a.ndim.  margsums[k] is the result of summing a over all axes except k; it has the same number of dimensions as a, but the length of each axis except axis k will be 1.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.arange(12).reshape(2, 6)\n>>> a\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11]])\n>>> m0, m1 = margins(a)\n>>> m0\narray([[15],\n       [51]])\n>>> m1\narray([[ 6,  8, 10, 12, 14, 16]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.contingency.margins.html
scipy stats contingency margins	R	scipy.stats.contingency.margins										
scipy stats.contingency.margins	R	scipy.stats.contingency.margins										
scipy.stats.cosine	A										<section class="prog__container"><p>A cosine continuous random variable.</p><pre><code>scipy.stats.cosine = <scipy.stats._continuous_distns.cosine_gen object at 0x2aba94e3cd90></code></pre><span class="prog__sub">Examples:</span><pre><code>cosine.pdf(x) = 1/(2*pi) * (1+cos(x))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.cosine.html
scipy stats cosine	R	scipy.stats.cosine										
scipy stats.cosine	R	scipy.stats.cosine										
scipy.stats.cumfreq	A										<section class="prog__container"><p>Returns a cumulative frequency histogram, using the histogram function.</p><pre><code>scipy.stats.cumfreq(a, numbins=10, defaultreallimits=None, weights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nnumbins : int, optional\n    The number of bins to use for the histogram. Default is 10. \ndefaultreallimits : tuple (lower, upper), optional\n    The lower and upper values for the range of the histogram. If no value is given, a range slightly larger than the range of the values in a is used. Specifically (a.min() - s, a.max() + s), where s = (1/2)(a.max() - a.min()) / (numbins - 1). \nweights : array_like, optional\n    The weights for each value in a. Default is None, which gives each value a weight of 1.0</code></pre><span class="prog__sub">Returns:</span><pre><code>cumcount : ndarray\n    Binned values of cumulative frequency. \nlowerlimit : float\n    Lower real limit \nbinsize : float\n    Width of each bin. \nextrapoints : int\n    Extra points.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy import stats\n>>> x = [1, 4, 2, 1, 3, 1]\n>>> res = stats.cumfreq(x, numbins=4, defaultreallimits=(1.5, 5))\n>>> res.cumcount\narray([ 1.,  2.,  3.,  3.])\n>>> res.extrapoints\n3</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.cumfreq.html
scipy stats cumfreq	R	scipy.stats.cumfreq										
scipy stats.cumfreq	R	scipy.stats.cumfreq										
scipy.stats.describe	A					[[scipy.stats.skew]]\\n[[scipy.stats.kurtosis]]					<section class="prog__container"><p>Computes several descriptive statistics of the passed array.</p><pre><code>scipy.stats.describe(a, axis=0, ddof=1, bias=True, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data. \naxis : int or None, optional\n    Axis along which statistics are calculated. Default is 0. If None, compute over the whole array a. \nddof : int, optional\n    Delta degrees of freedom (only for variance).  Default is 1. \nbias : bool, optional\n    If False, then the skewness and kurtosis calculations are corrected for statistical bias. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>nobs : int\n    Number of observations (length of data along axis). \nminmax: tuple of ndarrays or floats\n    Minimum and maximum value of data array. \nmean : ndarray or float\n    Arithmetic mean of data along axis. \nvariance : ndarray or float\n    Unbiased variance of the data along axis, denominator is number of observations minus one. \nskewness : ndarray or float\n    Skewness, based on moment calculations with denominator equal to the number of observations, i.e. no degrees of freedom correction. \nkurtosis : ndarray or float\n    Kurtosis (Fisher).  The kurtosis is normalized so that it is zero for the normal distribution.  No degrees of freedom are used.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> a = np.arange(10)\n>>> stats.describe(a)\nDescribeResult(nobs=10, minmax=(0, 9), mean=4.5, variance=9.1666666666666661,\n               skewness=0.0, kurtosis=-1.2242424242424244)\n>>> b = [[1, 2], [3, 4]]\n>>> stats.describe(b)\nDescribeResult(nobs=2, minmax=(array([1, 2]), array([3, 4])),\n               mean=array([ 2., 3.]), variance=array([ 2., 2.]),\n               skewness=array([ 0., 0.]), kurtosis=array([-2., -2.]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.describe.html
scipy stats describe	R	scipy.stats.describe										
scipy stats.describe	R	scipy.stats.describe										
scipy.stats.dgamma	A										<section class="prog__container"><p>A double gamma continuous random variable.</p><pre><code>scipy.stats.dgamma = <scipy.stats._continuous_distns.dgamma_gen object at 0x2aba94e3cf90></code></pre><span class="prog__sub">Examples:</span><pre><code>dgamma.pdf(x, a) = 1 / (2*gamma(a)) * abs(x)**(a-1) * exp(-abs(x))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.dgamma.html
scipy stats dgamma	R	scipy.stats.dgamma										
scipy stats.dgamma	R	scipy.stats.dgamma										
scipy.stats.dirichlet	A										<section class="prog__container"><p>A Dirichlet random variable.</p><pre><code>scipy.stats.dirichlet = <scipy.stats._multivariate.dirichlet_gen object at 0x2aba953e4a50></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Quantiles, with the last axis of x denoting the components. \nalpha : array_like\n    The concentration parameters. The number of entries determines the dimensionality of the distribution. \nrandom_state : None or int or np.random.RandomState instance, optional\n    If int or RandomState, use it for drawing the random variates. If None (or np.random), the global np.random state is used. Default is None. \nAlternatively, the object may be called (as a function) to fix\nconcentration parameters, returning a “frozen” Dirichlet\nrandom variable:\nrv = dirichlet(alpha)\n    Frozen object with the same methods but holding the given concentration parameters fixed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.dirichlet.html
scipy stats dirichlet	R	scipy.stats.dirichlet										
scipy stats.dirichlet	R	scipy.stats.dirichlet										
scipy.stats.dlaplace	A										<section class="prog__container"><p>A  Laplacian discrete random variable.</p><pre><code>scipy.stats.dlaplace = <scipy.stats._discrete_distns.dlaplace_gen object at 0x2aba95116110></code></pre><span class="prog__sub">Examples:</span><pre><code>dlaplace.pmf(k) = tanh(a/2) * exp(-a*abs(k))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.dlaplace.html
scipy stats dlaplace	R	scipy.stats.dlaplace										
scipy stats.dlaplace	R	scipy.stats.dlaplace										
scipy.stats.dweibull	A										<section class="prog__container"><p>A double Weibull continuous random variable.</p><pre><code>scipy.stats.dweibull = <scipy.stats._continuous_distns.dweibull_gen object at 0x2aba95072250></code></pre><span class="prog__sub">Examples:</span><pre><code>dweibull.pdf(x, c) = c / 2 * abs(x)**(c-1) * exp(-abs(x)**c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.dweibull.html
scipy stats dweibull	R	scipy.stats.dweibull										
scipy stats.dweibull	R	scipy.stats.dweibull										
scipy.stats.entropy	A										<section class="prog__container"><p>Calculate the entropy of a distribution for given probability values.</p><pre><code>scipy.stats.entropy(pk, qk=None, base=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>pk : sequence\n    Defines the (discrete) distribution. pk[i] is the (possibly unnormalized) probability of event i. \nqk : sequence, optional\n    Sequence against which the relative entropy is computed. Should be in the same format as pk. \nbase : float, optional\n    The logarithmic base to use, defaults to e (natural logarithm).</code></pre><span class="prog__sub">Returns:</span><pre><code>S : float\n    The calculated entropy.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.entropy.html
scipy stats entropy	R	scipy.stats.entropy										
scipy stats.entropy	R	scipy.stats.entropy										
scipy.stats.erlang	A					[[scipy.stats.gamma]]					<section class="prog__container"><p>An Erlang continuous random variable.</p><pre><code>scipy.stats.erlang = <scipy.stats._continuous_distns.erlang_gen object at 0x2aba9508cf10></code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.erlang.html
scipy stats erlang	R	scipy.stats.erlang										
scipy stats.erlang	R	scipy.stats.erlang										
scipy.stats.expon	A										<section class="prog__container"><p>An exponential continuous random variable.</p><pre><code>scipy.stats.expon = <scipy.stats._continuous_distns.expon_gen object at 0x2aba950724d0></code></pre><span class="prog__sub">Examples:</span><pre><code>expon.pdf(x) = exp(-x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.expon.html
scipy.stats.exponnorm	A										<section class="prog__container"><p>An exponentially modified Normal continuous random variable.</p><pre><code>scipy.stats.exponnorm = <scipy.stats._continuous_distns.exponnorm_gen object at 0x2aba950726d0></code></pre><span class="prog__sub">Examples:</span><pre><code>exponnorm.pdf(x, K) = 1/(2*K) exp(1/(2 * K**2)) exp(-x / K) * erfc(-(x - 1/K) / sqrt(2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.exponnorm.html
scipy stats exponnorm	R	scipy.stats.exponnorm										
scipy stats.exponnorm	R	scipy.stats.exponnorm										
scipy.stats.exponpow	A										<section class="prog__container"><p>An exponential power continuous random variable.</p><pre><code>scipy.stats.exponpow = <scipy.stats._continuous_distns.exponpow_gen object at 0x2aba95072bd0></code></pre><span class="prog__sub">Examples:</span><pre><code>exponpow.pdf(x, b) = b * x**(b-1) * exp(1 + x**b - exp(x**b))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.exponpow.html
scipy stats exponpow	R	scipy.stats.exponpow										
scipy stats.exponpow	R	scipy.stats.exponpow										
scipy stats expon	R	scipy.stats.expon										
scipy stats.expon	R	scipy.stats.expon										
scipy.stats.exponweib	A										<section class="prog__container"><p>An exponentiated Weibull continuous random variable.</p><pre><code>scipy.stats.exponweib = <scipy.stats._continuous_distns.exponweib_gen object at 0x2aba95072950></code></pre><span class="prog__sub">Examples:</span><pre><code>exponweib.pdf(x, a, c) =\n    a * c * (1-exp(-x**c))**(a-1) * exp(-x**c)*x**(c-1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.exponweib.html
scipy stats exponweib	R	scipy.stats.exponweib										
scipy stats.exponweib	R	scipy.stats.exponweib										
scipy.stats.f	A										<section class="prog__container"><p>An F continuous random variable.</p><pre><code>scipy.stats.f = <scipy.stats._continuous_distns.f_gen object at 0x2aba95079390></code></pre><span class="prog__sub">Examples:</span><pre><code>df2**(df2/2) * df1**(df1/2) * x**(df1/2-1)\nF.pdf(x, df1, df2) = --------------------------------------------\n                     (df2+df1*x)**((df1+df2)/2) * B(df1/2, df2/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.f.html
scipy.stats.fatiguelife	A										<section class="prog__container"><p>A fatigue-life (Birnbaum-Saunders) continuous random variable.</p><pre><code>scipy.stats.fatiguelife = <scipy.stats._continuous_distns.fatiguelife_gen object at 0x2aba95072e50></code></pre><span class="prog__sub">Examples:</span><pre><code>fatiguelife.pdf(x, c) =\n    (x+1) / (2*c*sqrt(2*pi*x**3)) * exp(-(x-1)**2/(2*x*c**2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.fatiguelife.html
scipy stats fatiguelife	R	scipy.stats.fatiguelife										
scipy stats.fatiguelife	R	scipy.stats.fatiguelife										
scipy.stats.find_repeats	A										<section class="prog__container"><p>Find repeats and repeat counts.</p><pre><code>scipy.stats.find_repeats(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : array_like\n    Input array. This is cast to float64.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : ndarray\n    The unique values from the (flattened) input that are repeated. \ncounts : ndarray\n    Number of times the corresponding ‘value’ is repeated.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> stats.find_repeats([2, 1, 2, 3, 2, 2, 5])\nRepeatedResults(values=array([ 2.]), counts=array([4]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.find_repeats.html
scipy stats find_repeats	R	scipy.stats.find_repeats										
scipy stats.find_repeats	R	scipy.stats.find_repeats										
scipy.stats.fisher_exact	A										<section class="prog__container"><p>Performs a Fisher exact test on a 2x2 contingency table.</p><pre><code>scipy.stats.fisher_exact(table, alternative='two-sided')</code></pre><span class="prog__sub">Parameters:</span><pre><code>table : array_like of ints\n    A 2x2 contingency table.  Elements should be non-negative integers. \nalternative : {‘two-sided’, ‘less’, ‘greater’}, optional\n    Which alternative hypothesis to the null hypothesis the test uses. Default is ‘two-sided’.</code></pre><span class="prog__sub">Returns:</span><pre><code>oddsratio : float\n    This is prior odds ratio and not a posterior estimate. \np_value : float\n    P-value, the probability of obtaining a distribution at least as extreme as the one that was actually observed, assuming that the null hypothesis is true.</code></pre><span class="prog__sub">Examples:</span><pre><code>Atlantic  Indian\nwhales     8        2\nsharks     1        5</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.fisher_exact.html
scipy stats fisher_exact	R	scipy.stats.fisher_exact										
scipy stats.fisher_exact	R	scipy.stats.fisher_exact										
scipy.stats.fisk	A					[[scipy.stats.burr]]					<section class="prog__container"><p>A Fisk continuous random variable.</p><pre><code>scipy.stats.fisk = <scipy.stats._continuous_distns.fisk_gen object at 0x2aba94e3c410></code></pre><span class="prog__sub">Examples:</span><pre><code>fisk.pdf(x, c) = c * x**(-c-1) * (1 + x**(-c))**(-2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.fisk.html
scipy stats fisk	R	scipy.stats.fisk										
scipy stats.fisk	R	scipy.stats.fisk										
scipy.stats.fligner	A										<section class="prog__container"><p>Perform Fligner-Killeen test for equality of variance.</p><pre><code>scipy.stats.fligner(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample1, sample2, ... : array_like\n    Arrays of sample data.  Need not be the same length. \ncenter : {‘mean’, ‘median’, ‘trimmed’}, optional\n    Keyword argument controlling which function of the data is used in computing the test statistic.  The default is ‘median’. \nproportiontocut : float, optional\n    When center is ‘trimmed’, this gives the proportion of data points to cut from each end. (See scipy.stats.trim_mean.) Default is 0.05.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The test statistic. \npvalue : float\n    The p-value for the hypothesis test.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.fligner.html
scipy stats fligner	R	scipy.stats.fligner										
scipy stats.fligner	R	scipy.stats.fligner										
scipy.stats.foldcauchy	A										<section class="prog__container"><p>A folded Cauchy continuous random variable.</p><pre><code>scipy.stats.foldcauchy = <scipy.stats._continuous_distns.foldcauchy_gen object at 0x2aba95079110></code></pre><span class="prog__sub">Examples:</span><pre><code>foldcauchy.pdf(x, c) = 1/(pi*(1+(x-c)**2)) + 1/(pi*(1+(x+c)**2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.foldcauchy.html
scipy stats foldcauchy	R	scipy.stats.foldcauchy										
scipy stats.foldcauchy	R	scipy.stats.foldcauchy										
scipy.stats.foldnorm	A										<section class="prog__container"><p>A folded normal continuous random variable.</p><pre><code>scipy.stats.foldnorm = <scipy.stats._continuous_distns.foldnorm_gen object at 0x2aba95079610></code></pre><span class="prog__sub">Examples:</span><pre><code>foldnormal.pdf(x, c) = sqrt(2/pi) * cosh(c*x) * exp(-(x**2+c**2)/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.foldnorm.html
scipy stats foldnorm	R	scipy.stats.foldnorm										
scipy stats.foldnorm	R	scipy.stats.foldnorm										
scipy.stats.f_oneway	A										<section class="prog__container"><p>Performs a 1-way ANOVA.</p><pre><code>scipy.stats.f_oneway(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample1, sample2, ... : array_like\n    The sample measurements for each group.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The computed F-value of the test. \npvalue : float\n    The associated p-value from the F-distribution.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import scipy.stats as stats</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.f_oneway.html
scipy stats f_oneway	R	scipy.stats.f_oneway										
scipy stats.f_oneway	R	scipy.stats.f_oneway										
scipy.stats.frechet_l	A					[[scipy.stats.frechet_r]]\\n[[scipy.stats.weibull_min]]					<section class="prog__container"><p>A Frechet left (or Weibull maximum) continuous random variable.</p><pre><code>scipy.stats.frechet_l = <scipy.stats._continuous_distns.frechet_l_gen object at 0x2aba95079d50></code></pre><span class="prog__sub">Examples:</span><pre><code>frechet_l.pdf(x, c) = c * (-x)**(c-1) * exp(-(-x)**c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.frechet_l.html
scipy stats frechet_l	R	scipy.stats.frechet_l										
scipy stats.frechet_l	R	scipy.stats.frechet_l										
scipy.stats.frechet_r	A					[[scipy.stats.frechet_l]]\\n[[scipy.stats.weibull_max]]					<section class="prog__container"><p>A Frechet right (or Weibull minimum) continuous random variable.</p><pre><code>scipy.stats.frechet_r = <scipy.stats._continuous_distns.frechet_r_gen object at 0x2aba95079890></code></pre><span class="prog__sub">Examples:</span><pre><code>frechet_r.pdf(x, c) = c * x**(c-1) * exp(-x**c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.frechet_r.html
scipy stats frechet_r	R	scipy.stats.frechet_r										
scipy stats.frechet_r	R	scipy.stats.frechet_r										
scipy.stats.friedmanchisquare	A										<section class="prog__container"><p>Computes the Friedman test for repeated measurements</p><pre><code>scipy.stats.friedmanchisquare(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>measurements1, measurements2, measurements3... : array_like\n    Arrays of measurements.  All of the arrays must have the same number of elements.  At least 3 sets of measurements must be given.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    the test statistic, correcting for ties \npvalue : float\n    the associated p-value assuming that the test statistic has a chi squared distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.friedmanchisquare.html
scipy stats friedmanchisquare	R	scipy.stats.friedmanchisquare										
scipy stats.friedmanchisquare	R	scipy.stats.friedmanchisquare										
scipy stats f	R	scipy.stats.f										
scipy stats.f	R	scipy.stats.f										
scipy.stats.f_value	A										<section class="prog__container"><p>f_value is deprecated!\nstats.f_value deprecated in scipy 0.17.0</p><pre><code>scipy.stats.f_value(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>ER : float\n    ER is the sum of squared residuals for the restricted model or null hypothesis     EF : float  EF is the sum of squared residuals for the unrestricted model or alternate hypothesis    dfR : int dfR is the degrees of freedom in the restricted model  dfF : int dfF is the degrees of freedom in the unrestricted model</code></pre><span class="prog__sub">Returns:</span><pre><code>F-statistic : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.f_value.html
scipy stats f_value	R	scipy.stats.f_value										
scipy stats.f_value	R	scipy.stats.f_value										
scipy.stats.gamma	A					[[scipy.stats.erlang]]\\n[[scipy.stats.expon]]					<section class="prog__container"><p>A gamma continuous random variable.</p><pre><code>scipy.stats.gamma = <scipy.stats._continuous_distns.gamma_gen object at 0x2aba9508cc90></code></pre><span class="prog__sub">Examples:</span><pre><code>gamma.pdf(x, a) = x**(a-1) * exp(-x) / gamma(a)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gamma.html
scipy stats gamma	R	scipy.stats.gamma										
scipy stats.gamma	R	scipy.stats.gamma										
scipy.stats.gausshyper	A										<section class="prog__container"><p>A Gauss hypergeometric continuous random variable.</p><pre><code>scipy.stats.gausshyper = <scipy.stats._continuous_distns.gausshyper_gen object at 0x2aba950a0590></code></pre><span class="prog__sub">Examples:</span><pre><code>gausshyper.pdf(x, a, b, c, z) =\n    C * x**(a-1) * (1-x)**(b-1) * (1+z*x)**(-c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gausshyper.html
scipy stats gausshyper	R	scipy.stats.gausshyper										
scipy stats.gausshyper	R	scipy.stats.gausshyper										
scipy.stats.gaussian_kde	A										<section class="prog__container"><p>Representation of a kernel-density estimate using Gaussian kernels.</p><pre><code>class scipy.stats.gaussian_kde(dataset, bw_method=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>dataset : array_like\n    Datapoints to estimate from. In case of univariate data this is a 1-D array, otherwise a 2-D array with shape (# of dims, # of data). \nbw_method : str, scalar or callable, optional\n    The method used to calculate the estimator bandwidth.  This can be ‘scott’, ‘silverman’, a scalar constant or a callable.  If a scalar, this will be used directly as kde.factor.  If a callable, it should take a gaussian_kde instance as only parameter and return a scalar. If None (default), ‘scott’ is used.  See Notes for more details.</code></pre><span class="prog__sub">Examples:</span><pre><code>n**(-1./(d+4)),</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html
scipy.stats.gaussian_kde.__call__	A										<section class="prog__container"><p>Evaluate the estimated pdf on a set of points.</p><pre><code>gaussian_kde.__call__(points)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : (# of dimensions, # of points)-array\n    Alternatively, a (# of dimensions,) vector can be passed in and treated as a single point.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : (# of points,)-array\n    The values at each point.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.__call__.html
scipy stats gaussian_kde __call__	R	scipy.stats.gaussian_kde.__call__										
scipy stats.gaussian_kde.__call__	R	scipy.stats.gaussian_kde.__call__										
scipy.stats.gaussian_kde.covariance_factor	A										<section class="prog__container"><p>Computes the coefficient (kde.factor) that\nmultiplies the data covariance matrix to obtain the kernel covariance\nmatrix. The default is scotts_factor.  A subclass can overwrite this\nmethod to provide a different method, or set it through a call to\nkde.set_bandwidth.</p><pre><code>gaussian_kde.covariance_factor()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.covariance_factor.html
scipy stats gaussian_kde covariance_factor	R	scipy.stats.gaussian_kde.covariance_factor										
scipy stats.gaussian_kde.covariance_factor	R	scipy.stats.gaussian_kde.covariance_factor										
scipy.stats.gaussian_kde.evaluate	A										<section class="prog__container"><p>Evaluate the estimated pdf on a set of points.</p><pre><code>gaussian_kde.evaluate(points)</code></pre><span class="prog__sub">Parameters:</span><pre><code>points : (# of dimensions, # of points)-array\n    Alternatively, a (# of dimensions,) vector can be passed in and treated as a single point.</code></pre><span class="prog__sub">Returns:</span><pre><code>values : (# of points,)-array\n    The values at each point.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.evaluate.html
scipy stats gaussian_kde evaluate	R	scipy.stats.gaussian_kde.evaluate										
scipy stats.gaussian_kde.evaluate	R	scipy.stats.gaussian_kde.evaluate										
scipy.stats.gaussian_kde.integrate_box_1d	A										<section class="prog__container"><p>Computes the integral of a 1D pdf between two bounds.</p><pre><code>gaussian_kde.integrate_box_1d(low, high)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low : scalar\n    Lower bound of integration. \nhigh : scalar\n    Upper bound of integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>value : scalar\n    The result of the integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.integrate_box_1d.html
scipy stats gaussian_kde integrate_box_1d	R	scipy.stats.gaussian_kde.integrate_box_1d										
scipy stats.gaussian_kde.integrate_box_1d	R	scipy.stats.gaussian_kde.integrate_box_1d										
scipy.stats.gaussian_kde.integrate_box	A										<section class="prog__container"><p>Computes the integral of a pdf over a rectangular interval.</p><pre><code>gaussian_kde.integrate_box(low_bounds, high_bounds, maxpts=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>low_bounds : array_like\n    A 1-D array containing the lower bounds of integration. \nhigh_bounds : array_like\n    A 1-D array containing the upper bounds of integration. \nmaxpts : int, optional\n    The maximum number of points to use for integration.</code></pre><span class="prog__sub">Returns:</span><pre><code>value : scalar\n    The result of the integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.integrate_box.html
scipy stats gaussian_kde integrate_box	R	scipy.stats.gaussian_kde.integrate_box										
scipy stats.gaussian_kde.integrate_box	R	scipy.stats.gaussian_kde.integrate_box										
scipy.stats.gaussian_kde.integrate_gaussian	A										<section class="prog__container"><p>Multiply estimated density by a multivariate Gaussian and integrate\nover the whole space.</p><pre><code>gaussian_kde.integrate_gaussian(mean, cov)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean : aray_like\n    A 1-D array, specifying the mean of the Gaussian. \ncov : array_like\n    A 2-D array, specifying the covariance matrix of the Gaussian.</code></pre><span class="prog__sub">Returns:</span><pre><code>result : scalar\n    The value of the integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.integrate_gaussian.html
scipy stats gaussian_kde integrate_gaussian	R	scipy.stats.gaussian_kde.integrate_gaussian										
scipy stats.gaussian_kde.integrate_gaussian	R	scipy.stats.gaussian_kde.integrate_gaussian										
scipy.stats.gaussian_kde.integrate_kde	A										<section class="prog__container"><p>Computes the integral of the product of this  kernel density estimate\nwith another.</p><pre><code>gaussian_kde.integrate_kde(other)</code></pre><span class="prog__sub">Parameters:</span><pre><code>other : gaussian_kde instance\n    The other kde.</code></pre><span class="prog__sub">Returns:</span><pre><code>value : scalar\n    The result of the integral.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.integrate_kde.html
scipy stats gaussian_kde integrate_kde	R	scipy.stats.gaussian_kde.integrate_kde										
scipy stats.gaussian_kde.integrate_kde	R	scipy.stats.gaussian_kde.integrate_kde										
scipy.stats.gaussian_kde.logpdf	A										<section class="prog__container"><p>Evaluate the log of the estimated pdf on a provided set of points.</p><pre><code>gaussian_kde.logpdf(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.logpdf.html
scipy stats gaussian_kde logpdf	R	scipy.stats.gaussian_kde.logpdf										
scipy stats.gaussian_kde.logpdf	R	scipy.stats.gaussian_kde.logpdf										
scipy.stats.gaussian_kde.pdf	A										<section class="prog__container"><p>Evaluate the estimated pdf on a provided set of points.</p><pre><code>gaussian_kde.pdf(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.pdf.html
scipy stats gaussian_kde pdf	R	scipy.stats.gaussian_kde.pdf										
scipy stats.gaussian_kde.pdf	R	scipy.stats.gaussian_kde.pdf										
scipy.stats.gaussian_kde.resample	A										<section class="prog__container"><p>Randomly sample a dataset from the estimated pdf.</p><pre><code>gaussian_kde.resample(size=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>size : int, optional\n    The number of samples to draw.  If not provided, then the size is the same as the underlying dataset.</code></pre><span class="prog__sub">Returns:</span><pre><code>resample : (self.d, size) ndarray\n    The sampled dataset.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.resample.html
scipy stats gaussian_kde resample	R	scipy.stats.gaussian_kde.resample										
scipy stats.gaussian_kde.resample	R	scipy.stats.gaussian_kde.resample										
scipy stats gaussian_kde	R	scipy.stats.gaussian_kde										
scipy stats.gaussian_kde	R	scipy.stats.gaussian_kde										
scipy.stats.gaussian_kde.scotts_factor	A										<section class="prog__container"><p>Computes the coefficient (kde.factor) that\nmultiplies the data covariance matrix to obtain the kernel covariance\nmatrix. The default is scotts_factor.  A subclass can overwrite this\nmethod to provide a different method, or set it through a call to\nkde.set_bandwidth.</p><pre><code>gaussian_kde.scotts_factor()</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.scotts_factor.html
scipy stats gaussian_kde scotts_factor	R	scipy.stats.gaussian_kde.scotts_factor										
scipy stats.gaussian_kde.scotts_factor	R	scipy.stats.gaussian_kde.scotts_factor										
scipy.stats.gaussian_kde.set_bandwidth	A										<section class="prog__container"><p>Compute the estimator bandwidth with given method.</p><pre><code>gaussian_kde.set_bandwidth(bw_method=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>bw_method : str, scalar or callable, optional\n    The method used to calculate the estimator bandwidth.  This can be ‘scott’, ‘silverman’, a scalar constant or a callable.  If a scalar, this will be used directly as kde.factor.  If a callable, it should take a gaussian_kde instance as only parameter and return a scalar.  If None (default), nothing happens; the current kde.covariance_factor method is kept.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import scipy.stats as stats\n>>> x1 = np.array([-7, -5, 1, 4, 5.])\n>>> kde = stats.gaussian_kde(x1)\n>>> xs = np.linspace(-10, 10, num=50)\n>>> y1 = kde(xs)\n>>> kde.set_bandwidth(bw_method='silverman')\n>>> y2 = kde(xs)\n>>> kde.set_bandwidth(bw_method=kde.factor / 3.)\n>>> y3 = kde(xs)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.set_bandwidth.html
scipy stats gaussian_kde set_bandwidth	R	scipy.stats.gaussian_kde.set_bandwidth										
scipy stats.gaussian_kde.set_bandwidth	R	scipy.stats.gaussian_kde.set_bandwidth										
scipy.stats.genexpon	A										<section class="prog__container"><p>A generalized exponential continuous random variable.</p><pre><code>scipy.stats.genexpon = <scipy.stats._continuous_distns.genexpon_gen object at 0x2aba9508c750></code></pre><span class="prog__sub">Examples:</span><pre><code>genexpon.pdf(x, a, b, c) = (a + b * (1 - exp(-c*x))) *                                    exp(-a*x - b*x + b/c * (1-exp(-c*x)))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.genexpon.html
scipy stats genexpon	R	scipy.stats.genexpon										
scipy stats.genexpon	R	scipy.stats.genexpon										
scipy.stats.genextreme	A					[[scipy.stats.gumbel_r]]					<section class="prog__container"><p>A generalized extreme value continuous random variable.</p><pre><code>scipy.stats.genextreme = <scipy.stats._continuous_distns.genextreme_gen object at 0x2aba9508ca10></code></pre><span class="prog__sub">Examples:</span><pre><code>genextreme.pdf(x, c) =\n    exp(-exp(-x))*exp(-x),                    for c==0\n    exp(-(1-c*x)**(1/c))*(1-c*x)**(1/c-1),    for x <= 1/c, c > 0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.genextreme.html
scipy stats genextreme	R	scipy.stats.genextreme										
scipy stats.genextreme	R	scipy.stats.genextreme										
scipy.stats.gengamma	A										<section class="prog__container"><p>A generalized gamma continuous random variable.</p><pre><code>scipy.stats.gengamma = <scipy.stats._continuous_distns.gengamma_gen object at 0x2aba950971d0></code></pre><span class="prog__sub">Examples:</span><pre><code>gengamma.pdf(x, a, c) = abs(c) * x**(c*a-1) * exp(-x**c) / gamma(a)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gengamma.html
scipy stats gengamma	R	scipy.stats.gengamma										
scipy stats.gengamma	R	scipy.stats.gengamma										
scipy.stats.genhalflogistic	A										<section class="prog__container"><p>A generalized half-logistic continuous random variable.</p><pre><code>scipy.stats.genhalflogistic = <scipy.stats._continuous_distns.genhalflogistic_gen object at 0x2aba95097450></code></pre><span class="prog__sub">Examples:</span><pre><code>genhalflogistic.pdf(x, c) = 2 * (1-c*x)**(1/c-1) / (1+(1-c*x)**(1/c))**2</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.genhalflogistic.html
scipy stats genhalflogistic	R	scipy.stats.genhalflogistic										
scipy stats.genhalflogistic	R	scipy.stats.genhalflogistic										
scipy.stats.genlogistic	A										<section class="prog__container"><p>A generalized logistic continuous random variable.</p><pre><code>scipy.stats.genlogistic = <scipy.stats._continuous_distns.genlogistic_gen object at 0x2aba9508c250></code></pre><span class="prog__sub">Examples:</span><pre><code>genlogistic.pdf(x, c) = c * exp(-x) / (1 + exp(-x))**(c+1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.genlogistic.html
scipy stats genlogistic	R	scipy.stats.genlogistic										
scipy stats.genlogistic	R	scipy.stats.genlogistic										
scipy.stats.gennorm	A										<section class="prog__container"><p>A generalized normal continuous random variable.</p><pre><code>scipy.stats.gennorm = <scipy.stats._continuous_distns.gennorm_gen object at 0x2aba950fb890></code></pre><span class="prog__sub">Examples:</span><pre><code>beta\ngennorm.pdf(x, beta) =  ---------------  exp(-|x|**beta)\n                        2 gamma(1/beta)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gennorm.html
scipy stats gennorm	R	scipy.stats.gennorm										
scipy stats.gennorm	R	scipy.stats.gennorm										
scipy.stats.genpareto	A										<section class="prog__container"><p>A generalized Pareto continuous random variable.</p><pre><code>scipy.stats.genpareto = <scipy.stats._continuous_distns.genpareto_gen object at 0x2aba9508c4d0></code></pre><span class="prog__sub">Examples:</span><pre><code>genpareto.pdf(x, c) = (1 + c * x)**(-1 - 1/c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.genpareto.html
scipy stats genpareto	R	scipy.stats.genpareto										
scipy stats.genpareto	R	scipy.stats.genpareto										
scipy.stats.geom	A										<section class="prog__container"><p>A geometric discrete random variable.</p><pre><code>scipy.stats.geom = <scipy.stats._discrete_distns.geom_gen object at 0x2aba95088e10></code></pre><span class="prog__sub">Examples:</span><pre><code>geom.pmf(k) = (1-p)**(k-1)*p</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.geom.html
scipy stats geom	R	scipy.stats.geom										
scipy stats.geom	R	scipy.stats.geom										
scipy.stats.gilbrat	A										<section class="prog__container"><p>A Gilbrat continuous random variable.</p><pre><code>scipy.stats.gilbrat = <scipy.stats._continuous_distns.gilbrat_gen object at 0x2aba950b8710></code></pre><span class="prog__sub">Examples:</span><pre><code>gilbrat.pdf(x) = 1/(x*sqrt(2*pi)) * exp(-1/2*(log(x))**2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gilbrat.html
scipy stats gilbrat	R	scipy.stats.gilbrat										
scipy stats.gilbrat	R	scipy.stats.gilbrat										
scipy.stats.gmean	A										<section class="prog__container"><p>Compute the geometric mean along the specified axis.</p><pre><code>scipy.stats.gmean(a, axis=0, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : int or None, optional\n    Axis along which the geometric mean is computed. Default is 0. If None, compute over the whole array a. \ndtype : dtype, optional\n    Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>gmean : ndarray\n    see dtype parameter above</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gmean.html
scipy stats gmean	R	scipy.stats.gmean										
scipy stats.gmean	R	scipy.stats.gmean										
scipy.stats.gompertz	A										<section class="prog__container"><p>A Gompertz (or truncated Gumbel) continuous random variable.</p><pre><code>scipy.stats.gompertz = <scipy.stats._continuous_distns.gompertz_gen object at 0x2aba950976d0></code></pre><span class="prog__sub">Examples:</span><pre><code>gompertz.pdf(x, c) = c * exp(x) * exp(-c*(exp(x)-1))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gompertz.html
scipy stats gompertz	R	scipy.stats.gompertz										
scipy stats.gompertz	R	scipy.stats.gompertz										
scipy.stats.gumbel_l	A					[[scipy.stats.gumbel_r]]\\n[[scipy.stats.gompertz]]\\n[[scipy.stats.genextreme]]					<section class="prog__container"><p>A left-skewed Gumbel continuous random variable.</p><pre><code>scipy.stats.gumbel_l = <scipy.stats._continuous_distns.gumbel_l_gen object at 0x2aba95097b50></code></pre><span class="prog__sub">Examples:</span><pre><code>gumbel_l.pdf(x) = exp(x - exp(x))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gumbel_l.html
scipy stats gumbel_l	R	scipy.stats.gumbel_l										
scipy stats.gumbel_l	R	scipy.stats.gumbel_l										
scipy.stats.gumbel_r	A					[[scipy.stats.gumbel_l]]\\n[[scipy.stats.gompertz]]\\n[[scipy.stats.genextreme]]					<section class="prog__container"><p>A right-skewed Gumbel continuous random variable.</p><pre><code>scipy.stats.gumbel_r = <scipy.stats._continuous_distns.gumbel_r_gen object at 0x2aba95097950></code></pre><span class="prog__sub">Examples:</span><pre><code>gumbel_r.pdf(x) = exp(-(x + exp(-x)))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gumbel_r.html
scipy stats gumbel_r	R	scipy.stats.gumbel_r										
scipy stats.gumbel_r	R	scipy.stats.gumbel_r										
scipy.stats.halfcauchy	A										<section class="prog__container"><p>A Half-Cauchy continuous random variable.</p><pre><code>scipy.stats.halfcauchy = <scipy.stats._continuous_distns.halfcauchy_gen object at 0x2aba95097d50></code></pre><span class="prog__sub">Examples:</span><pre><code>halfcauchy.pdf(x) = 2 / (pi * (1 + x**2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.halfcauchy.html
scipy stats halfcauchy	R	scipy.stats.halfcauchy										
scipy stats.halfcauchy	R	scipy.stats.halfcauchy										
scipy.stats.halfgennorm	A										<section class="prog__container"><p>The upper half of a generalized normal continuous random variable.</p><pre><code>scipy.stats.halfgennorm = <scipy.stats._continuous_distns.halfgennorm_gen object at 0x2aba950fbb10></code></pre><span class="prog__sub">Examples:</span><pre><code>beta\nhalfgennorm.pdf(x, beta) =  -------------  exp(-|x|**beta)\n                            gamma(1/beta)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.halfgennorm.html
scipy stats halfgennorm	R	scipy.stats.halfgennorm										
scipy stats.halfgennorm	R	scipy.stats.halfgennorm										
scipy.stats.halflogistic	A										<section class="prog__container"><p>A half-logistic continuous random variable.</p><pre><code>scipy.stats.halflogistic = <scipy.stats._continuous_distns.halflogistic_gen object at 0x2aba95097f50></code></pre><span class="prog__sub">Examples:</span><pre><code>halflogistic.pdf(x) = 2 * exp(-x) / (1+exp(-x))**2 = 1/2 * sech(x/2)**2</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.halflogistic.html
scipy stats halflogistic	R	scipy.stats.halflogistic										
scipy stats.halflogistic	R	scipy.stats.halflogistic										
scipy.stats.halfnorm	A										<section class="prog__container"><p>A half-normal continuous random variable.</p><pre><code>scipy.stats.halfnorm = <scipy.stats._continuous_distns.halfnorm_gen object at 0x2aba950a0190></code></pre><span class="prog__sub">Examples:</span><pre><code>halfnorm.pdf(x) = sqrt(2/pi) * exp(-x**2/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.halfnorm.html
scipy stats halfnorm	R	scipy.stats.halfnorm										
scipy stats.halfnorm	R	scipy.stats.halfnorm										
scipy.stats.histogram2	A										<section class="prog__container"><p>histogram2 is deprecated!\nscipy.stats.histogram2 is deprecated in scipy 0.16.0; use np.histogram2d instead</p><pre><code>scipy.stats.histogram2(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like of rank 1\n    The array of values to be assigned into bins   bins : array_like of rank 1 Defines the ranges of values to use during histogramming.</code></pre><span class="prog__sub">Returns:</span><pre><code>histogram2 : ndarray of rank 1\n    Each value represents the occurrences for a given bin (range) of values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.histogram2.html
scipy stats histogram2	R	scipy.stats.histogram2										
scipy stats.histogram2	R	scipy.stats.histogram2										
scipy.stats.histogram	A										<section class="prog__container"><p>histogram is deprecated!\nscipy.stats.histogram is deprecated in scipy 0.17.0; use np.histogram instead</p><pre><code>scipy.stats.histogram(*args, **kwds)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.histogram.html
scipy stats histogram	R	scipy.stats.histogram										
scipy stats.histogram	R	scipy.stats.histogram										
scipy.stats.hmean	A										<section class="prog__container"><p>Calculates the harmonic mean along the specified axis.</p><pre><code>scipy.stats.hmean(a, axis=0, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, masked array or object that can be converted to an array. \naxis : int or None, optional\n    Axis along which the harmonic mean is computed. Default is 0. If None, compute over the whole array a. \ndtype : dtype, optional\n    Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>hmean : ndarray\n    see dtype parameter above</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.hmean.html
scipy stats hmean	R	scipy.stats.hmean										
scipy stats.hmean	R	scipy.stats.hmean										
scipy.stats.hypergeom	A										<section class="prog__container"><p>A hypergeometric discrete random variable.</p><pre><code>scipy.stats.hypergeom = <scipy.stats._discrete_distns.hypergeom_gen object at 0x2aba9510f0d0></code></pre><span class="prog__sub">Examples:</span><pre><code>pmf(k, M, n, N) = choose(n, k) * choose(M - n, N - k) / choose(M, N),\n                               for max(0, N - (M-n)) <= k <= min(n, N)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.hypergeom.html
scipy stats hypergeom	R	scipy.stats.hypergeom										
scipy stats.hypergeom	R	scipy.stats.hypergeom										
scipy.stats.hypsecant	A										<section class="prog__container"><p>A hyperbolic secant continuous random variable.</p><pre><code>scipy.stats.hypsecant = <scipy.stats._continuous_distns.hypsecant_gen object at 0x2aba950a0390></code></pre><span class="prog__sub">Examples:</span><pre><code>hypsecant.pdf(x) = 1/pi * sech(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.hypsecant.html
scipy stats hypsecant	R	scipy.stats.hypsecant										
scipy stats.hypsecant	R	scipy.stats.hypsecant										
scipy.stats.invgamma	A										<section class="prog__container"><p>An inverted gamma continuous random variable.</p><pre><code>scipy.stats.invgamma = <scipy.stats._continuous_distns.invgamma_gen object at 0x2aba950a0810></code></pre><span class="prog__sub">Examples:</span><pre><code>invgamma.pdf(x, a) = x**(-a-1) / gamma(a) * exp(-1/x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.invgamma.html
scipy stats invgamma	R	scipy.stats.invgamma										
scipy stats.invgamma	R	scipy.stats.invgamma										
scipy.stats.invgauss	A										<section class="prog__container"><p>An inverse Gaussian continuous random variable.</p><pre><code>scipy.stats.invgauss = <scipy.stats._continuous_distns.invgauss_gen object at 0x2aba950a0a90></code></pre><span class="prog__sub">Examples:</span><pre><code>invgauss.pdf(x, mu) = 1 / sqrt(2*pi*x**3) * exp(-(x-mu)**2/(2*x*mu**2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.invgauss.html
scipy stats invgauss	R	scipy.stats.invgauss										
scipy stats.invgauss	R	scipy.stats.invgauss										
scipy.stats.invweibull	A										<section class="prog__container"><p>An inverted Weibull continuous random variable.</p><pre><code>scipy.stats.invweibull = <scipy.stats._continuous_distns.invweibull_gen object at 0x2aba950a0d10></code></pre><span class="prog__sub">Examples:</span><pre><code>invweibull.pdf(x, c) = c * x**(-c-1) * exp(-x**(-c))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.invweibull.html
scipy stats invweibull	R	scipy.stats.invweibull										
scipy stats.invweibull	R	scipy.stats.invweibull										
scipy.stats.invwishart	A					[[scipy.stats.wishart]]					<section class="prog__container"><p>An inverse Wishart random variable.</p><pre><code>scipy.stats.invwishart = <scipy.stats._multivariate.invwishart_gen object at 0x2aba953e4e90></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Quantiles, with the last axis of x denoting the components. \ndf : int\n    Degrees of freedom, must be greater than or equal to dimension of the scale matrix \nscale : array_like\n    Symmetric positive definite scale matrix of the distribution \nrandom_state : None or int or np.random.RandomState instance, optional\n    If int or RandomState, use it for drawing the random variates. If None (or np.random), the global np.random state is used. Default is None. \nAlternatively, the object may be called (as a function) to fix the degrees\nof freedom and scale parameters, returning a “frozen” inverse Wishart\nrandom variable:\nrv = invwishart(df=1, scale=1)\n    Frozen object with the same methods but holding the given degrees of freedom and scale fixed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy.stats import invwishart, invgamma\n>>> x = np.linspace(0.01, 1, 100)\n>>> iw = invwishart.pdf(x, df=6, scale=1)\n>>> iw[:3]\narray([  1.20546865e-15,   5.42497807e-06,   4.45813929e-03])\n>>> ig = invgamma.pdf(x, 6/2., scale=1./2)\n>>> ig[:3]\narray([  1.20546865e-15,   5.42497807e-06,   4.45813929e-03])\n>>> plt.plot(x, iw)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.invwishart.html
scipy stats invwishart	R	scipy.stats.invwishart										
scipy stats.invwishart	R	scipy.stats.invwishart										
scipy.stats.iqr	A					[[(in NumPy v1.11)]]\\n[[(in NumPy v1.11)]]					<section class="prog__container"><p>Compute the interquartile range of the data along the specified\naxis.</p><pre><code>scipy.stats.iqr(x, axis=None, rng=(25, 75), scale='raw', nan_policy='propagate', interpolation='linear', keepdims=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array or object that can be converted to an array. \naxis : int or sequence of int, optional\n    Axis along which the range is computed. The default is to compute the IQR for the entire array. \nrng : Two-element sequence containing floats in range of [0,100] optional\n    Percentiles over which to compute the range. Each must be between 0 and 100, inclusive. The default is the true IQR: (25, 75). The order of the elements is not important. \nscale : scalar or str, optional\n    The numerical value of scale will be divided out of the final result. The following string values are recognized:  ‘raw’ : No scaling, just return the raw IQR. ‘normal’ : Scale by \(2 \sqrt{2} erf^{-1}(\frac{1}{2}) \approx 1.349\).  The default is ‘raw’. Array-like scale is also allowed, as long as it broadcasts correctly to the output such that out / scale is a valid operation. The output dimensions depend on the input array, x, the axis argument, and the keepdims flag. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’. \ninterpolation : {‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}, optional\n    Specifies the interpolation method to use when the percentile boundaries lie between two data points i and j:    ‘linear’ : i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.    ‘lower’ : i.  ‘higher’ : j.  ‘nearest’ : i or j whichever is nearest.  ‘midpoint’ : (i + j) / 2.    Default is ‘linear’. \nkeepdims : bool, optional\n    If this is set to True, the reduced axes are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array x.</code></pre><span class="prog__sub">Returns:</span><pre><code>iqr : scalar or ndarray\n    If axis=None, a scalar is returned. If the input contains integers or floats of smaller precision than np.float64, then the output data-type is np.float64. Otherwise, the output data-type is the same as that of the input.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import iqr\n>>> x = np.array([[10, 7, 4], [3, 2, 1]])\n>>> x\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n>>> iqr(x)\n4.0\n>>> iqr(x, axis=0)\narray([ 3.5,  2.5,  1.5])\n>>> iqr(x, axis=1)\narray([ 3.,  1.])\n>>> iqr(x, axis=1, keepdims=True)\narray([[ 3.],\n       [ 1.]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.iqr.html
scipy stats iqr	R	scipy.stats.iqr										
scipy stats.iqr	R	scipy.stats.iqr										
scipy.stats.itemfreq	A										<section class="prog__container"><p>Returns a 2-D array of item frequencies.</p><pre><code>scipy.stats.itemfreq(a)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : (N,) array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>itemfreq : (K, 2) ndarray\n    A 2-D frequency table.  Column 1 contains sorted, unique values from a, column 2 contains their respective counts.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> a = np.array([1, 1, 5, 0, 1, 2, 2, 0, 1, 4])\n>>> stats.itemfreq(a)\narray([[ 0.,  2.],\n       [ 1.,  4.],\n       [ 2.,  2.],\n       [ 4.,  1.],\n       [ 5.,  1.]])\n>>> np.bincount(a)\narray([2, 4, 2, 0, 1, 1])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.itemfreq.html
scipy stats itemfreq	R	scipy.stats.itemfreq										
scipy stats.itemfreq	R	scipy.stats.itemfreq										
scipy.stats.jarque_bera	A										<section class="prog__container"><p>Perform the Jarque-Bera goodness of fit test on sample data.</p><pre><code>scipy.stats.jarque_bera(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Observations of a random variable.</code></pre><span class="prog__sub">Returns:</span><pre><code>jb_value : float\n    The test statistic. \np : float\n    The p-value for the hypothesis test.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(987654321)\n>>> x = np.random.normal(0, 1, 100000)\n>>> y = np.random.rayleigh(1, 100000)\n>>> stats.jarque_bera(x)\n(4.7165707989581342, 0.09458225503041906)\n>>> stats.jarque_bera(y)\n(6713.7098548143422, 0.0)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.jarque_bera.html
scipy stats jarque_bera	R	scipy.stats.jarque_bera										
scipy stats.jarque_bera	R	scipy.stats.jarque_bera										
scipy.stats.johnsonsb	A					[[scipy.stats.johnsonsu]]					<section class="prog__container"><p>A Johnson SB continuous random variable.</p><pre><code>scipy.stats.johnsonsb = <scipy.stats._continuous_distns.johnsonsb_gen object at 0x2aba950a0f90></code></pre><span class="prog__sub">Examples:</span><pre><code>johnsonsb.pdf(x, a, b) = b / (x*(1-x)) * phi(a + b * log(x/(1-x)))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.johnsonsb.html
scipy stats johnsonsb	R	scipy.stats.johnsonsb										
scipy stats.johnsonsb	R	scipy.stats.johnsonsb										
scipy.stats.johnsonsu	A					[[scipy.stats.johnsonsb]]					<section class="prog__container"><p>A Johnson SU continuous random variable.</p><pre><code>scipy.stats.johnsonsu = <scipy.stats._continuous_distns.johnsonsu_gen object at 0x2aba950b0250></code></pre><span class="prog__sub">Examples:</span><pre><code>johnsonsu.pdf(x, a, b) = b / sqrt(x**2 + 1) *\n                         phi(a + b * log(x + sqrt(x**2 + 1)))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.johnsonsu.html
scipy stats johnsonsu	R	scipy.stats.johnsonsu										
scipy stats.johnsonsu	R	scipy.stats.johnsonsu										
scipy.stats.kappa3	A										<section class="prog__container"><p>Kappa 3 parameter distribution.</p><pre><code>scipy.stats.kappa3 = <scipy.stats._continuous_distns.kappa3_gen object at 0x2aba950c4050></code></pre><span class="prog__sub">Examples:</span><pre><code>kappa3.pdf(x, a) =\n    a*[a + x**a]**(-(a + 1)/a),     for ``x > 0``\n    0.0,                            for ``x <= 0``</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kappa3.html
scipy stats kappa3	R	scipy.stats.kappa3										
scipy stats.kappa3	R	scipy.stats.kappa3										
scipy.stats.kappa4	A										<section class="prog__container"><p>Kappa 4 parameter distribution.</p><pre><code>scipy.stats.kappa4 = <scipy.stats._continuous_distns.kappa4_gen object at 0x2aba950b8d90></code></pre><span class="prog__sub">Examples:</span><pre><code>kappa4.pdf(x, h, k) = (1.0 - k*x)**(1.0/k - 1.0)*\n                      (1.0 - h*(1.0 - k*x)**(1.0/k))**(1.0/h-1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kappa4.html
scipy stats kappa4	R	scipy.stats.kappa4										
scipy stats.kappa4	R	scipy.stats.kappa4										
scipy.stats.kendalltau	A										<section class="prog__container"><p>Calculates Kendall’s tau, a correlation measure for ordinal data.</p><pre><code>scipy.stats.kendalltau(x, y, initial_lexsort=None, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of rankings, of the same shape. If arrays are not 1-D, they will be flattened to 1-D. \ninitial_lexsort : bool, optional\n    Whether to use lexsort or quicksort as the sorting method for the initial sort of the inputs. Default is lexsort (True), for which kendalltau is of complexity O(n log(n)). If False, the complexity is O(n^2), but with a smaller pre-factor (so quicksort may be faster for small arrays). \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>correlation : float\n    The tau statistic. \npvalue : float\n    The two-sided p-value for a hypothesis test whose null hypothesis is an absence of association, tau = 0.</code></pre><span class="prog__sub">Examples:</span><pre><code>tau = (P - Q) / sqrt((P + Q + T) * (P + Q + U))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kendalltau.html
scipy stats kendalltau	R	scipy.stats.kendalltau										
scipy stats.kendalltau	R	scipy.stats.kendalltau										
scipy.stats.kruskal	A										<section class="prog__container"><p>Compute the Kruskal-Wallis H-test for independent samples</p><pre><code>scipy.stats.kruskal(*args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample1, sample2, ... : array_like\n    Two or more arrays with the sample measurements can be given as arguments. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The Kruskal-Wallis H statistic, corrected for ties \npvalue : float\n    The p-value for the test using the assumption that H has a chi square distribution</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = [1, 3, 5, 7, 9]\n>>> y = [2, 4, 6, 8, 10]\n>>> stats.kruskal(x, y)\nKruskalResult(statistic=0.27272727272727337, pvalue=0.60150813444058948)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kruskal.html
scipy stats kruskal	R	scipy.stats.kruskal										
scipy stats.kruskal	R	scipy.stats.kruskal										
scipy.stats.ks_2samp	A										<section class="prog__container"><p>Computes the Kolmogorov-Smirnov statistic on 2 samples.</p><pre><code>scipy.stats.ks_2samp(data1, data2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data1, data2 : sequence of 1-D ndarrays\n    two arrays of sample observations assumed to be drawn from a continuous distribution, sample sizes can be different</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    KS statistic \npvalue : float\n    two-tailed p-value</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(12345678)  #fix random seed to get the same result\n>>> n1 = 200  # size of first sample\n>>> n2 = 300  # size of second sample</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ks_2samp.html
scipy stats ks_2samp	R	scipy.stats.ks_2samp										
scipy stats.ks_2samp	R	scipy.stats.ks_2samp										
scipy.stats.ksone	A										<section class="prog__container"><p>General Kolmogorov-Smirnov one-sided test.</p><pre><code>scipy.stats.ksone = <scipy.stats._continuous_distns.ksone_gen object at 0x2aba94e1a9d0></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import ksone\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ksone.html
scipy stats ksone	R	scipy.stats.ksone										
scipy stats.ksone	R	scipy.stats.ksone										
scipy.stats.kstat	A										<section class="prog__container"><p>Return the nth k-statistic (1<=n<=4 so far).</p><pre><code>scipy.stats.kstat(data, n=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input array. Note that n-D input gets flattened. \nn : int, {1, 2, 3, 4}, optional\n    Default is equal to 2.</code></pre><span class="prog__sub">Returns:</span><pre><code>kstat : float\n    The nth k-statistic.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> rndm = np.random.RandomState(1234)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kstat.html
scipy stats kstat	R	scipy.stats.kstat										
scipy stats.kstat	R	scipy.stats.kstat										
scipy.stats.kstatvar	A										<section class="prog__container"><p>Returns an unbiased estimator of the variance of the k-statistic.</p><pre><code>scipy.stats.kstatvar(data, n=2)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input array. Note that n-D input gets flattened. \nn : int, {1, 2}, optional\n    Default is equal to 2.</code></pre><span class="prog__sub">Returns:</span><pre><code>kstatvar : float\n    The nth k-statistic variance.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kstatvar.html
scipy stats kstatvar	R	scipy.stats.kstatvar										
scipy stats.kstatvar	R	scipy.stats.kstatvar										
scipy.stats.kstest	A										<section class="prog__container"><p>Perform the Kolmogorov-Smirnov test for goodness of fit.</p><pre><code>scipy.stats.kstest(rvs, cdf, args=(), N=20, alternative='two-sided', mode='approx')</code></pre><span class="prog__sub">Parameters:</span><pre><code>rvs : str, array or callable\n    If a string, it should be the name of a distribution in scipy.stats. If an array, it should be a 1-D array of observations of random variables. If a callable, it should be a function to generate random variables; it is required to have a keyword argument size. \ncdf : str or callable\n    If a string, it should be the name of a distribution in scipy.stats. If rvs is a string then cdf can be False or the same as rvs. If a callable, that callable is used to calculate the cdf. \nargs : tuple, sequence, optional\n    Distribution parameters, used if rvs or cdf are strings. \nN : int, optional\n    Sample size if rvs is string or callable.  Default is 20. \nalternative : {‘two-sided’, ‘less’,’greater’}, optional\n    Defines the alternative hypothesis (see explanation above). Default is ‘two-sided’. \nmode : ‘approx’ (default) or ‘asymp’, optional\n    Defines the distribution used for calculating the p-value.   ‘approx’ : use approximation to exact distribution of test statistic ‘asymp’ : use asymptotic distribution of test statistic</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    KS test statistic, either D, D+ or D-. \npvalue :  float\n    One-tailed or two-tailed p-value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kstest.html
scipy stats kstest	R	scipy.stats.kstest										
scipy stats.kstest	R	scipy.stats.kstest										
scipy.stats.kstwobign	A										<section class="prog__container"><p>Kolmogorov-Smirnov two-sided test for large N.</p><pre><code>scipy.stats.kstwobign = <scipy.stats._continuous_distns.kstwobign_gen object at 0x2aba94e1abd0></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import kstwobign\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kstwobign.html
scipy stats kstwobign	R	scipy.stats.kstwobign										
scipy stats.kstwobign	R	scipy.stats.kstwobign										
scipy.stats.kurtosis	A										<section class="prog__container"><p>Computes the kurtosis (Fisher or Pearson) of a dataset.</p><pre><code>scipy.stats.kurtosis(a, axis=0, fisher=True, bias=True, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array\n    data for which the kurtosis is calculated \naxis : int or None, optional\n    Axis along which the kurtosis is calculated. Default is 0. If None, compute over the whole array a. \nfisher : bool, optional\n    If True, Fisher’s definition is used (normal ==> 0.0). If False, Pearson’s definition is used (normal ==> 3.0). \nbias : bool, optional\n    If False, then the calculations are corrected for statistical bias. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>kurtosis : array\n    The kurtosis of values along an axis. If all values are equal, return -3 for Fisher’s definition and 0 for Pearson’s definition.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kurtosis.html
scipy stats kurtosis	R	scipy.stats.kurtosis										
scipy stats.kurtosis	R	scipy.stats.kurtosis										
scipy.stats.kurtosistest	A										<section class="prog__container"><p>Tests whether a dataset has normal kurtosis</p><pre><code>scipy.stats.kurtosistest(a, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array\n    array of the sample data \naxis : int or None, optional\n    Axis along which to compute test. Default is 0. If None, compute over the whole array a. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The computed z-score for this test. \npvalue : float\n    The 2-sided p-value for the hypothesis test</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kurtosistest.html
scipy stats kurtosistest	R	scipy.stats.kurtosistest										
scipy stats.kurtosistest	R	scipy.stats.kurtosistest										
scipy.stats.laplace	A										<section class="prog__container"><p>A Laplace continuous random variable.</p><pre><code>scipy.stats.laplace = <scipy.stats._continuous_distns.laplace_gen object at 0x2aba950b04d0></code></pre><span class="prog__sub">Examples:</span><pre><code>laplace.pdf(x) = 1/2 * exp(-abs(x))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.laplace.html
scipy stats laplace	R	scipy.stats.laplace										
scipy stats.laplace	R	scipy.stats.laplace										
scipy.stats.levene	A										<section class="prog__container"><p>Perform Levene test for equal variances.</p><pre><code>scipy.stats.levene(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample1, sample2, ... : array_like\n    The sample data, possibly with different lengths \ncenter : {‘mean’, ‘median’, ‘trimmed’}, optional\n    Which function of the data to use in the test.  The default is ‘median’. \nproportiontocut : float, optional\n    When center is ‘trimmed’, this gives the proportion of data points to cut from each end. (See scipy.stats.trim_mean.) Default is 0.05.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The test statistic. \npvalue : float\n    The p-value for the test.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.levene.html
scipy stats levene	R	scipy.stats.levene										
scipy stats.levene	R	scipy.stats.levene										
scipy.stats.levy	A					[[scipy.stats.levy_stable]]\\n[[scipy.stats.levy_l]]					<section class="prog__container"><p>A Levy continuous random variable.</p><pre><code>scipy.stats.levy = <scipy.stats._continuous_distns.levy_gen object at 0x2aba950b05d0></code></pre><span class="prog__sub">Examples:</span><pre><code>levy.pdf(x) = 1 / (x * sqrt(2*pi*x)) * exp(-1/(2*x))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.levy.html
scipy.stats.levy_l	A					[[scipy.stats.levy]]\\n[[scipy.stats.levy_stable]]					<section class="prog__container"><p>A left-skewed Levy continuous random variable.</p><pre><code>scipy.stats.levy_l = <scipy.stats._continuous_distns.levy_l_gen object at 0x2aba950b08d0></code></pre><span class="prog__sub">Examples:</span><pre><code>levy_l.pdf(x) = 1 / (abs(x) * sqrt(2*pi*abs(x))) * exp(-1/(2*abs(x)))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.levy_l.html
scipy stats levy_l	R	scipy.stats.levy_l										
scipy stats.levy_l	R	scipy.stats.levy_l										
scipy stats levy	R	scipy.stats.levy										
scipy stats.levy	R	scipy.stats.levy										
scipy.stats.levy_stable	A					[[scipy.stats.levy]]\\n[[scipy.stats.levy_l]]					<section class="prog__container"><p>A Levy-stable continuous random variable.</p><pre><code>scipy.stats.levy_stable = <scipy.stats._continuous_distns.levy_stable_gen object at 0x2aba950b0ad0></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import levy_stable\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.levy_stable.html
scipy stats levy_stable	R	scipy.stats.levy_stable										
scipy stats.levy_stable	R	scipy.stats.levy_stable										
scipy.stats.linregress	A										<section class="prog__container"><p>Calculate a linear least-squares regression for two sets of measurements.</p><pre><code>scipy.stats.linregress(x, y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Two sets of measurements.  Both arrays should have the same length. If only x is given (and y=None), then it must be a two-dimensional array where one dimension has length 2.  The two sets of measurements are then found by splitting the array along the length-2 dimension.</code></pre><span class="prog__sub">Returns:</span><pre><code>slope : float\n    slope of the regression line \nintercept : float\n    intercept of the regression line \nrvalue : float\n    correlation coefficient \npvalue : float\n    two-sided p-value for a hypothesis test whose null hypothesis is that the slope is zero. \nstderr : float\n    Standard error of the estimated gradient.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(12345678)\n>>> x = np.random.random(10)\n>>> y = np.random.random(10)\n>>> slope, intercept, r_value, p_value, std_err = stats.linregress(x,y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html
scipy stats linregress	R	scipy.stats.linregress										
scipy stats.linregress	R	scipy.stats.linregress										
scipy.stats.loggamma	A										<section class="prog__container"><p>A log gamma continuous random variable.</p><pre><code>scipy.stats.loggamma = <scipy.stats._continuous_distns.loggamma_gen object at 0x2aba950b0f50></code></pre><span class="prog__sub">Examples:</span><pre><code>loggamma.pdf(x, c) = exp(c*x-exp(x)) / gamma(c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.loggamma.html
scipy stats loggamma	R	scipy.stats.loggamma										
scipy stats.loggamma	R	scipy.stats.loggamma										
scipy.stats.logistic	A										<section class="prog__container"><p>A logistic (or Sech-squared) continuous random variable.</p><pre><code>scipy.stats.logistic = <scipy.stats._continuous_distns.logistic_gen object at 0x2aba950b0d50></code></pre><span class="prog__sub">Examples:</span><pre><code>logistic.pdf(x) = exp(-x) / (1+exp(-x))**2</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.logistic.html
scipy stats logistic	R	scipy.stats.logistic										
scipy stats.logistic	R	scipy.stats.logistic										
scipy.stats.loglaplace	A										<section class="prog__container"><p>A log-Laplace continuous random variable.</p><pre><code>scipy.stats.loglaplace = <scipy.stats._continuous_distns.loglaplace_gen object at 0x2aba950b8210></code></pre><span class="prog__sub">Examples:</span><pre><code>loglaplace.pdf(x, c) = c / 2 * x**(c-1),   for 0 < x < 1\n                     = c / 2 * x**(-c-1),  for x >= 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.loglaplace.html
scipy stats loglaplace	R	scipy.stats.loglaplace										
scipy stats.loglaplace	R	scipy.stats.loglaplace										
scipy.stats.lognorm	A										<section class="prog__container"><p>A lognormal continuous random variable.</p><pre><code>scipy.stats.lognorm = <scipy.stats._continuous_distns.lognorm_gen object at 0x2aba950b8490></code></pre><span class="prog__sub">Examples:</span><pre><code>lognorm.pdf(x, s) = 1 / (s*x*sqrt(2*pi)) * exp(-1/2*(log(x)/s)**2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.lognorm.html
scipy stats lognorm	R	scipy.stats.lognorm										
scipy stats.lognorm	R	scipy.stats.lognorm										
scipy.stats.logser	A										<section class="prog__container"><p>A Logarithmic (Log-Series, Series) discrete random variable.</p><pre><code>scipy.stats.logser = <scipy.stats._discrete_distns.logser_gen object at 0x2aba9510f250></code></pre><span class="prog__sub">Examples:</span><pre><code>logser.pmf(k) = - p**k / (k*log(1-p))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.logser.html
scipy stats logser	R	scipy.stats.logser										
scipy stats.logser	R	scipy.stats.logser										
scipy.stats.lomax	A										<section class="prog__container"><p>A Lomax (Pareto of the second kind) continuous random variable.</p><pre><code>scipy.stats.lomax = <scipy.stats._continuous_distns.lomax_gen object at 0x2aba950c82d0></code></pre><span class="prog__sub">Examples:</span><pre><code>lomax.pdf(x, c) = c / (1+x)**(c+1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.lomax.html
scipy stats lomax	R	scipy.stats.lomax										
scipy stats.lomax	R	scipy.stats.lomax										
scipy.stats.mannwhitneyu	A										<section class="prog__container"><p>Computes the Mann-Whitney rank test on samples x and y.</p><pre><code>scipy.stats.mannwhitneyu(x, y, use_continuity=True, alternative=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Array of samples, should be one-dimensional. \nuse_continuity : bool, optional\n    Whether a continuity correction (1/2.) should be taken into account. Default is True. \nalternative : None (deprecated), ‘less’, ‘two-sided’, or ‘greater’\n    Whether to get the p-value for the one-sided hypothesis (‘less’ or ‘greater’) or for the two-sided hypothesis (‘two-sided’). Defaults to None, which results in a p-value half the size of the ‘two-sided’ p-value and a different U statistic. The default behavior is not the same as using ‘less’ or ‘greater’: it only exists for backward compatibility and is deprecated.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The Mann-Whitney U statistic, equal to min(U for x, U for y) if alternative is equal to None (deprecated; exists for backward compatibility), and U for y otherwise. \npvalue : float\n    p-value assuming an asymptotic normal distribution. One-sided or two-sided, depending on the choice of alternative.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mannwhitneyu.html
scipy stats mannwhitneyu	R	scipy.stats.mannwhitneyu										
scipy stats.mannwhitneyu	R	scipy.stats.mannwhitneyu										
scipy.stats.matrix_normal	A										<section class="prog__container"><p>A matrix normal random variable.</p><pre><code>scipy.stats.matrix_normal = <scipy.stats._multivariate.matrix_normal_gen object at 0x2aba953e4b10></code></pre><span class="prog__sub">Parameters:</span><pre><code>X : array_like\n    Quantiles, with the last two axes of X denoting the components. \nmean : array_like, optional\n    Mean of the distribution (default: None) \nrowcov : array_like, optional\n    Among-row covariance matrix of the distribution (default: 1) \ncolcov : array_like, optional\n    Among-column covariance matrix of the distribution (default: 1) \nrandom_state : None or int or np.random.RandomState instance, optional\n    If int or RandomState, use it for drawing the random variates. If None (or np.random), the global np.random state is used. Default is None. \nAlternatively, the object may be called (as a function) to fix the mean\nand covariance parameters, returning a “frozen” matrix normal\nrandom variable:\nrv = matrix_normal(mean=None, rowcov=1, colcov=1)\n    Frozen object with the same methods but holding the given mean and covariance fixed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import matrix_normal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.matrix_normal.html
scipy stats matrix_normal	R	scipy.stats.matrix_normal										
scipy stats.matrix_normal	R	scipy.stats.matrix_normal										
scipy.stats.maxwell	A										<section class="prog__container"><p>A Maxwell continuous random variable.</p><pre><code>scipy.stats.maxwell = <scipy.stats._continuous_distns.maxwell_gen object at 0x2aba950b8910></code></pre><span class="prog__sub">Examples:</span><pre><code>maxwell.pdf(x) = sqrt(2/pi)x**2 * exp(-x**2/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.maxwell.html
scipy stats maxwell	R	scipy.stats.maxwell										
scipy stats.maxwell	R	scipy.stats.maxwell										
scipy.stats.median_test	A										<section class="prog__container"><p>Mood’s median test.</p><pre><code>scipy.stats.median_test(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample1, sample2, ... : array_like\n    The set of samples.  There must be at least two samples. Each sample must be a one-dimensional sequence containing at least one value.  The samples are not required to have the same length. \nties : str, optional\n    Determines how values equal to the grand median are classified in the contingency table.  The string must be one of: "below":     Values equal to the grand median are counted as "below". "above":     Values equal to the grand median are counted as "above". "ignore":     Values equal to the grand median are not counted.   The default is “below”. \ncorrection : bool, optional\n    If True, and there are just two samples, apply Yates’ correction for continuity when computing the test statistic associated with the contingency table.  Default is True. \nlambda_ : float or str, optional.\n    By default, the statistic computed in this test is Pearson’s chi-squared statistic.  lambda_ allows a statistic from the Cressie-Read power divergence family to be used instead.  See power_divergence for details. Default is 1 (Pearson’s chi-squared statistic).</code></pre><span class="prog__sub">Returns:</span><pre><code>stat : float\n    The test statistic.  The statistic that is returned is determined by lambda_.  The default is Pearson’s chi-squared statistic. \np : float\n    The p-value of the test. \nm : float\n    The grand median. \ntable : ndarray\n    The contingency table.  The shape of the table is (2, n), where n is the number of samples.  The first row holds the counts of the values above the grand median, and the second row holds the counts of the values below the grand median.  The table allows further analysis with, for example, scipy.stats.chi2_contingency, or with scipy.stats.fisher_exact if there are two samples, without having to recompute the table.</code></pre><span class="prog__sub">Examples:</span><pre><code>"below":\n    Values equal to the grand median are counted as "below".\n"above":\n    Values equal to the grand median are counted as "above".\n"ignore":\n    Values equal to the grand median are not counted.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.median_test.html
scipy stats median_test	R	scipy.stats.median_test										
scipy stats.median_test	R	scipy.stats.median_test										
scipy.stats.mielke	A										<section class="prog__container"><p>A Mielke’s Beta-Kappa continuous random variable.</p><pre><code>scipy.stats.mielke = <scipy.stats._continuous_distns.mielke_gen object at 0x2aba950b8b10></code></pre><span class="prog__sub">Examples:</span><pre><code>mielke.pdf(x, k, s) = k * x**(k-1) / (1+x**s)**(1+k/s)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mielke.html
scipy stats mielke	R	scipy.stats.mielke										
scipy stats.mielke	R	scipy.stats.mielke										
scipy.stats.mode	A										<section class="prog__container"><p>Returns an array of the modal (most common) value in the passed array.</p><pre><code>scipy.stats.mode(a, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    n-dimensional array of which to find mode(s). \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>mode : ndarray\n    Array of modal values. \ncount : ndarray\n    Array of counts for each mode.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([[6, 8, 3, 0],\n...               [3, 2, 1, 7],\n...               [8, 1, 8, 4],\n...               [5, 3, 0, 5],\n...               [4, 7, 5, 9]])\n>>> from scipy import stats\n>>> stats.mode(a)\n(array([[3, 1, 0, 0]]), array([[1, 1, 1, 1]]))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mode.html
scipy stats mode	R	scipy.stats.mode										
scipy stats.mode	R	scipy.stats.mode										
scipy.stats.moment	A					[[scipy.stats.kurtosis]]\\n[[scipy.stats.skew]]\\n[[scipy.stats.describe]]					<section class="prog__container"><p>Calculates the nth moment about the mean for a sample.</p><pre><code>scipy.stats.moment(a, moment=1, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    data \nmoment : int or array_like of ints, optional\n    order of central moment that is returned. Default is 1. \naxis : int or None, optional\n    Axis along which the central moment is computed. Default is 0. If None, compute over the whole array a. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>n-th central moment : ndarray or float\n    The appropriate moment along the given axis or over all values if axis is None. The denominator for the moment calculation is the number of observations, no degrees of freedom correction is done.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.moment.html
scipy stats moment	R	scipy.stats.moment										
scipy stats.moment	R	scipy.stats.moment										
scipy.stats.mood	A										<section class="prog__container"><p>Perform Mood’s test for equal scale parameters.</p><pre><code>scipy.stats.mood(x, y, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Arrays of sample data. \naxis : int, optional\n    The axis along which the samples are tested.  x and y can be of different length along axis. If axis is None, x and y are flattened and the test is done on all values in the flattened arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>z : scalar or ndarray\n    The z-score for the hypothesis test.  For 1-D inputs a scalar is returned. \np-value : scalar ndarray\n    The p-value for the hypothesis test.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(1234)\n>>> x2 = np.random.randn(2, 45, 6, 7)\n>>> x1 = np.random.randn(2, 30, 6, 7)\n>>> z, p = stats.mood(x1, x2, axis=1)\n>>> p.shape\n(2, 6, 7)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mood.html
scipy stats mood	R	scipy.stats.mood										
scipy stats.mood	R	scipy.stats.mood										
scipy.stats.mstats.argstoarray	A										<section class="prog__container"><p>Constructs a 2D array from a group of sequences.</p><pre><code>scipy.stats.mstats.argstoarray(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>args : sequences\n    Group of sequences.</code></pre><span class="prog__sub">Returns:</span><pre><code>argstoarray : MaskedArray\n    A ( m x n ) masked array, where m is the number of arguments and n the length of the longest argument.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.argstoarray.html
scipy stats mstats argstoarray	R	scipy.stats.mstats.argstoarray										
scipy stats.mstats.argstoarray	R	scipy.stats.mstats.argstoarray										
scipy.stats.mstats.betai	A										<section class="prog__container"><p>betai is deprecated!\nmstats.betai is deprecated in scipy 0.17.0; use special.betainc instead.</p><pre><code>scipy.stats.mstats.betai(*args, **kwds)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.betai.html
scipy stats mstats betai	R	scipy.stats.mstats.betai										
scipy stats.mstats.betai	R	scipy.stats.mstats.betai										
scipy.stats.mstats.chisquare	A										<section class="prog__container"><p>Calculates a one-way chi square test.</p><pre><code>scipy.stats.mstats.chisquare(f_obs, f_exp=None, ddof=0, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f_obs : array_like\n    Observed frequencies in each category. \nf_exp : array_like, optional\n    Expected frequencies in each category.  By default the categories are assumed to be equally likely. \nddof : int, optional\n    “Delta degrees of freedom”: adjustment to the degrees of freedom for the p-value.  The p-value is computed using a chi-squared distribution with k - 1 - ddof degrees of freedom, where k is the number of observed frequencies.  The default value of ddof is 0. \naxis : int or None, optional\n    The axis of the broadcast result of f_obs and f_exp along which to apply the test.  If axis is None, all values in f_obs are treated as a single data set.  Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>chisq : float or ndarray\n    The chi-squared test statistic.  The value is a float if axis is None or f_obs and f_exp are 1-D. \np : float or ndarray\n    The p-value of the test.  The value is a float if ddof and the return value chisq are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import chisquare\n>>> chisquare([16, 18, 16, 14, 12, 12])\n(2.0, 0.84914503608460956)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.chisquare.html
scipy stats mstats chisquare	R	scipy.stats.mstats.chisquare										
scipy stats.mstats.chisquare	R	scipy.stats.mstats.chisquare										
scipy.stats.mstats.compare_medians_ms	A										<section class="prog__container"><p>Compares the medians from two independent groups along the given axis.</p><pre><code>scipy.stats.mstats.compare_medians_ms(group_1, group_2, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>group_1 : array_like\n    First dataset. \ngroup_2 : array_like\n    Second dataset. \naxis : int, optional\n    Axis along which the medians are estimated. If None, the arrays are flattened.  If axis is not None, then group_1 and group_2 should have the same shape.</code></pre><span class="prog__sub">Returns:</span><pre><code>compare_medians_ms : {float, ndarray}\n    If axis is None, then returns a float, otherwise returns a 1-D ndarray of floats with a length equal to the length of group_1 along axis.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.compare_medians_ms.html
scipy stats mstats compare_medians_ms	R	scipy.stats.mstats.compare_medians_ms										
scipy stats.mstats.compare_medians_ms	R	scipy.stats.mstats.compare_medians_ms										
scipy.stats.mstats.count_tied_groups	A										<section class="prog__container"><p>Counts the number of tied values.</p><pre><code>scipy.stats.mstats.count_tied_groups(x, use_missing=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : sequence\n    Sequence of data on which to counts the ties \nuse_missing : bool, optional\n    Whether to consider missing values as tied.</code></pre><span class="prog__sub">Returns:</span><pre><code>count_tied_groups : dict\n    Returns a dictionary (nb of ties: nb of groups).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import mstats\n>>> z = [0, 0, 0, 2, 2, 2, 3, 3, 4, 5, 6]\n>>> mstats.count_tied_groups(z)\n{2: 1, 3: 2}</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.count_tied_groups.html
scipy stats mstats count_tied_groups	R	scipy.stats.mstats.count_tied_groups										
scipy stats.mstats.count_tied_groups	R	scipy.stats.mstats.count_tied_groups										
scipy.stats.mstats.describe	A										<section class="prog__container"><p>Computes several descriptive statistics of the passed array.</p><pre><code>scipy.stats.mstats.describe(a, axis=0, ddof=0, bias=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Data array \naxis : int or None, optional\n    Axis along which to calculate statistics. Default 0. If None, compute over the whole array a. \nddof : int, optional\n    degree of freedom (default 0); note that default ddof is different from the same routine in stats.describe \nbias : bool, optional\n    If False, then the skewness and kurtosis calculations are corrected for statistical bias.</code></pre><span class="prog__sub">Returns:</span><pre><code>nobs : int\n    (size of the data (discarding missing values) \nminmax : (int, int)\n    min, max \nmean : float\n    arithmetic mean \nvariance : float\n    unbiased variance \nskewness : float\n    biased skewness \nkurtosis : float\n    biased kurtosis</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats.mstats import describe\n>>> ma = np.ma.array(range(6), mask=[0, 0, 0, 1, 1, 1])\n>>> describe(ma)\nDescribeResult(nobs=array(3), minmax=(masked_array(data = 0,\n             mask = False,\n       fill_value = 999999)\n, masked_array(data = 2,\n             mask = False,\n       fill_value = 999999)\n), mean=1.0, variance=0.66666666666666663, skewness=masked_array(data = 0.0,\n             mask = False,\n       fill_value = 1e+20)\n, kurtosis=-1.5)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.describe.html
scipy stats mstats describe	R	scipy.stats.mstats.describe										
scipy stats.mstats.describe	R	scipy.stats.mstats.describe										
scipy.stats.mstats.find_repeats	A										<section class="prog__container"><p>Find repeats in arr and return a tuple (repeats, repeat_count).</p><pre><code>scipy.stats.mstats.find_repeats(arr)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arr : sequence\n    Input array. The array is flattened if it is not 1D.</code></pre><span class="prog__sub">Returns:</span><pre><code>repeats : ndarray\n    Array of repeated values. \ncounts : ndarray\n    Array of counts.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.find_repeats.html
scipy stats mstats find_repeats	R	scipy.stats.mstats.find_repeats										
scipy stats.mstats.find_repeats	R	scipy.stats.mstats.find_repeats										
scipy.stats.mstats.f_oneway	A										<section class="prog__container"><p>Performs a 1-way ANOVA, returning an F-value and probability given\nany number of groups.  From Heiman, pp.394-7.</p><pre><code>scipy.stats.mstats.f_oneway(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>statistic : float\n    The computed F-value of the test. \npvalue : float\n    The associated p-value from the F-distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.f_oneway.html
scipy stats mstats f_oneway	R	scipy.stats.mstats.f_oneway										
scipy stats.mstats.f_oneway	R	scipy.stats.mstats.f_oneway										
scipy.stats.mstats.friedmanchisquare	A										<section class="prog__container"><p>Friedman Chi-Square is a non-parametric, one-way within-subjects ANOVA.\nThis function calculates the Friedman Chi-square test for repeated measures\nand returns the result, along with the associated probability value.</p><pre><code>scipy.stats.mstats.friedmanchisquare(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>statistic : float\n    the test statistic. \npvalue : float\n    the associated p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.friedmanchisquare.html
scipy stats mstats friedmanchisquare	R	scipy.stats.mstats.friedmanchisquare										
scipy stats.mstats.friedmanchisquare	R	scipy.stats.mstats.friedmanchisquare										
scipy.stats.mstats.f_value_wilks_lambda	A										<section class="prog__container"><p>f_value_wilks_lambda is deprecated!\nmstats.f_value_wilks_lambda deprecated in scipy 0.17.0</p><pre><code>scipy.stats.mstats.f_value_wilks_lambda(*args, **kwds)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.f_value_wilks_lambda.html
scipy stats mstats f_value_wilks_lambda	R	scipy.stats.mstats.f_value_wilks_lambda										
scipy stats.mstats.f_value_wilks_lambda	R	scipy.stats.mstats.f_value_wilks_lambda										
scipy.stats.mstats.gmean	A										<section class="prog__container"><p>Compute the geometric mean along the specified axis.</p><pre><code>scipy.stats.mstats.gmean(a, axis=0, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array or object that can be converted to an array. \naxis : int or None, optional\n    Axis along which the geometric mean is computed. Default is 0. If None, compute over the whole array a. \ndtype : dtype, optional\n    Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>gmean : ndarray\n    see dtype parameter above</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.gmean.html
scipy stats mstats gmean	R	scipy.stats.mstats.gmean										
scipy stats.mstats.gmean	R	scipy.stats.mstats.gmean										
scipy.stats.mstats.hdmedian	A										<section class="prog__container"><p>Returns the Harrell-Davis estimate of the median along the given axis.</p><pre><code>scipy.stats.mstats.hdmedian(data, axis=-1, var=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    Data array. \naxis : int, optional\n    Axis along which to compute the quantiles. If None, use a flattened array. \nvar : bool, optional\n    Whether to return the variance of the estimate.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.hdmedian.html
scipy stats mstats hdmedian	R	scipy.stats.mstats.hdmedian										
scipy stats.mstats.hdmedian	R	scipy.stats.mstats.hdmedian										
scipy.stats.mstats.hdquantiles	A										<section class="prog__container"><p>Computes quantile estimates with the Harrell-Davis method.</p><pre><code>scipy.stats.mstats.hdquantiles(data, prob=[0.25, 0.5, 0.75], axis=None, var=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Data array. \nprob : sequence, optional\n    Sequence of quantiles to compute. \naxis : int or None, optional\n    Axis along which to compute the quantiles. If None, use a flattened array. \nvar : bool, optional\n    Whether to return the variance of the estimate.</code></pre><span class="prog__sub">Returns:</span><pre><code>hdquantiles : MaskedArray\n    A (p,) array of quantiles (if var is False), or a (2,p) array of quantiles and variances (if var is True), where p is the number of quantiles.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.hdquantiles.html
scipy stats mstats hdquantiles	R	scipy.stats.mstats.hdquantiles										
scipy stats.mstats.hdquantiles	R	scipy.stats.mstats.hdquantiles										
scipy.stats.mstats.hdquantiles_sd	A										<section class="prog__container"><p>The standard error of the Harrell-Davis quantile estimates by jackknife.</p><pre><code>scipy.stats.mstats.hdquantiles_sd(data, prob=[0.25, 0.5, 0.75], axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Data array. \nprob : sequence, optional\n    Sequence of quantiles to compute. \naxis : int, optional\n    Axis along which to compute the quantiles. If None, use a flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>hdquantiles_sd : MaskedArray\n    Standard error of the Harrell-Davis quantile estimates.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.hdquantiles_sd.html
scipy stats mstats hdquantiles_sd	R	scipy.stats.mstats.hdquantiles_sd										
scipy stats.mstats.hdquantiles_sd	R	scipy.stats.mstats.hdquantiles_sd										
scipy.stats.mstats.hmean	A										<section class="prog__container"><p>Calculates the harmonic mean along the specified axis.</p><pre><code>scipy.stats.mstats.hmean(a, axis=0, dtype=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array, masked array or object that can be converted to an array. \naxis : int or None, optional\n    Axis along which the harmonic mean is computed. Default is 0. If None, compute over the whole array a. \ndtype : dtype, optional\n    Type of the returned array and of the accumulator in which the elements are summed. If dtype is not specified, it defaults to the dtype of a, unless a has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</code></pre><span class="prog__sub">Returns:</span><pre><code>hmean : ndarray\n    see dtype parameter above</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.hmean.html
scipy stats mstats hmean	R	scipy.stats.mstats.hmean										
scipy stats.mstats.hmean	R	scipy.stats.mstats.hmean										
scipy.stats.mstats.idealfourths	A										<section class="prog__container"><p>Returns an estimate of the lower and upper quartiles.</p><pre><code>scipy.stats.mstats.idealfourths(data, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input array. \naxis : int, optional\n    Axis along which the quartiles are estimated. If None, the arrays are flattened.</code></pre><span class="prog__sub">Returns:</span><pre><code>idealfourths : {list of floats, masked array}\n    Returns the two internal values that divide data into four parts using the ideal fourths algorithm either along the flattened array (if axis is None) or along axis of data.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.idealfourths.html
scipy stats mstats idealfourths	R	scipy.stats.mstats.idealfourths										
scipy stats.mstats.idealfourths	R	scipy.stats.mstats.idealfourths										
scipy.stats.mstats.kendalltau	A										<section class="prog__container"><p>Computes Kendall’s rank correlation tau on two variables x and y.</p><pre><code>scipy.stats.mstats.kendalltau(x, y, use_ties=True, use_missing=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : sequence\n    First data list (for example, time). \ny : sequence\n    Second data list. \nuse_ties : {True, False}, optional\n    Whether ties correction should be performed. \nuse_missing : {False, True}, optional\n    Whether missing data should be allocated a rank of 0 (False) or the average rank (True)</code></pre><span class="prog__sub">Returns:</span><pre><code>correlation : float\n    Kendall tau \npvalue : float\n    Approximate 2-side p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.kendalltau.html
scipy stats mstats kendalltau	R	scipy.stats.mstats.kendalltau										
scipy stats.mstats.kendalltau	R	scipy.stats.mstats.kendalltau										
scipy.stats.mstats.kendalltau_seasonal	A										<section class="prog__container"><p>Computes a multivariate Kendall’s rank correlation tau, for seasonal data.</p><pre><code>scipy.stats.mstats.kendalltau_seasonal(x)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : 2-D ndarray\n    Array of seasonal data, with seasons in columns.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.kendalltau_seasonal.html
scipy stats mstats kendalltau_seasonal	R	scipy.stats.mstats.kendalltau_seasonal										
scipy stats.mstats.kendalltau_seasonal	R	scipy.stats.mstats.kendalltau_seasonal										
scipy.stats.mstats.kruskal	A										<section class="prog__container"><p>Compute the Kruskal-Wallis H-test for independent samples</p><pre><code>scipy.stats.mstats.kruskal(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample1, sample2, ... : array_like\n    Two or more arrays with the sample measurements can be given as arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The Kruskal-Wallis H statistic, corrected for ties \npvalue : float\n    The p-value for the test using the assumption that H has a chi square distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.kruskal.html
scipy stats mstats kruskal	R	scipy.stats.mstats.kruskal										
scipy stats.mstats.kruskal	R	scipy.stats.mstats.kruskal										
scipy.stats.mstats.kruskalwallis	A										<section class="prog__container"><p>Compute the Kruskal-Wallis H-test for independent samples</p><pre><code>scipy.stats.mstats.kruskalwallis(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>sample1, sample2, ... : array_like\n    Two or more arrays with the sample measurements can be given as arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The Kruskal-Wallis H statistic, corrected for ties \npvalue : float\n    The p-value for the test using the assumption that H has a chi square distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.kruskalwallis.html
scipy stats mstats kruskalwallis	R	scipy.stats.mstats.kruskalwallis										
scipy stats.mstats.kruskalwallis	R	scipy.stats.mstats.kruskalwallis										
scipy.stats.mstats.ks_2samp	A										<section class="prog__container"><p>Computes the Kolmogorov-Smirnov test on two samples.</p><pre><code>scipy.stats.mstats.ks_2samp(data1, data2, alternative='two-sided')</code></pre><span class="prog__sub">Parameters:</span><pre><code>data1 : array_like\n    First data set \ndata2 : array_like\n    Second data set \nalternative : {‘two-sided’, ‘less’, ‘greater’}, optional\n    Indicates the alternative hypothesis.  Default is ‘two-sided’.</code></pre><span class="prog__sub">Returns:</span><pre><code>d : float\n    Value of the Kolmogorov Smirnov test \np : float\n    Corresponding p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.ks_2samp.html
scipy stats mstats ks_2samp	R	scipy.stats.mstats.ks_2samp										
scipy stats.mstats.ks_2samp	R	scipy.stats.mstats.ks_2samp										
scipy.stats.mstats.ks_twosamp	A										<section class="prog__container"><p>Computes the Kolmogorov-Smirnov test on two samples.</p><pre><code>scipy.stats.mstats.ks_twosamp(data1, data2, alternative='two-sided')</code></pre><span class="prog__sub">Parameters:</span><pre><code>data1 : array_like\n    First data set \ndata2 : array_like\n    Second data set \nalternative : {‘two-sided’, ‘less’, ‘greater’}, optional\n    Indicates the alternative hypothesis.  Default is ‘two-sided’.</code></pre><span class="prog__sub">Returns:</span><pre><code>d : float\n    Value of the Kolmogorov Smirnov test \np : float\n    Corresponding p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.ks_twosamp.html
scipy stats mstats ks_twosamp	R	scipy.stats.mstats.ks_twosamp										
scipy stats.mstats.ks_twosamp	R	scipy.stats.mstats.ks_twosamp										
scipy.stats.mstats.kurtosis	A										<section class="prog__container"><p>Computes the kurtosis (Fisher or Pearson) of a dataset.</p><pre><code>scipy.stats.mstats.kurtosis(a, axis=0, fisher=True, bias=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array\n    data for which the kurtosis is calculated \naxis : int or None, optional\n    Axis along which the kurtosis is calculated. Default is 0. If None, compute over the whole array a. \nfisher : bool, optional\n    If True, Fisher’s definition is used (normal ==> 0.0). If False, Pearson’s definition is used (normal ==> 3.0). \nbias : bool, optional\n    If False, then the calculations are corrected for statistical bias.</code></pre><span class="prog__sub">Returns:</span><pre><code>kurtosis : array\n    The kurtosis of values along an axis. If all values are equal, return -3 for Fisher’s definition and 0 for Pearson’s definition.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.kurtosis.html
scipy stats mstats kurtosis	R	scipy.stats.mstats.kurtosis										
scipy stats.mstats.kurtosis	R	scipy.stats.mstats.kurtosis										
scipy.stats.mstats.kurtosistest	A										<section class="prog__container"><p>Tests whether a dataset has normal kurtosis</p><pre><code>scipy.stats.mstats.kurtosistest(a, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array\n    array of the sample data \naxis : int or None, optional\n    Axis along which to compute test. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The computed z-score for this test. \npvalue : float\n    The 2-sided p-value for the hypothesis test</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.kurtosistest.html
scipy stats mstats kurtosistest	R	scipy.stats.mstats.kurtosistest										
scipy stats.mstats.kurtosistest	R	scipy.stats.mstats.kurtosistest										
scipy.stats.mstats.linregress	A										<section class="prog__container"><p>Calculate a linear least-squares regression for two sets of measurements.</p><pre><code>scipy.stats.mstats.linregress(x, y=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x, y : array_like\n    Two sets of measurements.  Both arrays should have the same length. If only x is given (and y=None), then it must be a two-dimensional array where one dimension has length 2.  The two sets of measurements are then found by splitting the array along the length-2 dimension.</code></pre><span class="prog__sub">Returns:</span><pre><code>slope : float\n    slope of the regression line \nintercept : float\n    intercept of the regression line \nrvalue : float\n    correlation coefficient \npvalue : float\n    two-sided p-value for a hypothesis test whose null hypothesis is that the slope is zero. \nstderr : float\n    Standard error of the estimated gradient.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(12345678)\n>>> x = np.random.random(10)\n>>> y = np.random.random(10)\n>>> slope, intercept, r_value, p_value, std_err = stats.linregress(x,y)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.linregress.html
scipy stats mstats linregress	R	scipy.stats.mstats.linregress										
scipy stats.mstats.linregress	R	scipy.stats.mstats.linregress										
scipy.stats.mstats.mannwhitneyu	A										<section class="prog__container"><p>Computes the Mann-Whitney statistic</p><pre><code>scipy.stats.mstats.mannwhitneyu(x, y, use_continuity=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : sequence\n    Input \ny : sequence\n    Input \nuse_continuity : {True, False}, optional\n    Whether a continuity correction (1/2.) should be taken into account.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The Mann-Whitney statistics \npvalue : float\n    Approximate p-value assuming a normal distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mannwhitneyu.html
scipy stats mstats mannwhitneyu	R	scipy.stats.mstats.mannwhitneyu										
scipy stats.mstats.mannwhitneyu	R	scipy.stats.mstats.mannwhitneyu										
scipy.stats.mstats.median_cihs	A										<section class="prog__container"><p>Computes the alpha-level confidence interval for the median of the data.</p><pre><code>scipy.stats.mstats.median_cihs(data, alpha=0.05, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data. Masked values are discarded. The input should be 1D only, or axis should be set to None. \nalpha : float, optional\n    Confidence level of the intervals. \naxis : int or None, optional\n    Axis along which to compute the quantiles. If None, use a flattened array.</code></pre><span class="prog__sub">Returns:</span><pre><code>median_cihs\n    Alpha level confidence interval.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.median_cihs.html
scipy stats mstats median_cihs	R	scipy.stats.mstats.median_cihs										
scipy stats.mstats.median_cihs	R	scipy.stats.mstats.median_cihs										
scipy.stats.mstats.meppf	A										<section class="prog__container"><p>Returns plotting positions (or empirical percentile points) for the data.</p><pre><code>scipy.stats.mstats.meppf(data, alpha=0.4, beta=0.4)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data, as a sequence or array of dimension at most 2. \nalpha : float, optional\n    Plotting positions parameter. Default is 0.4. \nbeta : float, optional\n    Plotting positions parameter. Default is 0.4.</code></pre><span class="prog__sub">Returns:</span><pre><code>positions : MaskedArray\n    The calculated plotting positions.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.meppf.html
scipy stats mstats meppf	R	scipy.stats.mstats.meppf										
scipy stats.mstats.meppf	R	scipy.stats.mstats.meppf										
scipy.stats.mstats.mjci	A										<section class="prog__container"><p>Returns the Maritz-Jarrett estimators of the standard error of selected\nexperimental quantiles of the data.</p><pre><code>scipy.stats.mstats.mjci(data, prob=[0.25, 0.5, 0.75], axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    Data array. \nprob : sequence, optional\n    Sequence of quantiles to compute. \naxis : int or None, optional\n    Axis along which to compute the quantiles. If None, use a flattened array.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mjci.html
scipy stats mstats mjci	R	scipy.stats.mstats.mjci										
scipy stats.mstats.mjci	R	scipy.stats.mstats.mjci										
scipy.stats.mstats.mode	A										<section class="prog__container"><p>Returns an array of the modal (most common) value in the passed array.</p><pre><code>scipy.stats.mstats.mode(a, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    n-dimensional array of which to find mode(s). \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>mode : ndarray\n    Array of modal values. \ncount : ndarray\n    Array of counts for each mode.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mode.html
scipy stats mstats mode	R	scipy.stats.mstats.mode										
scipy stats.mstats.mode	R	scipy.stats.mstats.mode										
scipy.stats.mstats.moment	A										<section class="prog__container"><p>Calculates the nth moment about the mean for a sample.</p><pre><code>scipy.stats.mstats.moment(a, moment=1, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    data \nmoment : int, optional\n    order of central moment that is returned \naxis : int or None, optional\n    Axis along which the central moment is computed. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>n-th central moment : ndarray or float\n    The appropriate moment along the given axis or over all values if axis is None. The denominator for the moment calculation is the number of observations, no degrees of freedom correction is done.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.moment.html
scipy stats mstats moment	R	scipy.stats.mstats.moment										
scipy stats.mstats.moment	R	scipy.stats.mstats.moment										
scipy.stats.mstats.mquantiles	A										<section class="prog__container"><p>Computes empirical quantiles for a data array.</p><pre><code>scipy.stats.mstats.mquantiles(a, prob=[0.25, 0.5, 0.75], alphap=0.4, betap=0.4, axis=None, limit=())</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input data, as a sequence or array of dimension at most 2. \nprob : array_like, optional\n    List of quantiles to compute. \nalphap : float, optional\n    Plotting positions parameter, default is 0.4. \nbetap : float, optional\n    Plotting positions parameter, default is 0.4. \naxis : int, optional\n    Axis along which to perform the trimming. If None (default), the input array is first flattened. \nlimit : tuple, optional\n    Tuple of (lower, upper) values. Values of a outside this open interval are ignored.</code></pre><span class="prog__sub">Returns:</span><pre><code>mquantiles : MaskedArray\n    An array containing the calculated quantiles.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats.mstats import mquantiles\n>>> a = np.array([6., 47., 49., 15., 42., 41., 7., 39., 43., 40., 36.])\n>>> mquantiles(a)\narray([ 19.2,  40. ,  42.8])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html
scipy.stats.mstats.mquantiles_cimj	A										<section class="prog__container"><p>Computes the alpha confidence interval for the selected quantiles of the\ndata, with Maritz-Jarrett estimators.</p><pre><code>scipy.stats.mstats.mquantiles_cimj(data, prob=[0.25, 0.5, 0.75], alpha=0.05, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    Data array. \nprob : sequence, optional\n    Sequence of quantiles to compute. \nalpha : float, optional\n    Confidence level of the intervals. \naxis : int or None, optional\n    Axis along which to compute the quantiles. If None, use a flattened array.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles_cimj.html
scipy stats mstats mquantiles_cimj	R	scipy.stats.mstats.mquantiles_cimj										
scipy stats.mstats.mquantiles_cimj	R	scipy.stats.mstats.mquantiles_cimj										
scipy stats mstats mquantiles	R	scipy.stats.mstats.mquantiles										
scipy stats.mstats.mquantiles	R	scipy.stats.mstats.mquantiles										
scipy.stats.mstats.msign	A										<section class="prog__container"><p>Returns the sign of x, or 0 if x is masked.</p><pre><code>scipy.stats.mstats.msign(x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.msign.html
scipy stats mstats msign	R	scipy.stats.mstats.msign										
scipy stats.mstats.msign	R	scipy.stats.mstats.msign										
scipy.stats.mstats.normaltest	A										<section class="prog__container"><p>Tests whether a sample differs from a normal distribution.</p><pre><code>scipy.stats.mstats.normaltest(a, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array containing the data to be tested. \naxis : int or None, optional\n    Axis along which to compute test. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    s^2 + k^2, where s is the z-score returned by skewtest and k is the z-score returned by kurtosistest. \npvalue : float or array\n    A 2-sided chi squared probability for the hypothesis test.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.normaltest.html
scipy stats mstats normaltest	R	scipy.stats.mstats.normaltest										
scipy stats.mstats.normaltest	R	scipy.stats.mstats.normaltest										
scipy.stats.mstats.obrientransform	A										<section class="prog__container"><p>Computes a transform on input data (any number of columns).  Used to\ntest for homogeneity of variance prior to running one-way stats.  Each\narray in *args is one level of a factor.  If an f_oneway() run on\nthe transformed data and found significant, variances are unequal.   From\nMaxwell and Delaney, p.112.</p><pre><code>scipy.stats.mstats.obrientransform(*args)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.obrientransform.html
scipy stats mstats obrientransform	R	scipy.stats.mstats.obrientransform										
scipy stats.mstats.obrientransform	R	scipy.stats.mstats.obrientransform										
scipy.stats.mstats.pearsonr	A										<section class="prog__container"><p>Calculates a Pearson correlation coefficient and the p-value for testing\nnon-correlation.</p><pre><code>scipy.stats.mstats.pearsonr(x, y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : 1-D array_like\n    Input \ny : 1-D array_like\n    Input</code></pre><span class="prog__sub">Returns:</span><pre><code>pearsonr : float\n    Pearson’s correlation coefficient, 2-tailed p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.pearsonr.html
scipy stats mstats pearsonr	R	scipy.stats.mstats.pearsonr										
scipy stats.mstats.pearsonr	R	scipy.stats.mstats.pearsonr										
scipy.stats.mstats.plotting_positions	A										<section class="prog__container"><p>Returns plotting positions (or empirical percentile points) for the data.</p><pre><code>scipy.stats.mstats.plotting_positions(data, alpha=0.4, beta=0.4)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data, as a sequence or array of dimension at most 2. \nalpha : float, optional\n    Plotting positions parameter. Default is 0.4. \nbeta : float, optional\n    Plotting positions parameter. Default is 0.4.</code></pre><span class="prog__sub">Returns:</span><pre><code>positions : MaskedArray\n    The calculated plotting positions.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.plotting_positions.html
scipy stats mstats plotting_positions	R	scipy.stats.mstats.plotting_positions										
scipy stats.mstats.plotting_positions	R	scipy.stats.mstats.plotting_positions										
scipy.stats.mstats.pointbiserialr	A										<section class="prog__container"><p>Calculates a point biserial correlation coefficient and its p-value.</p><pre><code>scipy.stats.mstats.pointbiserialr(x, y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like of bools\n    Input array. \ny : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>correlation : float\n    R value \npvalue : float\n    2-tailed p-value</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.pointbiserialr.html
scipy stats mstats pointbiserialr	R	scipy.stats.mstats.pointbiserialr										
scipy stats.mstats.pointbiserialr	R	scipy.stats.mstats.pointbiserialr										
scipy.stats.mstats.rankdata	A										<section class="prog__container"><p>Returns the rank (also known as order statistics) of each data point\nalong the given axis.</p><pre><code>scipy.stats.mstats.rankdata(data, axis=None, use_missing=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : sequence\n    Input data. The data is transformed to a masked array \naxis : {None,int}, optional\n    Axis along which to perform the ranking. If None, the array is first flattened. An exception is raised if the axis is specified for arrays with a dimension larger than 2 \nuse_missing : bool, optional\n    Whether the masked values have a rank of 0 (False) or equal to the average rank of the unmasked values (True).</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.rankdata.html
scipy stats mstats rankdata	R	scipy.stats.mstats.rankdata										
scipy stats.mstats.rankdata	R	scipy.stats.mstats.rankdata										
scipy.stats.mstats.rsh	A										<section class="prog__container"><p>Evaluates Rosenblatt’s shifted histogram estimators for each point\non the dataset ‘data’.</p><pre><code>scipy.stats.mstats.rsh(data, points=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : sequence\n    Input data. Masked values are ignored. \npoints : sequence or None, optional\n    Sequence of points where to evaluate Rosenblatt shifted histogram. If None, use the data.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.rsh.html
scipy stats mstats rsh	R	scipy.stats.mstats.rsh										
scipy stats.mstats.rsh	R	scipy.stats.mstats.rsh										
scipy.stats.mstats.scoreatpercentile	A										<section class="prog__container"><p>Calculate the score at the given ‘per’ percentile of the\nsequence a.  For example, the score at per=50 is the median.</p><pre><code>scipy.stats.mstats.scoreatpercentile(data, per, limit=(), alphap=0.4, betap=0.4)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.scoreatpercentile.html
scipy stats mstats scoreatpercentile	R	scipy.stats.mstats.scoreatpercentile										
scipy stats.mstats.scoreatpercentile	R	scipy.stats.mstats.scoreatpercentile										
scipy.stats.mstats.sem	A										<section class="prog__container"><p>Calculates the standard error of the mean of the input array.</p><pre><code>scipy.stats.mstats.sem(a, axis=0, ddof=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    An array containing the values for which the standard error is returned. \naxis : int or None, optional\n    If axis is None, ravel a first. If axis is an integer, this will be the axis over which to operate. Defaults to 0. \nddof : int, optional\n    Delta degrees-of-freedom. How many degrees of freedom to adjust for bias in limited samples relative to the population estimate of variance. Defaults to 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : ndarray or float\n    The standard error of the mean in the sample(s), along the input axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> a = np.arange(20).reshape(5,4)\n>>> print(stats.mstats.sem(a))\n[2.8284271247461903 2.8284271247461903 2.8284271247461903\n 2.8284271247461903]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.sem.html
scipy stats mstats sem	R	scipy.stats.mstats.sem										
scipy stats.mstats.sem	R	scipy.stats.mstats.sem										
scipy.stats.mstats.signaltonoise	A										<section class="prog__container"><p>signaltonoise is deprecated!\nmstats.signaltonoise is deprecated in scipy 0.16.0</p><pre><code>scipy.stats.mstats.signaltonoise(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : sequence\n    Input data   axis : {0, int}, optional Axis along which to compute. If None, the computation is performed on a flat version of the array.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.signaltonoise.html
scipy stats mstats signaltonoise	R	scipy.stats.mstats.signaltonoise										
scipy stats.mstats.signaltonoise	R	scipy.stats.mstats.signaltonoise										
scipy.stats.mstats.skew	A										<section class="prog__container"><p>Computes the skewness of a data set.</p><pre><code>scipy.stats.mstats.skew(a, axis=0, bias=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    data \naxis : int or None, optional\n    Axis along which skewness is calculated. Default is 0. If None, compute over the whole array a. \nbias : bool, optional\n    If False, then the calculations are corrected for statistical bias.</code></pre><span class="prog__sub">Returns:</span><pre><code>skewness : ndarray\n    The skewness of values along an axis, returning 0 where all values are equal.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.skew.html
scipy stats mstats skew	R	scipy.stats.mstats.skew										
scipy stats.mstats.skew	R	scipy.stats.mstats.skew										
scipy.stats.mstats.skewtest	A										<section class="prog__container"><p>Tests whether the skew is different from the normal distribution.</p><pre><code>scipy.stats.mstats.skewtest(a, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array\n    The data to be tested \naxis : int or None, optional\n    Axis along which statistics are calculated. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The computed z-score for this test. \npvalue : float\n    a 2-sided p-value for the hypothesis test</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.skewtest.html
scipy stats mstats skewtest	R	scipy.stats.mstats.skewtest										
scipy stats.mstats.skewtest	R	scipy.stats.mstats.skewtest										
scipy.stats.mstats.spearmanr	A										<section class="prog__container"><p>Calculates a Spearman rank-order correlation coefficient and the p-value\nto test for non-correlation.</p><pre><code>scipy.stats.mstats.spearmanr(x, y, use_ties=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The length of x must be > 2. \ny : array_like\n    The length of y must be > 2. \nuse_ties : bool, optional\n    Whether the correction for ties should be computed.</code></pre><span class="prog__sub">Returns:</span><pre><code>correlation : float\n    Spearman correlation coefficient \npvalue : float\n    2-tailed p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.spearmanr.html
scipy stats mstats spearmanr	R	scipy.stats.mstats.spearmanr										
scipy stats.mstats.spearmanr	R	scipy.stats.mstats.spearmanr										
scipy.stats.mstats.theilslopes	A										<section class="prog__container"><p>Computes the Theil-Sen estimator for a set of points (x, y).</p><pre><code>scipy.stats.mstats.theilslopes(y, x=None, alpha=0.95)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Dependent variable. \nx : array_like or None, optional\n    Independent variable. If None, use arange(len(y)) instead. \nalpha : float, optional\n    Confidence degree between 0 and 1. Default is 95% confidence. Note that alpha is symmetric around 0.5, i.e. both 0.1 and 0.9 are interpreted as “find the 90% confidence interval”.</code></pre><span class="prog__sub">Returns:</span><pre><code>medslope : float\n    Theil slope. \nmedintercept : float\n    Intercept of the Theil line, as median(y) - medslope*median(x). \nlo_slope : float\n    Lower bound of the confidence interval on medslope. \nup_slope : float\n    Upper bound of the confidence interval on medslope.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.theilslopes.html
scipy stats mstats theilslopes	R	scipy.stats.mstats.theilslopes										
scipy stats.mstats.theilslopes	R	scipy.stats.mstats.theilslopes										
scipy.stats.mstats.threshold	A										<section class="prog__container"><p>threshold is deprecated!\nmstats.threshold is deprecated in scipy 0.17.0</p><pre><code>scipy.stats.mstats.threshold(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    Input data   threshmin : {None, float}, optional Lower threshold. If None, set to the minimum value.  threshmax : {None, float}, optional Upper threshold. If None, set to the maximum value.  newval : {0, float}, optional Value outside the thresholds.</code></pre><span class="prog__sub">Returns:</span><pre><code>threshold : ndarray\n    Returns a, with values less then threshmin and values greater threshmax replaced with newval.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.threshold.html
scipy stats mstats threshold	R	scipy.stats.mstats.threshold										
scipy stats.mstats.threshold	R	scipy.stats.mstats.threshold										
scipy.stats.mstats.tmax	A										<section class="prog__container"><p>Compute the trimmed maximum</p><pre><code>scipy.stats.mstats.tmax(a, upperlimit=None, axis=0, inclusive=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    array of values \nupperlimit : None or float, optional\n    Values in the input array greater than the given limit will be ignored. When upperlimit is None, then all values are used. The default value is None. \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \ninclusive : {True, False}, optional\n    This flag determines whether values exactly equal to the upper limit are included.  The default value is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>tmax : float, int or ndarray</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.tmax.html
scipy stats mstats tmax	R	scipy.stats.mstats.tmax										
scipy stats.mstats.tmax	R	scipy.stats.mstats.tmax										
scipy.stats.mstats.tmean	A										<section class="prog__container"><p>Compute the trimmed mean.</p><pre><code>scipy.stats.mstats.tmean(a, limits=None, inclusive=(True, True), axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array of values. \nlimits : None or (lower limit, upper limit), optional\n    Values in the input array less than the lower limit or greater than the upper limit will be ignored.  When limits is None (default), then all values are used.  Either of the limit values in the tuple can also be None representing a half-open interval. \ninclusive : (bool, bool), optional\n    A tuple consisting of the (lower flag, upper flag).  These flags determine whether values exactly equal to the lower or upper limits are included.  The default value is (True, True). \naxis : int or None, optional\n    Axis along which to operate. If None, compute over the whole array. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>tmean : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.tmean.html
scipy stats mstats tmean	R	scipy.stats.mstats.tmean										
scipy stats.mstats.tmean	R	scipy.stats.mstats.tmean										
scipy.stats.mstats.tmin	A										<section class="prog__container"><p>Compute the trimmed minimum</p><pre><code>scipy.stats.mstats.tmin(a, lowerlimit=None, axis=0, inclusive=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    array of values \nlowerlimit : None or float, optional\n    Values in the input array less than the given limit will be ignored. When lowerlimit is None, then all values are used. The default value is None. \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \ninclusive : {True, False}, optional\n    This flag determines whether values exactly equal to the lower limit are included.  The default value is True.</code></pre><span class="prog__sub">Returns:</span><pre><code>tmin : float, int or ndarray</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.tmin.html
scipy stats mstats tmin	R	scipy.stats.mstats.tmin										
scipy stats.mstats.tmin	R	scipy.stats.mstats.tmin										
scipy.stats.mstats.trima	A										<section class="prog__container"><p>Trims an array by masking the data outside some given limits.</p><pre><code>scipy.stats.mstats.trima(a, limits=None, inclusive=(True, True))</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nlimits : {None, tuple}, optional\n    Tuple of (lower limit, upper limit) in absolute values. Values of the input array lower (greater) than the lower (upper) limit will be masked.  A limit is None indicates an open interval. \ninclusive : (bool, bool) tuple, optional\n    Tuple of (lower flag, upper flag), indicating whether values exactly equal to the lower (upper) limit are allowed.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.trima.html
scipy stats mstats trima	R	scipy.stats.mstats.trima										
scipy stats.mstats.trima	R	scipy.stats.mstats.trima										
scipy.stats.mstats.trim	A										<section class="prog__container"><p>Trims an array by masking the data outside some given limits.</p><pre><code>scipy.stats.mstats.trim(a, limits=None, inclusive=(True, True), relative=False, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : sequence\n    Input array \nlimits : {None, tuple}, optional\n    If relative is False, tuple (lower limit, upper limit) in absolute values. Values of the input array lower (greater) than the lower (upper) limit are masked. If relative is True, tuple (lower percentage, upper percentage) to cut on each side of the  array, with respect to the number of unmasked data. Noting n the number of unmasked data before trimming, the (n*limits[0])th smallest data and the (n*limits[1])th largest data are masked, and the total number of unmasked data after trimming is n*(1.-sum(limits)) In each case, the value of one limit can be set to None to indicate an open interval. If limits is None, no trimming is performed \ninclusive : {(bool, bool) tuple}, optional\n    If relative is False, tuple indicating whether values exactly equal to the absolute limits are allowed. If relative is True, tuple indicating whether the number of data being masked on each side should be rounded (True) or truncated (False). \nrelative : bool, optional\n    Whether to consider the limits as absolute values (False) or proportions to cut (True). \naxis : int, optional\n    Axis along which to trim.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats.mstats import trim\n>>> z = [ 1, 2, 3, 4, 5, 6, 7, 8, 9,10]\n>>> print(trim(z,(3,8)))\n[-- -- 3 4 5 6 7 8 -- --]\n>>> print(trim(z,(0.1,0.2),relative=True))\n[-- 2 3 4 5 6 7 8 -- --]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.trim.html
scipy.stats.mstats.trimboth	A										<section class="prog__container"><p>Trims the smallest and largest data values.</p><pre><code>scipy.stats.mstats.trimboth(data, proportiontocut=0.2, inclusive=(True, True), axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : ndarray\n    Data to trim. \nproportiontocut : float, optional\n    Percentage of trimming (as a float between 0 and 1). If n is the number of unmasked values before trimming, the number of values after trimming is (1 - 2*proportiontocut) * n. Default is 0.2. \ninclusive : {(bool, bool) tuple}, optional\n    Tuple indicating whether the number of data being masked on each side should be rounded (True) or truncated (False). \naxis : int, optional\n    Axis along which to perform the trimming. If None, the input array is first flattened.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.trimboth.html
scipy stats mstats trimboth	R	scipy.stats.mstats.trimboth										
scipy stats.mstats.trimboth	R	scipy.stats.mstats.trimboth										
scipy.stats.mstats.trimmed_mean_ci	A										<section class="prog__container"><p>Selected confidence interval of the trimmed mean along the given axis.</p><pre><code>scipy.stats.mstats.trimmed_mean_ci(data, limits=(0.2, 0.2), inclusive=(True, True), alpha=0.05, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input data. \nlimits : {None, tuple}, optional\n    None or a two item tuple. Tuple of the percentages to cut on each side of the array, with respect to the number of unmasked data, as floats between 0. and 1. If n is the number of unmasked data before trimming, then (n * limits[0])th smallest data and (n * limits[1])th largest data are masked.  The total number of unmasked data after trimming is n * (1. - sum(limits)). The value of one limit can be set to None to indicate an open interval. Defaults to (0.2, 0.2). \ninclusive : (2,) tuple of boolean, optional\n    If relative==False, tuple indicating whether values exactly equal to the absolute limits are allowed. If relative==True, tuple indicating whether the number of data being masked on each side should be rounded (True) or truncated (False). Defaults to (True, True). \nalpha : float, optional\n    Confidence level of the intervals. Defaults to 0.05. \naxis : int, optional\n    Axis along which to cut. If None, uses a flattened version of data. Defaults to None.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed_mean_ci : (2,) ndarray\n    The lower and upper confidence intervals of the trimmed data.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.trimmed_mean_ci.html
scipy stats mstats trimmed_mean_ci	R	scipy.stats.mstats.trimmed_mean_ci										
scipy stats.mstats.trimmed_mean_ci	R	scipy.stats.mstats.trimmed_mean_ci										
scipy.stats.mstats.trimmed_stde	A										<section class="prog__container"><p>Returns the standard error of the trimmed mean along the given axis.</p><pre><code>scipy.stats.mstats.trimmed_stde(a, limits=(0.1, 0.1), inclusive=(1, 1), axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : sequence\n    Input array \nlimits : {(0.1,0.1), tuple of float}, optional\n    tuple (lower percentage, upper percentage) to cut  on each side of the array, with respect to the number of unmasked data. If n is the number of unmasked data before trimming, the values smaller than n * limits[0] and the values larger than n * `limits[1] are masked, and the total number of unmasked data after trimming is n * (1.-sum(limits)).  In each case, the value of one limit can be set to None to indicate an open interval. If limits is None, no trimming is performed. \ninclusive : {(bool, bool) tuple} optional\n    Tuple indicating whether the number of data being masked on each side should be rounded (True) or truncated (False). \naxis : int, optional\n    Axis along which to trim.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimmed_stde : scalar or ndarray</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.trimmed_stde.html
scipy stats mstats trimmed_stde	R	scipy.stats.mstats.trimmed_stde										
scipy stats.mstats.trimmed_stde	R	scipy.stats.mstats.trimmed_stde										
scipy.stats.mstats.trimr	A										<section class="prog__container"><p>Trims an array by masking some proportion of the data on each end.\nReturns a masked version of the input array.</p><pre><code>scipy.stats.mstats.trimr(a, limits=None, inclusive=(True, True), axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : sequence\n    Input array. \nlimits : {None, tuple}, optional\n    Tuple of the percentages to cut on each side of the array, with respect to the number of unmasked data, as floats between 0. and 1. Noting n the number of unmasked data before trimming, the (n*limits[0])th smallest data and the (n*limits[1])th largest data are masked, and the total number of unmasked data after trimming is n*(1.-sum(limits)).  The value of one limit can be set to None to indicate an open interval. \ninclusive : {(True,True) tuple}, optional\n    Tuple of flags indicating whether the number of data being masked on the left (right) end should be truncated (True) or rounded (False) to integers. \naxis : {None,int}, optional\n    Axis along which to trim. If None, the whole array is trimmed, but its shape is maintained.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.trimr.html
scipy stats mstats trimr	R	scipy.stats.mstats.trimr										
scipy stats.mstats.trimr	R	scipy.stats.mstats.trimr										
scipy stats mstats trim	R	scipy.stats.mstats.trim										
scipy stats.mstats.trim	R	scipy.stats.mstats.trim										
scipy.stats.mstats.trimtail	A										<section class="prog__container"><p>Trims the data by masking values from one tail.</p><pre><code>scipy.stats.mstats.trimtail(data, proportiontocut=0.2, tail='left', inclusive=(True, True), axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Data to trim. \nproportiontocut : float, optional\n    Percentage of trimming. If n is the number of unmasked values before trimming, the number of values after trimming is (1 - proportiontocut) * n.  Default is 0.2. \ntail : {‘left’,’right’}, optional\n    If ‘left’ the proportiontocut lowest values will be masked. If ‘right’ the proportiontocut highest values will be masked. Default is ‘left’. \ninclusive : {(bool, bool) tuple}, optional\n    Tuple indicating whether the number of data being masked on each side should be rounded (True) or truncated (False).  Default is (True, True). \naxis : int, optional\n    Axis along which to perform the trimming. If None, the input array is first flattened.  Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>trimtail : ndarray\n    Returned array of same shape as data with masked tail values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.trimtail.html
scipy stats mstats trimtail	R	scipy.stats.mstats.trimtail										
scipy stats.mstats.trimtail	R	scipy.stats.mstats.trimtail										
scipy.stats.mstats.tsem	A										<section class="prog__container"><p>Compute the trimmed standard error of the mean.</p><pre><code>scipy.stats.mstats.tsem(a, limits=None, inclusive=(True, True), axis=0, ddof=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    array of values \nlimits : None or (lower limit, upper limit), optional\n    Values in the input array less than the lower limit or greater than the upper limit will be ignored. When limits is None, then all values are used. Either of the limit values in the tuple can also be None representing a half-open interval.  The default value is None. \ninclusive : (bool, bool), optional\n    A tuple consisting of the (lower flag, upper flag).  These flags determine whether values exactly equal to the lower or upper limits are included.  The default value is (True, True). \naxis : int or None, optional\n    Axis along which to operate. If None, compute over the whole array. Default is zero. \nddof : int, optional\n    Delta degrees of freedom. Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>tsem : float</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.tsem.html
scipy stats mstats tsem	R	scipy.stats.mstats.tsem										
scipy stats.mstats.tsem	R	scipy.stats.mstats.tsem										
scipy.stats.mstats.ttest_1samp	A										<section class="prog__container"><p>Calculates the T-test for the mean of ONE group of scores.</p><pre><code>scipy.stats.mstats.ttest_1samp(a, popmean, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    sample observation \npopmean : float or array_like\n    expected value in null hypothesis, if array_like than it must have the same shape as a excluding the axis dimension \naxis : int or None, optional\n    Axis along which to compute test. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    t-statistic \npvalue : float or array\n    two-tailed p-value</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.ttest_1samp.html
scipy stats mstats ttest_1samp	R	scipy.stats.mstats.ttest_1samp										
scipy stats.mstats.ttest_1samp	R	scipy.stats.mstats.ttest_1samp										
scipy.stats.mstats.ttest_ind	A										<section class="prog__container"><p>Calculates the T-test for the means of TWO INDEPENDENT samples of scores.</p><pre><code>scipy.stats.mstats.ttest_ind(a, b, axis=0, equal_var=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default). \naxis : int or None, optional\n    Axis along which to compute test. If None, compute over the whole arrays, a, and b. \nequal_var : bool, optional\n    If True, perform a standard independent 2 sample test that assumes equal population variances. If False, perform Welch’s t-test, which does not assume equal population variance. .. versionadded:: 0.17.0</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    The calculated t-statistic. \npvalue : float or array\n    The two-tailed p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.ttest_ind.html
scipy stats mstats ttest_ind	R	scipy.stats.mstats.ttest_ind										
scipy stats.mstats.ttest_ind	R	scipy.stats.mstats.ttest_ind										
scipy.stats.mstats.ttest_onesamp	A										<section class="prog__container"><p>Calculates the T-test for the mean of ONE group of scores.</p><pre><code>scipy.stats.mstats.ttest_onesamp(a, popmean, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    sample observation \npopmean : float or array_like\n    expected value in null hypothesis, if array_like than it must have the same shape as a excluding the axis dimension \naxis : int or None, optional\n    Axis along which to compute test. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    t-statistic \npvalue : float or array\n    two-tailed p-value</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.ttest_onesamp.html
scipy stats mstats ttest_onesamp	R	scipy.stats.mstats.ttest_onesamp										
scipy stats.mstats.ttest_onesamp	R	scipy.stats.mstats.ttest_onesamp										
scipy.stats.mstats.ttest_rel	A										<section class="prog__container"><p>Calculates the T-test on TWO RELATED samples of scores, a and b.</p><pre><code>scipy.stats.mstats.ttest_rel(a, b, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    The arrays must have the same shape. \naxis : int or None, optional\n    Axis along which to compute test. If None, compute over the whole arrays, a, and b.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    t-statistic \npvalue : float or array\n    two-tailed p-value</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.ttest_rel.html
scipy stats mstats ttest_rel	R	scipy.stats.mstats.ttest_rel										
scipy stats.mstats.ttest_rel	R	scipy.stats.mstats.ttest_rel										
scipy.stats.mstats.tvar	A										<section class="prog__container"><p>Compute the trimmed variance</p><pre><code>scipy.stats.mstats.tvar(a, limits=None, inclusive=(True, True), axis=0, ddof=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array of values. \nlimits : None or (lower limit, upper limit), optional\n    Values in the input array less than the lower limit or greater than the upper limit will be ignored. When limits is None, then all values are used. Either of the limit values in the tuple can also be None representing a half-open interval.  The default value is None. \ninclusive : (bool, bool), optional\n    A tuple consisting of the (lower flag, upper flag).  These flags determine whether values exactly equal to the lower or upper limits are included.  The default value is (True, True). \naxis : int or None, optional\n    Axis along which to operate. If None, compute over the whole array. Default is zero. \nddof : int, optional\n    Delta degrees of freedom. Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>tvar : float\n    Trimmed variance.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.tvar.html
scipy stats mstats tvar	R	scipy.stats.mstats.tvar										
scipy stats.mstats.tvar	R	scipy.stats.mstats.tvar										
scipy.stats.mstats.variation	A										<section class="prog__container"><p>Computes the coefficient of variation, the ratio of the biased standard\ndeviation to the mean.</p><pre><code>scipy.stats.mstats.variation(a, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int or None, optional\n    Axis along which to calculate the coefficient of variation. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>variation : ndarray\n    The calculated variation along the requested axis.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.variation.html
scipy stats mstats variation	R	scipy.stats.mstats.variation										
scipy stats.mstats.variation	R	scipy.stats.mstats.variation										
scipy.stats.mstats.winsorize	A										<section class="prog__container"><p>Returns a Winsorized version of the input array.</p><pre><code>scipy.stats.mstats.winsorize(a, limits=None, inclusive=(True, True), inplace=False, axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : sequence\n    Input array. \nlimits : {None, tuple of float}, optional\n    Tuple of the percentages to cut on each side of the array, with respect to the number of unmasked data, as floats between 0. and 1. Noting n the number of unmasked data before trimming, the (n*limits[0])th smallest data and the (n*limits[1])th largest data are masked, and the total number of unmasked data after trimming is n*(1.-sum(limits)) The value of one limit can be set to None to indicate an open interval. \ninclusive : {(True, True) tuple}, optional\n    Tuple indicating whether the number of data being masked on each side should be rounded (True) or truncated (False). \ninplace : {False, True}, optional\n    Whether to winsorize in place (True) or to use a copy (False) \naxis : {None, int}, optional\n    Axis along which to trim. If None, the whole array is trimmed, but its shape is maintained.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.winsorize.html
scipy stats mstats winsorize	R	scipy.stats.mstats.winsorize										
scipy stats.mstats.winsorize	R	scipy.stats.mstats.winsorize										
scipy.stats.mstats.zmap	A										<section class="prog__container"><p>Calculates the relative z-scores.</p><pre><code>scipy.stats.mstats.zmap(scores, compare, axis=0, ddof=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scores : array_like\n    The input for which z-scores are calculated. \ncompare : array_like\n    The input from which the mean and standard deviation of the normalization are taken; assumed to have the same dimension as scores. \naxis : int or None, optional\n    Axis over which mean and variance of compare are calculated. Default is 0. If None, compute over the whole array scores. \nddof : int, optional\n    Degrees of freedom correction in the calculation of the standard deviation. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>zscore : array_like\n    Z-scores, in the same shape as scores.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import zmap\n>>> a = [0.5, 2.0, 2.5, 3]\n>>> b = [0, 1, 2, 3, 4]\n>>> zmap(a, b)\narray([-1.06066017,  0.        ,  0.35355339,  0.70710678])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.zmap.html
scipy stats mstats zmap	R	scipy.stats.mstats.zmap										
scipy stats.mstats.zmap	R	scipy.stats.mstats.zmap										
scipy.stats.mstats.zscore	A										<section class="prog__container"><p>Calculates the z score of each value in the sample, relative to the\nsample mean and standard deviation.</p><pre><code>scipy.stats.mstats.zscore(a, axis=0, ddof=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    An array like object containing the sample data. \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \nddof : int, optional\n    Degrees of freedom correction in the calculation of the standard deviation. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>zscore : array_like\n    The z-scores, standardized by mean and standard deviation of input array a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,\n...                0.1954,  0.6307,  0.6599,  0.1065,  0.0508])\n>>> from scipy import stats\n>>> stats.zscore(a)\narray([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,\n        0.6748, -1.1488, -1.3324])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.zscore.html
scipy stats mstats zscore	R	scipy.stats.mstats.zscore										
scipy stats.mstats.zscore	R	scipy.stats.mstats.zscore										
scipy.stats.multivariate_normal	A										<section class="prog__container"><p>A multivariate normal random variable.</p><pre><code>scipy.stats.multivariate_normal = <scipy.stats._multivariate.multivariate_normal_gen object at 0x2aba953e48d0></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Quantiles, with the last axis of x denoting the components. \nmean : array_like, optional\n    Mean of the distribution (default zero) \ncov : array_like, optional\n    Covariance matrix of the distribution (default one) \nallow_singular : bool, optional\n    Whether to allow a singular covariance matrix.  (Default: False) \nrandom_state : None or int or np.random.RandomState instance, optional\n    If int or RandomState, use it for drawing the random variates. If None (or np.random), the global np.random state is used. Default is None. \nAlternatively, the object may be called (as a function) to fix the mean\nand covariance parameters, returning a “frozen” multivariate normal\nrandom variable:\nrv = multivariate_normal(mean=None, cov=1, allow_singular=False)\n    Frozen object with the same methods but holding the given mean and covariance fixed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy.stats import multivariate_normal</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.multivariate_normal.html
scipy stats multivariate_normal	R	scipy.stats.multivariate_normal										
scipy stats.multivariate_normal	R	scipy.stats.multivariate_normal										
scipy.stats.mvsdist	A					[[scipy.stats.bayes_mvs]]					<section class="prog__container"><p>‘Frozen’ distributions for mean, variance, and standard deviation of data.</p><pre><code>scipy.stats.mvsdist(data)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Input array. Converted to 1-D using ravel. Requires 2 or more data-points.</code></pre><span class="prog__sub">Returns:</span><pre><code>mdist : “frozen” distribution object\n    Distribution object representing the mean of the data \nvdist : “frozen” distribution object\n    Distribution object representing the variance of the data \nsdist : “frozen” distribution object\n    Distribution object representing the standard deviation of the data</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> data = [6, 9, 12, 7, 8, 8, 13]\n>>> mean, var, std = stats.mvsdist(data)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mvsdist.html
scipy stats mvsdist	R	scipy.stats.mvsdist										
scipy stats.mvsdist	R	scipy.stats.mvsdist										
scipy.stats.nakagami	A										<section class="prog__container"><p>A Nakagami continuous random variable.</p><pre><code>scipy.stats.nakagami = <scipy.stats._continuous_distns.nakagami_gen object at 0x2aba950c42d0></code></pre><span class="prog__sub">Examples:</span><pre><code>nakagami.pdf(x, nu) = 2 * nu**nu / gamma(nu) *\n                      x**(2*nu-1) * exp(-nu*x**2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.nakagami.html
scipy stats nakagami	R	scipy.stats.nakagami										
scipy stats.nakagami	R	scipy.stats.nakagami										
scipy.stats.nbinom	A										<section class="prog__container"><p>A negative binomial discrete random variable.</p><pre><code>scipy.stats.nbinom = <scipy.stats._discrete_distns.nbinom_gen object at 0x2aba95088bd0></code></pre><span class="prog__sub">Examples:</span><pre><code>nbinom.pmf(k) = choose(k+n-1, n-1) * p**n * (1-p)**k</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.nbinom.html
scipy stats nbinom	R	scipy.stats.nbinom										
scipy stats.nbinom	R	scipy.stats.nbinom										
scipy.stats.ncf	A										<section class="prog__container"><p>A non-central F distribution continuous random variable.</p><pre><code>scipy.stats.ncf = <scipy.stats._continuous_distns.ncf_gen object at 0x2aba950c47d0></code></pre><span class="prog__sub">Examples:</span><pre><code>ncf.pdf(x, df1, df2, nc) = exp(nc/2 + nc*df1*x/(2*(df1*x+df2))) *\n            df1**(df1/2) * df2**(df2/2) * x**(df1/2-1) *\n            (df2+df1*x)**(-(df1+df2)/2) *\n            gamma(df1/2)*gamma(1+df2/2) *\n            L^{v1/2-1}^{v2/2}(-nc*v1*x/(2*(v1*x+v2))) /\n            (B(v1/2, v2/2) * gamma((v1+v2)/2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ncf.html
scipy stats ncf	R	scipy.stats.ncf										
scipy stats.ncf	R	scipy.stats.ncf										
scipy.stats.nct	A										<section class="prog__container"><p>A non-central Student’s T continuous random variable.</p><pre><code>scipy.stats.nct = <scipy.stats._continuous_distns.nct_gen object at 0x2aba950c4d10></code></pre><span class="prog__sub">Examples:</span><pre><code>df**(df/2) * gamma(df+1)\nnct.pdf(x, df, nc) = ----------------------------------------------------\n                     2**df*exp(nc**2/2) * (df+x**2)**(df/2) * gamma(df/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.nct.html
scipy stats nct	R	scipy.stats.nct										
scipy stats.nct	R	scipy.stats.nct										
scipy.stats.ncx2	A										<section class="prog__container"><p>A non-central chi-squared continuous random variable.</p><pre><code>scipy.stats.ncx2 = <scipy.stats._continuous_distns.ncx2_gen object at 0x2aba950c4550></code></pre><span class="prog__sub">Examples:</span><pre><code>ncx2.pdf(x, df, nc) = exp(-(nc+x)/2) * 1/2 * (x/nc)**((df-2)/4)\n                      * I[(df-2)/2](sqrt(nc*x))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ncx2.html
scipy stats ncx2	R	scipy.stats.ncx2										
scipy stats.ncx2	R	scipy.stats.ncx2										
scipy.stats.normaltest	A										<section class="prog__container"><p>Tests whether a sample differs from a normal distribution.</p><pre><code>scipy.stats.normaltest(a, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array containing the data to be tested. \naxis : int or None, optional\n    Axis along which to compute test. Default is 0. If None, compute over the whole array a. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    s^2 + k^2, where s is the z-score returned by skewtest and k is the z-score returned by kurtosistest. \npvalue : float or array\n    A 2-sided chi squared probability for the hypothesis test.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.normaltest.html
scipy stats normaltest	R	scipy.stats.normaltest										
scipy stats.normaltest	R	scipy.stats.normaltest										
scipy.stats.norm	A										<section class="prog__container"><p>A normal continuous random variable.</p><pre><code>scipy.stats.norm = <scipy.stats._continuous_distns.norm_gen object at 0x2aba94e1add0></code></pre><span class="prog__sub">Examples:</span><pre><code>norm.pdf(x) = exp(-x**2/2)/sqrt(2*pi)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html
scipy stats norm	R	scipy.stats.norm										
scipy stats.norm	R	scipy.stats.norm										
scipy.stats.obrientransform	A										<section class="prog__container"><p>Computes the O’Brien transform on input data (any number of arrays).</p><pre><code>scipy.stats.obrientransform(*args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>args : tuple of array_like\n    Any number of arrays.</code></pre><span class="prog__sub">Returns:</span><pre><code>obrientransform : ndarray\n    Transformed data for use in an ANOVA.  The first dimension of the result corresponds to the sequence of transformed arrays.  If the arrays given are all 1-D of the same length, the return value is a 2-D array; otherwise it is a 1-D array of type object, with each element being an ndarray.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> x = [10, 11, 13, 9, 7, 12, 12, 9, 10]\n>>> y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15]</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.obrientransform.html
scipy stats obrientransform	R	scipy.stats.obrientransform										
scipy stats.obrientransform	R	scipy.stats.obrientransform										
scipy.stats.ortho_group	A										<section class="prog__container"><p>A matrix-valued O(N) random variable.</p><pre><code>scipy.stats.ortho_group = <scipy.stats._multivariate.ortho_group_gen object at 0x2aba953f2050></code></pre><span class="prog__sub">Parameters:</span><pre><code>dim : scalar\n    Dimension of matrices</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import ortho_group\n>>> x = ortho_group.rvs(3)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ortho_group.html
scipy stats ortho_group	R	scipy.stats.ortho_group										
scipy stats.ortho_group	R	scipy.stats.ortho_group										
scipy.stats.pareto	A										<section class="prog__container"><p>A Pareto continuous random variable.</p><pre><code>scipy.stats.pareto = <scipy.stats._continuous_distns.pareto_gen object at 0x2aba950c4fd0></code></pre><span class="prog__sub">Examples:</span><pre><code>pareto.pdf(x, b) = b / x**(b+1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pareto.html
scipy stats pareto	R	scipy.stats.pareto										
scipy stats.pareto	R	scipy.stats.pareto										
scipy.stats.pearson3	A										<section class="prog__container"><p>A pearson type III continuous random variable.</p><pre><code>scipy.stats.pearson3 = <scipy.stats._continuous_distns.pearson3_gen object at 0x2aba950c8550></code></pre><span class="prog__sub">Examples:</span><pre><code>pearson3.pdf(x, skew) = abs(beta) / gamma(alpha) *\n    (beta * (x - zeta))**(alpha - 1) * exp(-beta*(x - zeta))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearson3.html
scipy stats pearson3	R	scipy.stats.pearson3										
scipy stats.pearson3	R	scipy.stats.pearson3										
scipy.stats.pearsonr	A										<section class="prog__container"><p>Calculates a Pearson correlation coefficient and the p-value for testing\nnon-correlation.</p><pre><code>scipy.stats.pearsonr(x, y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : (N,) array_like\n    Input \ny : (N,) array_like\n    Input</code></pre><span class="prog__sub">Returns:</span><pre><code>r : float\n    Pearson’s correlation coefficient \np-value : float\n    2-tailed p-value</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html
scipy stats pearsonr	R	scipy.stats.pearsonr										
scipy stats.pearsonr	R	scipy.stats.pearsonr										
scipy.stats.percentileofscore	A					[[(in NumPy v1.11)]]					<section class="prog__container"><p>The percentile rank of a score relative to a list of scores.</p><pre><code>scipy.stats.percentileofscore(a, score, kind='rank')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array of scores to which score is compared. \nscore : int or float\n    Score that is compared to the elements in a. \nkind : {‘rank’, ‘weak’, ‘strict’, ‘mean’}, optional\n    This optional parameter specifies the interpretation of the resulting score:   “rank”: Average percentage ranking of score.  In case of multiple matches, average the percentage rankings of all matching scores.     “weak”: This kind corresponds to the definition of a cumulative distribution function.  A percentileofscore of 80% means that 80% of values are less than or equal to the provided score.     “strict”: Similar to “weak”, except that only values that are strictly less than the given score are counted.     “mean”: The average of the “weak” and “strict” scores, often used in testing.  See http://en.wikipedia.org/wiki/Percentile_rank</code></pre><span class="prog__sub">Returns:</span><pre><code>pcos : float\n    Percentile-position of score (0-100) relative to a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> stats.percentileofscore([1, 2, 3, 4], 3)\n75.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.percentileofscore.html
scipy stats percentileofscore	R	scipy.stats.percentileofscore										
scipy stats.percentileofscore	R	scipy.stats.percentileofscore										
scipy.stats.planck	A										<section class="prog__container"><p>A Planck discrete exponential random variable.</p><pre><code>scipy.stats.planck = <scipy.stats._discrete_distns.planck_gen object at 0x2aba9510f790></code></pre><span class="prog__sub">Examples:</span><pre><code>planck.pmf(k) = (1-exp(-lambda_))*exp(-lambda_*k)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.planck.html
scipy stats planck	R	scipy.stats.planck										
scipy stats.planck	R	scipy.stats.planck										
scipy.stats.pointbiserialr	A										<section class="prog__container"><p>Calculates a point biserial correlation coefficient and its p-value.</p><pre><code>scipy.stats.pointbiserialr(x, y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like of bools\n    Input array. \ny : array_like\n    Input array.</code></pre><span class="prog__sub">Returns:</span><pre><code>correlation : float\n    R value \npvalue : float\n    2-tailed p-value</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> a = np.array([0, 0, 0, 1, 1, 1, 1])\n>>> b = np.arange(7)\n>>> stats.pointbiserialr(a, b)\n(0.8660254037844386, 0.011724811003954652)\n>>> stats.pearsonr(a, b)\n(0.86602540378443871, 0.011724811003954626)\n>>> np.corrcoef(a, b)\narray([[ 1.       ,  0.8660254],\n       [ 0.8660254,  1.       ]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pointbiserialr.html
scipy stats pointbiserialr	R	scipy.stats.pointbiserialr										
scipy stats.pointbiserialr	R	scipy.stats.pointbiserialr										
scipy.stats.poisson	A										<section class="prog__container"><p>A Poisson discrete random variable.</p><pre><code>scipy.stats.poisson = <scipy.stats._discrete_distns.poisson_gen object at 0x2aba9510f450></code></pre><span class="prog__sub">Examples:</span><pre><code>poisson.pmf(k) = exp(-mu) * mu**k / k!</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.poisson.html
scipy stats poisson	R	scipy.stats.poisson										
scipy stats.poisson	R	scipy.stats.poisson										
scipy.stats.power_divergence	A					[[scipy.stats.chisquare]]					<section class="prog__container"><p>Cressie-Read power divergence statistic and goodness of fit test.</p><pre><code>scipy.stats.power_divergence(f_obs, f_exp=None, ddof=0, axis=0, lambda_=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>f_obs : array_like\n    Observed frequencies in each category. \nf_exp : array_like, optional\n    Expected frequencies in each category.  By default the categories are assumed to be equally likely. \nddof : int, optional\n    “Delta degrees of freedom”: adjustment to the degrees of freedom for the p-value.  The p-value is computed using a chi-squared distribution with k - 1 - ddof degrees of freedom, where k is the number of observed frequencies.  The default value of ddof is 0. \naxis : int or None, optional\n    The axis of the broadcast result of f_obs and f_exp along which to apply the test.  If axis is None, all values in f_obs are treated as a single data set.  Default is 0. \nlambda_ : float or str, optional\n    lambda_ gives the power in the Cressie-Read power divergence statistic.  The default is 1.  For convenience, lambda_ may be assigned one of the following strings, in which case the corresponding numerical value is used: String              Value   Description "pearson"             1     Pearson's chi-squared statistic.                             In this case, the function is                             equivalent to `stats.chisquare`. "log-likelihood"      0     Log-likelihood ratio. Also known as                             the G-test [R557]_. "freeman-tukey"      -1/2   Freeman-Tukey statistic. "mod-log-likelihood" -1     Modified log-likelihood ratio. "neyman"             -2     Neyman's statistic. "cressie-read"        2/3   The power recommended in [R559]_.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or ndarray\n    The Cressie-Read power divergence test statistic.  The value is a float if axis is None or if` f_obs and f_exp are 1-D. \npvalue : float or ndarray\n    The p-value of the test.  The value is a float if ddof and the return value stat are scalars.</code></pre><span class="prog__sub">Examples:</span><pre><code>String              Value   Description\n"pearson"             1     Pearson's chi-squared statistic.\n                            In this case, the function is\n                            equivalent to `stats.chisquare`.\n"log-likelihood"      0     Log-likelihood ratio. Also known as\n                            the G-test [R557]_.\n"freeman-tukey"      -1/2   Freeman-Tukey statistic.\n"mod-log-likelihood" -1     Modified log-likelihood ratio.\n"neyman"             -2     Neyman's statistic.\n"cressie-read"        2/3   The power recommended in [R559]_.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.power_divergence.html
scipy stats power_divergence	R	scipy.stats.power_divergence										
scipy stats.power_divergence	R	scipy.stats.power_divergence										
scipy.stats.powerlaw	A										<section class="prog__container"><p>A power-function continuous random variable.</p><pre><code>scipy.stats.powerlaw = <scipy.stats._continuous_distns.powerlaw_gen object at 0x2aba950c87d0></code></pre><span class="prog__sub">Examples:</span><pre><code>powerlaw.pdf(x, a) = a * x**(a-1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.powerlaw.html
scipy stats powerlaw	R	scipy.stats.powerlaw										
scipy stats.powerlaw	R	scipy.stats.powerlaw										
scipy.stats.powerlognorm	A										<section class="prog__container"><p>A power log-normal continuous random variable.</p><pre><code>scipy.stats.powerlognorm = <scipy.stats._continuous_distns.powerlognorm_gen object at 0x2aba950c8a50></code></pre><span class="prog__sub">Examples:</span><pre><code>powerlognorm.pdf(x, c, s) = c / (x*s) * phi(log(x)/s) *\n                                        (Phi(-log(x)/s))**(c-1),</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.powerlognorm.html
scipy stats powerlognorm	R	scipy.stats.powerlognorm										
scipy stats.powerlognorm	R	scipy.stats.powerlognorm										
scipy.stats.powernorm	A										<section class="prog__container"><p>A power normal continuous random variable.</p><pre><code>scipy.stats.powernorm = <scipy.stats._continuous_distns.powernorm_gen object at 0x2aba950c8cd0></code></pre><span class="prog__sub">Examples:</span><pre><code>powernorm.pdf(x, c) = c * phi(x) * (Phi(-x))**(c-1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.powernorm.html
scipy stats powernorm	R	scipy.stats.powernorm										
scipy stats.powernorm	R	scipy.stats.powernorm										
scipy.stats.ppcc_max	A					[[scipy.stats.ppcc_plot]]\\n[[scipy.stats.probplot]]\\n[[scipy.stats.boxcox]]					<section class="prog__container"><p>Calculate the shape parameter that maximizes the PPCC</p><pre><code>scipy.stats.ppcc_max(x, brack=(0.0, 1.0), dist='tukeylambda')</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \nbrack : tuple, optional\n    Triple (a,b,c) where (a<b<c). If bracket consists of two numbers (a, c) then they are assumed to be a starting interval for a downhill bracket search (see scipy.optimize.brent). \ndist : str or stats.distributions instance, optional\n    Distribution or distribution function name.  Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted.  The default is 'tukeylambda'.</code></pre><span class="prog__sub">Returns:</span><pre><code>shape_value : float\n    The shape parameter at which the probability plot correlation coefficient reaches its max value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = stats.tukeylambda.rvs(-0.7, loc=2, scale=0.5, size=10000,\n...                           random_state=1234567) + 1e4</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ppcc_max.html
scipy stats ppcc_max	R	scipy.stats.ppcc_max										
scipy stats.ppcc_max	R	scipy.stats.ppcc_max										
scipy.stats.ppcc_plot	A					[[scipy.stats.ppcc_max]]\\n[[scipy.stats.probplot]]\\n[[scipy.stats.boxcox_normplot]]\\n[[scipy.stats.tukeylambda]]					<section class="prog__container"><p>Calculate and optionally plot probability plot correlation coefficient.</p><pre><code>scipy.stats.ppcc_plot(x, a, b, dist='tukeylambda', plot=None, N=80)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Input array. \na, b: scalar\n    Lower and upper bounds of the shape parameter to use. \ndist : str or stats.distributions instance, optional\n    Distribution or distribution function name.  Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted.  The default is 'tukeylambda'. \nplot : object, optional\n    If given, plots PPCC against the shape parameter. plot is an object that has to have methods “plot” and “text”. The matplotlib.pyplot module or a Matplotlib Axes object can be used, or a custom object with the same methods. Default is None, which means that no plot is created. \nN : int, optional\n    Number of points on the horizontal axis (equally distributed from a to b).</code></pre><span class="prog__sub">Returns:</span><pre><code>svals : ndarray\n    The shape values for which ppcc was calculated. \nppcc : ndarray\n    The calculated probability plot correlation coefficient values.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> import matplotlib.pyplot as plt\n>>> np.random.seed(1234567)\n>>> x = stats.tukeylambda.rvs(-0.7, loc=2, scale=0.5, size=10000) + 1e4</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ppcc_plot.html
scipy stats ppcc_plot	R	scipy.stats.ppcc_plot										
scipy stats.ppcc_plot	R	scipy.stats.ppcc_plot										
scipy.stats.probplot	A										<section class="prog__container"><p>Calculate quantiles for a probability plot, and optionally show the plot.</p><pre><code>scipy.stats.probplot(x, sparams=(), dist='norm', fit=True, plot=None, rvalue=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Sample/response data from which probplot creates the plot. \nsparams : tuple, optional\n    Distribution-specific shape parameters (shape parameters plus location and scale). \ndist : str or stats.distributions instance, optional\n    Distribution or distribution function name. The default is ‘norm’ for a normal probability plot.  Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted. \nfit : bool, optional\n    Fit a least-squares regression (best-fit) line to the sample data if True (default). \nplot : object, optional\n    If given, plots the quantiles and least squares fit. plot is an object that has to have methods “plot” and “text”. The matplotlib.pyplot module or a Matplotlib Axes object can be used, or a custom object with the same methods. Default is None, which means that no plot is created.</code></pre><span class="prog__sub">Returns:</span><pre><code>(osm, osr) : tuple of ndarrays\n    Tuple of theoretical quantiles (osm, or order statistic medians) and ordered responses (osr).  osr is simply sorted input x. For details on how osm is calculated see the Notes section. \n(slope, intercept, r) : tuple of floats, optional\n    Tuple  containing the result of the least-squares fit, if that is performed by probplot. r is the square root of the coefficient of determination.  If fit=False and plot=None, this tuple is not returned.</code></pre><span class="prog__sub">Examples:</span><pre><code>quantiles = dist.ppf(val), for\n\n        0.5**(1/n),                  for i = n\n  val = (i - 0.3175) / (n + 0.365),  for i = 2, ..., n-1\n        1 - 0.5**(1/n),              for i = 1</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.probplot.html
scipy stats probplot	R	scipy.stats.probplot										
scipy stats.probplot	R	scipy.stats.probplot										
scipy.stats.randint	A										<section class="prog__container"><p>A uniform discrete random variable.</p><pre><code>scipy.stats.randint = <scipy.stats._discrete_distns.randint_gen object at 0x2aba9510fc10></code></pre><span class="prog__sub">Examples:</span><pre><code>randint.pmf(k) = 1./(high - low)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.randint.html
scipy stats randint	R	scipy.stats.randint										
scipy stats.randint	R	scipy.stats.randint										
scipy.stats.random_correlation	A										<section class="prog__container"><p>A random correlation matrix.</p><pre><code>scipy.stats.random_correlation = <scipy.stats._multivariate.random_correlation_gen object at 0x2aba953f2110></code></pre><span class="prog__sub">Parameters:</span><pre><code>eigs : 1d ndarray\n    Eigenvalues of correlation matrix.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import random_correlation\n>>> np.random.seed(514)\n>>> x = random_correlation.rvs((.5, .8, 1.2, 1.5))\n>>> x\narray([[ 1.        , -0.20387311,  0.18366501, -0.04953711],\n       [-0.20387311,  1.        , -0.24351129,  0.06703474],\n       [ 0.18366501, -0.24351129,  1.        ,  0.38530195],\n       [-0.04953711,  0.06703474,  0.38530195,  1.        ]])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.random_correlation.html
scipy stats random_correlation	R	scipy.stats.random_correlation										
scipy stats.random_correlation	R	scipy.stats.random_correlation										
scipy.stats.rankdata	A										<section class="prog__container"><p>Assign ranks to data, dealing with ties appropriately.</p><pre><code>scipy.stats.rankdata(a, method='average')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    The array of values to be ranked.  The array is first flattened. \nmethod : str, optional\n    The method used to assign ranks to tied elements. The options are ‘average’, ‘min’, ‘max’, ‘dense’ and ‘ordinal’.  ‘average’: The average of the ranks that would have been assigned to all the tied values is assigned to each value.  ‘min’: The minimum of the ranks that would have been assigned to all the tied values is assigned to each value.  (This is also referred to as “competition” ranking.)  ‘max’: The maximum of the ranks that would have been assigned to all the tied values is assigned to each value.  ‘dense’: Like ‘min’, but the rank of the next highest element is assigned the rank immediately after those assigned to the tied elements.  ‘ordinal’: All values are given a distinct rank, corresponding to the order that the values occur in a.   The default is ‘average’.</code></pre><span class="prog__sub">Returns:</span><pre><code>ranks : ndarray\n    An array of length equal to the size of a, containing rank scores.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import rankdata\n>>> rankdata([0, 2, 3, 2])\narray([ 1. ,  2.5,  4. ,  2.5])\n>>> rankdata([0, 2, 3, 2], method='min')\narray([ 1,  2,  4,  2])\n>>> rankdata([0, 2, 3, 2], method='max')\narray([ 1,  3,  4,  3])\n>>> rankdata([0, 2, 3, 2], method='dense')\narray([ 1,  2,  3,  2])\n>>> rankdata([0, 2, 3, 2], method='ordinal')\narray([ 1,  2,  4,  3])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rankdata.html
scipy stats rankdata	R	scipy.stats.rankdata										
scipy stats.rankdata	R	scipy.stats.rankdata										
scipy.stats.ranksums	A										<section class="prog__container"><p>Compute the Wilcoxon rank-sum statistic for two samples.</p><pre><code>scipy.stats.ranksums(x, y)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x,y : array_like\n    The data from the two samples</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The test statistic under the large-sample approximation that the rank sum statistic is normally distributed \npvalue : float\n    The two-sided p-value of the test</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ranksums.html
scipy stats ranksums	R	scipy.stats.ranksums										
scipy stats.ranksums	R	scipy.stats.ranksums										
scipy.stats.rayleigh	A										<section class="prog__container"><p>A Rayleigh continuous random variable.</p><pre><code>scipy.stats.rayleigh = <scipy.stats._continuous_distns.rayleigh_gen object at 0x2aba950e0210></code></pre><span class="prog__sub">Examples:</span><pre><code>rayleigh.pdf(r) = r * exp(-r**2/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rayleigh.html
scipy stats rayleigh	R	scipy.stats.rayleigh										
scipy stats.rayleigh	R	scipy.stats.rayleigh										
scipy.stats.rdist	A										<section class="prog__container"><p>An R-distributed continuous random variable.</p><pre><code>scipy.stats.rdist = <scipy.stats._continuous_distns.rdist_gen object at 0x2aba950c8f50></code></pre><span class="prog__sub">Examples:</span><pre><code>rdist.pdf(x, c) = (1-x**2)**(c/2-1) / B(1/2, c/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rdist.html
scipy stats rdist	R	scipy.stats.rdist										
scipy stats.rdist	R	scipy.stats.rdist										
scipy.stats.recipinvgauss	A										<section class="prog__container"><p>A reciprocal inverse Gaussian continuous random variable.</p><pre><code>scipy.stats.recipinvgauss = <scipy.stats._continuous_distns.recipinvgauss_gen object at 0x2aba950e0910></code></pre><span class="prog__sub">Examples:</span><pre><code>recipinvgauss.pdf(x, mu) = 1/sqrt(2*pi*x) * exp(-(1-mu*x)**2/(2*x*mu**2))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.recipinvgauss.html
scipy stats recipinvgauss	R	scipy.stats.recipinvgauss										
scipy stats.recipinvgauss	R	scipy.stats.recipinvgauss										
scipy.stats.reciprocal	A										<section class="prog__container"><p>A reciprocal continuous random variable.</p><pre><code>scipy.stats.reciprocal = <scipy.stats._continuous_distns.reciprocal_gen object at 0x2aba950e0410></code></pre><span class="prog__sub">Examples:</span><pre><code>reciprocal.pdf(x, a, b) = 1 / (x*log(b/a))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.reciprocal.html
scipy stats reciprocal	R	scipy.stats.reciprocal										
scipy stats.reciprocal	R	scipy.stats.reciprocal										
scipy.stats.relfreq	A										<section class="prog__container"><p>Returns a relative frequency histogram, using the histogram function.</p><pre><code>scipy.stats.relfreq(a, numbins=10, defaultreallimits=None, weights=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \nnumbins : int, optional\n    The number of bins to use for the histogram. Default is 10. \ndefaultreallimits : tuple (lower, upper), optional\n    The lower and upper values for the range of the histogram. If no value is given, a range slightly larger than the range of the values in a is used. Specifically (a.min() - s, a.max() + s), where s = (1/2)(a.max() - a.min()) / (numbins - 1). \nweights : array_like, optional\n    The weights for each value in a. Default is None, which gives each value a weight of 1.0</code></pre><span class="prog__sub">Returns:</span><pre><code>frequency : ndarray\n    Binned values of relative frequency. \nlowerlimit : float\n    Lower real limit \nbinsize : float\n    Width of each bin. \nextrapoints : int\n    Extra points.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy import stats\n>>> a = np.array([2, 4, 1, 2, 3, 2])\n>>> res = stats.relfreq(a, numbins=4)\n>>> res.frequency\narray([ 0.16666667, 0.5       , 0.16666667,  0.16666667])\n>>> np.sum(res.frequency)  # relative frequencies should add up to 1\n1.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.relfreq.html
scipy stats relfreq	R	scipy.stats.relfreq										
scipy stats.relfreq	R	scipy.stats.relfreq										
scipy.stats.rice	A										<section class="prog__container"><p>A Rice continuous random variable.</p><pre><code>scipy.stats.rice = <scipy.stats._continuous_distns.rice_gen object at 0x2aba950e0690></code></pre><span class="prog__sub">Examples:</span><pre><code>rice.pdf(x, b) = x * exp(-(x**2+b**2)/2) * I[0](x*b)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rice.html
scipy stats rice	R	scipy.stats.rice										
scipy stats.rice	R	scipy.stats.rice										
scipy.stats.rv_continuous	A										<section class="prog__container"><p>A generic continuous random variable class meant for subclassing.</p><pre><code>class scipy.stats.rv_continuous(momtype=1, a=None, b=None, xtol=1e-14, badvalue=None, name=None, longname=None, shapes=None, extradoc=None, seed=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>momtype : int, optional\n    The type of generic moment calculation to use: 0 for pdf, 1 (default) for ppf. \na : float, optional\n    Lower bound of the support of the distribution, default is minus infinity. \nb : float, optional\n    Upper bound of the support of the distribution, default is plus infinity. \nxtol : float, optional\n    The tolerance for fixed point calculation for generic ppf. \nbadvalue : float, optional\n    The value in a result arrays that indicates a value that for which some argument restriction is violated, default is np.nan. \nname : str, optional\n    The name of the instance. This string is used to construct the default example for distributions. \nlongname : str, optional\n    This string is used as part of the first line of the docstring returned when a subclass has no docstring of its own. Note: longname exists for backwards compatibility, do not use for new subclasses. \nshapes : str, optional\n    The shape of the distribution. For example "m, n" for a distribution that takes two integers as the two shape arguments for all its methods. If not provided, shape parameters will be inferred from the signature of the private methods, _pdf and _cdf of the instance. \nextradoc :  str, optional, deprecated\n    This string is used as the last part of the docstring returned when a subclass has no docstring of its own. Note: extradoc exists for backwards compatibility, do not use for new subclasses. \nseed : None or int or numpy.random.RandomState instance, optional\n    This parameter defines the RandomState object to use for drawing random variates. If None (or np.random), the global np.random state is used. If integer, it is used to seed the local RandomState instance. Default is None.</code></pre><span class="prog__sub">Examples:</span><pre><code>_logpdf, _cdf, _logcdf, _ppf, _rvs, _isf, _sf, _logsf</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.html
scipy.stats.rv_continuous.__call__	A										<section class="prog__container"><p>Freeze the distribution for the given arguments.</p><pre><code>rv_continuous.__call__(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution.  Should include all the non-optional arguments, may include loc and scale.</code></pre><span class="prog__sub">Returns:</span><pre><code>rv_frozen : rv_frozen instance\n    The frozen distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.__call__.html
scipy stats rv_continuous __call__	R	scipy.stats.rv_continuous.__call__										
scipy stats.rv_continuous.__call__	R	scipy.stats.rv_continuous.__call__										
scipy.stats.rv_continuous.cdf	A										<section class="prog__container"><p>Cumulative distribution function of the given RV.</p><pre><code>rv_continuous.cdf(x, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    quantiles \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>cdf : ndarray\n    Cumulative distribution function evaluated at x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.cdf.html
scipy stats rv_continuous cdf	R	scipy.stats.rv_continuous.cdf										
scipy stats.rv_continuous.cdf	R	scipy.stats.rv_continuous.cdf										
scipy.stats.rv_continuous.entropy	A										<section class="prog__container"><p>Differential entropy of the RV.</p><pre><code>rv_continuous.entropy(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0). \nscale : array_like, optional  (continuous distributions only).\n    Scale parameter (default=1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> drv = rv_discrete(values=((0, 1), (0.5, 0.5)))\n>>> np.allclose(drv.entropy(), np.log(2.0))\nTrue</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.entropy.html
scipy stats rv_continuous entropy	R	scipy.stats.rv_continuous.entropy										
scipy stats.rv_continuous.entropy	R	scipy.stats.rv_continuous.entropy										
scipy.stats.rv_continuous.expect	A										<section class="prog__container"><p>Calculate expected value of a function with respect to the\ndistribution.</p><pre><code>rv_continuous.expect(func=None, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable, optional\n    Function for which integral is calculated. Takes only one argument. The default is the identity mapping f(x) = x. \nargs : tuple, optional\n    Shape parameters of the distribution. \nloc : float, optional\n    Location parameter (default=0). \nscale : float, optional\n    Scale parameter (default=1). \nlb, ub : scalar, optional\n    Lower and upper bound for integration. Default is set to the support of the distribution. \nconditional : bool, optional\n    If True, the integral is corrected by the conditional probability of the integration interval.  The return value is the expectation of the function, conditional on being in the given interval. Default is False. \nAdditional keyword arguments are passed to the integration routine.</code></pre><span class="prog__sub">Returns:</span><pre><code>expect : float\n    The calculated expected value.</code></pre><span class="prog__sub">Examples:</span><pre><code>ubound\nE[x] = Integral(f(x) * dist.pdf(x))\n        lbound</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.expect.html
scipy stats rv_continuous expect	R	scipy.stats.rv_continuous.expect										
scipy stats.rv_continuous.expect	R	scipy.stats.rv_continuous.expect										
scipy.stats.rv_continuous.fit	A										<section class="prog__container"><p>Return MLEs for shape, location, and scale parameters from data.</p><pre><code>rv_continuous.fit(data, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Data to use in calculating the MLEs. \nargs : floats, optional\n    Starting value(s) for any shape-characterizing arguments (those not provided will be determined by a call to _fitstart(data)). No default value. \nkwds : floats, optional\n    Starting values for the location and scale parameters; no default. Special keyword arguments are recognized as holding certain parameters fixed:  f0...fn : hold respective shape parameters fixed. Alternatively, shape parameters to fix can be specified by name. For example, if self.shapes == "a, b", fa``and ``fix_a are equivalent to f0, and fb and fix_b are equivalent to f1. floc : hold location parameter fixed to specified value. fscale : hold scale parameter fixed to specified value. optimizer : The optimizer to use.  The optimizer must take func, and starting position as the first two arguments, plus args (for extra arguments to pass to the function to be optimized) and disp=0 to suppress output as keyword arguments.</code></pre><span class="prog__sub">Returns:</span><pre><code>shape, loc, scale : tuple of floats\n    MLEs for any shape statistics, followed by those for location and scale.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import beta\n>>> a, b = 1., 2.\n>>> x = beta.rvs(a, b, size=1000)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html
scipy.stats.rv_continuous.fit_loc_scale	A										<section class="prog__container"><p>Estimate loc and scale parameters from data using 1st and 2nd moments.</p><pre><code>rv_continuous.fit_loc_scale(data, *args)</code></pre><span class="prog__sub">Parameters:</span><pre><code>data : array_like\n    Data to fit. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information).</code></pre><span class="prog__sub">Returns:</span><pre><code>Lhat : float\n    Estimated location parameter for the data. \nShat : float\n    Estimated scale parameter for the data.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit_loc_scale.html
scipy stats rv_continuous fit_loc_scale	R	scipy.stats.rv_continuous.fit_loc_scale										
scipy stats.rv_continuous.fit_loc_scale	R	scipy.stats.rv_continuous.fit_loc_scale										
scipy stats rv_continuous fit	R	scipy.stats.rv_continuous.fit										
scipy stats.rv_continuous.fit	R	scipy.stats.rv_continuous.fit										
scipy.stats.rv_continuous.freeze	A										<section class="prog__container"><p>Freeze the distribution for the given arguments.</p><pre><code>rv_continuous.freeze(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution.  Should include all the non-optional arguments, may include loc and scale.</code></pre><span class="prog__sub">Returns:</span><pre><code>rv_frozen : rv_frozen instance\n    The frozen distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.freeze.html
scipy stats rv_continuous freeze	R	scipy.stats.rv_continuous.freeze										
scipy stats.rv_continuous.freeze	R	scipy.stats.rv_continuous.freeze										
scipy.stats.rv_continuous.interval	A										<section class="prog__container"><p>Confidence interval with equal areas around the median.</p><pre><code>rv_continuous.interval(alpha, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : array_like of float\n    Probability that an rv will be drawn from the returned range. Each value should be in the range [0, 1]. \narg1, arg2, ... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    location parameter, Default is 0. \nscale : array_like, optional\n    scale parameter, Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>a, b : ndarray of float\n    end-points of range that contain 100 * alpha % of the rv’s possible values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.interval.html
scipy stats rv_continuous interval	R	scipy.stats.rv_continuous.interval										
scipy stats.rv_continuous.interval	R	scipy.stats.rv_continuous.interval										
scipy.stats.rv_continuous.isf	A										<section class="prog__container"><p>Inverse survival function (inverse of sf) at q of the given RV.</p><pre><code>rv_continuous.isf(q, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>q : array_like\n    upper tail probability \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : ndarray or scalar\n    Quantile corresponding to the upper tail probability q.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.isf.html
scipy stats rv_continuous isf	R	scipy.stats.rv_continuous.isf										
scipy stats.rv_continuous.isf	R	scipy.stats.rv_continuous.isf										
scipy.stats.rv_continuous.logcdf	A										<section class="prog__container"><p>Log of the cumulative distribution function at x of the given RV.</p><pre><code>rv_continuous.logcdf(x, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    quantiles \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>logcdf : array_like\n    Log of the cumulative distribution function evaluated at x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.logcdf.html
scipy stats rv_continuous logcdf	R	scipy.stats.rv_continuous.logcdf										
scipy stats.rv_continuous.logcdf	R	scipy.stats.rv_continuous.logcdf										
scipy.stats.rv_continuous.logpdf	A										<section class="prog__container"><p>Log of the probability density function at x of the given RV.</p><pre><code>rv_continuous.logpdf(x, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    quantiles \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>logpdf : array_like\n    Log of the probability density function evaluated at x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.logpdf.html
scipy stats rv_continuous logpdf	R	scipy.stats.rv_continuous.logpdf										
scipy stats.rv_continuous.logpdf	R	scipy.stats.rv_continuous.logpdf										
scipy.stats.rv_continuous.logsf	A										<section class="prog__container"><p>Log of the survival function of the given RV.</p><pre><code>rv_continuous.logsf(x, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    quantiles \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>logsf : ndarray\n    Log of the survival function evaluated at x.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.logsf.html
scipy stats rv_continuous logsf	R	scipy.stats.rv_continuous.logsf										
scipy stats.rv_continuous.logsf	R	scipy.stats.rv_continuous.logsf										
scipy.stats.rv_continuous.mean	A										<section class="prog__container"><p>Mean of the distribution.</p><pre><code>rv_continuous.mean(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>mean : float\n    the mean of the distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.mean.html
scipy stats rv_continuous mean	R	scipy.stats.rv_continuous.mean										
scipy stats.rv_continuous.mean	R	scipy.stats.rv_continuous.mean										
scipy.stats.rv_continuous.median	A										<section class="prog__container"><p>Median of the distribution.</p><pre><code>rv_continuous.median(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    Location parameter, Default is 0. \nscale : array_like, optional\n    Scale parameter, Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : float\n    The median of the distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.median.html
scipy stats rv_continuous median	R	scipy.stats.rv_continuous.median										
scipy stats.rv_continuous.median	R	scipy.stats.rv_continuous.median										
scipy.stats.rv_continuous.moment	A										<section class="prog__container"><p>n-th order non-central moment of distribution.</p><pre><code>rv_continuous.moment(n, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, n >= 1\n    Order of moment. \narg1, arg2, arg3,... : float\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.moment.html
scipy stats rv_continuous moment	R	scipy.stats.rv_continuous.moment										
scipy stats.rv_continuous.moment	R	scipy.stats.rv_continuous.moment										
scipy.stats.rv_continuous.nnlf	A										<section class="prog__container"><p>Return negative loglikelihood function.</p><pre><code>rv_continuous.nnlf(theta, x)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.nnlf.html
scipy stats rv_continuous nnlf	R	scipy.stats.rv_continuous.nnlf										
scipy stats.rv_continuous.nnlf	R	scipy.stats.rv_continuous.nnlf										
scipy.stats.rv_continuous.pdf	A										<section class="prog__container"><p>Probability density function at x of the given RV.</p><pre><code>rv_continuous.pdf(x, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    quantiles \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>pdf : ndarray\n    Probability density function evaluated at x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.pdf.html
scipy stats rv_continuous pdf	R	scipy.stats.rv_continuous.pdf										
scipy stats.rv_continuous.pdf	R	scipy.stats.rv_continuous.pdf										
scipy.stats.rv_continuous.ppf	A										<section class="prog__container"><p>Percent point function (inverse of cdf) at q of the given RV.</p><pre><code>rv_continuous.ppf(q, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>q : array_like\n    lower tail probability \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>x : array_like\n    quantile corresponding to the lower tail probability q.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.ppf.html
scipy stats rv_continuous ppf	R	scipy.stats.rv_continuous.ppf										
scipy stats.rv_continuous.ppf	R	scipy.stats.rv_continuous.ppf										
scipy.stats.rv_continuous.random_state	A										<section class="prog__container"><p>Get or set the RandomState object for generating random variates.</p><pre><code>rv_continuous.random_state</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.random_state.html
scipy stats rv_continuous random_state	R	scipy.stats.rv_continuous.random_state										
scipy stats.rv_continuous.random_state	R	scipy.stats.rv_continuous.random_state										
scipy stats rv_continuous	R	scipy.stats.rv_continuous										
scipy stats.rv_continuous	R	scipy.stats.rv_continuous										
scipy.stats.rv_continuous.rvs	A										<section class="prog__container"><p>Random variates of given type.</p><pre><code>rv_continuous.rvs(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0). \nscale : array_like, optional\n    Scale parameter (default=1). \nsize : int or tuple of ints, optional\n    Defining number of random variates (default is 1). \nrandom_state : None or int or np.random.RandomState instance, optional\n    If int or RandomState, use it for drawing the random variates. If None, rely on self.random_state. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>rvs : ndarray or scalar\n    Random variates of given size.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.rvs.html
scipy stats rv_continuous rvs	R	scipy.stats.rv_continuous.rvs										
scipy stats.rv_continuous.rvs	R	scipy.stats.rv_continuous.rvs										
scipy.stats.rv_continuous.sf	A										<section class="prog__container"><p>Survival function (1 - cdf) at x of the given RV.</p><pre><code>rv_continuous.sf(x, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    quantiles \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>sf : array_like\n    Survival function evaluated at x</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.sf.html
scipy stats rv_continuous sf	R	scipy.stats.rv_continuous.sf										
scipy stats.rv_continuous.sf	R	scipy.stats.rv_continuous.sf										
scipy.stats.rv_continuous.stats	A										<section class="prog__container"><p>Some statistics of the given RV.</p><pre><code>rv_continuous.stats(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional (continuous RVs only)\n    scale parameter (default=1) \nmoments : str, optional\n    composed of letters [‘mvsk’] defining which moments to compute: ‘m’ = mean, ‘v’ = variance, ‘s’ = (Fisher’s) skew, ‘k’ = (Fisher’s) kurtosis. (default is ‘mv’)</code></pre><span class="prog__sub">Returns:</span><pre><code>stats : sequence\n    of requested moments.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.stats.html
scipy stats rv_continuous stats	R	scipy.stats.rv_continuous.stats										
scipy stats.rv_continuous.stats	R	scipy.stats.rv_continuous.stats										
scipy.stats.rv_continuous.std	A										<section class="prog__container"><p>Standard deviation of the distribution.</p><pre><code>rv_continuous.std(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>std : float\n    standard deviation of the distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.std.html
scipy stats rv_continuous std	R	scipy.stats.rv_continuous.std										
scipy stats.rv_continuous.std	R	scipy.stats.rv_continuous.std										
scipy.stats.rv_continuous.var	A										<section class="prog__container"><p>Variance of the distribution.</p><pre><code>rv_continuous.var(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>var : float\n    the variance of the distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.var.html
scipy stats rv_continuous var	R	scipy.stats.rv_continuous.var										
scipy stats.rv_continuous.var	R	scipy.stats.rv_continuous.var										
scipy.stats.rv_discrete	A										<section class="prog__container"><p>A generic discrete random variable class meant for subclassing.</p><pre><code>class scipy.stats.rv_discrete(a=0, b=inf, name=None, badvalue=None, moment_tol=1e-08, values=None, inc=1, longname=None, shapes=None, extradoc=None, seed=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : float, optional\n    Lower bound of the support of the distribution, default: 0 \nb : float, optional\n    Upper bound of the support of the distribution, default: plus infinity \nmoment_tol : float, optional\n    The tolerance for the generic calculation of moments. \nvalues : tuple of two array_like, optional\n    (xk, pk) where xk are integers with non-zero probabilities pk  with sum(pk) = 1. \ninc : integer, optional\n    Increment for the support of the distribution. Default is 1. (other values have not been tested) \nbadvalue : float, optional\n    The value in a result arrays that indicates a value that for which some argument restriction is violated, default is np.nan. \nname : str, optional\n    The name of the instance. This string is used to construct the default example for distributions. \nlongname : str, optional\n    This string is used as part of the first line of the docstring returned when a subclass has no docstring of its own. Note: longname exists for backwards compatibility, do not use for new subclasses. \nshapes : str, optional\n    The shape of the distribution. For example “m, n” for a distribution that takes two integers as the two shape arguments for all its methods If not provided, shape parameters will be inferred from the signatures of the private methods, _pmf and _cdf of the instance. \nextradoc :  str, optional\n    This string is used as the last part of the docstring returned when a subclass has no docstring of its own. Note: extradoc exists for backwards compatibility, do not use for new subclasses. \nseed : None or int or numpy.random.RandomState instance, optional\n    This parameter defines the RandomState object to use for drawing random variates. If None, the global np.random state is used. If integer, it is used to seed the local RandomState instance. Default is None.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import rv_discrete\n>>> class poisson_gen(rv_discrete):\n...     "Poisson distribution"\n...     def _pmf(self, k, mu):\n...         return exp(-mu) * mu**k / factorial(k)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.html
scipy.stats.rv_discrete.__call__	A										<section class="prog__container"><p>Freeze the distribution for the given arguments.</p><pre><code>rv_discrete.__call__(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution.  Should include all the non-optional arguments, may include loc and scale.</code></pre><span class="prog__sub">Returns:</span><pre><code>rv_frozen : rv_frozen instance\n    The frozen distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.__call__.html
scipy stats rv_discrete __call__	R	scipy.stats.rv_discrete.__call__										
scipy stats.rv_discrete.__call__	R	scipy.stats.rv_discrete.__call__										
scipy.stats.rv_discrete.cdf	A										<section class="prog__container"><p>Cumulative distribution function of the given RV.</p><pre><code>rv_discrete.cdf(k, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like, int\n    Quantiles. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0).</code></pre><span class="prog__sub">Returns:</span><pre><code>cdf : ndarray\n    Cumulative distribution function evaluated at k.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.cdf.html
scipy stats rv_discrete cdf	R	scipy.stats.rv_discrete.cdf										
scipy stats.rv_discrete.cdf	R	scipy.stats.rv_discrete.cdf										
scipy.stats.rv_discrete.entropy	A										<section class="prog__container"><p>Differential entropy of the RV.</p><pre><code>rv_discrete.entropy(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0). \nscale : array_like, optional  (continuous distributions only).\n    Scale parameter (default=1).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> drv = rv_discrete(values=((0, 1), (0.5, 0.5)))\n>>> np.allclose(drv.entropy(), np.log(2.0))\nTrue</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.entropy.html
scipy stats rv_discrete entropy	R	scipy.stats.rv_discrete.entropy										
scipy stats.rv_discrete.entropy	R	scipy.stats.rv_discrete.entropy										
scipy.stats.rv_discrete.expect	A										<section class="prog__container"><p>Calculate expected value of a function with respect to the distribution\nfor discrete distribution.</p><pre><code>rv_discrete.expect(func=None, args=(), loc=0, lb=None, ub=None, conditional=False, maxcount=1000, tolerance=1e-10, chunksize=32)</code></pre><span class="prog__sub">Parameters:</span><pre><code>func : callable, optional\n    Function for which the expectation value is calculated. Takes only one argument. The default is the identity mapping f(k) = k. \nargs : tuple, optional\n    Shape parameters of the distribution. \nloc : float, optional\n    Location parameter. Default is 0. \nlb, ub : int, optional\n    Lower and upper bound for the summation, default is set to the support of the distribution, inclusive (ul <= k <= ub). \nconditional : bool, optional\n    If true then the expectation is corrected by the conditional probability of the summation interval. The return value is the expectation of the function, func, conditional on being in the given interval (k such that ul <= k <= ub). Default is False. \nmaxcount : int, optional\n    Maximal number of terms to evaluate (to avoid an endless loop for an infinite sum). Default is 1000. \ntolerance : float, optional\n    Absolute tolerance for the summation. Default is 1e-10. \nchunksize : int, optional\n    Iterate over the support of a distributions in chunks of this size. Default is 32.</code></pre><span class="prog__sub">Returns:</span><pre><code>expect : float\n    Expected value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.expect.html
scipy stats rv_discrete expect	R	scipy.stats.rv_discrete.expect										
scipy stats.rv_discrete.expect	R	scipy.stats.rv_discrete.expect										
scipy.stats.rv_discrete.freeze	A										<section class="prog__container"><p>Freeze the distribution for the given arguments.</p><pre><code>rv_discrete.freeze(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution.  Should include all the non-optional arguments, may include loc and scale.</code></pre><span class="prog__sub">Returns:</span><pre><code>rv_frozen : rv_frozen instance\n    The frozen distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.freeze.html
scipy stats rv_discrete freeze	R	scipy.stats.rv_discrete.freeze										
scipy stats.rv_discrete.freeze	R	scipy.stats.rv_discrete.freeze										
scipy.stats.rv_discrete.interval	A										<section class="prog__container"><p>Confidence interval with equal areas around the median.</p><pre><code>rv_discrete.interval(alpha, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>alpha : array_like of float\n    Probability that an rv will be drawn from the returned range. Each value should be in the range [0, 1]. \narg1, arg2, ... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    location parameter, Default is 0. \nscale : array_like, optional\n    scale parameter, Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>a, b : ndarray of float\n    end-points of range that contain 100 * alpha % of the rv’s possible values.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.interval.html
scipy stats rv_discrete interval	R	scipy.stats.rv_discrete.interval										
scipy stats.rv_discrete.interval	R	scipy.stats.rv_discrete.interval										
scipy.stats.rv_discrete.isf	A										<section class="prog__container"><p>Inverse survival function (inverse of sf) at q of the given RV.</p><pre><code>rv_discrete.isf(q, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>q : array_like\n    Upper tail probability. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0).</code></pre><span class="prog__sub">Returns:</span><pre><code>k : ndarray or scalar\n    Quantile corresponding to the upper tail probability, q.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.isf.html
scipy stats rv_discrete isf	R	scipy.stats.rv_discrete.isf										
scipy stats.rv_discrete.isf	R	scipy.stats.rv_discrete.isf										
scipy.stats.rv_discrete.logcdf	A										<section class="prog__container"><p>Log of the cumulative distribution function at k of the given RV.</p><pre><code>rv_discrete.logcdf(k, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like, int\n    Quantiles. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0).</code></pre><span class="prog__sub">Returns:</span><pre><code>logcdf : array_like\n    Log of the cumulative distribution function evaluated at k.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.logcdf.html
scipy stats rv_discrete logcdf	R	scipy.stats.rv_discrete.logcdf										
scipy stats.rv_discrete.logcdf	R	scipy.stats.rv_discrete.logcdf										
scipy.stats.rv_discrete.logpmf	A										<section class="prog__container"><p>Log of the probability mass function at k of the given RV.</p><pre><code>rv_discrete.logpmf(k, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    Quantiles. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>logpmf : array_like\n    Log of the probability mass function evaluated at k.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.logpmf.html
scipy stats rv_discrete logpmf	R	scipy.stats.rv_discrete.logpmf										
scipy stats.rv_discrete.logpmf	R	scipy.stats.rv_discrete.logpmf										
scipy.stats.rv_discrete.logsf	A										<section class="prog__container"><p>Log of the survival function of the given RV.</p><pre><code>rv_discrete.logsf(k, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    Quantiles. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0).</code></pre><span class="prog__sub">Returns:</span><pre><code>logsf : ndarray\n    Log of the survival function evaluated at k.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.logsf.html
scipy stats rv_discrete logsf	R	scipy.stats.rv_discrete.logsf										
scipy stats.rv_discrete.logsf	R	scipy.stats.rv_discrete.logsf										
scipy.stats.rv_discrete.mean	A										<section class="prog__container"><p>Mean of the distribution.</p><pre><code>rv_discrete.mean(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>mean : float\n    the mean of the distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.mean.html
scipy stats rv_discrete mean	R	scipy.stats.rv_discrete.mean										
scipy stats.rv_discrete.mean	R	scipy.stats.rv_discrete.mean										
scipy.stats.rv_discrete.median	A										<section class="prog__container"><p>Median of the distribution.</p><pre><code>rv_discrete.median(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    Location parameter, Default is 0. \nscale : array_like, optional\n    Scale parameter, Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>median : float\n    The median of the distribution.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.median.html
scipy stats rv_discrete median	R	scipy.stats.rv_discrete.median										
scipy stats.rv_discrete.median	R	scipy.stats.rv_discrete.median										
scipy.stats.rv_discrete.moment	A										<section class="prog__container"><p>n-th order non-central moment of distribution.</p><pre><code>rv_discrete.moment(n, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>n : int, n >= 1\n    Order of moment. \narg1, arg2, arg3,... : float\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.moment.html
scipy stats rv_discrete moment	R	scipy.stats.rv_discrete.moment										
scipy stats.rv_discrete.moment	R	scipy.stats.rv_discrete.moment										
scipy.stats.rv_discrete.pmf	A										<section class="prog__container"><p>Probability mass function at k of the given RV.</p><pre><code>rv_discrete.pmf(k, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    Quantiles. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    Location parameter (default=0).</code></pre><span class="prog__sub">Returns:</span><pre><code>pmf : array_like\n    Probability mass function evaluated at k</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.pmf.html
scipy stats rv_discrete pmf	R	scipy.stats.rv_discrete.pmf										
scipy stats.rv_discrete.pmf	R	scipy.stats.rv_discrete.pmf										
scipy.stats.rv_discrete.ppf	A										<section class="prog__container"><p>Percent point function (inverse of cdf) at q of the given RV.</p><pre><code>rv_discrete.ppf(q, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>q : array_like\n    Lower tail probability. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0).</code></pre><span class="prog__sub">Returns:</span><pre><code>k : array_like\n    Quantile corresponding to the lower tail probability, q.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.ppf.html
scipy stats rv_discrete ppf	R	scipy.stats.rv_discrete.ppf										
scipy stats.rv_discrete.ppf	R	scipy.stats.rv_discrete.ppf										
scipy.stats.rv_discrete.random_state	A										<section class="prog__container"><p>Get or set the RandomState object for generating random variates.</p><pre><code>rv_discrete.random_state</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.random_state.html
scipy stats rv_discrete random_state	R	scipy.stats.rv_discrete.random_state										
scipy stats.rv_discrete.random_state	R	scipy.stats.rv_discrete.random_state										
scipy.stats.rv_discrete.return_integers	A										<section class="prog__container"><p>return_integers is deprecated!\nreturn_integers attribute is not used anywhere any  longer and is deprecated in scipy 0.18.</p><pre><code>rv_discrete.return_integers</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.return_integers.html
scipy stats rv_discrete return_integers	R	scipy.stats.rv_discrete.return_integers										
scipy stats.rv_discrete.return_integers	R	scipy.stats.rv_discrete.return_integers										
scipy stats rv_discrete	R	scipy.stats.rv_discrete										
scipy stats.rv_discrete	R	scipy.stats.rv_discrete										
scipy.stats.rv_discrete.rvs	A										<section class="prog__container"><p>Random variates of given type.</p><pre><code>rv_discrete.rvs(*args, **kwargs)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0). \nsize : int or tuple of ints, optional\n    Defining number of random variates (Default is 1).  Note that size has to be given as keyword, not as positional argument. \nrandom_state : None or int or np.random.RandomState instance, optional\n    If int or RandomState, use it for drawing the random variates. If None, rely on self.random_state. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>rvs : ndarray or scalar\n    Random variates of given size.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.rvs.html
scipy stats rv_discrete rvs	R	scipy.stats.rv_discrete.rvs										
scipy stats.rv_discrete.rvs	R	scipy.stats.rv_discrete.rvs										
scipy.stats.rv_discrete.sf	A										<section class="prog__container"><p>Survival function (1 - cdf) at k of the given RV.</p><pre><code>rv_discrete.sf(k, *args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>k : array_like\n    Quantiles. \narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information). \nloc : array_like, optional\n    Location parameter (default=0).</code></pre><span class="prog__sub">Returns:</span><pre><code>sf : array_like\n    Survival function evaluated at k.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.sf.html
scipy stats rv_discrete sf	R	scipy.stats.rv_discrete.sf										
scipy stats.rv_discrete.sf	R	scipy.stats.rv_discrete.sf										
scipy.stats.rv_discrete.stats	A										<section class="prog__container"><p>Some statistics of the given RV.</p><pre><code>rv_discrete.stats(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional (continuous RVs only)\n    scale parameter (default=1) \nmoments : str, optional\n    composed of letters [‘mvsk’] defining which moments to compute: ‘m’ = mean, ‘v’ = variance, ‘s’ = (Fisher’s) skew, ‘k’ = (Fisher’s) kurtosis. (default is ‘mv’)</code></pre><span class="prog__sub">Returns:</span><pre><code>stats : sequence\n    of requested moments.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.stats.html
scipy stats rv_discrete stats	R	scipy.stats.rv_discrete.stats										
scipy stats.rv_discrete.stats	R	scipy.stats.rv_discrete.stats										
scipy.stats.rv_discrete.std	A										<section class="prog__container"><p>Standard deviation of the distribution.</p><pre><code>rv_discrete.std(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>std : float\n    standard deviation of the distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.std.html
scipy stats rv_discrete std	R	scipy.stats.rv_discrete.std										
scipy stats.rv_discrete.std	R	scipy.stats.rv_discrete.std										
scipy.stats.rv_discrete.var	A										<section class="prog__container"><p>Variance of the distribution.</p><pre><code>rv_discrete.var(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>arg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the instance object for more information) \nloc : array_like, optional\n    location parameter (default=0) \nscale : array_like, optional\n    scale parameter (default=1)</code></pre><span class="prog__sub">Returns:</span><pre><code>var : float\n    the variance of the distribution</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.var.html
scipy stats rv_discrete var	R	scipy.stats.rv_discrete.var										
scipy stats.rv_discrete.var	R	scipy.stats.rv_discrete.var										
scipy.stats.scoreatpercentile	A					[[scipy.stats.percentileofscore]]\\n[[(in NumPy v1.11)]]					<section class="prog__container"><p>Calculate the score at a given percentile of the input sequence.</p><pre><code>scipy.stats.scoreatpercentile(a, per, limit=(), interpolation_method='fraction', axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    A 1-D array of values from which to extract score. \nper : array_like\n    Percentile(s) at which to extract score.  Values should be in range [0,100]. \nlimit : tuple, optional\n    Tuple of two scalars, the lower and upper limits within which to compute the percentile. Values of a outside this (closed) interval will be ignored. \ninterpolation_method : {‘fraction’, ‘lower’, ‘higher’}, optional\n    This optional parameter specifies the interpolation method to use, when the desired quantile lies between two data points i and j   fraction: i + (j - i) * fraction where fraction is the fractional part of the index surrounded by i and j. lower: i. higher: j.   \naxis : int, optional\n    Axis along which the percentiles are computed. Default is None. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>score : float or ndarray\n    Score at percentile(s).</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> a = np.arange(100)\n>>> stats.scoreatpercentile(a, 50)\n49.5</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.scoreatpercentile.html
scipy stats scoreatpercentile	R	scipy.stats.scoreatpercentile										
scipy stats.scoreatpercentile	R	scipy.stats.scoreatpercentile										
scipy.stats.sem	A										<section class="prog__container"><p>Calculates the standard error of the mean (or standard error of\nmeasurement) of the values in the input array.</p><pre><code>scipy.stats.sem(a, axis=0, ddof=1, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    An array containing the values for which the standard error is returned. \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \nddof : int, optional\n    Delta degrees-of-freedom. How many degrees of freedom to adjust for bias in limited samples relative to the population estimate of variance. Defaults to 1. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>s : ndarray or float\n    The standard error of the mean in the sample(s), along the input axis.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> a = np.arange(20).reshape(5,4)\n>>> stats.sem(a)\narray([ 2.8284,  2.8284,  2.8284,  2.8284])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.sem.html
scipy.stats.semicircular	A										<section class="prog__container"><p>A semicircular continuous random variable.</p><pre><code>scipy.stats.semicircular = <scipy.stats._continuous_distns.semicircular_gen object at 0x2aba950e0b90></code></pre><span class="prog__sub">Examples:</span><pre><code>semicircular.pdf(x) = 2/pi * sqrt(1-x**2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.semicircular.html
scipy stats semicircular	R	scipy.stats.semicircular										
scipy stats.semicircular	R	scipy.stats.semicircular										
scipy stats sem	R	scipy.stats.sem										
scipy stats.sem	R	scipy.stats.sem										
scipy.stats.shapiro	A										<section class="prog__container"><p>Perform the Shapiro-Wilk test for normality.</p><pre><code>scipy.stats.shapiro(x, a=None, reta=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Array of sample data. \na : array_like, optional\n    Array of internal parameters used in the calculation.  If these are not given, they will be computed internally.  If x has length n, then a must have length n/2. \nreta : bool, optional\n    Whether or not to return the internally computed a values.  The default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>W : float\n    The test statistic. \np-value : float\n    The p-value for the hypothesis test. \na : array_like, optional\n    If reta is True, then these are the internally computed “a” values that may be passed into this function on future calls.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(12345678)\n>>> x = stats.norm.rvs(loc=5, scale=3, size=100)\n>>> stats.shapiro(x)\n(0.9772805571556091, 0.08144091814756393)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.shapiro.html
scipy stats shapiro	R	scipy.stats.shapiro										
scipy stats.shapiro	R	scipy.stats.shapiro										
scipy.stats.sigmaclip	A										<section class="prog__container"><p>Iterative sigma-clipping of array elements.</p><pre><code>scipy.stats.sigmaclip(a, low=4.0, high=4.0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Data array, will be raveled if not 1-D. \nlow : float, optional\n    Lower bound factor of sigma clipping. Default is 4. \nhigh : float, optional\n    Upper bound factor of sigma clipping. Default is 4.</code></pre><span class="prog__sub">Returns:</span><pre><code>clipped : ndarray\n    Input array with clipped elements removed. \nlower : float\n    Lower threshold value use for clipping. \nupper : float\n    Upper threshold value use for clipping.</code></pre><span class="prog__sub">Examples:</span><pre><code>mean(c) - std(c)*low < c < mean(c) + std(c)*high</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.sigmaclip.html
scipy stats sigmaclip	R	scipy.stats.sigmaclip										
scipy stats.sigmaclip	R	scipy.stats.sigmaclip										
scipy.stats.signaltonoise	A										<section class="prog__container"><p>signaltonoise is deprecated!\nscipy.stats.signaltonoise is deprecated in scipy 0.16.0</p><pre><code>scipy.stats.signaltonoise(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    An array_like object containing the sample data.   axis : int or None, optional Axis along which to operate. Default is 0. If None, compute over the whole array a.  ddof : int, optional Degrees of freedom correction for standard deviation. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>s2n : ndarray\n    The mean to standard deviation ratio(s) along axis, or 0 where the standard deviation is 0.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.signaltonoise.html
scipy stats signaltonoise	R	scipy.stats.signaltonoise										
scipy stats.signaltonoise	R	scipy.stats.signaltonoise										
scipy.stats.skellam	A										<section class="prog__container"><p>A  Skellam discrete random variable.</p><pre><code>scipy.stats.skellam = <scipy.stats._discrete_distns.skellam_gen object at 0x2aba95116310></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import skellam\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.skellam.html
scipy stats skellam	R	scipy.stats.skellam										
scipy stats.skellam	R	scipy.stats.skellam										
scipy.stats.skew	A										<section class="prog__container"><p>Computes the skewness of a data set.</p><pre><code>scipy.stats.skew(a, axis=0, bias=True, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : ndarray\n    data \naxis : int or None, optional\n    Axis along which skewness is calculated. Default is 0. If None, compute over the whole array a. \nbias : bool, optional\n    If False, then the calculations are corrected for statistical bias. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>skewness : ndarray\n    The skewness of values along an axis, returning 0 where all values are equal.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.skew.html
scipy.stats.skewnorm	A										<section class="prog__container"><p>A skew-normal random variable.</p><pre><code>scipy.stats.skewnorm = <scipy.stats._continuous_distns.skew_norm_gen object at 0x2aba950e0d90></code></pre><span class="prog__sub">Examples:</span><pre><code>skewnorm.pdf(x, a) = 2*norm.pdf(x)*norm.cdf(ax)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.skewnorm.html
scipy stats skewnorm	R	scipy.stats.skewnorm										
scipy stats.skewnorm	R	scipy.stats.skewnorm										
scipy stats skew	R	scipy.stats.skew										
scipy stats.skew	R	scipy.stats.skew										
scipy.stats.skewtest	A										<section class="prog__container"><p>Tests whether the skew is different from the normal distribution.</p><pre><code>scipy.stats.skewtest(a, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array\n    The data to be tested \naxis : int or None, optional\n    Axis along which statistics are calculated. Default is 0. If None, compute over the whole array a. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The computed z-score for this test. \npvalue : float\n    a 2-sided p-value for the hypothesis test</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.skewtest.html
scipy stats skewtest	R	scipy.stats.skewtest										
scipy stats.skewtest	R	scipy.stats.skewtest										
scipy.stats.spearmanr	A										<section class="prog__container"><p>Calculates a Spearman rank-order correlation coefficient and the p-value\nto test for non-correlation.</p><pre><code>scipy.stats.spearmanr(a, b=None, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : 1D or 2D array_like, b is optional\n    One or two 1-D or 2-D arrays containing multiple variables and observations. When these are 1-D, each represents a vector of observations of a single variable. For the behavior in the 2-D case, see under axis, below. Both arrays need to have the same length in the axis dimension. \naxis : int or None, optional\n    If axis=0 (default), then each column represents a variable, with observations in the rows. If axis=1, the relationship is transposed: each row represents a variable, while the columns contain observations. If axis=None, then both arrays will be raveled. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>correlation : float or ndarray (2-D square)\n    Spearman correlation matrix or correlation coefficient (if only 2 variables are given as parameters. Correlation matrix is square with length equal to total number of variables (columns or rows) in a and b combined. \npvalue : float\n    The two-sided p-value for a hypothesis test whose null hypothesis is that two sets of data are uncorrelated, has same dimension as rho.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> stats.spearmanr([1,2,3,4,5], [5,6,7,8,7])\n(0.82078268166812329, 0.088587005313543798)\n>>> np.random.seed(1234321)\n>>> x2n = np.random.randn(100, 2)\n>>> y2n = np.random.randn(100, 2)\n>>> stats.spearmanr(x2n)\n(0.059969996999699973, 0.55338590803773591)\n>>> stats.spearmanr(x2n[:,0], x2n[:,1])\n(0.059969996999699973, 0.55338590803773591)\n>>> rho, pval = stats.spearmanr(x2n, y2n)\n>>> rho\narray([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626],\n       [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653],\n       [ 0.18569457,  0.110003  ,  1.        ,  0.03488749],\n       [ 0.06258626,  0.02534653,  0.03488749,  1.        ]])\n>>> pval\narray([[ 0.        ,  0.55338591,  0.06435364,  0.53617935],\n       [ 0.55338591,  0.        ,  0.27592895,  0.80234077],\n       [ 0.06435364,  0.27592895,  0.        ,  0.73039992],\n       [ 0.53617935,  0.80234077,  0.73039992,  0.        ]])\n>>> rho, pval = stats.spearmanr(x2n.T, y2n.T, axis=1)\n>>> rho\narray([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626],\n       [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653],\n       [ 0.18569457,  0.110003  ,  1.        ,  0.03488749],\n       [ 0.06258626,  0.02534653,  0.03488749,  1.        ]])\n>>> stats.spearmanr(x2n, y2n, axis=None)\n(0.10816770419260482, 0.1273562188027364)\n>>> stats.spearmanr(x2n.ravel(), y2n.ravel())\n(0.10816770419260482, 0.1273562188027364)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.spearmanr.html
scipy stats spearmanr	R	scipy.stats.spearmanr										
scipy stats.spearmanr	R	scipy.stats.spearmanr										
scipy.stats.special_ortho_group	A										<section class="prog__container"><p>A matrix-valued SO(N) random variable.</p><pre><code>scipy.stats.special_ortho_group = <scipy.stats._multivariate.special_ortho_group_gen object at 0x2aba953e4f50></code></pre><span class="prog__sub">Parameters:</span><pre><code>dim : scalar\n    Dimension of matrices</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import special_ortho_group\n>>> x = special_ortho_group.rvs(3)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.special_ortho_group.html
scipy stats special_ortho_group	R	scipy.stats.special_ortho_group										
scipy stats.special_ortho_group	R	scipy.stats.special_ortho_group										
scipy.stats.square_of_sums	A										<section class="prog__container"><p>square_of_sums is deprecated!\nscipy.stats.square_of_sums is deprecated in scipy 0.17.0</p><pre><code>scipy.stats.square_of_sums(*args, **kwds)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.square_of_sums.html
scipy stats square_of_sums	R	scipy.stats.square_of_sums										
scipy stats.square_of_sums	R	scipy.stats.square_of_sums										
scipy.stats.ss	A										<section class="prog__container"><p>ss is deprecated!\nscipy.stats.ss is deprecated in scipy 0.17.0</p><pre><code>scipy.stats.ss(*args, **kwds)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ss.html
scipy stats ss	R	scipy.stats.ss										
scipy stats.ss	R	scipy.stats.ss										
scipy.stats.t	A										<section class="prog__container"><p>A Student’s T continuous random variable.</p><pre><code>scipy.stats.t = <scipy.stats._continuous_distns.t_gen object at 0x2aba950c4a90></code></pre><span class="prog__sub">Examples:</span><pre><code>gamma((df+1)/2)\nt.pdf(x, df) = ---------------------------------------------------\n               sqrt(pi*df) * gamma(df/2) * (1+x**2/df)**((df+1)/2)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.t.html
scipy.stats.theilslopes	A										<section class="prog__container"><p>Computes the Theil-Sen estimator for a set of points (x, y).</p><pre><code>scipy.stats.theilslopes(y, x=None, alpha=0.95)</code></pre><span class="prog__sub">Parameters:</span><pre><code>y : array_like\n    Dependent variable. \nx : array_like or None, optional\n    Independent variable. If None, use arange(len(y)) instead. \nalpha : float, optional\n    Confidence degree between 0 and 1. Default is 95% confidence. Note that alpha is symmetric around 0.5, i.e. both 0.1 and 0.9 are interpreted as “find the 90% confidence interval”.</code></pre><span class="prog__sub">Returns:</span><pre><code>medslope : float\n    Theil slope. \nmedintercept : float\n    Intercept of the Theil line, as median(y) - medslope*median(x). \nlo_slope : float\n    Lower bound of the confidence interval on medslope. \nup_slope : float\n    Upper bound of the confidence interval on medslope.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> import matplotlib.pyplot as plt</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.theilslopes.html
scipy stats theilslopes	R	scipy.stats.theilslopes										
scipy stats.theilslopes	R	scipy.stats.theilslopes										
scipy.stats.threshold	A										<section class="prog__container"><p>threshold is deprecated!\nstats.threshold is deprecated in scipy 0.17.0</p><pre><code>scipy.stats.threshold(*args, **kwds)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Data to threshold.   threshmin : float, int or None, optional Minimum threshold, defaults to None.  threshmax : float, int or None, optional Maximum threshold, defaults to None.  newval : float or int, optional Value to put in place of values in a outside of bounds. Defaults to 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    The clipped input array, with values less than threshmin or greater than threshmax replaced with newval.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([9, 9, 6, 3, 1, 6, 1, 0, 0, 8])\n>>> from scipy import stats\n>>> stats.threshold(a, threshmin=2, threshmax=8, newval=-1)\narray([-1, -1,  6,  3, -1,  6, -1, -1, -1,  8])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.threshold.html
scipy stats threshold	R	scipy.stats.threshold										
scipy stats.threshold	R	scipy.stats.threshold										
scipy.stats.tiecorrect	A										<section class="prog__container"><p>Tie correction factor for ties in the Mann-Whitney U and\nKruskal-Wallis H tests.</p><pre><code>scipy.stats.tiecorrect(rankvals)</code></pre><span class="prog__sub">Parameters:</span><pre><code>rankvals : array_like\n    A 1-D sequence of ranks.  Typically this will be the array returned by stats.rankdata.</code></pre><span class="prog__sub">Returns:</span><pre><code>factor : float\n    Correction factor for U or H.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import tiecorrect, rankdata\n>>> tiecorrect([1, 2.5, 2.5, 4])\n0.9\n>>> ranks = rankdata([1, 3, 2, 4, 5, 7, 2, 8, 4])\n>>> ranks\narray([ 1. ,  4. ,  2.5,  5.5,  7. ,  8. ,  2.5,  9. ,  5.5])\n>>> tiecorrect(ranks)\n0.9833333333333333</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.tiecorrect.html
scipy stats tiecorrect	R	scipy.stats.tiecorrect										
scipy stats.tiecorrect	R	scipy.stats.tiecorrect										
scipy.stats.tmax	A										<section class="prog__container"><p>Compute the trimmed maximum</p><pre><code>scipy.stats.tmax(a, upperlimit=None, axis=0, inclusive=True, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    array of values \nupperlimit : None or float, optional\n    Values in the input array greater than the given limit will be ignored. When upperlimit is None, then all values are used. The default value is None. \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \ninclusive : {True, False}, optional\n    This flag determines whether values exactly equal to the upper limit are included.  The default value is True. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>tmax : float, int or ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = np.arange(20)\n>>> stats.tmax(x)\n19</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.tmax.html
scipy stats tmax	R	scipy.stats.tmax										
scipy stats.tmax	R	scipy.stats.tmax										
scipy.stats.tmean	A										<section class="prog__container"><p>Compute the trimmed mean.</p><pre><code>scipy.stats.tmean(a, limits=None, inclusive=(True, True), axis=None)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array of values. \nlimits : None or (lower limit, upper limit), optional\n    Values in the input array less than the lower limit or greater than the upper limit will be ignored.  When limits is None (default), then all values are used.  Either of the limit values in the tuple can also be None representing a half-open interval. \ninclusive : (bool, bool), optional\n    A tuple consisting of the (lower flag, upper flag).  These flags determine whether values exactly equal to the lower or upper limits are included.  The default value is (True, True). \naxis : int or None, optional\n    Axis along which to compute test. Default is None.</code></pre><span class="prog__sub">Returns:</span><pre><code>tmean : float</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = np.arange(20)\n>>> stats.tmean(x)\n9.5\n>>> stats.tmean(x, (3,17))\n10.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.tmean.html
scipy stats tmean	R	scipy.stats.tmean										
scipy stats.tmean	R	scipy.stats.tmean										
scipy.stats.tmin	A										<section class="prog__container"><p>Compute the trimmed minimum</p><pre><code>scipy.stats.tmin(a, lowerlimit=None, axis=0, inclusive=True, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    array of values \nlowerlimit : None or float, optional\n    Values in the input array less than the given limit will be ignored. When lowerlimit is None, then all values are used. The default value is None. \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \ninclusive : {True, False}, optional\n    This flag determines whether values exactly equal to the lower limit are included.  The default value is True. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>tmin : float, int or ndarray</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = np.arange(20)\n>>> stats.tmin(x)\n0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.tmin.html
scipy stats tmin	R	scipy.stats.tmin										
scipy stats.tmin	R	scipy.stats.tmin										
scipy.stats.trapz	A										<section class="prog__container"><p>A trapezoidal continuous random variable.</p><pre><code>scipy.stats.trapz = <scipy.stats._continuous_distns.trapz_gen object at 0x2aba950eb090></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import trapz\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.trapz.html
scipy stats trapz	R	scipy.stats.trapz										
scipy stats.trapz	R	scipy.stats.trapz										
scipy.stats.triang	A										<section class="prog__container"><p>A triangular continuous random variable.</p><pre><code>scipy.stats.triang = <scipy.stats._continuous_distns.triang_gen object at 0x2aba950eb310></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import triang\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.triang.html
scipy stats triang	R	scipy.stats.triang										
scipy stats.triang	R	scipy.stats.triang										
scipy.stats.trim1	A										<section class="prog__container"><p>Slices off a proportion from ONE end of the passed array distribution.</p><pre><code>scipy.stats.trim1(a, proportiontocut, tail='right', axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array \nproportiontocut : float\n    Fraction to cut off of ‘left’ or ‘right’ of distribution \ntail : {‘left’, ‘right’}, optional\n    Defaults to ‘right’. \naxis : int or None, optional\n    Axis along which to trim data. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>trim1 : ndarray\n    Trimmed version of array a. The order of the trimmed content is undefined.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.trim1.html
scipy stats trim1	R	scipy.stats.trim1										
scipy stats.trim1	R	scipy.stats.trim1										
scipy.stats.trimboth	A					[[scipy.stats.trim_mean]]					<section class="prog__container"><p>Slices off a proportion of items from both ends of an array.</p><pre><code>scipy.stats.trimboth(a, proportiontocut, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Data to trim. \nproportiontocut : float\n    Proportion (in range 0-1) of total data set to trim of each end. \naxis : int or None, optional\n    Axis along which to trim data. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>out : ndarray\n    Trimmed version of array a. The order of the trimmed content is undefined.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> a = np.arange(20)\n>>> b = stats.trimboth(a, 0.1)\n>>> b.shape\n(16,)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.trimboth.html
scipy stats trimboth	R	scipy.stats.trimboth										
scipy stats.trimboth	R	scipy.stats.trimboth										
scipy.stats.trim_mean	A										<section class="prog__container"><p>Return mean of array after trimming distribution from both tails.</p><pre><code>scipy.stats.trim_mean(a, proportiontocut, axis=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array \nproportiontocut : float\n    Fraction to cut off of both tails of the distribution \naxis : int or None, optional\n    Axis along which the trimmed means are computed. Default is 0. If None, compute over the whole array a.</code></pre><span class="prog__sub">Returns:</span><pre><code>trim_mean : ndarray\n    Mean of trimmed array.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = np.arange(20)\n>>> stats.trim_mean(x, 0.1)\n9.5\n>>> x2 = x.reshape(5, 4)\n>>> x2\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15],\n       [16, 17, 18, 19]])\n>>> stats.trim_mean(x2, 0.25)\narray([  8.,   9.,  10.,  11.])\n>>> stats.trim_mean(x2, 0.25, axis=1)\narray([  1.5,   5.5,   9.5,  13.5,  17.5])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.trim_mean.html
scipy stats trim_mean	R	scipy.stats.trim_mean										
scipy stats.trim_mean	R	scipy.stats.trim_mean										
scipy stats t	R	scipy.stats.t										
scipy stats.t	R	scipy.stats.t										
scipy.stats.truncexpon	A										<section class="prog__container"><p>A truncated exponential continuous random variable.</p><pre><code>scipy.stats.truncexpon = <scipy.stats._continuous_distns.truncexpon_gen object at 0x2aba950eb590></code></pre><span class="prog__sub">Examples:</span><pre><code>truncexpon.pdf(x, b) = exp(-x) / (1-exp(-b))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.truncexpon.html
scipy stats truncexpon	R	scipy.stats.truncexpon										
scipy stats.truncexpon	R	scipy.stats.truncexpon										
scipy.stats.truncnorm	A										<section class="prog__container"><p>A truncated normal continuous random variable.</p><pre><code>scipy.stats.truncnorm = <scipy.stats._continuous_distns.truncnorm_gen object at 0x2aba950eb810></code></pre><span class="prog__sub">Examples:</span><pre><code>a, b = (myclip_a - my_mean) / my_std, (myclip_b - my_mean) / my_std</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.truncnorm.html
scipy stats truncnorm	R	scipy.stats.truncnorm										
scipy stats.truncnorm	R	scipy.stats.truncnorm										
scipy.stats.tsem	A										<section class="prog__container"><p>Compute the trimmed standard error of the mean.</p><pre><code>scipy.stats.tsem(a, limits=None, inclusive=(True, True), axis=0, ddof=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    array of values \nlimits : None or (lower limit, upper limit), optional\n    Values in the input array less than the lower limit or greater than the upper limit will be ignored. When limits is None, then all values are used. Either of the limit values in the tuple can also be None representing a half-open interval.  The default value is None. \ninclusive : (bool, bool), optional\n    A tuple consisting of the (lower flag, upper flag).  These flags determine whether values exactly equal to the lower or upper limits are included.  The default value is (True, True). \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \nddof : int, optional\n    Delta degrees of freedom.  Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>tsem : float</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = np.arange(20)\n>>> stats.tsem(x)\n1.3228756555322954\n>>> stats.tsem(x, (3,17))\n1.1547005383792515</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.tsem.html
scipy stats tsem	R	scipy.stats.tsem										
scipy stats.tsem	R	scipy.stats.tsem										
scipy.stats.tstd	A										<section class="prog__container"><p>Compute the trimmed sample standard deviation</p><pre><code>scipy.stats.tstd(a, limits=None, inclusive=(True, True), axis=0, ddof=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    array of values \nlimits : None or (lower limit, upper limit), optional\n    Values in the input array less than the lower limit or greater than the upper limit will be ignored. When limits is None, then all values are used. Either of the limit values in the tuple can also be None representing a half-open interval.  The default value is None. \ninclusive : (bool, bool), optional\n    A tuple consisting of the (lower flag, upper flag).  These flags determine whether values exactly equal to the lower or upper limits are included.  The default value is (True, True). \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \nddof : int, optional\n    Delta degrees of freedom.  Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>tstd : float</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = np.arange(20)\n>>> stats.tstd(x)\n5.9160797830996161\n>>> stats.tstd(x, (3,17))\n4.4721359549995796</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.tstd.html
scipy stats tstd	R	scipy.stats.tstd										
scipy stats.tstd	R	scipy.stats.tstd										
scipy.stats.ttest_1samp	A										<section class="prog__container"><p>Calculates the T-test for the mean of ONE group of scores.</p><pre><code>scipy.stats.ttest_1samp(a, popmean, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    sample observation \npopmean : float or array_like\n    expected value in null hypothesis, if array_like than it must have the same shape as a excluding the axis dimension \naxis : int or None, optional\n    Axis along which to compute test. If None, compute over the whole array a. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    t-statistic \npvalue : float or array\n    two-tailed p-value</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_1samp.html
scipy stats ttest_1samp	R	scipy.stats.ttest_1samp										
scipy stats.ttest_1samp	R	scipy.stats.ttest_1samp										
scipy.stats.ttest_ind	A										<section class="prog__container"><p>Calculates the T-test for the means of two independent samples of scores.</p><pre><code>scipy.stats.ttest_ind(a, b, axis=0, equal_var=True, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    The arrays must have the same shape, except in the dimension corresponding to axis (the first, by default). \naxis : int or None, optional\n    Axis along which to compute test. If None, compute over the whole arrays, a, and b. \nequal_var : bool, optional\n    If True (default), perform a standard independent 2 sample test that assumes equal population variances [R576]. If False, perform Welch’s t-test, which does not assume equal population variance [R577].  New in version 0.11.0.  \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    The calculated t-statistic. \npvalue : float or array\n    The two-tailed p-value.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(12345678)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_ind.html
scipy.stats.ttest_ind_from_stats	A					[[scipy.stats.ttest_ind]]					<section class="prog__container"><p>T-test for means of two independent samples from descriptive statistics.</p><pre><code>scipy.stats.ttest_ind_from_stats(mean1, std1, nobs1, mean2, std2, nobs2, equal_var=True)</code></pre><span class="prog__sub">Parameters:</span><pre><code>mean1 : array_like\n    The mean(s) of sample 1. \nstd1 : array_like\n    The standard deviation(s) of sample 1. \nnobs1 : array_like\n    The number(s) of observations of sample 1. \nmean2 : array_like\n    The mean(s) of sample 2 \nstd2 : array_like\n    The standard deviations(s) of sample 2. \nnobs2 : array_like\n    The number(s) of observations of sample 2. \nequal_var : bool, optional\n    If True (default), perform a standard independent 2 sample test that assumes equal population variances [R578]. If False, perform Welch’s t-test, which does not assume equal population variance [R579].</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    The calculated t-statistics \npvalue : float or array\n    The two-tailed p-value.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_ind_from_stats.html
scipy stats ttest_ind_from_stats	R	scipy.stats.ttest_ind_from_stats										
scipy stats.ttest_ind_from_stats	R	scipy.stats.ttest_ind_from_stats										
scipy stats ttest_ind	R	scipy.stats.ttest_ind										
scipy stats.ttest_ind	R	scipy.stats.ttest_ind										
scipy.stats.ttest_rel	A										<section class="prog__container"><p>Calculates the T-test on TWO RELATED samples of scores, a and b.</p><pre><code>scipy.stats.ttest_rel(a, b, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a, b : array_like\n    The arrays must have the same shape. \naxis : int or None, optional\n    Axis along which to compute test. If None, compute over the whole arrays, a, and b. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float or array\n    t-statistic \npvalue : float or array\n    two-tailed p-value</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> np.random.seed(12345678) # fix random seed to get same numbers</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_rel.html
scipy stats ttest_rel	R	scipy.stats.ttest_rel										
scipy stats.ttest_rel	R	scipy.stats.ttest_rel										
scipy.stats.tukeylambda	A										<section class="prog__container"><p>A Tukey-Lamdba continuous random variable.</p><pre><code>scipy.stats.tukeylambda = <scipy.stats._continuous_distns.tukeylambda_gen object at 0x2aba950eba90></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import tukeylambda\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.tukeylambda.html
scipy stats tukeylambda	R	scipy.stats.tukeylambda										
scipy stats.tukeylambda	R	scipy.stats.tukeylambda										
scipy.stats.tvar	A										<section class="prog__container"><p>Compute the trimmed variance</p><pre><code>scipy.stats.tvar(a, limits=None, inclusive=(True, True), axis=0, ddof=1)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Array of values. \nlimits : None or (lower limit, upper limit), optional\n    Values in the input array less than the lower limit or greater than the upper limit will be ignored. When limits is None, then all values are used. Either of the limit values in the tuple can also be None representing a half-open interval.  The default value is None. \ninclusive : (bool, bool), optional\n    A tuple consisting of the (lower flag, upper flag).  These flags determine whether values exactly equal to the lower or upper limits are included.  The default value is (True, True). \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \nddof : int, optional\n    Delta degrees of freedom.  Default is 1.</code></pre><span class="prog__sub">Returns:</span><pre><code>tvar : float\n    Trimmed variance.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy import stats\n>>> x = np.arange(20)\n>>> stats.tvar(x)\n35.0\n>>> stats.tvar(x, (3,17))\n20.0</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.tvar.html
scipy stats tvar	R	scipy.stats.tvar										
scipy stats.tvar	R	scipy.stats.tvar										
scipy.stats.uniform	A										<section class="prog__container"><p>A uniform continuous random variable.</p><pre><code>scipy.stats.uniform = <scipy.stats._continuous_distns.uniform_gen object at 0x2aba950ebd10></code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import uniform\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots(1, 1)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.uniform.html
scipy stats uniform	R	scipy.stats.uniform										
scipy stats.uniform	R	scipy.stats.uniform										
scipy.stats.variation	A										<section class="prog__container"><p>Computes the coefficient of variation, the ratio of the biased standard\ndeviation to the mean.</p><pre><code>scipy.stats.variation(a, axis=0, nan_policy='propagate')</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    Input array. \naxis : int or None, optional\n    Axis along which to calculate the coefficient of variation. Default is 0. If None, compute over the whole array a. \nnan_policy : {‘propagate’, ‘raise’, ‘omit’}, optional\n    Defines how to handle when input contains nan. ‘propagate’ returns nan, ‘raise’ throws an error, ‘omit’ performs the calculations ignoring nan values. Default is ‘propagate’.</code></pre><span class="prog__sub">Returns:</span><pre><code>variation : ndarray\n    The calculated variation along the requested axis.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.variation.html
scipy stats variation	R	scipy.stats.variation										
scipy stats.variation	R	scipy.stats.variation										
scipy.stats.vonmises	A										<section class="prog__container"><p>A Von Mises continuous random variable.</p><pre><code>scipy.stats.vonmises = <scipy.stats._continuous_distns.vonmises_gen object at 0x2aba950ebf10></code></pre><span class="prog__sub">Examples:</span><pre><code>vonmises.pdf(x, kappa) = exp(kappa * cos(x)) / (2*pi*I[0](kappa))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.vonmises.html
scipy.stats.vonmises_line	A										<section class="prog__container"><p>A Von Mises continuous random variable.</p><pre><code>scipy.stats.vonmises_line = <scipy.stats._continuous_distns.vonmises_gen object at 0x2aba950fb1d0></code></pre><span class="prog__sub">Examples:</span><pre><code>vonmises.pdf(x, kappa) = exp(kappa * cos(x)) / (2*pi*I[0](kappa))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.vonmises_line.html
scipy stats vonmises_line	R	scipy.stats.vonmises_line										
scipy stats.vonmises_line	R	scipy.stats.vonmises_line										
scipy stats vonmises	R	scipy.stats.vonmises										
scipy stats.vonmises	R	scipy.stats.vonmises										
scipy.stats.wald	A										<section class="prog__container"><p>A Wald continuous random variable.</p><pre><code>scipy.stats.wald = <scipy.stats._continuous_distns.wald_gen object at 0x2aba950fb410></code></pre><span class="prog__sub">Examples:</span><pre><code>wald.pdf(x) = 1/sqrt(2*pi*x**3) * exp(-(x-1)**2/(2*x))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wald.html
scipy stats wald	R	scipy.stats.wald										
scipy stats.wald	R	scipy.stats.wald										
scipy.stats.weibull_max	A					[[scipy.stats.frechet_r]]\\n[[scipy.stats.weibull_min]]					<section class="prog__container"><p>A Frechet left (or Weibull maximum) continuous random variable.</p><pre><code>scipy.stats.weibull_max = <scipy.stats._continuous_distns.frechet_l_gen object at 0x2aba95079fd0></code></pre><span class="prog__sub">Examples:</span><pre><code>frechet_l.pdf(x, c) = c * (-x)**(c-1) * exp(-(-x)**c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.weibull_max.html
scipy stats weibull_max	R	scipy.stats.weibull_max										
scipy stats.weibull_max	R	scipy.stats.weibull_max										
scipy.stats.weibull_min	A					[[scipy.stats.frechet_l]]\\n[[scipy.stats.weibull_max]]					<section class="prog__container"><p>A Frechet right (or Weibull minimum) continuous random variable.</p><pre><code>scipy.stats.weibull_min = <scipy.stats._continuous_distns.frechet_r_gen object at 0x2aba95079b10></code></pre><span class="prog__sub">Examples:</span><pre><code>frechet_r.pdf(x, c) = c * x**(c-1) * exp(-x**c)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.weibull_min.html
scipy stats weibull_min	R	scipy.stats.weibull_min										
scipy stats.weibull_min	R	scipy.stats.weibull_min										
scipy.stats.wilcoxon	A										<section class="prog__container"><p>Calculate the Wilcoxon signed-rank test.</p><pre><code>scipy.stats.wilcoxon(x, y=None, zero_method='wilcox', correction=False)</code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    The first set of measurements. \ny : array_like, optional\n    The second set of measurements.  If y is not given, then the x array is considered to be the differences between the two sets of measurements. \nzero_method : string, {“pratt”, “wilcox”, “zsplit”}, optional\n    “pratt”: Pratt treatment: includes zero-differences in the ranking process (more conservative)  “wilcox”: Wilcox treatment: discards all zero-differences  “zsplit”: Zero rank split: just like Pratt, but spliting the zero rank between positive and negative ones   \ncorrection : bool, optional\n    If True, apply continuity correction by adjusting the Wilcoxon rank statistic by 0.5 towards the mean value when computing the z-statistic.  Default is False.</code></pre><span class="prog__sub">Returns:</span><pre><code>statistic : float\n    The sum of the ranks of the differences above or below zero, whichever is smaller. \npvalue : float\n    The two-sided p-value for the test.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wilcoxon.html
scipy stats wilcoxon	R	scipy.stats.wilcoxon										
scipy stats.wilcoxon	R	scipy.stats.wilcoxon										
scipy.stats.wishart	A					[[scipy.stats.invwishart]]\\n[[scipy.stats.chi2]]					<section class="prog__container"><p>A Wishart random variable.</p><pre><code>scipy.stats.wishart = <scipy.stats._multivariate.wishart_gen object at 0x2aba953e4a10></code></pre><span class="prog__sub">Parameters:</span><pre><code>x : array_like\n    Quantiles, with the last axis of x denoting the components. \ndf : int\n    Degrees of freedom, must be greater than or equal to dimension of the scale matrix \nscale : array_like\n    Symmetric positive definite scale matrix of the distribution \nrandom_state : None or int or np.random.RandomState instance, optional\n    If int or RandomState, use it for drawing the random variates. If None (or np.random), the global np.random state is used. Default is None. \nAlternatively, the object may be called (as a function) to fix the degrees\nof freedom and scale parameters, returning a “frozen” Wishart random\nvariable:\nrv = wishart(df=1, scale=1)\n    Frozen object with the same methods but holding the given degrees of freedom and scale fixed.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> import matplotlib.pyplot as plt\n>>> from scipy.stats import wishart, chi2\n>>> x = np.linspace(1e-5, 8, 100)\n>>> w = wishart.pdf(x, df=3, scale=1); w[:5]\narray([ 0.00126156,  0.10892176,  0.14793434,  0.17400548,  0.1929669 ])\n>>> c = chi2.pdf(x, 3); c[:5]\narray([ 0.00126156,  0.10892176,  0.14793434,  0.17400548,  0.1929669 ])\n>>> plt.plot(x, w)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wishart.html
scipy stats wishart	R	scipy.stats.wishart										
scipy stats.wishart	R	scipy.stats.wishart										
scipy.stats.wrapcauchy	A										<section class="prog__container"><p>A wrapped Cauchy continuous random variable.</p><pre><code>scipy.stats.wrapcauchy = <scipy.stats._continuous_distns.wrapcauchy_gen object at 0x2aba950fb610></code></pre><span class="prog__sub">Examples:</span><pre><code>wrapcauchy.pdf(x, c) = (1-c**2) / (2*pi*(1+c**2-2*c*cos(x)))</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wrapcauchy.html
scipy stats wrapcauchy	R	scipy.stats.wrapcauchy										
scipy stats.wrapcauchy	R	scipy.stats.wrapcauchy										
scipy.stats.zipf	A										<section class="prog__container"><p>A Zipf discrete random variable.</p><pre><code>scipy.stats.zipf = <scipy.stats._discrete_distns.zipf_gen object at 0x2aba9510fe90></code></pre><span class="prog__sub">Examples:</span><pre><code>zipf.pmf(k, a) = 1/(zeta(a) * k**a)</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.zipf.html
scipy stats zipf	R	scipy.stats.zipf										
scipy stats.zipf	R	scipy.stats.zipf										
scipy.stats.zmap	A										<section class="prog__container"><p>Calculates the relative z-scores.</p><pre><code>scipy.stats.zmap(scores, compare, axis=0, ddof=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>scores : array_like\n    The input for which z-scores are calculated. \ncompare : array_like\n    The input from which the mean and standard deviation of the normalization are taken; assumed to have the same dimension as scores. \naxis : int or None, optional\n    Axis over which mean and variance of compare are calculated. Default is 0. If None, compute over the whole array scores. \nddof : int, optional\n    Degrees of freedom correction in the calculation of the standard deviation. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>zscore : array_like\n    Z-scores, in the same shape as scores.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> from scipy.stats import zmap\n>>> a = [0.5, 2.0, 2.5, 3]\n>>> b = [0, 1, 2, 3, 4]\n>>> zmap(a, b)\narray([-1.06066017,  0.        ,  0.35355339,  0.70710678])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.zmap.html
scipy stats zmap	R	scipy.stats.zmap										
scipy stats.zmap	R	scipy.stats.zmap										
scipy.stats.zscore	A										<section class="prog__container"><p>Calculates the z score of each value in the sample, relative to the\nsample mean and standard deviation.</p><pre><code>scipy.stats.zscore(a, axis=0, ddof=0)</code></pre><span class="prog__sub">Parameters:</span><pre><code>a : array_like\n    An array like object containing the sample data. \naxis : int or None, optional\n    Axis along which to operate. Default is 0. If None, compute over the whole array a. \nddof : int, optional\n    Degrees of freedom correction in the calculation of the standard deviation. Default is 0.</code></pre><span class="prog__sub">Returns:</span><pre><code>zscore : array_like\n    The z-scores, standardized by mean and standard deviation of input array a.</code></pre><span class="prog__sub">Examples:</span><pre><code>>>> a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,\n...                0.1954,  0.6307,  0.6599,  0.1065,  0.0508])\n>>> from scipy import stats\n>>> stats.zscore(a)\narray([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,\n        0.6748, -1.1488, -1.3324])</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.zscore.html
scipy stats zscore	R	scipy.stats.zscore										
scipy stats.zscore	R	scipy.stats.zscore										
scipy.weave.inline	A										<section class="prog__container"><p>Inline C/C++ code within Python scripts.</p><pre><code>scipy.weave.inline(code, arg_names=[], local_dict=None, global_dict=None, force=0, compiler='', verbose=0, support_code=None, headers=[], customize=None, type_converters=None, auto_downcast=1, newarr_converter=0, **kw)</code></pre><span class="prog__sub">Parameters:</span><pre><code>code : string\n    A string of valid C++ code.  It should not specify a return statement.  Instead it should assign results that need to be returned to Python in the return_val. \narg_names : [str], optional\n    A list of Python variable names that should be transferred from Python into the C/C++ code.  It defaults to an empty string. \nlocal_dict : dict, optional\n    If specified, it is a dictionary of values that should be used as the local scope for the C/C++ code.  If local_dict is not specified the local dictionary of the calling function is used. \nglobal_dict : dict, optional\n    If specified, it is a dictionary of values that should be used as the global scope for the C/C++ code.  If global_dict is not specified, the global dictionary of the calling function is used. \nforce : {0, 1}, optional\n    If 1, the C++ code is compiled every time inline is called.  This is really only useful for debugging, and probably only useful if your editing support_code a lot. \ncompiler : str, optional\n    The name of compiler to use when compiling.  On windows, it understands ‘msvc’ and ‘gcc’ as well as all the compiler names understood by distutils.  On Unix, it’ll only understand the values understood by distutils. (I should add ‘gcc’ though to this). On windows, the compiler defaults to the Microsoft C++ compiler. If this isn’t available, it looks for mingw32 (the gcc compiler). On Unix, it’ll probably use the same compiler that was used when compiling Python. Cygwin’s behavior should be similar. \nverbose : {0,1,2}, optional\n    Specifies how much information is printed during the compile phase of inlining code.  0 is silent (except on windows with msvc where it still prints some garbage). 1 informs you when compiling starts, finishes, and how long it took.  2 prints out the command lines for the compilation process and can be useful if your having problems getting code to work.  Its handy for finding the name of the .cpp file if you need to examine it.  verbose has no effect if the compilation isn’t necessary. \nsupport_code : str, optional\n    A string of valid C++ code declaring extra code that might be needed by your compiled function.  This could be declarations of functions, classes, or structures. \nheaders : [str], optional\n    A list of strings specifying header files to use when compiling the code.  The list might look like ["<vector>","'my_header'"]. Note that the header strings need to be in a form than can be pasted at the end of a #include statement in the C++ code. \ncustomize : base_info.custom_info, optional\n    An alternative way to specify support_code, headers, etc. needed by the function.  See scipy.weave.base_info for more details. (not sure this’ll be used much). \ntype_converters : [type converters], optional\n    These guys are what convert Python data types to C/C++ data types. If you’d like to use a different set of type conversions than the default, specify them here. Look in the type conversions section of the main documentation for examples. \nauto_downcast : {1,0}, optional\n    This only affects functions that have numpy arrays as input variables.  Setting this to 1 will cause all floating point values to be cast as float instead of double if all the Numeric arrays are of type float.  If even one of the arrays has type double or double complex, all variables maintain their standard types. \nnewarr_converter : int, optional\n    Unused.</code></pre></section>	https://docs.scipy.org/doc/scipy/reference/generated/scipy.weave.inline.html
scipy weave inline	R	scipy.weave.inline										
scipy weave.inline	R	scipy.weave.inline										
