comment	A										<section class="prog__container"><p>Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>/*</code> <i>comment</i> <code>*/</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>//</code> <i>comment</i>\\n</td><td> (2)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) Often known as "C-style" or "multi-line" comments.</ul><ul>2) Often known as "C++-style" or "single-line" comments.</ul><p>All comments are removed from the program at translation phase 3 by replacing each comment with a single whitespace character.</p><h3><span class="prog__sub">C-style</span></h3><p>C-style comments are usually used to comment large blocks of text or small fragments of code; however, they can be used to comment single lines. To insert text as a C-style comment, simply surround the text with <code>/*</code> and <code>*/</code>. C-style comments tell the compiler to ignore all content between <code>/*</code> and <code>*/</code>. Although it is not part of the C standard, <code>/**</code> and <code>*/</code> are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment.</p><p>Except within a character constant, a string literal, or a comment, the characters <code>/*</code> introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters <code>*/</code> that terminate the comment. C-style comments cannot be nested.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><h3><span class="prog__sub"> C++-style</span></h3><p>C++-style comments are usually used to comment single lines of text or code; however, they can be placed together to form multi-line comments. To insert text as a C++-style comment, simply precede the text with <code>//</code> and follow the text with the new line character. C++-style comments tell the compiler to ignore all content between <code>//</code> and a new line.</p><p>Except within a character constant, a string literal, or a comment, the characters <code>//</code>introduce a comment that includes all multibyte characters up to, but not including, the next new-line character. The contents of such a comment are examined only to identifymultibyte characters and to find the new-line character that terminates the comment. C++-style comments can be nested:</p><pre><code>//  y = f(x);   // invoke algorithm</code></pre><p>A C-style comment may appear within a C++-style comment:<br></p><pre><code>//  y = f(x);   /* invoke algorithm */</code></pre><p>A C++-style comment may appear within a C-style comment; this is a mechanism for excluding a small block of source code:<br></p><pre><code>/*<br>    y = f(x);   // invoke algorithms<br>    z = g(x);<br>*/</code></pre></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/comment.html
header	A										<section class="prog__container"><table class="t-dsc-begin"><tr class="t-dsc"><td> <code><assert.h></code></td><td> Conditionally compiled macro that compares its argument to zero</td></tr><tr class="t-dsc"><td> <code><complex.h></code> </td><td> Complex number arithmetic</td></tr><tr class="t-dsc"><td> <code><ctype.h></code></td><td> Functions to determine the type contained in character data</td></tr><tr class="t-dsc"><td> <code><errno.h></code></td><td> Macros reporting error conditions</td></tr><tr class="t-dsc"><td> <code><fenv.h></code> </td><td> Floating-point environment</td></tr><tr class="t-dsc"><td> <code><float.h></code></td><td> Limits of float types</td></tr><tr class="t-dsc"><td> <code><inttypes.h></code> </td><td> Format conversion of integer types</td></tr><tr class="t-dsc"><td> <code><iso646.h></code> </td><td>  Alternative operator spellings</td></tr><tr class="t-dsc"><td> <code><limits.h></code></td><td> Sizes of basic types</td></tr><tr class="t-dsc"><td> <code><locale.h></code></td><td> Localization utilities</td></tr><tr class="t-dsc"><td> <code><math.h></code></td><td> Common mathematics functions</td></tr><tr class="t-dsc"><td> <code><setjmp.h></code></td><td> Nonlocal jumps</td></tr><tr class="t-dsc"><td> <code><signal.h></code></td><td> Signal handling</td></tr><tr class="t-dsc"><td> <code><stdalign.h></code> </td><td> alignas and alignof convenience macros</td></tr><tr class="t-dsc"><td> <code><stdarg.h></code></td><td> Variable arguments</td></tr><tr class="t-dsc"><td> <code><stdatomic.h></code> </td><td> Atomic types</td></tr><tr class="t-dsc"><td> <code><stdbool.h></code> </td><td> Boolean type</td></tr><tr class="t-dsc"><td> <code><stddef.h></code></td><td> Common macro definitions</td></tr><tr class="t-dsc"><td> <code><stdint.h></code> </td><td> Fixed-width integer types</td></tr><tr class="t-dsc"><td> <code><stdio.h></code></td><td> Input/output</td></tr><tr class="t-dsc"><td> <code><stdlib.h></code></td><td> General utilities: memory management, program utilities, string conversions, random numbers</td></tr><tr class="t-dsc"><td> <code><stdnoreturn.h></code> </td><td> noreturn convenience macros</td></tr><tr class="t-dsc"><td> <code><string.h></code></td><td> String handling</td></tr><tr class="t-dsc"><td> <code><tgmath.h></code> </td><td> Type-generic math (macros wrapping math.h and complex.h)</td></tr><tr class="t-dsc"><td> <code><threads.h></code> </td><td> Thread library</td></tr><tr class="t-dsc"><td> <code><time.h></code></td><td> Time/date utilities</td></tr><tr class="t-dsc"><td> <code><uchar.h></code> </td><td> UTF-16 and UTF-32 character utilities</td></tr><tr class="t-dsc"><td> <code><wchar.h></code> </td><td> Extended multibyte and wide character utilities</td></tr><tr class="t-dsc"><td> <code><wctype.h></code> </td><td> Wide character classification and mapping utilities</td></tr></table><p><br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/header.html
language.1	A										<section class="prog__container"><p>This is a reference of the core C language constructs.<br></p><table cellpadding="5"><tr valign="top"><td><p><b> Basic concepts</b></p><p> Comments<br> ASCII chart<br> Translation phases<br> identifier  - scope - lifetime<br> lookup and name spaces<br> type -  arithmetic types<br> objects and alignment <br> The <code>main</code> function<br> Memory model and data races<br></p><p><b> Keywords</b></p><p><b> Preprocessor</b></p><p> #if - #ifdef - #ifndef<br> #define - # - ##<br> #include - #pragma<br> #line - #error<br></p><p><b> Statements</b></p><p> <code>if</code> - <code>switch</code><br> <code>for</code><br> <code>while</code> -  <code>do</code>-<code>while</code><br> <code>continue</code> - <code>break</code><br> <code>goto</code> - <code>return</code><br></p></td><td><p><b> Expressions</b></p><p> Value categories<br> Evaluation order and sequencing<br> Constants and literals<br>  integer constants<br>  floating constants<br>  character constants<br>  string literals<br>  compound literals<br> Constant expressions<br> Implicit conversions <br>Operators<br>  member access and indirection<br>  logical - comparison<br>  arithmetic - assignment<br>  increment and decrement<br>  call, comma, ternary<br>  <code>sizeof</code> - <code>alignof</code><br>  cast operators<br> Operator precedence<br> Generic selection<br></p><p><b> Initialization</b></p><p> scalar<br> array<br> structure/union <br></p></td><td><p><b> Declarations</b></p><p> Pointers - Arrays<br> Enumerations<br> Storage duration and linkage <br>const - volatile - restrict<br> struct  -  union - bit fields<br> <code>alignas</code> - <code>typedef</code><br> static_assert<br> Atomic types<br> External and tentative definitions<br></p><p><b> Functions</b></p><p> Function declaration<br> Function definition<br>inline - noreturn<br> Variadic arguments<br></p><p><b>Miscellaneous</b></p><p> History of C<br> Conformance<br> Undefined behavior<br> Inline assembly<br> As-if rule<br> signal handling <br> Analyzability<br></p><br/><p><br></p></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language.1.html
bsearch	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>void* bsearch( const void *key, const void *ptr, size_t count, size_t size,<br>               int (*comp)(const void*, const void*) );<br></code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>void* bsearch_s( const void *key, const void *ptr, rsize_t count, rsize_t size,<br>                 int (*comp)(const void *, const void *, void *),<br>                 void *context );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Finds an element equal to element pointed to by <code>key</code> in an array pointed to by <code>ptr</code>. The array contains <code>count</code> elements of <code>size</code> bytes and must be partitioned with respect to <code>key</code>, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by <code>comp</code>. The behavior is undefined if the array is not already partitioned with respect to <code>*key</code> in ascending order according to the same criterion that <code>comp</code> uses.</ul><ul>2) Same as (1), except that the additional context argument <code>context</code> is passed to <code>comp</code> and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>count</code> or <code>size</code> is greater than <code>RSIZE_MAX</code></li><li> <code>key</code>, <code>ptr</code> or <code>comp</code> is a null pointer (unless <code>count</code> is zero)</li></ul></dd><dd>As with all bounds-checked functions, <code>bsearch_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></ul><p>If the array contains several elements that <code>comp</code> would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  key</td><td> -</td><td>  pointer to the element to search for</td></tr><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to the array to examine</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of element in the array</td></tr><tr class="t-par"><td>  size</td><td> -</td><td>  size of each element in the array in bytes</td></tr><tr class="t-par"><td>   comp</td><td> -</td><td>  comparison function which returns ​a negative integer value if the first argument is <i>less</i> than the second, <br><p>a positive integer value if the first argument is <i>greater</i> than the second and zero if the arguments are equal. <code>key</code> is passed as the first argument, an element from the array as the second.<br>The signature of the comparison function should be equivalent to the following:<br></p><p><code> int cmp(const void *a, const void *b);</code></p><p>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.<br></p><p>​<br></p><br></td></tr><tr class="t-par"><td>  context</td><td> -</td><td>  additional information (e.g., collating sequence), passed to <code>comp</code> as the third argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) Pointer to an element in the array that compares equal to <code>*key</code>, or null pointer if such element has not been found.</ul><ul>2) Same as (1), except that the null pointer is also returned on runtime constraints violations.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/algorithm/bsearch.html
qsort	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>void qsort( void *ptr, size_t count, size_t size,<br>            int (*comp)(const void *, const void *) );<br></code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t qsort_s( void *ptr, rsize_t count, rsize_t size,<br>                 int (*comp)(const void *, const void *, void *),<br>                 void *context );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Sorts the given array pointed to by <code>ptr</code> in ascending order. The array contains <code>count</code> elements of <code>size</code> bytes. Function pointed to by <code>comp</code> is used for object comparison. </ul><ul>2) Same as (1), except that the additional context parameter <code>context</code> is passed to <code>comp</code> and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>count</code> or <code>size</code> is greater than <code>RSIZE_MAX</code></li><li> <code>ptr</code> or <code>comp</code> is a null pointer (unless <code>count</code> is zero)</li></ul></dd><dd>As with all bounds-checked functions, <code>qsort_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></ul><p>If <code>comp</code> indicates two elements as equivalent, their order in the resulting sorted array is undefined.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to the array to sort</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of element in the array</td></tr><tr class="t-par"><td>  size</td><td> -</td><td>  size of each element in the array in bytes</td></tr><tr class="t-par"><td>   comp</td><td> -</td><td>  comparison function which returns ​a negative integer value if the first argument is <i>less</i> than the second, <br><p>a positive integer value if the first argument is <i>greater</i> than the second and zero if the arguments are equal.<br>The signature of the comparison function should be equivalent to the following:<br></p><p><code> int cmp(const void *a, const void *b);</code></p><p>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.<br></p><p>​<br></p><br></td></tr><tr class="t-par"><td>  context</td><td> -</td><td>  additional information (e.g., collating sequence), passed to <code>comp</code> as the third argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) (none)</ul><ul>2) zero on success, non-zero if a runtime constraints violation was detected</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/algorithm/qsort.html
atomic_compare_exchange	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>_Bool atomic_compare_exchange_strong( volatile A* obj,<br>                                      C* expected, C desired );<br></code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>_Bool atomic_compare_exchange_weak( volatile A *obj, <br>                                    C* expected, C desired );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>_Bool atomic_compare_exchange_strong_explicit( volatile A* obj, <br>                                               C* expected, C desired,<br>                                               memory_order succ, <br>                                               memory_order fail );<br></code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>_Bool atomic_compare_exchange_weak_explicit( volatile A *obj, <br>                                             C* expected, C desired,<br>                                             memory_order succ, <br>                                             memory_order fail );<br></code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically compares the value pointed to by <code>obj</code> with the value pointed to by <code>expected</code>, and if those are equal, replaces the former with <code>desired</code> (performs read-modify-write operation). Otherwise, loads the actual value pointed to by <code>obj</code> into <code>*expected</code> (performs load operation).</p><p>The memory models for the read-modify-write and load operations are <code>succ</code> and <code>fail</code> respectively. The (1-2) versions use <code>memory_order_seq_cst</code> by default.</p><p>The weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if <code>*obj != *expected</code> even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to test and modify</td></tr><tr class="t-par"><td>  expected</td><td> -</td><td>  pointer to the value expected to be found in the atomic object</td></tr><tr class="t-par"><td>  desired</td><td> -</td><td>  the value to store in the atomic object if it is as expected</td></tr><tr class="t-par"><td>  succ</td><td> -</td><td>  the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted.</td></tr><tr class="t-par"><td>  fail</td><td> -</td><td>  the memory synchronization ordering for the load operation if the comparison fails. Cannot be <code>memory_order_release</code> or <code>memory_order_acq_rel</code> and cannot specify stronger ordering than <code>succ</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The result of the comparison: <code>true</code> if <code>*obj</code> was equal to <code>*exp</code>, <code>false</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_compare_exchange.html
atomic_exchange	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_exchange( volatile A* obj, C desired );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_exchange_explicit( volatile A* obj, C desired, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with <code>desired</code> and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>. </p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>..</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr class="t-par"><td>  desired</td><td> -</td><td>  the value to replace the atomic object with</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_exchange.html
atomic_fetch_add	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_add( volatile A* obj, M arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_add_explicit( volatile A* obj, M arg, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of addition of <code>arg</code> to the old value of <code>obj</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <code>ptrdiff_t</code> if <code>A</code> is atomic pointer type.</p><p>For signed integer types, arithmetic is defined to use two’s complement representation. There<br>are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr class="t-par"><td>  arg</td><td> -</td><td>  the value to add to the value stored in the atomic object</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_add.html
atomic_fetch_and	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_and( volatile A* obj, M arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_and_explicit( volatile A* obj, M arg, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of bitwise AND between the old value of <code>obj</code> and <code>arg</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <code>ptrdiff_t</code> if <code>A</code> is atomic pointer type.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr class="t-par"><td>  arg</td><td> -</td><td>  the value to bitwise AND to the value stored in the atomic object</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory sycnhronization ordering for this operation: all values are permitted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_and.html
atomic_fetch_or	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_or( volatile A* obj, M arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_or_explicit( volatile A* obj, M arg, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of bitwise OR between the old value of <code>obj</code> and <code>arg</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <code>ptrdiff_t</code> if <code>A</code> is atomic pointer type.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr class="t-par"><td>  arg</td><td> -</td><td>  the value to bitwise OR to the value stored in the atomic object</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_or.html
atomic_fetch_sub	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_sub( volatile A* obj, M arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_sub_explicit( volatile A* obj, M arg, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of subtraction of <code>arg</code> from the old value of <code>obj</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <code>ptrdiff_t</code> if <code>A</code> is atomic pointer type.</p><p>For signed integer types, arithmetic is defined to use two’s complement representation. There<br>are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr class="t-par"><td>  arg</td><td> -</td><td>  the value to subtract from the value stored in the atomic object</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The value held previously by the atomic object pointed to by <code>obj</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_sub.html
atomic_fetch_xor	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_xor( volatile A* obj, M arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_fetch_xor_explicit( volatile A* obj, M arg, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of bitwise XOR between the old value of <code>obj</code> and <code>arg</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <code>ptrdiff_t</code> if <code>A</code> is atomic pointer type.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr class="t-par"><td>  arg</td><td> -</td><td>  the value to bitwise XOR to the value stored in the atomic object</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_xor.html
atomic_flag	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>struct atomic_flag;</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><code>atomic_flag</code> is an atomic boolean type. Unlike other atomic types, it is guaranteed to be lock-free. Unlike <code>atomic_bool</code>, <code>atomic_flag</code> does not provide load or store operations.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_flag.html
atomic_flag_clear	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void atomic_flag_clear( volatile atomic_flag* obj );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>void atomic_flag_clear_explicit( volatile atomic_flag* obj, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically changes the state of a <code>atomic_flag</code> pointed to by <code>obj</code> to clear (<code>false</code>). The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>.</p><p>The argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic flags.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic flag object to modify</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_flag_clear.html
ATOMIC_FLAG_INIT	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>#define ATOMIC_FLAG_INIT /* unspecified */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Expands to an expression that can be used to initialize <code>atomic_flag</code> type. The value <code>atomic_flag</code> that is not initialized using this macro is undefined.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/ATOMIC_FLAG_INIT.html
atomic_flag_test_and_set	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>_Bool atomic_flag_test_and_set( volatile atomic_flag* obj );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>_Bool atomic_flag_test_and_set_explicit( volatile atomic_flag* obj, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically changes the state of a <code>atomic_flag</code> pointed to by <code>obj</code> to set (<code>true</code>) and returns the previous value. The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>.</p><p>The argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic flags.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic flag object to modify</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The previous value held by the atomic flag pointed to by <code>obj</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set.html
atomic_init	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void atomic_init( volatile A* obj, C desired );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Initializes the default-constructed atomic object <code>obj</code> with the value <code>desired</code>. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race. </p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to an atomic object to initialize</td></tr><tr class="t-par"><td>  desired</td><td> -</td><td>  the value to initialize atomic object with</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_init.html
atomic_is_lock_free	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>_Bool atomic_is_lock_free( const volatile A* obj );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the atomic operations on all objects of the type <code>A</code> (the type of the object pointed to by <code>obj</code>) are lock-free. In any given program execution, the result of calling <code>atomic_is_lock_free</code> is the same for all pointers of the same type.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to inspect</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>true</code> if the the operations on all objects of the type <code>A</code> are lock-free, <code>false</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_is_lock_free.html
atomic_load	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_load( const volatile A* obj );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>C atomic_load_explicit( const volatile A* obj, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically loads and returns the current value of the atomic variable pointed to by <code>obj</code>. The operation is atomic read operation. </p><p>The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>. <code>order</code> must be one of <code>memory_order_relaxed</code>, <code>memory_order_consume</code>, <code>memory_order_acquire</code> or <code>memory_order_seq_cst</code>. Otherwise the behavior is undefined.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to access</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The current value of the atomic variable pointed to by <code>obj</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_load.html
ATOMIC_LOCK_FREE_consts	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>#define ATOMIC_BOOL_LOCK_FREE     /* implementation-defined */<br>#define ATOMIC_CHAR_LOCK_FREE     /* implementation-defined */<br>#define ATOMIC_CHAR16_T_LOCK_FREE /* implementation-defined */<br>#define ATOMIC_CHAR32_T_LOCK_FREE /* implementation-defined */<br>#define ATOMIC_WCHAR_T_LOCK_FREE  /* implementation-defined */<br>#define ATOMIC_SHORT_LOCK_FREE    /* implementation-defined */<br>#define ATOMIC_INT_LOCK_FREE      /* implementation-defined */<br>#define ATOMIC_LONG_LOCK_FREE     /* implementation-defined */<br>#define ATOMIC_LLONG_LOCK_FREE    /* implementation-defined */<br>#define ATOMIC_POINTER_LOCK_FREE  /* implementation-defined */<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Expands to preprocessor constant expressions that evaluate to either <code>0</code>, <code>1</code>, or <code>2</code> which indicate the lock-free property of the corresponding atomic types (both signed and unsigned).</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Value</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>0</code></td><td>  The atomic type is never lock-free</td></tr><tr class="t-dsc"><td> <code>1</code></td><td>  The atomic type is sometimes lock-free</td></tr><tr class="t-dsc"><td> <code>2</code></td><td>  The atomic type is always lock-free</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/ATOMIC_LOCK_FREE_consts.html
atomic_signal_fence	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void atomic_signal_fence( memory_order order );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by <code>order</code>, between a thread and a signal handler executed on the same thread. This is equivalent to <code>atomic_thread_fence</code>, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as <code>order</code> instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  order</td><td> -</td><td>  the memory ordering executed by this fence</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_signal_fence.html
atomic_store	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void atomic_store( volatile A* obj , C desired);</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>void atomic_store_explicit( volatile A* obj, C desired, memory_order order );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value of the atomic variable pointed to by <code>obj</code> with <code>desired</code>. The operation is atomic write operation. </p><p>The first version orders memory accesses according to <code>memory_order_seq_cst</code>, the second version orders memory accesses according to <code>order</code>. <code>order</code> must be one of <code>memory_order_relaxed</code>, <code>memory_order_release</code> or <code>memory_order_seq_cst</code>. Otherwise the behavior is undefined.</p><p>This is a generic function defined for all atomic object types <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr class="t-par"><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_store.html
atomic_thread_fence	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void atomic_thread_fence( memory_order order );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by <code>order</code>, without an associated atomic operation. For example, all non-atomic and relaxed atomic stores that happen before a <code>memory_order_release</code> fence in thread A will be synchronized with non-atomic and relaxed atomic loads from the same locations made in thread B after an <code>memory_order_acquire</code> fence.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  order</td><td> -</td><td>  the memory ordering executed by this fence</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/atomic_thread_fence.html
ATOMIC_VAR_INIT	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>#define ATOMIC_VAR_INIT(value) /* unspecified */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Expands to an expression that can be used to initialize an atomic variable of the same type as <code>value</code>. The initial value of atomic object of automatic storage duration that is not initialized using this macro is undefined. The default (zero) initialization of static and thread-local variables produces valid value however.</p><p>If this macro is not used for initialization of an atomic variable, any accesses during initialization from another thread, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a <code>memory_order_relaxed</code> operation).</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/ATOMIC_VAR_INIT.html
kill_dependency	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>A kill_dependency(A y);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Informs the compiler that the dependency tree started by an <code>memory_order_consume</code> atomic load operation does not extend past the return value of <code>kill_dependency</code>; that is, the argument does not carry a dependency into the return value.</p><p>The function is implemented as a macro. <code>A</code> is the type of <code>y</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  y</td><td> -</td><td>  the expression whose return value is to be removed from a dependency tree</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Returns <code>y</code>, no longer a part of a dependency tree.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/kill_dependency.html
memory_order	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdatomic.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>enum memory_order {<br>    memory_order_relaxed,<br>    memory_order_consume,<br>    memory_order_acquire,<br>    memory_order_release,<br>    memory_order_acq_rel,<br>    memory_order_seq_cst<br>};<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><code>memory_order</code> specifies how regular, non-atomic memory accesses are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.</p><p>The default behavior of all atomic operations in the language and the library provides for <i>sequentially consistent ordering</i> (see discussion below). That default can hurt performance, but the library's atomic operations can be given an additional <code>memory_order</code> argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.</p><h3><span class="prog__sub">Constants</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdatomic.h></code> </td></tr><tr class="t-dsc-hitem"><td>  Value</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>memory_order_relaxed</code></td><td>  Relaxed operation: there are no synchronization or ordering constraints, only atomicity is required of this operation (see Relaxed ordering below)</td></tr><tr class="t-dsc"><td> <code>memory_order_consume</code></td><td>  A load operation with this memory order performs a <i>consume operation</i> on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see Release-Consume ordering below)</td></tr><tr class="t-dsc"><td> <code>memory_order_acquire</code></td><td>  A load operation with this memory order performs the <i>acquire operation</i> on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)</td></tr><tr class="t-dsc"><td> <code>memory_order_release</code></td><td>  A store operation with this memory order performs the <i>release operation</i>: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see Release-Consume ordering below).</td></tr><tr class="t-dsc"><td> <code>memory_order_acq_rel</code></td><td>  A read-modify-write operation with this memory order is both an <i>acquire operation</i> and a <i>release operation</i>. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</td></tr><tr class="t-dsc"><td> <code>memory_order_seq_cst</code></td><td>  Any operation with this memory order is both an <i>acquire operation</i> and a <i>release operation</i>, plus a single total order exists in which all threads observe all modifications in the same order (see Sequentially-consistent ordering below)</td></tr></table><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: happens-before and other concepts, as in C++, but keep modification orders and the four consistencies in c/language/atomic <br></td></tr></table><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: when doing above, don't forget that although happens-before wasn't acyclic in C11 as published, this was updated to match C++11 via DR 401 <br></td></tr></table><h4>Relaxed ordering</h4><p>Atomic operations tagged <code>memory_order_relaxed</code> are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</p><p>For example, with <code>x</code> and <code>y</code> initially zero,</p><p><code>// Thread 1:<br>r1 = atomic_load_explicit(y, memory_order_relaxed); // A<br>atomic_store_explicit(x, r1, memory_order_relaxed); // B<br>// Thread 2:<br>r2 = atomic_load_explicit(x, memory_order_relaxed); // C<br>atomic_store_explicit(y, 42, memory_order_relaxed); // D<br></code></p><p>is allowed to produce <code>r1 == r2 == 42</code> because, although A is <i>sequenced-before</i> B within thread 1 and C is <i>sequenced before</i> D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in Thread 1  while the side effect of B on x could be visible to the load C in Thread 2.</p><p><br></p><p>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters , since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor)<br></p><h4>Release-Consume ordering</h4><p>If an atomic store in thread A is tagged <code>memory_order_release</code> and an atomic load in thread B from the same variable is tagged <code>memory_order_consume</code>, all memory writes (non-atomic and relaxed atomic) that are <i>dependency-ordered-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> within those operations in thread B into which the load operation <i>carries dependency</i>, that is, once the atomic load is completed, those operators and functions in thread B that use the value obtained from the load are guaranteed to see what thread A wrote to memory.</p><p>The synchronization is established only between the threads <i>releasing</i> and <i>consuming</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.</p><p>On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain). <br></p><p>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is rcu_dereference.</p><p><br></p><p>Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.<br></p><h4>Release sequence</h4><p>If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a "release sequence" is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no <code>memory_order_release</code> semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.</p><h4>Release-Acquire ordering</h4><p>If an atomic store in thread A is tagged <code>memory_order_release</code> and an atomic load in thread B from the same variable is tagged <code>memory_order_acquire</code>, all memory writes (non-atomic and relaxed atomic) that <i>happened-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> in thread B, that is, once the atomic load is completed, thread B is guaranteed to see everything thread A wrote to memory.</p><p>The synchronization is established only between the threads <i>releasing</i> and <i>acquiring</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.</p><p>On strongly-ordered systems (x86, SPARC TSO, IBM mainframe), release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from moving non-atomic stores past the atomic store-release or perform non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions have to be used.<br></p><p>Mutual exclusion locks (such as mutexes or atomic spinlock) are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.</p><h4>Sequentially-consistent ordering</h4><p>Atomic operations tagged <code>memory_order_seq_cst</code> not only order memory the same way as release/acquire ordering (everything that <i>happened-before</i> a store in one thread becomes a <i>visible side effect</i> in the thread that did a load), but also establish a <i>single total modification order</i> of all atomic operations that are so tagged.</p><p>Formally,<br></p><p>Each <code>memory_order_seq_cst</code> operation B that loads from atomic variable M, observes one of the following:</p><ul><li> the result of the last operation A that modified M, which appears before B in the single total order</li><li> OR, if there was such an A, B may observe the result of some modification on M that is not <code>memory_order_seq_cst</code> and does not <i>happen-before</i> A</li><li> OR, if there wasn't such an A, B may observe the result of some unrelated modification of M that is not <code>memory_order_seq_cst</code></li></ul><p>If there was a <code>memory_order_seq_cst</code> <code>atomic_thread_fence</code> operation X <i>sequenced-before</i> B, then B observes one of the following:</p><ul><li> the last <code>memory_order_seq_cst</code> modification of M that appears before X in the single total order</li><li> some unrelated modification of M that appears later in M's modification order</li></ul><p>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two <code>memory_order_seq_cst</code> <code>atomic_thread_fence</code>s X and Y, and if A is <i>sequenced-before</i> X, Y is <i>sequenced-before</i> B, and X appears before Y in the Single Total Order, then B observes either:</p><ul><li> the effect of A</li><li> some unrelated modification of M that appears after A in M's modification order</li></ul><p>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if <br></p><ul><li> there is a <code>memory_order_seq_cst</code> <code>atomic_thread_fence</code> X such that A is <i>sequenced-before</i> X and X appears before B in the Single Total Order</li><li> or, there is a <code>memory_order_seq_cst</code> <code>atomic_thread_fence</code> Y such that Y is <i>sequenced-before</i> B and A appears before Y in the Single Total Order</li><li> or, there are <code>memory_order_seq_cst</code> <code>atomic_thread_fence</code>s X and Y such that A is <i>sequenced-before</i> X, Y is <i>sequenced-before</i> B, and X appears before Y in the Single Total Order.</li></ul><p>Note that this means that:<br></p><ul>1) as soon as atomic operations that are not tagged <code>memory_order_seq_cst</code> enter the picture, the sequential consistency is lost</ul><ul>2) the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (<i>sequenced-before</i> is not a cross-thread relationship, unlike <i>happens-before</i>)</ul><p>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.<br></p><p>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.<br></p><h3><span class="prog__sub">Relationship with volatile</span></h3><p>Within a thread of execution, accesses (reads and writes) to volatile objects cannot be reordered past observable side-effects (including other volatile accesses) that are separated by a sequence point within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.</p><p>In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</p><p>One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (MSDN), and thus volatiles may be used for inter-thread synchronization. Standard <code>volatile</code> semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a <code>signal</code> handler that runs in the same thread when applied to <code>sig_atomic_t</code> variables.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/atomic/memory_order.html
asctime	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>char* asctime( const struct tm* time_ptr );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t asctime_s(char *buf, rsize_t bufsz, const struct tm *time_ptr);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts given calendar time <code>tm</code> to a textual representation of the following fixed 25-character form: <code>Www Mmm dd hh:mm:ss yyyy\\n</code><ul><li><code>Www</code> - three-letter English abbreviated day of the week from <code>time_ptr->tm_wday</code>, one of <code>Mon</code>, <code>Tue</code>, <code>Wed</code>, <code>Thu</code>, <code>Fri</code>, <code>Sat</code>, <code>Sun</code>.</li><li><code>Mmm</code> - three-letter English abbreviated month name from <code>time_ptr->tm_mon</code>, one of <code>Jan</code>, <code>Feb</code>, <code>Mar</code>, <code>Apr</code>, <code>May</code>, <code>Jun</code>, <code>Jul</code>, <code>Aug</code>, <code>Sep</code>, <code>Oct</code>, <code>Nov</code>, <code>Dec</code>.</li><li><code>dd</code> - 2-digit day of the month from <code>timeptr->tm_mday</code> as if printed by <code>sprintf</code> using <code>%2d</code></li><li><code>hh</code> - 2-digit hour from <code>timeptr->tm_hour</code> as if printed by <code>sprintf</code> using <code>%.2d</code></li><li><code>mm</code> - 2-digit minute from <code>timeptr->tm_min</code> as if printed by <code>sprintf</code> using <code>%.2d</code></li><li><code>ss</code> - 2-digit second from <code>timeptr->tm_sec</code> as if printed by <code>sprintf</code> using <code>%.2d</code></li><li><code>yyyy</code> - 4-digit year from <code>timeptr->tm_year + 1900</code> as if printed by <code>sprintf</code> using <code>%4d</code></li></ul></ul><ul> The behavior is undefined if any member of <code>*time_ptr</code> is outside its normal range</ul><ul> The behavior is undefined if the calendar year indicated by <code>time_ptr->tm_year</code> has more than 4 digits or is less than the year 1000.</ul><ul> The function does not support localization, and the newline character cannot be removed.</ul><ul> The function modifies static storage and is not thread-safe.</ul><ul>2) Same as (1), except that the message is copied into user-provided storage <code>buf</code>, which is guaranteed to be null-terminated, and the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>buf</code> or <code>time_ptr</code> is a null pointer</li><li> <code>bufsz</code> is less than 26 or greater than <code>RSIZE_MAX</code></li><li> not all members of <code>*time_ptr</code> are within their normal ranges</li><li> the year indicated by <code>time_ptr->tm_year</code> is less than 0 or greater than 9999</li></ul></dd><dd>As all bounds-checked functions, <code>asctime_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>time.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  time_ptr</td><td> -</td><td>  pointer to a <code>tm</code> object specifying the time to print</td></tr><tr class="t-par"><td>  buf</td><td> -</td><td>  pointer to a user-supplied buffer at least 26 bytes in length</td></tr><tr class="t-par"><td>  bufsz</td><td> -</td><td>  size of the user-supplied buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) pointer to a static null-terminated character string holding the textual representation of date and time as described above. The string may be shared between <code>asctime</code> and <code>ctime</code>, and may be overwritten on each invocation of any of those functions.</ul><ul>2) zero on success, non-zero on failure, in which case <code>buf[0]</code> is set to zero (unless <code>buf</code> is a null pointer or <code>bufsz</code> is zero or greater than <code>RSIZE_MAX</code>).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/asctime.html
clock	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>clock_t clock(void);</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds, divide it by <code>CLOCKS_PER_SEC</code>. </p><p>Only the difference between two values returned by different calls to <code>clock</code> is meaningful, as the beginning of the <code>clock</code> era does not have to coincide with the start of the program. <code>clock</code> time may advance faster or slower than the wall clock, depending on the execution resources given to the program by the operating system. For example, if the CPU is shared by other processes, <code>clock</code> time may advance slower than wall clock. On the other hand, if the current process is multithreaded and more than one execution core is available, <code>clock</code> time may advance faster than wall clock.</p><h3><span class="prog__sub">Parameters</span></h3><p>(none)<br></p><h3><span class="prog__sub">Return value</span></h3><p>Processor time used by the program so far or <code>(clock_t)(-1)</code> if that information is unavailable or its value cannot be represented.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/clock.html
clock_t	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>typedef /* unspecified */ clock_t;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><span>Arithmetic</span> <span></span><span>Real</span> <span></span> type capable of representing the processor time used by a process. It has implementation-defined range and precision.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/clock_t.html
CLOCKS_PER_SEC	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define CLOCKS_PER_SEC /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Expands to an expression (not necessarily a compile-time constant) of type <code>clock_t</code> equal to the number of clock ticks per second, as returned by <code>clock()</code>. </p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/CLOCKS_PER_SEC.html
ctime	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>char* ctime( const time_t* time );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td> <code>errno_t ctime_s(char *buffer, rsize_t bufsz, const time_t *time);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts given time since epoch to a calendar local time and then to a textual representation, as if by calling <code>asctime(localtime(time))</code>.</ul><ul>2) Same as (1), except that the function is equivalent to <code>asctime_s(buffer, bufsz, localtime_s(time, &amp;(struct tm){0}))</code>, and the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>buffer</code> or <code>time</code> is a null pointer</li><li> <code>bufsz</code> is less than <code>26</code> or greater than <code>RSIZE_MAX</code></li></ul></dd><dd>As with all bounds-checked functions, <code>ctime_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>time.h</code>.</dd></dl></ul><p>The resulting string has the following format:<br></p><pre><code>Www Mmm dd hh:mm:ss yyyy\\n</code></pre><ul><li><code>Www</code> - the day of the week (one of <code>Mon</code>, <code>Tue</code>, <code>Wed</code>, <code>Thu</code>, <code>Fri</code>, <code>Sat</code>, <code>Sun</code>).</li><li><code>Mmm</code> - the month (one of <code>Jan</code>, <code>Feb</code>, <code>Mar</code>, <code>Apr</code>, <code>May</code>, <code>Jun</code>, <code>Jul</code>, <code>Aug</code>, <code>Sep</code>, <code>Oct</code>, <code>Nov</code>, <code>Dec</code>).</li><li><code>dd</code> - the day of the month</li><li><code>hh</code> - hours</li><li><code>mm</code> - minutes</li><li><code>ss</code> - seconds </li><li><code>yyyy</code> - years</li></ul><p>The function does not support localization.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  time</td><td> -</td><td>  pointer to a <code>time_t</code> object specifying the time to print</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to an element of a char array of size at least <code>bufsz</code></td></tr><tr class="t-par"><td>  bufsz</td><td> -</td><td>  max number of bytes to output, typically the size of the buffer pointed to by <code>buffer</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) pointer to a static null-terminated character string holding the textual representation of date and time. The string may be shared between <code>asctime</code> and <code>ctime</code>, and may be overwritten on each invocation of any of those functions.</ul><ul>2) zero on success (in which case the string representatino of time has been written out to the array pointed to by <code>buffer</code>), or non-zero on failure (in which case, the terminating null character is always written to <code>buffer[0]</code> unless <code>buffer</code> is a null pointer or <code>bufsz</code> is zero or greater than RSIZE_MAX.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/ctime.html
difftime	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>double difftime( time_t time_end, time_t time_beg );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Computes difference between two calendar times as <code>time_t</code> objects (<code>time_end - time_beg</code>) in seconds. If <code>time_end</code> refers to time point before <code>time_beg</code> then the result is negative.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  time_beg, time_end</td><td> -</td><td>  times to compare</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Difference between two times in seconds.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/difftime.html
gmtime	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>struct tm *gmtime( const time_t *time );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>struct tm *gmtime_s(const time_t *restrict time, struct tm *restrict result);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts given time since epoch (a <code>time_t</code> value pointed to by <code>time</code>) into calendar time, expressed in Coordinated Universal Time (UTC) in the struct tm format. The result is stored in static storage and a pointer to that static storage is returned.</ul><ul>2) Same as (1), except that the function uses user-provided storage <code>result</code> for the result and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>time</code> or <code>result</code> is a null pointer</li></ul></dd><dd>As with all bounds-checked functions, <code>gmtime_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>time.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  time</td><td> -</td><td>  pointer to a time_t object to convert</td></tr><tr class="t-par"><td>  result</td><td> -</td><td>  pointer to a struct tm object to store the result</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) pointer to a static internal <code>tm</code> object on success, or null pointer otherwise. The structure may be shared between <code>gmtime</code>, <code>localtime</code>, and <code>ctime</code> and may be overwritten on each invocation.</ul><ul>2) copy of the <code>result</code> pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to UTC)</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/gmtime.html
localtime	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>struct tm *localtime( const time_t *time );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>struct tm *localtime_s(const time_t *restrict time, struct tm *restrict result);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts given time since epoch (a <code>time_t</code> value pointed to by <code>time</code>) into calendar time, expressed in local time, in the struct tm format. The result is stored in static storage and a pointer to that static storage is returned.</ul><ul>2) Same as (1), except that the function uses user-provided storage <code>result</code> for the result and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>time</code> or <code>result</code> is a null pointer</li></ul></dd><dd>As with all bounds-checked functions, <code>localtime_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>time.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  time</td><td> -</td><td>  pointer to a <code>time_t</code> object to convert</td></tr><tr class="t-par"><td>  result</td><td> -</td><td>  pointer to a struct tm object to store the result</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) pointer to a static internal <code>tm</code> object on success, or null pointer otherwise. The structure may be shared between <code>gmtime</code>, <code>localtime</code>, and <code>ctime</code> and may be overwritten on each invocation.</ul><ul>2) copy of the <code>result</code> pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to local calendar time)</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/localtime.html
mktime	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>time_t mktime( struct tm *time );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Renormalizes local calendar time expressed as a <code>struct tm</code> object and also converts it to time since epoch as a <code>time_t</code> object. <code>time->tm_wday</code> and <code>time->tm_yday</code> are ignored. The values in <code>time</code> are not checked for being out of range.</p><p>A negative value of <code>time->tm_isdst</code> causes <code>mktime</code> to attempt to determine if Daylight Saving Time was in effect in the specified time.</p><p>If the conversion to <code>time_t</code> is successful, the <code>time</code> object is modified. All fields of <code>time</code> are updated to fit their proper ranges. <code>time->tm_wday</code> and <code>time->tm_yday</code> are recalculated using information available in other fields.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  time</td><td> -</td><td>  pointer to a <code>tm</code> object specifying local calendar time to convert</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>time since epoch as a <code>time_t</code> object on success or <code>-1</code> if <code>time</code> cannot be represented as a <code>time_t</code> object (POSIX also requires <code>EOVERFLOW</code> to be stored in <code>errno</code> in this case).</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/mktime.html
strftime	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>size_t strftime( char *         str, size_t count, <br>                 const char *         format, const struct tm *         time );<br></code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>size_t strftime( char *restrict str, size_t count, <br>                 const char *restrict format, const struct tm *restrict time );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts the date and time information from a given calendar time <code>time</code> to a null-terminated multibyte character string <code>str</code> according to format string <code>format</code>. Up to <code>count</code> bytes are written.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the first element of the char array for output</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of bytes to write</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated multibyte character string specifying the format of conversion.<p>The format string consists of zero or more conversion specifiers and ordinary characters (except <code>%</code>). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with <code>%</code> character, optionally followed by <code>E</code> or <code>O</code> modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</p><table class="wikitable" style="font-size:85%; max-width:90em;"><tr><th> Conversion<br> specifier<br></th><th> Explanation</th><th> Used fields</th></tr><tr><th> <code>%</code></th><td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td></td></tr><tr><th> <code>n</code><br></th><td> writes newline character</td><td></td></tr><tr><th> <code>t</code><br></th><td> writes horizontal tab character</td><td></td></tr><tr><th colspan="3"> Year</th></tr><tr><th> <code>Y</code></th><td> writes <b>year</b> as a decimal number, e.g. 2017</td><td> <code>tm_year</code></td></tr><tr><th> <code>EY</code><br></th><td> writes <b>year</b> in the alternative representation, e.g.平成23年 (year Heisei 23) instead of 2011年 (year 2011) in ja_JP locale</td><td> <code>tm_year</code></td></tr><tr><th> <code>y</code></th><td> writes last 2 digits of <b>year</b> as a decimal number (range <code>[00,99]</code>)</td><td> <code>tm_year</code></td></tr><tr><th> <code>Oy</code><br></th><td> writes last 2 digits of <b>year</b> using the alternative numeric system, e.g. 十一 instead of 11 in ja_JP locale</td><td> <code>tm_year</code></td></tr><tr><th> <code>Ey</code><br></th><td> writes <b>year</b> as offset from locale's alternative calendar period <code>%EC</code> (locale-dependent)</td><td> <code>tm_year</code></td></tr><tr><th> <code>C</code><br></th><td> writes first 2 digits of <b>year</b> as a decimal number (range <code>[00,99]</code>)</td><td> <code>tm_year</code></td></tr><tr><th> <code>EC</code><br></th><td> writes name of the <b>base year (period)</b> in the locale's alternative representation, e.g. 平成 (Heisei era) in ja_JP</td><td> <code>tm_year</code></td></tr><tr><th> <code>G</code><br></th><td> writes <b>ISO 8601 week-based year</b>, i.e. the year that contains the specified week.<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year</li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>g</code><br></th><td> writes last 2 digits of <b>ISO 8601 week-based year</b>, i.e. the year that contains the specified week (range <code>[00,99]</code>).<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year </li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th colspan="3"> Month</th></tr><tr><th> <code>b</code></th><td> writes <b>abbreviated month</b> name, e.g. <code>Oct</code> (locale dependent)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>h</code><br></th><td> synonym of <code>b</code></td><td> <code>tm_mon</code></td></tr><tr><th> <code>B</code></th><td> writes <b>full month</b> name, e.g. <code>October</code> (locale dependent)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>m</code></th><td> writes <b>month</b> as a decimal number (range <code>[01,12]</code>)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>Om</code><br></th><td> writes <b>month</b> using the alternative numeric system, e.g. 十二 instead of 12 in ja_JP locale</td><td> <code>tm_mon</code></td></tr><tr><th colspan="3"> Week</th></tr><tr><th> <code>U</code></th><td> writes <b>week of the year</b> as a decimal number (Sunday is the first day of the week) (range <code>[00,53]</code>)</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OU</code><br></th><td> writes <b>week of the year</b>, as by <code>%U</code>, using the alternative numeric system, e.g. 五十二 instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>W</code></th><td> writes <b>week of the year</b> as a decimal number (Monday is the first day of the week) (range <code>[00,53]</code>)</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OW</code><br></th><td> writes <b>week of the year</b>, as by <code>%W</code>, using the alternative numeric system, e.g. 五十二 instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>V</code><br></th><td> writes <b>ISO 8601 week of the year</b> (range <code>[01,53]</code>).<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year </li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OV</code><br></th><td> writes <b>week of the year</b>, as by <code>%V</code>, using the alternative numeric system, e.g. 五十二 instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th colspan="3"> Day of the year/month</th></tr><tr><th> <code>j</code></th><td> writes <b>day of the year</b> as a decimal number (range <code>[001,366]</code>)</td><td> <code>tm_yday</code></td></tr><tr><th> <code>d</code></th><td> writes <b>day of the month</b> as a decimal number (range <code>[01,31]</code>)</td><td> <code>tm_mday</code></td></tr><tr><th> <code>Od</code><br></th><td> writes zero-based <b>day of the month</b> using the alternative numeric system, e.g 二十七 instead of 23 in ja_JP locale<p>Single character is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th> <code>e</code><br></th><td> writes <b>day of the month</b> as a decimal number (range <code>[1,31]</code>).<p>Single digit is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th> <code>Oe</code><br></th><td> writes one-based <b>day of the month</b> using the alternative numeric system, e.g. 二十七 instead of 27 in ja_JP locale<p>Single character is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th colspan="3"> Day of the week</th></tr><tr><th> <code>a</code></th><td> writes <b>abbreviated weekday</b> name, e.g. <code>Fri</code> (locale dependent)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>A</code></th><td> writes <b>full weekday</b> name, e.g. <code>Friday</code> (locale dependent)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>w</code></th><td> writes <b>weekday</b> as a decimal number, where Sunday is <code>0</code> (range <code>[0-6]</code>)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>Ow</code><br></th><td> writes <b>weekday</b>, where Sunday is <code>0</code>, using the alternative numeric system, e.g. 二 instead of 2 in ja_JP locale</td><td> <code>tm_wday</code></td></tr><tr><th> <code>u</code><br></th><td> writes <b>weekday</b> as a decimal number, where Monday is <code>1</code> (ISO 8601 format) (range <code>[1-7]</code>)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>Ou</code><br></th><td> writes <b>weekday</b>, where Monday is <code>1</code>, using the alternative numeric system, e.g. 二 instead of 2 in ja_JP locale</td><td> <code>tm_wday</code></td></tr><tr><th colspan="3"> Hour, minute, second</th></tr><tr><th> <code>H</code></th><td> writes <b>hour</b> as a decimal number, 24 hour clock (range <code>[00-23]</code>)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>OH</code><br></th><td> writes <b>hour</b> from 24-hour clock using the alternative numeric system, e.g. 十八 instead of 18 in ja_JP locale</td><td> <code>tm_hour</code></td></tr><tr><th> <code>I</code></th><td> writes <b>hour</b> as a decimal number, 12 hour clock (range <code>[01,12]</code>)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>OI</code><br></th><td> writes <b>hour</b> from 12-hour clock using the alternative numeric system, e.g. 六 instead of 06 in ja_JP locale</td><td> <code>tm_hour</code></td></tr><tr><th> <code>M</code></th><td> writes <b>minute</b> as a decimal number (range <code>[00,59]</code>)</td><td> <code>tm_min</code></td></tr><tr><th> <code>OM</code><br></th><td> writes <b>minute</b> using the alternative numeric system, e.g. 二十五 instead of 25 in ja_JP locale</td><td> <code>tm_min</code></td></tr><tr><th> <code>S</code></th><td> writes <b>second</b> as a decimal number (range <code>[00,60]</code>)</td><td> <code>tm_sec</code></td></tr><tr><th> <code>OS</code><br></th><td> writes <b>second</b> using the alternative numeric system, e.g. 二十四 instead of 24 in ja_JP locale</td><td> <code>tm_sec</code></td></tr><tr><th colspan="3"> Other</th></tr><tr><th> <code>c</code></th><td> writes <b>standard date and time string</b>, e.g. <code>Sun Oct 17 04:41:13 2010</code> (locale dependent)</td><td> all</td></tr><tr><th> <code>Ec</code><br></th><td> writes <b>alternative date and time string</b>, e.g. using 平成23年 (year Heisei 23) instead of 2011年 (year 2011) in ja_JP locale</td><td> all</td></tr><tr><th> <code>x</code></th><td> writes localized <b>date representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>Ex</code><br></th><td> writes <b>alternative date representation</b>, e.g. using 平成23年 (year Heisei 23) instead of 2011年 (year 2011) in ja_JP locale</td><td> all</td></tr><tr><th> <code>X</code></th><td> writes localized <b>time representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>EX</code><br></th><td> writes <b>alternative time representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>D</code><br></th><td> equivalent to <b>"%m/%d/%y"</b></td><td> <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_year</code></td></tr><tr><th> <code>F</code><br></th><td> equivalent to <b>"%Y-%m-%d"</b> (the ISO 8601 date format)</td><td> <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_year</code></td></tr><tr><th> <code>r</code><br></th><td> writes localized <b>12-hour clock</b> time (locale dependent)</td><td> <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code></td></tr><tr><th> <code>R</code><br></th><td> equivalent to <b>"%H:%M"</b></td><td> <code>tm_hour</code>, <code>tm_min</code></td></tr><tr><th> <code>T</code><br></th><td> equivalent to <b>"%H:%M:%S"</b> (the ISO 8601 time format)</td><td> <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code></td></tr><tr><th> <code>p</code></th><td> writes localized <b>a.m. or p.m.</b> (locale dependent)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>z</code><br></th><td> writes <b>offset from UTC</b> in the ISO 8601 format (e.g. <code>-0430</code>), or no characters if the time zone information is not available</td><td> <code>tm_isdst</code></td></tr><tr><th> <code>Z</code></th><td> writes <b>time zone name or abbreviation</b>, or no characters if the time zone information is not available (locale dependent)</td><td> <code>tm_isdst</code></td></tr></table><p><br></p></td></tr><tr class="t-par"><td>  time</td><td> -</td><td>  pointer to a struct tm object specifying the time to format</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The number of bytes written into the character array pointed to by <code>str</code> not including the terminating <code>'\\0'</code> on success. If <code>count</code> was reached before the entire string could be stored, <code>​0​</code> is returned and the contents are undefined.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/strftime.html
time	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>time_t time( time_t *arg );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the current calendar time encoded as a <code>time_t</code> object, and also stores it in the <code>time_t</code> object pointed to by <code>arg</code> (unless <code>arg</code> is a null pointer)</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  pointer to a <code>time_t</code> object where the time will be stored, or a null pointer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Current calendar time encoded as <code>time_t</code> object on success, <code>(time_t)(-1)</code> on error. If <code>arg</code> is not a null pointer, the return value is also stored in the object pointed to by  <code>arg</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/time.html
time_t	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>typedef /* unspecified */ time_t;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><span>Arithmetic</span> <span></span> <span>Real</span> <span></span> type capable of representing times.</p><p>Although not defined by the C standard, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to  POSIX time.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/time_t.html
timespec	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>struct timespec;</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Structure holding an interval broken down into seconds and nanoseconds.<br></p><h3><span class="prog__sub">Member objects</span></h3><table class="t-dsc-begin"><tr class="t-dsc"><td> time_t tv_sec</td><td> whole seconds (valid values are >= 0)</td></tr><tr class="t-dsc"><td> long tv_nsec</td><td>  nanoseconds (valid values are [0, 999999999])</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/timespec.html
timespec_get	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int timespec_get( struct timespec *ts, int base)</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>#define TIME_UTC /* implementation-defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Modifies the <code>timespec</code> object pointed to by <code>ts</code> to hold the current calendar time in the time base <code>base</code>.</ul><ul>2) Expands to a value suitable for use as the <code>base</code> argument of <code>timespec_get</code></ul><p>Other macro constants beginning with <code>TIME_</code> may be provided by the implementation to indicate additional time bases</p><p>If <code>base</code> is <code>TIME_UTC</code>, then</p><ul><li> ts->tv_sec is set to the number of seconds since an implementation defined epoch, truncated to a whole value</li><li> ts->tv_nsec member is set to the integral number of nanoseconds, rounded to the resolution of the system clock</li></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ts</td><td> -</td><td>  pointer to an object of type <code>struct timespec</code></td></tr><tr class="t-par"><td>  base</td><td> -</td><td> <code>TIME_UTC</code> or another nonzero integer value indicating the time base</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The value of <code>base</code> if successful, zero otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/timespec_get.html
tm	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>struct tm;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Structure holding a calendar date and time broken down into its components.<br></p><h3><span class="prog__sub">Member objects</span></h3><table class="t-dsc-begin"><tr class="t-dsc"><td> int tm_sec</td><td>  seconds after the minute – [0, 61](until C99) / [0, 60] <sup class="reference" id="cite_ref-leapsecond_1-0">[note 1]</sup></td></tr><tr class="t-dsc"><td> int tm_min</td><td>  minutes after the hour – [0, 59]</td></tr><tr class="t-dsc"><td> int tm_hour</td><td>  hours since midnight – [0, 23]</td></tr><tr class="t-dsc"><td> int tm_mday</td><td>  day of the month – [1, 31]</td></tr><tr class="t-dsc"><td> int tm_mon</td><td>  months since January – [0, 11]</td></tr><tr class="t-dsc"><td> int tm_year</td><td>  years since 1900</td></tr><tr class="t-dsc"><td> int tm_wday</td><td>  days since Sunday – [0, 6]</td></tr><tr class="t-dsc"><td> int tm_yday</td><td>  days since January 1 – [0, 365]</td></tr><tr class="t-dsc"><td> int tm_isdst</td><td>  Daylight Saving Time flag. The value is positive if DST is in effect, zero if not and negative if no information is available</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/tm.html
wcsftime	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>size_t wcsftime( wchar_t* str, size_t count, const wchar_t* format, tm* time );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts the date and time information from a given calendar time <code>time</code> to a null-terminated wide character string <code>str</code> according to format string <code>format</code>. Up to <code>count</code> bytes are written.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the first element of the wchar_t array for output</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of wide characters to write</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated wide character string specifying the format of conversion.<p>The format string consists of zero or more conversion specifiers and ordinary characters (except <code>%</code>). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with <code>%</code> character, optionally followed by <code>E</code> or <code>O</code> modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</p><table class="wikitable" style="font-size:85%; max-width:90em;"><tr><th> Conversion<br> specifier<br></th><th> Explanation</th><th> Used fields</th></tr><tr><th> <code>%</code></th><td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td></td></tr><tr><th> <code>n</code><br></th><td> writes newline character</td><td></td></tr><tr><th> <code>t</code><br></th><td> writes horizontal tab character</td><td></td></tr><tr><th colspan="3"> Year</th></tr><tr><th> <code>Y</code></th><td> writes <b>year</b> as a decimal number, e.g. 2017</td><td> <code>tm_year</code></td></tr><tr><th> <code>EY</code><br></th><td> writes <b>year</b> in the alternative representation, e.g.平成23年 (year Heisei 23) instead of 2011年 (year 2011) in ja_JP locale</td><td> <code>tm_year</code></td></tr><tr><th> <code>y</code></th><td> writes last 2 digits of <b>year</b> as a decimal number (range <code>[00,99]</code>)</td><td> <code>tm_year</code></td></tr><tr><th> <code>Oy</code><br></th><td> writes last 2 digits of <b>year</b> using the alternative numeric system, e.g. 十一 instead of 11 in ja_JP locale</td><td> <code>tm_year</code></td></tr><tr><th> <code>Ey</code><br></th><td> writes <b>year</b> as offset from locale's alternative calendar period <code>%EC</code> (locale-dependent)</td><td> <code>tm_year</code></td></tr><tr><th> <code>C</code><br></th><td> writes first 2 digits of <b>year</b> as a decimal number (range <code>[00,99]</code>)</td><td> <code>tm_year</code></td></tr><tr><th> <code>EC</code><br></th><td> writes name of the <b>base year (period)</b> in the locale's alternative representation, e.g. 平成 (Heisei era) in ja_JP</td><td> <code>tm_year</code></td></tr><tr><th> <code>G</code><br></th><td> writes <b>ISO 8601 week-based year</b>, i.e. the year that contains the specified week.<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year</li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>g</code><br></th><td> writes last 2 digits of <b>ISO 8601 week-based year</b>, i.e. the year that contains the specified week (range <code>[00,99]</code>).<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year </li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th colspan="3"> Month</th></tr><tr><th> <code>b</code></th><td> writes <b>abbreviated month</b> name, e.g. <code>Oct</code> (locale dependent)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>h</code><br></th><td> synonym of <code>b</code></td><td> <code>tm_mon</code></td></tr><tr><th> <code>B</code></th><td> writes <b>full month</b> name, e.g. <code>October</code> (locale dependent)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>m</code></th><td> writes <b>month</b> as a decimal number (range <code>[01,12]</code>)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>Om</code><br></th><td> writes <b>month</b> using the alternative numeric system, e.g. 十二 instead of 12 in ja_JP locale</td><td> <code>tm_mon</code></td></tr><tr><th colspan="3"> Week</th></tr><tr><th> <code>U</code></th><td> writes <b>week of the year</b> as a decimal number (Sunday is the first day of the week) (range <code>[00,53]</code>)</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OU</code><br></th><td> writes <b>week of the year</b>, as by <code>%U</code>, using the alternative numeric system, e.g. 五十二 instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>W</code></th><td> writes <b>week of the year</b> as a decimal number (Monday is the first day of the week) (range <code>[00,53]</code>)</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OW</code><br></th><td> writes <b>week of the year</b>, as by <code>%W</code>, using the alternative numeric system, e.g. 五十二 instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>V</code><br></th><td> writes <b>ISO 8601 week of the year</b> (range <code>[01,53]</code>).<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year </li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OV</code><br></th><td> writes <b>week of the year</b>, as by <code>%V</code>, using the alternative numeric system, e.g. 五十二 instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th colspan="3"> Day of the year/month</th></tr><tr><th> <code>j</code></th><td> writes <b>day of the year</b> as a decimal number (range <code>[001,366]</code>)</td><td> <code>tm_yday</code></td></tr><tr><th> <code>d</code></th><td> writes <b>day of the month</b> as a decimal number (range <code>[01,31]</code>)</td><td> <code>tm_mday</code></td></tr><tr><th> <code>Od</code><br></th><td> writes zero-based <b>day of the month</b> using the alternative numeric system, e.g 二十七 instead of 23 in ja_JP locale<p>Single character is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th> <code>e</code><br></th><td> writes <b>day of the month</b> as a decimal number (range <code>[1,31]</code>).<p>Single digit is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th> <code>Oe</code><br></th><td> writes one-based <b>day of the month</b> using the alternative numeric system, e.g. 二十七 instead of 27 in ja_JP locale<p>Single character is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th colspan="3"> Day of the week</th></tr><tr><th> <code>a</code></th><td> writes <b>abbreviated weekday</b> name, e.g. <code>Fri</code> (locale dependent)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>A</code></th><td> writes <b>full weekday</b> name, e.g. <code>Friday</code> (locale dependent)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>w</code></th><td> writes <b>weekday</b> as a decimal number, where Sunday is <code>0</code> (range <code>[0-6]</code>)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>Ow</code><br></th><td> writes <b>weekday</b>, where Sunday is <code>0</code>, using the alternative numeric system, e.g. 二 instead of 2 in ja_JP locale</td><td> <code>tm_wday</code></td></tr><tr><th> <code>u</code><br></th><td> writes <b>weekday</b> as a decimal number, where Monday is <code>1</code> (ISO 8601 format) (range <code>[1-7]</code>)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>Ou</code><br></th><td> writes <b>weekday</b>, where Monday is <code>1</code>, using the alternative numeric system, e.g. 二 instead of 2 in ja_JP locale</td><td> <code>tm_wday</code></td></tr><tr><th colspan="3"> Hour, minute, second</th></tr><tr><th> <code>H</code></th><td> writes <b>hour</b> as a decimal number, 24 hour clock (range <code>[00-23]</code>)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>OH</code><br></th><td> writes <b>hour</b> from 24-hour clock using the alternative numeric system, e.g. 十八 instead of 18 in ja_JP locale</td><td> <code>tm_hour</code></td></tr><tr><th> <code>I</code></th><td> writes <b>hour</b> as a decimal number, 12 hour clock (range <code>[01,12]</code>)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>OI</code><br></th><td> writes <b>hour</b> from 12-hour clock using the alternative numeric system, e.g. 六 instead of 06 in ja_JP locale</td><td> <code>tm_hour</code></td></tr><tr><th> <code>M</code></th><td> writes <b>minute</b> as a decimal number (range <code>[00,59]</code>)</td><td> <code>tm_min</code></td></tr><tr><th> <code>OM</code><br></th><td> writes <b>minute</b> using the alternative numeric system, e.g. 二十五 instead of 25 in ja_JP locale</td><td> <code>tm_min</code></td></tr><tr><th> <code>S</code></th><td> writes <b>second</b> as a decimal number (range <code>[00,60]</code>)</td><td> <code>tm_sec</code></td></tr><tr><th> <code>OS</code><br></th><td> writes <b>second</b> using the alternative numeric system, e.g. 二十四 instead of 24 in ja_JP locale</td><td> <code>tm_sec</code></td></tr><tr><th colspan="3"> Other</th></tr><tr><th> <code>c</code></th><td> writes <b>standard date and time string</b>, e.g. <code>Sun Oct 17 04:41:13 2010</code> (locale dependent)</td><td> all</td></tr><tr><th> <code>Ec</code><br></th><td> writes <b>alternative date and time string</b>, e.g. using 平成23年 (year Heisei 23) instead of 2011年 (year 2011) in ja_JP locale</td><td> all</td></tr><tr><th> <code>x</code></th><td> writes localized <b>date representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>Ex</code><br></th><td> writes <b>alternative date representation</b>, e.g. using 平成23年 (year Heisei 23) instead of 2011年 (year 2011) in ja_JP locale</td><td> all</td></tr><tr><th> <code>X</code></th><td> writes localized <b>time representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>EX</code><br></th><td> writes <b>alternative time representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>D</code><br></th><td> equivalent to <b>"%m/%d/%y"</b></td><td> <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_year</code></td></tr><tr><th> <code>F</code><br></th><td> equivalent to <b>"%Y-%m-%d"</b> (the ISO 8601 date format)</td><td> <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_year</code></td></tr><tr><th> <code>r</code><br></th><td> writes localized <b>12-hour clock</b> time (locale dependent)</td><td> <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code></td></tr><tr><th> <code>R</code><br></th><td> equivalent to <b>"%H:%M"</b></td><td> <code>tm_hour</code>, <code>tm_min</code></td></tr><tr><th> <code>T</code><br></th><td> equivalent to <b>"%H:%M:%S"</b> (the ISO 8601 time format)</td><td> <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code></td></tr><tr><th> <code>p</code></th><td> writes localized <b>a.m. or p.m.</b> (locale dependent)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>z</code><br></th><td> writes <b>offset from UTC</b> in the ISO 8601 format (e.g. <code>-0430</code>), or no characters if the time zone information is not available</td><td> <code>tm_isdst</code></td></tr><tr><th> <code>Z</code></th><td> writes <b>time zone name or abbreviation</b>, or no characters if the time zone information is not available (locale dependent)</td><td> <code>tm_isdst</code></td></tr></table><p><br></p></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>number of wide characters written into the wide character array pointed to by <code>str</code> not including the terminating <code>L'\\0'</code> on success. If <code>count</code> was reached before the entire string could be stored, <code>​0​</code> is returned and the contents are undefined.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/chrono/wcsftime.html
abort_handler_s	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void abort_handler_s( const char * restrict msg,<br>                      void * restrict ptr,<br>                      errno_t error<br>                    );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes an implementation-defined message to <code>stderr</code> which must include the string pointed to by <code>msg</code> and calls <code>abort()</code>.</p><p>A pointer to this function can be passed to set_constraint_handler_s to establish a runtime constraints violation handler.</p><dl><dd>As with all bounds-checked functions, <code>abort_handler_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdlib.h></code>.</dd></dl><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  msg</td><td> -</td><td>  pointer to the message written to the standard error stream</td></tr><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected</td></tr><tr class="t-par"><td>  error</td><td> -</td><td>  a positive value of type errno_t</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>none; this function does not return to its caller<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/error/abort_handler_s.html
assert	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><assert.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#ifdef NDEBUG<br>#define assert(condition) ((void)0)<br>#else<br>#define assert(condition) /*implementation defined*/<br>#endif<br></code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The definition of the macro <code>assert</code> depends on another macro, <code>NDEBUG</code>, which is not defined by the standard library.</p><p>If <code>NDEBUG</code> is defined as a macro name at the point in the source code where <code><assert.h></code> is included, then <code>assert</code> does nothing.</p><p>If <code>NDEBUG</code> is not defined, then <code>assert</code> checks if its argument (which must have scalar type) compares equal to zero. If it does, <code>assert</code> outputs implementation-specific diagnostic information on the standard error output and calls <code>abort()</code>. The diagnostic information is required to include the text of <code>expression</code>, as well as the values of the standard macros <code>__FILE__</code>,  <code>__LINE__</code><span>, and the predefined variable <code>__func__</code>.</span> <span></span></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  condition</td><td> -</td><td>  expression of scalar type</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/error/assert.html
errno	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><errno.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define errno /*implementation-defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><code>errno</code> is a preprocessor macro that expands to a <span>thread-local</span> <span></span> modifiable lvalue of type <code>int</code>. Several standard library functions indicate errors by writing positive integers to <code>errno</code>. Typically, the value of <code>errno</code> is set to one of the error codes listed in <code><errno.h></code> as macro constants beginning with the letter <code>E</code> followed by uppercase letters or digits.</p><p>The value of <code>errno</code> is <code>​0​</code> at program startup, and although library functions are allowed to write positive integers to <code>errno</code> whether or not an error occurred, library functions never store <code>​0​</code> in <code>errno</code>.</p><p>Library functions <code>perror</code> and <code>strerror</code> can be used to obtain textual descriptions of the error conditions that correspond to the current <code>errno</code> value.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/error/errno.html
errno_macros	A										<section class="prog__container"><p>Each of the macros defined in <code><errno.h></code> expands to an integer constant expression with type <code>int</code> and with a unique positive value. The following constants are defined by ISO C. The implementation may define more, as long as they begin with <code>'E'</code> followed by digits or uppercase letters.</p><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><errno.h></code> </td></tr><tr class="t-dsc"><td> <code>EDOM</code></td><td>                       Mathematics argument out of domain of function <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>EILSEQ</code><table><tr><td></td></tr></table></td><td>   Illegal byte sequence <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>ERANGE</code></td><td>                       Result too large <br> (macro constant)<br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/error/errno_macros.html
ignore_handler_s	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void ignore_handler_s( const char * restrict msg,<br>                       void * restrict ptr,<br>                       errno_t error<br>                     );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The function simply returns to the caller without performing any other action.<br></p><p>A pointer to this function can be passed to set_constraint_handler_s to establish a runtime constraints violation handler that does nothing.</p><dl><dd>As with all bounds-checked functions, <code>ignore_handler_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdlib.h></code>.</dd></dl><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  msg</td><td> -</td><td>  pointer to character string that describes the error</td></tr><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected</td></tr><tr class="t-par"><td>  error</td><td> -</td><td>  the error about to be returned by the calling function, if it happens to be one of the functions that return errno_t</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/error/ignore_handler_s.html
set_constraint_handler_s	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>constraint_handler_t set_constraint_handler_s( constraint_handler_t handler );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Configures the handler to be called by all bounds-checked functions on a runtime constraint violation or restores the default handler (if <code>handler</code> is a null pointer)</p><p>The handler must be a pointer to function of type <code>constraint_handler_t</code>, which is defined as</p><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>typedef void (*constraint_handler_t)( const char *restrict msg,<br>                                      void *restrict ptr,<br>                                      errno_t error);<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>On a runtime constraint violation, it is called with the following arguments:<br></p><ul>1) pointer to character string that describes the error</ul><ul>2) pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected</ul><ul>3) the error about to be returned by the calling function, if it happens to be one of the functions that return <code>errno_t</code></ul><p>If <code>set_constraint_handler_s</code> is never called, the default handler is implementation-defined: it may be <code>abort_handler_s</code>, <code>ignore_handler_s</code>, or some other implementation-defined handler.</p><dl><dd>As with all bounds-checked functions, <code>set_constraint_handler_s</code> and <code>constraint_handler_t</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdlib.h></code>.</dd></dl><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  handler</td><td> -</td><td>  pointer to function of type <code>constraint_handler_t</code> or a null pointer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>A pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling <code>set_constraint_handler_s(NULL)</code> sets up the system default handler)</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/error/set_constraint_handler_s.html
static_assert	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><assert.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define static_assert _Static_assert</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>This convenience macro expands to the keyword _Static_assert</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/error/static_assert.html
dynamic	A										<section class="prog__container"><p>Extensions to the C Library Part II: Dynamic Allocation Functions, ISO/IEC TR 24731-2:2010, defines the following new components for the C standard library:<br></p><table class="t-dsc-begin"><tr class="t-dsc"><td> <code>__STDC_ALLOC_LIB__</code></td><td>   integer constant of type <code>long</code> indicating conformance level <br> (macro constant)<br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdio.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fmemopen</td></tr></table></code><table><tr><td></td></tr></table></td><td>   opens a fixed-size memory buffer as an I/O stream <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>open_memstream</td></tr><tr><td>open_wmemstream</td></tr></table></code><table><tr><td></td></tr></table></td><td>   opens a dynamically resized memory buffer as an I/O stream <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>asprintf</td></tr><tr><td>aswprintf</td></tr><tr><td>vasprintf</td></tr><tr><td>vaswprintf</td></tr></table></code><table><tr><td></td></tr></table></td><td>   variants of <code>sprintf</code> etc that write to automatically-allocated buffer and return a pointer to it <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>getline</td></tr><tr><td>getwline</td></tr><tr><td>getdelim</td></tr><tr><td>getwdelim</td></tr></table></code><table><tr><td></td></tr></table></td><td>   read from a stream into a automatically resized buffer until delimiter/end of line <br> (function) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><string.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strdup</td></tr></table></code><table><tr><td></td></tr></table></td><td>   allocate a copy of a string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strndup</td></tr></table></code><table><tr><td></td></tr></table></td><td>   allocate a copy of a string up to specified size <br> (function) <br></td></tr></table><p>This library extension also introduces assignment-allocation character <code>m</code> for use with <code>%s</code>, <code>%[</code>, and <code>%c</code> conversion specifiers in <code>fscanf</code> and <code>fwscanf</code> family of functions.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/experimental/dynamic.html
fpext4	A										<section class="prog__container"><p>Floating-point extensions for C - Part 4: Supplementary functions, ISO/IEC TS 18661-4:2015, defines the following new components for the C standard library, as recommended by ISO/IEC/IEEE 60559:2011 (the current revision of IEEE-754)<br></p><table class="t-dsc-begin"><tr class="t-dsc"><td> <code>__STDC_IEC_60559_FUNCS__</code></td><td>   integer constant of type <code>long</code> and value <code>201506L</code> <br> (macro constant)<br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><math.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>exp2m1 exp2m1f exp2m1l</td></tr><tr><td>exp2m1fN exp2m1fNx</td></tr><tr><td>exp2m1dN exp2m1dNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute 2<span class="t-su">x<br/></span>-1 <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>exp10 exp10f exp10l</td></tr><tr><td>exp10fN exp10fNx</td></tr><tr><td>exp10dN exp10dNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute 10<span class="t-su">x<br/></span> <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>exp10m1 exp10m1f exp10m1l</td></tr><tr><td>exp10m1fN exp10m1fNx</td></tr><tr><td>exp10m1dN exp10m1dNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute 10<span class="t-su">x<br/></span>-1 <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>logp1 logp1f logp1l</td></tr><tr><td>logp1fN logp1fNx</td></tr><tr><td>logp1dN logp1dNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute ln(1+x) (same as <code>log1p</code>) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>log2p1 log2p1f log2p1l</td></tr><tr><td>log2p1fN log2p1fNx</td></tr><tr><td>log2p1dN log2p1dNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute log<span class="t-su t-su-b">2</span>(1+x) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>log10p1 log10p1f log10p1l</td></tr><tr><td>log10p1fN log10p1fNx</td></tr><tr><td>log10p1dN log10p1dNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute log<span class="t-su t-su-b">10</span>(1+x) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>rsqrt rsqrtf rsqrtl</td></tr><tr><td>rsqrtfN rsqrtfNx</td></tr><tr><td>rsqrtdN rsqrtdNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the inverse square root x<span class="t-su">-1/2<br/></span> <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>compoundn compoundnf compoundnl</td></tr><tr><td>compoundnfN compoundnfNx</td></tr><tr><td>compoundndN compoundndNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute compound interest, (1+x)<span class="t-su">n<br/></span> <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>rootn rootnf rootnl</td></tr><tr><td>rootnfN rootnfNx</td></tr><tr><td>rootndN rootndNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the nth root of x, x<span class="t-su">1/n<br/></span> <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>pown pownf pownl</td></tr><tr><td>pownfN pownfNx</td></tr><tr><td>powndN powndNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute x raised to the nth power, where n is integer <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>powr powrf powrl</td></tr><tr><td>powrfN powrfNx</td></tr><tr><td>powrdN powrdNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute x raised to the y power, x<span class="t-su">y<br/></span> <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>acospi acospif acospil</td></tr><tr><td>acospifN acospifNx</td></tr><tr><td>acospidN acospidNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute arccos(x)/π (measuring the angle in half-revolutions) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>asinpi asinpif asinpil</td></tr><tr><td>asinpifN asinpifNx</td></tr><tr><td>asinpidN asinpidNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute arcsin(x)/π (measuring the angle in half-revolutions) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>atanpi atanpif atanpil</td></tr><tr><td>atanpifN atanpifNx</td></tr><tr><td>atanpidN atanpidNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute arctan(x)/π (measuring the angle in half-revolutions) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>atan2pi atan2pif atan2pil</td></tr><tr><td>atan2pifN atan2pifNx</td></tr><tr><td>atan2pidN atan2pidNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute arctan(y/x)/π (measuring the angle in half-revolutions) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cospi cospif cospil</td></tr><tr><td>cospifN cospifNx</td></tr><tr><td>cospidN cospidNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute cos(πx) (measuring the angle in half-revolutions) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>sinpi sinpif sinpil</td></tr><tr><td>sinpifN sinpifNx</td></tr><tr><td>sinpidN sinpidNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute sin(πx) (measuring the angle in half-revolutions) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>tanpi tanpif tanpil</td></tr><tr><td>tanpifN tanpifNx</td></tr><tr><td>tanpidN tanpidNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute tan(πx) (measuring the angle in half-revolutions) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>reduc_sum reduc_sumf reduc_suml</td></tr><tr><td>reduc_sumfN reduc_sumfNx</td></tr><tr><td>reduc_sumdN reduc_sumdNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the sum of n members of an array <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>reduc_sumabs reduc_sumabsf reduc_sumabsl</td></tr><tr><td>reduc_sumabsfN reduc_sumabsfNx</td></tr><tr><td>reduc_sumabsdN reduc_sumabsdNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the sum of the absolute values of n members of an array <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>reduc_sumsq reduc_sumsqf reduc_sumsql</td></tr><tr><td>reduc_sumsqfN reduc_sumsqfNx</td></tr><tr><td>reduc_sumsqdN reduc_sumsqdNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the sum of squares of n members of an array <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>reduc_sumprod reduc_sumprodf reduc_sumprodl</td></tr><tr><td>reduc_sumprodfN reduc_sumprodfNx</td></tr><tr><td>reduc_sumproddN reduc_sumproddNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the dot product between n members of two arrays <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>scaled_prod scaled_prodf scaled_prodl</td></tr><tr><td>scaled_prodfN scaled_prodfNx</td></tr><tr><td>scaled_proddN scaled_proddNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the product of n members of an array as a scaled value and a scale factor <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>scaled_prodsum scaled_prodsumf scaled_prodsuml</td></tr><tr><td>scaled_prodsumfN scaled_prodsumfNx</td></tr><tr><td>scaled_prodsumdN scaled_prodsumdNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the dot product of n members of two arrays as a scaled value and a scale factor <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>scaled_proddiff scaled_proddifff scaled_proddiffl</td></tr><tr><td>scaled_proddifffN scaled_proddifffNx</td></tr><tr><td>scaled_proddiffdN scaled_proddiffdNx</td></tr></table></code><table><tr><td></td></tr></table></td><td>  compute the product of the differences between corresponding n members of two arrays as a scaled value and a scale factor <br> (function) <br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crexp(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>exp</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crexpm1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>expm1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crexp2(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>exp2</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crexp2m1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>exp2m1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crexp10(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>exp10</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crexp10m1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>exp10m1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crlog(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>log</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crlog2(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>log2</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crlog10(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>log10</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crlog1p(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>log1p</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crlogp1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>logp1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crlog2p1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>log2p1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crlog10p1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>log10p1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crrsqrt(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>rsqrt</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crcompoundn(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>compoundn</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crrootn(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>rootn</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crpown(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>pown</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crpow(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>pow</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crpowr(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>powr</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crsin(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>sin</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crcos(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>cos</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crtan(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>tan</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crsinpi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>sinpi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crcospi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>cospi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crtanpi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>tanpi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crasinpi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>asinpi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cracospi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>acospi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cracospi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>acospi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cratanpi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>atanpi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cratan2pi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>atan2pi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crasin(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>asin</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cracos(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>acos</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cratan(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>atan</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cratan2(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>atan2</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crsinh(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>sinh</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crcosh(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>cosh</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crtanh(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>tanh</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crasinh(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>asinh</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cracosh(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>acosh</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cratanh(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>atanh</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crhypot(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   correctly-rounded version of <code>hypot</code> <br> (function)<br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><complex.h></code> </td></tr><tr class="t-dsc"><td> <code><table><tr><td>cexp2m1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>exp2m1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cexp10(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>exp10</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cexp10m1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>exp10m1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>clogp1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>logp1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>clog2p1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>log2p1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>clog10p1(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>log10p1</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crsqrt (optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>rsqrt</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>ccompoundn (optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>compoundn</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>crootn(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>rootn</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cpown (optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>pown</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cpowr(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>powr</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>cacospi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>acospi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>casinpi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>asinpi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>catanpi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>atanpi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>ccospi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>cospi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>csinpi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>sinpi</code> <br> (function)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>ctanpi(optional)</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex number version of <code>tanpi</code> <br> (function)<br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/experimental/fpext4.html
getline	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>ssize_t getline(char **lineptr, size_t *n, FILE *stream);</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>ssize_t getwline(wchar_t **lineptr, size_t *n, FILE *stream);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl"><td> <code>ssize_t getdelim(char ** restrict lineptr, size_t * restrict n,<br>                 int delimiter, FILE *stream);<br></code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl"><td> <code>ssize_t getwdelim(wchar_t ** restrict lineptr, size_t * restrict n,<br>                 wint_t delimiter, FILE * stream);<br></code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Behaves like <code>getdelim(lineptr, n, '\\n', stream)</code></ul><ul>2) Behaves like <code>getwdelim(lineptr, n, L'\\n', stream)</code></ul><ul>3) Reads from the stream <code>stream</code> as if by <code>fgetc</code>, until <code>delimiter</code> is encountered, storing the characters in the buffer of size <code>*n</code> pointed to by <code>*lineptr</code>, automatically increasing its size as if by <code>realloc</code> to fit the entire input, including the delimiter, and adding a null terminator. <code>*lineptr</code> may be null, in which case <code>*n</code> is ignored and <code>getline</code> allocates a new buffer as if by <code>malloc</code>.The behavior is undefined if <code>delimiter</code> has a value that is outside the range of <code>unsigned char</code> or <code>EOF</code>.</ul><ul>4) Same as (3), except the characters are read as if by <code>fgetwc</code> and that <code>delimiter</code> must be a valid <code>wchar_t</code> or <code>WEOF</code>.</ul><p>If <code>*lineptr</code> is not null, the behavior is undefined if <code>*lineptr</code> is not a pointer that can be passed to <code>free</code> or if <code>*n</code> is less than the size of the allocated memory pointed to by <code>*lineptr</code></p><p>As all functions from Dynamic Memory TS, <code>getline</code> is only guaranteed to be available if <code>__STDC_ALLOC_LIB__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT2__</code> to the integer constant <code>1</code> before including <code>stdio.h</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lineptr</td><td> -</td><td>  pointer to a pointer to the initial buffer or to a null pointer</td></tr><tr class="t-par"><td>  n</td><td> -</td><td>  pointer to the size of the initial buffer</td></tr><tr class="t-par"><td>  delimiter</td><td> -</td><td>  the delimiter character</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  valid input stream, opened by <code>fopen</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The number of characters stored in the buffer, including the delimiter, but excluding the null terminator.<br></p><p>On error, returns <code>-1</code> and sets <code>feof</code> or <code>ferror</code> on <code>stream</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/experimental/dynamic/getline.html
strdup	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>char * strdup(const char *str1);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns a pointer to a null-terminated byte string, which is a duplicateof the string pointed to by str1. The returned pointer must be passed to <code>free</code> to avoid a memory leak.</p><p>If an error occurs, a null pointer is returned and <code>errno</code> may be set.</p><p>As all functions from Dynamic Memory TS, <code>strdup</code> is only guaranteed to be available if <code>__STDC_ALLOC_LIB__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT2__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str1</td><td> -</td><td>  pointer to the null-terminated byte string to duplicate</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>A pointer to the newly allocated string, or a null pointer if an error occurred.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/experimental/dynamic/strdup.html
strndup	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>char *strndup(const char *str, size_t size);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns a pointer to a null-terminated byte string, which contains copies of at most  <code>size</code> bytes from the string pointed to by <code>str</code>. If the null terminator is not encountered in the first <code>size</code> bytes, it is added to the duplicated string.</p><p>The returned pointer must be passed to <code>free</code> to avoid a memory leak.</p><p>If an error occurs, a null pointer is returned and <code>errno</code> may be set.</p><p>As all functions from Dynamic Memory TS, <code>strndup</code> is only guaranteed to be available if <code>__STDC_ALLOC_LIB__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT2__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to duplicate</td></tr><tr class="t-par"><td>  size</td><td> -</td><td>  max number of bytes to copy from <code>str</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>A pointer to the newly allocated string, or a null pointer if an error occurred.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/experimental/dynamic/strndup.html
clearerr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void clearerr( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Resets the error flags and the <code>EOF</code> indicator for the given file stream.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  the file to reset the error flags for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/clearerr.html
fclose	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int fclose( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.<br></p><p>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by <code>setbuf</code> or <code>setvbuf</code>, if any, is also disassociated and deallocated if automatic allocation was used.</p><p>The behavior is undefined if the value of the pointer <code>stream</code> is used after <code>fclose</code> returns.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  the file stream to close</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> on success, <code>EOF</code> otherwise</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fclose.html
feof	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int feof( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the end of the given file stream has been reached.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  the file stream to check</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>nonzero value if the end of the stream has been reached, otherwise <code>​0​</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/feof.html
ferror	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int ferror( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks the given stream for errors.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  the file stream to check</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero value if the file stream has errors occurred, <code>​0​</code> otherwise </p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/ferror.html
fflush	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int fflush( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the <code>stream</code>'s buffer to the associated output device.</p><p>For input streams (and for update streams on which the last operation was input), the behavior is undefined.<br></p><p>If <code>stream</code> is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  the file stream to write out</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Returns zero on success. Otherwise <code>EOF</code> is returned and the error indicator of the file stream is set.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fflush.html
fgetc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int fgetc( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int getc( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads the next character from the given input stream. <code>getc()</code> may be implemented as a macro. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  to read the character from</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The obtained character on success or <code>EOF</code> on failure. </p><p>If the failure has been caused by end-of-file condition, additionally sets the <i>eof</i> indicator (see <code>feof()</code>) on <code>stream</code>. If the failure has been caused by some other error, sets the <i>error</i> indicator (see <code>ferror()</code>) on <code>stream</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fgetc.html
fgetpos	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>int fgetpos( FILE          *stream, fpos_t          *pos );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int fgetpos( FILE *restrict stream, fpos_t *restrict pos );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Obtains the file position indicator and the current parse state (if any) for the file stream <code>stream</code> and stores them in the object pointed to by <code>pos</code>. The value stored is only meaningful as the input to <code>fsetpos</code>.</p><p><br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to examine</td></tr><tr class="t-par"><td>  pos</td><td> -</td><td>  pointer to a <code>fpos_t</code> object to store the file position indicator to</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> upon success, nonzero value otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fgetpos.html
fgets	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>char *fgets( char          *str, int count, FILE          *stream );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>char *fgets( char *restrict str, int count, FILE *restrict stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads at most <code>count - 1</code> characters from the given file stream and stores them in the character array pointed to by <code>str</code>. Parsing stops if end-of-file occurs or a newline character is found, in which case <code>str</code> will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to <code>str</code>.</p><p>The behavior is undefined if <code>count</code> is less than 1.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to an element of a char array</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of characters to write (typically the length of <code>str</code>)</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to read the data from</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>str</code> on success, null pointer on failure.</p><p>If the failure has been caused by end-of-file condition, additionally sets the <i>eof</i> indicator (see <code>feof()</code>) on <code>stream</code>. The contents of the array pointed to by <code>str</code> are not altered in this case.</p><p>If the failure has been caused by some other error, sets the <i>error</i> indicator (see <code>ferror()</code>) on <code>stream</code>. The contents of the array pointed to by <code>str</code> are indeterminate (it may not even be null-terminated).</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fgets.html
fgetwc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl"><td> <code>wint_t fgetwc( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl"><td> <code>wint_t getwc( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads the next wide character from the given input stream. <code>getwc()</code> may be implemented as a macro and may evaluate <code>stream</code> more than once.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  to read the wide character from</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The next wide character from the stream or <code>WEOF</code> if an error has occurred or the end of file has been reached. If an encoding error occurred, <code>errno</code> is set to <code>EILSEQ</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fgetwc.html
fgetws	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wchar_t *fgetws( wchar_t *str, int count, FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads at most <code>count - 1</code> wide characters from the given file stream and stores them in <code>str</code>. The produced wide string is always null-terminated. Parsing stops if end-of-file occurs or a newline wide character is found, in which case <code>str</code> will contain that wide newline character.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  wide string to read the characters to</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  the length of <code>str</code></td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to read the data from</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>str</code> on success, <code>NULL</code> on an error</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fgetws.html
fopen	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>FILE *fopen( const char *filename, const char *mode );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>FILE *fopen( const char *restrict filename, const char *restrict mode );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t fopen_s(FILE *restrict *restrict streamptr,<br>                const char *restrict filename,<br>                const char *restrict mode);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Opens a file indicated by <code>filename</code> and returns a pointer to the file stream associated with that file. <code>mode</code> is used to determine the file access mode. </ul><ul>2) Same as (1), except that the pointer to the file stream is written to <code>streamptr</code> and the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>streamptr</code> is a null pointer</li><li> <code>filename</code> is a null pointer</li><li> <code>mode</code> is a null pointer</li></ul></dd><dd>As all bounds-checked functions, <code>fopen_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  filename</td><td> -</td><td>  file name to associate the file stream to</td></tr><tr class="t-par"><td>  mode</td><td> -</td><td>  null-terminated character string determining file access mode<table class="wikitable"><tr><th> File access <br>mode string<br></th><th> Meaning</th><th> Explanation</th><th> Action if file <br> already exists<br></th><th> Action if file <br> does not exist<br></th></tr><tr><td> <code>"r"</code></td><td> read</td><td> Open a file for reading</td><td> read from start</td><td> failure to open</td></tr><tr><td> <code>"w"</code></td><td> write</td><td> Create a file for writing</td><td> destroy contents</td><td> create new</td></tr><tr><td> <code>"a"</code></td><td> append</td><td> Append to a file</td><td> write to end</td><td> create new</td></tr><tr><td> <code>"r+"</code></td><td> read extended</td><td> Open a file for read/write</td><td> read from start</td><td> error</td></tr><tr><td> <code>"w+"</code></td><td> write extended</td><td> Create a file for read/write</td><td> destroy contents</td><td> create new</td></tr><tr><td> <code>"a+"</code></td><td> append extended</td><td> Open a file for read/write</td><td> write to end</td><td> create new</td></tr><tr><td colspan="5"> File access mode flag <code>"b"</code> can optionally be specified to open a file in binary mode. This flag has effect only on Windows systems. <br> On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.<br></td></tr><tr><td colspan="5"> When a file is opened with update mode ('+' as the second or third character in the above list of mode argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the <code>fflush</code> function or to a file positioning function (<code>fseek</code>, <code>fsetpos</code>, or <code>rewind</code>), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end- of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.</td></tr><tr><td colspan="5"> File access mode flag <code>"x"</code> can optionally be appended to "w" or "w+" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. </td></tr><tr><td colspan="5"> When using <code>fopen_s</code> or <code>freopen_s</code>, file access permissions for any file created with "w" or "a" prevents other users from accessing it. File access mode flag <code>"u"</code> can optionally be prepended to any specifier that begins with "w" or "a", to enable the default <code>fopen</code> permissions. </td></tr></table></td></tr><tr class="t-par"><td>  streamptr</td><td> -</td><td>  pointer to a pointer where the function stores the result (an out-parameter)</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) If successful, returns a pointer to the new file stream. The stream is fully buffered unless <code>filename</code> refers to an interactive device.  On error, returns a <code>null pointer</code>. POSIX requires that <code>errno</code> is set in this case.</ul><ul>2) If successful, returns zero and a pointer to the new file stream is written to <code>*streamptr</code>.  On error, returns a non-zero error code and writes the null pointer to <code>*streamptr</code> (unless <code>streamptr</code> is a null pointer itself).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fopen.html
fprintf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>​int printf( const char *format, ... );​</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>​int printf( const char *restrict format, ... );​</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(2)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>int fprintf( FILE *stream, const char *format, ... );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int fprintf( FILE *restrict stream, const char *restrict format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(3)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>int sprintf( char *buffer, const char *format, ... );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int sprintf( char *restrict buffer, const char *restrict format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c99"><td> <code>int snprintf( char *restrict buffer, int bufsz, <br>              const char *restrict format, ... );<br></code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int printf_s(const char *restrict format, ...);</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int fprintf_s(FILE *restrict stream, const char *restrict format, ...);</code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int sprintf_s(char *restrict buffer, rsize_t bufsz,<br>              const char *restrict format, ...);<br></code></td><td> (7) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int snprintf_s(char *restrict buffer, rsize_t bufsz,<br>               const char *restrict format, ...);<br></code></td><td> (8) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.<br></p><ul>1) Writes the results to the output stream <code>stdout</code>.</ul><ul>2) Writes the results to the output stream <code>stream</code>.</ul><ul>3) Writes the results to a character string <code>buffer</code>. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by <code>buffer</code>.</ul><ul>4) Writes the results to a character string <code>buffer</code>. At most <code>bufsz</code> - 1 characters are written. The resulting character string will be terminated with a null character, unless <code>bufsz</code> is zero. If <code>bufsz</code> is zero, nothing is written and <code>buffer</code> may be a null pointer, however the return value (number of bytes that would be written) is still calculated and returned.</ul><ul>5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> the conversion specifier <code>%n</code> is present in <code>format</code></li><li> any of the arguments corresponding to <code>%s</code> is a null pointer</li><li> <code>format</code> or <code>buffer</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than <code>RSIZE_MAX</code></li><li> encoding errors occur in any of string and character conversion specifiers</li><li> (for <code>sprintf_s</code> only), the string to be stored in <code>buffer</code> (including the trailing null) would be exceed <code>bufsz</code></li></ul></dd><dd>As all bounds-checked functions, <code>printf_s</code>, <code>fprintf_s</code>, <code>sprintf_s</code>, and <code>snrintf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  output file stream to write to</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a character string to write to</td></tr><tr class="t-par"><td>  bufsz</td><td> -</td><td>  up to bufsz - 1 characters may be written, plus the null terminator</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated multibyte string specifying how to interpret the data.<p>The format string consists of ordinary multibyte characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) one or more flags that modify the behavior of the conversion:</li></ul><dl><dd><ul><li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified)</li><li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative)</li><li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present.</li><li> <code>#</code> : <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.</li><li> <code>0</code> : for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present.</li></ul></dd></dl></dd></dl><dl><dd><ul><li> (optional) integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.)</li></ul></dd></dl><dl><dd><ul><li> (optional) <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the argument</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="1"> Conversion<br> specifier<br></th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p><br></p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p><br></p></th><th> <code>j</code><p><br></p></th><th> <code>z</code><p><br></p></th><th> <code>t</code><p><br></p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td style="text-align:left;"> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td style="text-align:left;"><dl><dd> writes a <b>single character</b>.</dd></dl><p>The argument is first converted to <code>unsigned char</code>.If the <b>l</b> modifier is used, the argument is first converted to a character string as if by <b>%ls</b> with a <code>wchar_t[2]</code> argument.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>int</code></td><td> <code>wint_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td style="text-align:left;"><dl><dd> writes a <b>character string</b></dd></dl><p>The argument must be a pointer to the initial element of an array of characters. <i>Precision</i> specifies the maximum number of bytes to be written. If <i>Precision</i> is not specified, writes every byte up to and not including the first null terminator.If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>, which is converted to char array as if by a call to <code>wcrtomb</code> with zero-initialized conversion state.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>char*</code></td><td> <code>wchar_t*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>d</code><br> <code>i</code><br></th><td style="text-align:left;"><dl><dd>converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br> If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.<br></p></td><td rowspan="1"> <code>signed char</code></td><td rowspan="1"> <code>short</code></td><td rowspan="1"> <code>int</code></td><td rowspan="1"> <code>long</code></td><td rowspan="1"> <code>long long</code></td><td rowspan="1"> <code>intmax_t</code></td><td rowspan="1"> signed <code>size_t</code></td><td rowspan="1"> <code>ptrdiff_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>o</code></th><td style="text-align:left;"><dl><dd>converts a <b>unsigned integer</b> into octal representation <i>oooo</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero.In that case if both the converted value and the precision are <code>​0​</code>, single <code>​0​</code> is written.</p></td><td rowspan="3"> <code>unsigned char</code></td><td rowspan="3"> <code>unsigned short</code></td><td rowspan="3"> <code>unsigned int</code></td><td rowspan="3"> <code>unsigned long</code></td><td rowspan="3"> <code>unsigned long long</code></td><td rowspan="3"> <code>uintmax_t</code></td><td rowspan="3"> <code>size_t</code></td><td rowspan="3"> unsigned version of <code>ptrdiff_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>x</code><br> <code>X</code><br></th><td style="text-align:left;"><dl><dd>converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.</dd></dl><p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br>For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>u</code></th><td style="text-align:left;"><dl><dd>converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>f</code><br> <code>F</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear after the decimal point character. The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="4"> <code>double</code></td><td rowspan="4"> <code>double</code> </td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="4"> <code>long double</code></td></tr><tr><th> <code>e</code> <br> <code>E</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the decimal exponent notation.</dd></dl><p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>±dd</i> is used.<br>For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>±dd</i> is used.<br>The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>​0​</code>, the exponent is also <code>​0​</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>a</code> <br> <code>A</code><p><br></p><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the hexadecimal exponent notation.</dd></dl><p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>±d</i> is used.<br>For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>±d</i> is used.<br>The first hexadecimal digit is <code>0</code> if the argument is not a normalized floating point value.If the value is <code>​0​</code>, the exponent is also <code>​0​</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is sufficient for exact representation of the value.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>g</code> <br> <code>G</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.</dd></dl><p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br>For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br>Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>​0​</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:<br></p><ul><li> if <i>P > X ≥ −4</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P − 1 − X</i>.</li><li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P − 1</i>.</li></ul><p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left.For infinity and not-a-number conversion style see notes.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>n</code></th><td style="text-align:left;"><dl><dd>returns the <b>number of characters written</b> so far by this call to the function.</dd></dl><p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>.</p></td><td> <code>signed char*</code></td><td> <code>short*</code></td><td> <code>int*</code></td><td> <code>long*</code></td><td> <code>long long*</code></td><td> <code>intmax_t*</code></td><td> signed <code>size_t*</code></td><td> <code>ptrdiff_t*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>p</code></th><td style="text-align:left;"> writes an implementation defined character sequence defining a <b>pointer</b>.</td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>void*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr></table><p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p><p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p><p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p><p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p><p>The correct conversion specifications for the fixed-width character types (<code>int8_t</code>, etc) are defined in the header <inttypes.h> (although <code>PRIdMAX</code>, <code>PRIuMAX</code>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p><p>There is a sequence point after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable and printing the value stored by <code>%n</code> earlier within the same call.</p><p>If a conversion specification is invalid, the behavior is undefined.<br></p><p><br></p></td></tr><tr class="t-par"><td>  ...</td><td> -</td><td>  arguments specifying data to print</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1,2) number of characters transmitted to the output stream or negative value if an output error  or an encoding error (for string and character conversion specifiers) occurred</ul><ul>3) number of characters written to <code>buffer</code> (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred</ul><ul>4) number of characters (not including the terminating null character) which would have been written to <code>buffer</code> if <code>bufsz</code> was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred</ul><ul>5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.</ul><ul>7) number of characters written to <code>buffer</code>, not counting the null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX</code>), or zero on runtime constraint violations, and negative value on encoding errors</ul><ul>8) number of characters not including the terminating null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX</code>), which would have been written to <code>buffer</code> if <code>bufsz</code> was ignored, or a negative value if a runtime constraints violation or an encoding error occurred</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fprintf.html
fputc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int fputc( int ch, FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int putc( int ch, FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes a character <code>ch</code> to the given output stream <code>stream</code>. <code>putc()</code> may be implemented as a macro and evaluate <code>stream</code> more than once, so the corresponding argument should never be an expression with side effects. </p><p>Internally, the character is converted to <code>unsigned char</code> just before being written.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to be written</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  output stream</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns the written character.<br></p><p>On failure, returns <code>EOF</code> and sets the <i>error</i> indicator (see <code>ferror()</code>) on <code>stream</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fputc.html
fputs	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>int fputs( const char          *str, FILE          *stream );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int fputs( const char *restrict str, FILE *restrict stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes every character from the null-terminated string <code>str</code> to the output stream <code>stream</code>, as if by repeatedly executing <code>fputc</code>.</p><p>The terminating null character from <code>str</code> is not written.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  null-terminated character string to be written</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  output stream</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns a non-negative value<br></p><p>On failure, returns <code>EOF</code> and sets the <i>error</i> indicator (see <code>ferror()</code>) on <code>stream</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fputs.html
fputwc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl"><td> <code>wint_t fputwc( wchar_t ch, FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl"><td> <code>wint_t putwc( wchar_t ch, FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes a wide character <code>ch</code> to the given output stream <code>stream</code>. <code>putwc()</code> may be implemented as a macro and may evaluate <code>stream</code> more than once.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character to be written</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  the output stream</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>ch</code> on success, <code>WEOF</code> on failure. If an encoding error occurs, <code>errno</code> is set to <code>EILSEQ</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fputwc.html
fputws	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>int fputws( const wchar_t *str, FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) <br> <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int fputws( const wchar_t * restrict str, FILE * restrict stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes every character from the null-terminated wide string <code>str</code> to the output stream <code>stream</code>, as if by repeatedly executing <code>fputwc</code>.</p><p>The terminating null wide character from <code>str</code> is not written.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  null-terminated wide string to be written</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  output stream</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns a non-negative value<br></p><p>On failure, returns <code>EOF</code> and sets the <i>error</i> indicator (see <code>ferror</code>) on <code>stream</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fputws.html
fread	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>size_t fread( void          *buffer, size_t size, size_t count,<br>              FILE          *stream );<br></code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>size_t fread( void *restrict buffer, size_t size, size_t count, <br>              FILE *restrict stream );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads up to <code>count</code> objects into the array <code>buffer</code> from the given input stream <code>stream</code> as if by calling <code>fgetc</code> <code>size</code> times for each object, and storing the results, in the order obtained, into the successive positions of <code>buffer</code>, which is reinterpreted as an array of <code>unsigned char</code>. The file position indicator for the stream is advanced by the number of characters read.</p><p>If an error occurs, the resulting value of the file position indicator for the stream is<br>indeterminate. If a partial element is read, its value is indeterminate.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to the array where the read objects are stored</td></tr><tr class="t-par"><td>  size</td><td> -</td><td>  size of each object in bytes</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  the number of the objects to be read</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  the stream to read</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Number of objects read successfully, which may be less than <code>count</code> if an error or end-of-file condition occurs. </p><p>If <code>size</code> or <code>count</code> is zero, <code>fread</code> returns zero and performs no other action.</p><p><code>fread</code> does not distinguish between end-of-file and error, and callers must use <code>feof</code> and <code>ferror</code> to determine which occurred.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fread.html
freopen	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>FILE *freopen( const char *filename, const char *mode,<br>               FILE *stream );<br></code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>FILE *freopen( const char *restrict filename, const char *restrict mode, <br>               FILE *restrict stream );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t freopen_s(FILE *restrict *restrict newstreamptr,<br>                  const char *restrict filename, const char *restrict mode,<br>                  FILE *restrict stream);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) First, attempts to close the file associated with <code>stream</code>, ignoring any errors. Then, if <code>filename</code> is not null, attempts to open the file specified by <code>filename</code> using <code>mode</code> as if by <code>fopen</code>, and associates that file with the file stream pointed to by <code>stream</code>. If <code>filename</code> is a null pointer, then the function attempts to reopen the file that is already associated with <code>stream</code> (it is implementation defined which mode changes are allowed in this case).</ul><ul>2) Same as (1), except that <code>mode</code> is treated as in <code>fopen_s</code> and that the pointer to the file stream is written to <code>newstreamptr</code> and the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>newstreamptr</code> is a null pointer</li><li> <code>stream</code> is a null pointer</li><li> <code>mode</code> is a null pointer</li></ul></dd><dd>As all bounds-checked functions, <code>freopen_s</code> is only guaranteed to be available of <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><p><br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  filename</td><td> -</td><td>  file name to associate the file stream to</td></tr><tr class="t-par"><td>  mode</td><td> -</td><td>  null-terminated character string determining new file access mode<table class="wikitable"><tr><th> File access <br>mode string<br></th><th> Meaning</th><th> Explanation</th><th> Action if file <br> already exists<br></th><th> Action if file <br> does not exist<br></th></tr><tr><td> <code>"r"</code></td><td> read</td><td> Open a file for reading</td><td> read from start</td><td> failure to open</td></tr><tr><td> <code>"w"</code></td><td> write</td><td> Create a file for writing</td><td> destroy contents</td><td> create new</td></tr><tr><td> <code>"a"</code></td><td> append</td><td> Append to a file</td><td> write to end</td><td> create new</td></tr><tr><td> <code>"r+"</code></td><td> read extended</td><td> Open a file for read/write</td><td> read from start</td><td> error</td></tr><tr><td> <code>"w+"</code></td><td> write extended</td><td> Create a file for read/write</td><td> destroy contents</td><td> create new</td></tr><tr><td> <code>"a+"</code></td><td> append extended</td><td> Open a file for read/write</td><td> write to end</td><td> create new</td></tr><tr><td colspan="5"> File access mode flag <code>"b"</code> can optionally be specified to open a file in binary mode. This flag has effect only on Windows systems. <br> On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.<br></td></tr><tr><td colspan="5"> When a file is opened with update mode ('+' as the second or third character in the above list of mode argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the <code>fflush</code> function or to a file positioning function (<code>fseek</code>, <code>fsetpos</code>, or <code>rewind</code>), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end- of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.</td></tr><tr><td colspan="5"> File access mode flag <code>"x"</code> can optionally be appended to "w" or "w+" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. </td></tr><tr><td colspan="5"> When using <code>fopen_s</code> or <code>freopen_s</code>, file access permissions for any file created with "w" or "a" prevents other users from accessing it. File access mode flag <code>"u"</code> can optionally be prepended to any specifier that begins with "w" or "a", to enable the default <code>fopen</code> permissions. </td></tr></table></td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  the file stream to modify</td></tr><tr class="t-par"><td>  newstreamptr</td><td> -</td><td>  pointer to a pointer where the function stores the result (an out-parameter)</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) A copy of the value of <code>stream</code> on success, null pointer on failure.</ul><ul>2) zero on success (and a copy of the value of <code>stream</code> is written to <code>*newstreamptr</code>, non-zero on error (and null pointer is written to <code>*newstreamptr</code> unless <code>newstreamptr</code> is itself a null pointer).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/freopen.html
fscanf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>​int scanf( const char          *format, ... );​</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>​int scanf( const char *restrict format, ... );​</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(2)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>int fscanf( FILE          *stream, const char          *format, ... );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int fscanf( FILE *restrict stream, const char *restrict format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(3)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>int sscanf( const char          *buffer, const char          *format, ... );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int sscanf( const char *restrict buffer, const char *restrict format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>int scanf_s(const char *restrict format, ...);</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int fscanf_s(FILE *restrict stream, const char *restrict format, ...);</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int sscanf_s(const char *restrict buffer, const char *restrict format, ...);</code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads data from the a variety of sources, interprets it according to <code>format</code> and stores the results into given locations.</p><ul>1) reads the data from <code>stdin</code></ul><ul>2) reads the data from file stream <code>stream</code></ul><ul>3) reads the data from null-terminated character string <code>buffer</code>. Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fscanf</code></ul><ul>4-6) Same as (1-3), except that <code>%c</code>, <code>%s</code>, and <code>%[</code> conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> any of the arguments of pointer type is a null pointer</li><li> <code>format</code>, <code>stream</code>, or <code>buffer</code> is a null pointer</li><li> the number of characters that would be written by %c, %s, or %[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers</li><li> optionally, any other detectable error, such as unknown conversion specifier</li></ul></dd><dd>As all bounds-checked functions, <code>scanf_s</code>, <code>fscanf_s</code>, and <code>sscanf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  input file stream to read from</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a null-terminated character string to read from</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated character string specifying how to read the input.<p>The format string consists of <br></p><ul><li> non-whitespace multibyte characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li><li> whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling <tt>isspace</tt> in a loop). Note that there is no difference between <code>"\\n"</code>, <code>" "</code>, <code>"\\t\\t"</code>, or other whitespace in the format string.</li><li> conversion specifications. Each conversion specification has the following format:</li></ul><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) assignment-suppressing character <code>*</code>. If this option is present, the function does not assign the result of the conversion to any receiving argument.</li></ul></dd></dl><dl><dd><ul><li> (optional) integer number (greater than zero) that specifies <i>maximum field width</i>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided.</li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="1"> Conversion<br> specifier<br></th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p><br></p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p><br></p></th><th> <code>j</code><p><br></p></th><th> <code>z</code><p><br></p></th><th> <code>t</code><p><br></p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td style="text-align:left;"> matches literal <code>%</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td style="text-align:left;"><dl><dd> matches a <b>character</b> or a sequence of <b>characters</b></dd></dl><p>If a width specifier is used, matches exactly <i>width</i>  characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.</p></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="3"> <code>char*</code></td><td rowspan="3"> <code>wchar_t*</code></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td style="text-align:left;"><dl><dd> matches a sequence of non-whitespace characters (a <b>string</b>)</dd></dl><p>If width specifier is used, matches up to <i>width</i> or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>[</code><i>set</i><code>]</code></th><td style="text-align:left;"><dl><dd>matches a non-empty sequence of character from <i>set</i> of characters.</dd></dl><p>If the first character of the set is <code>^</code>, then all characters not in the set are matched. If the set begins with <code>]</code> or <code>^]</code> then the <code>]</code> character is also included into the set. It is implementation-defined whether the character <code>-</code> in the non-initial position in the scanset may be indicating a range, as in <code>[0-9]</code>. If width specifier is used, matches only up to <i>width</i>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>d</code></th><td style="text-align:left;"><dl><dd>matches a <b>decimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtol()</tt> with the value <code>10</code> for the <code>base</code> argument</p></td><td rowspan="6"> <code>signed char*</code> or <code>unsigned char*</code></td><td rowspan="6"> <code>signed short*</code> or <code>unsigned short*</code></td><td rowspan="6"> <code>signed int*</code> or <code>unsigned int*</code></td><td rowspan="6"> <code>signed long*</code> or <code>unsigned long*</code></td><td rowspan="6"> <code>signed long long*</code> or <code>unsigned long long*</code></td><td rowspan="6"> <code>intmax_t*</code> or <code>uintmax_t*</code></td><td rowspan="6"> <code>size_t*</code></td><td rowspan="6"> <code>ptrdiff_t*</code></td><td class="table-na" rowspan="6" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>i</code></th><td style="text-align:left;"><dl><dd>matches an <b>integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtol()</tt> with the value <code>​0​</code> for the <code>base</code> argument (base is determined by the first characters parsed)</p></td></tr><tr><th> <code>u</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>decimal integer</b>. </dd></dl><p>The format of the number is the same as expected by <tt>strtoul()</tt> with the value <code>10</code> for the <code>base</code> argument.</p></td></tr><tr><th> <code>o</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>octal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtoul()</tt> with the value <code>8</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>x</code>, <code>X</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>hexadecimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtoul()</tt> with the value <code>16</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>n</code></th><td style="text-align:left;"><dl><dd>returns the <b>number of characters read so far</b>.</dd></dl><p>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined<br></p></td></tr><tr><th> <code>a</code>, <code>A</code><br> <code>e</code>, <code>E</code><br> <code>f</code>, <code>F</code><br> <code>g</code>, <code>G</code><br></th><td style="text-align:left;"><dl><dd>matches a <b>floating-point number</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtof()</tt></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>float*</code></td><td> <code>double*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>long double*</code></td></tr><tr><th> <code>p</code></th><td style="text-align:left;"><dl><dd>matches implementation defined character sequence defining a <b>pointer</b>.</dd></dl><p><code>printf</code> family of functions should produce the same sequence using <code>%p</code> format specifier</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>void**</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr></table><p>For every conversion specifier other than <code>n</code>, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p><p>All conversion specifiers other than <code>[</code>, <code>c</code>, and <code>n</code> consume and discard all leading whitespace characters (determined as if by calling <tt>isspace</tt>) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</p><p>The conversion specifiers <code>lc</code>, <code>ls</code>, and <code>l[</code> perform multibyte-to-wide character conversion as if by calling <tt>mbrtowc()</tt> with an <tt>mbstate_t</tt> object initialized to zero before the first character is converted.</p><p>The conversion specifiers <code>s</code> and <code>[</code> always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width.</p><p>The correct conversion specifications for the fixed-width integer types (<code>int8_t</code>, etc) are defined in the header <inttypes.h> (although <tt>SCNdMAX</tt>, <tt>SCNuMAX</tt>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>There is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same "sink" variable.</p><p>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing <code>"100er"</code> with the conversion specifier <code>%f</code>, the sequence <code>"100e"</code> (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with <code>"r"</code> remaining. Existing implementations do not follow this rule and roll back to consume only <code>"100"</code>, leaving <code>"er"</code>, e.g. glibc bug 1765</p><p><br></p></td></tr><tr class="t-par"><td>  ...</td><td> -</td><td>  receiving arguments</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or <code>EOF</code> if input failure occurs before the first receiving argument was assigned.</ul><ul>4-6) Same as (1-3), except that <code>EOF</code> is also returned if there is a runtime constraint violation.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fscanf.html
fseek	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int fseek( FILE *stream, long offset, int origin );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Sets the file position indicator for the file stream <code>stream</code> to the value pointed to by <code>offset</code>.</p><p>If the <code>stream</code> is open in binary mode, the new position is exactly <code>offset</code> bytes measured from the beginning of the file if <code>origin</code> is <code>SEEK_SET</code>, from the current file position if <code>origin</code> is <code>SEEK_CUR</code>, and from the end of the file if <code>origin</code> is <code>SEEK_END</code>. Binary streams are not required to support <code>SEEK_END</code>, in particular if additional null bytes are output.</p><p>If the <code>stream</code> is open in text mode, the only supported values for <code>offset</code> are zero (which works with any <code>origin</code>) and a value returned by an earlier call to <code>ftell</code> on a stream associated with the same file (which only works with <code>origin</code> of <code>SEEK_SET</code>).</p><p>If the <code>stream</code> is wide-oriented, the restrictions of both text and binary streams apply (result of <code>ftell</code> is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</p><p>In addition to changing the file position indicator, <code>fseek</code> undoes the effects of <code>ungetc</code> and clears the end-of-file status, if applicable.</p><p>If a read or write error occurs, the error indicator for the stream (<code>ferror</code>) is set and the file position is unaffected.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to modify</td></tr><tr class="t-par"><td>  offset</td><td> -</td><td>  number of characters to shift the position relative to origin</td></tr><tr class="t-par"><td>  origin</td><td> -</td><td>  position to which <code>offset</code> is added. It can have one of the following values: <code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> upon success, nonzero value otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fseek.html
fsetpos	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int fsetpos( FILE *stream, const fpos_t *pos );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Sets the file position indicator and the multibyte parsing state (if any) for the file stream <code>stream</code> according to the value pointed to by <code>pos</code>. </p><p>Besides establishing new parse state and position, a call to this function undoes the effects of <code>ungetc</code> and clears the end-of-file state, if it is set.</p><p>If a read or write error occurs, the error indicator (<code>ferror</code>) for the stream is set.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to modify</td></tr><tr class="t-par"><td>  pos</td><td> -</td><td>  pointer to a <code>fpos_t</code> object to use as new value of file position indicator</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> upon success, nonzero value otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fsetpos.html
ftell	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>long ftell( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the file position indicator for the file stream <code>stream</code>. </p><p>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.<br></p><p>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to <code>fseek()</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to examine</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>File position indicator on success or <code>EOF</code> if failure occurs.</p><p>On error, the <code>errno</code> variable is set to implementation-defined positive value.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/ftell.html
fwide	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int fwide( FILE *stream, int mode );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>If <code>mode > 0</code>, attempts to make <code>stream</code> wide-oriented. If <code>mode < 0</code>, attempts to make <code>stream</code> byte-oriented. If <code>mode==0</code>, only queries the current orientation of the stream.</p><p>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  pointer to the C I/O stream to modify or query</td></tr><tr class="t-par"><td>  mode</td><td> -</td><td>  integer value greater than zero to set the stream wide, less than zero to set the stream narrow, or zero to query only</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fwide.html
fwprintf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int wprintf( const wchar_t *format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int wprintf( const wchar_t *restrict format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(2)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int fwprintf( FILE *stream, const wchar_t* format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int fwprintf( FILE *restrict stream,<br>              const wchar_t *restrict format, ... );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(3)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int swprintf( wchar_t *buffer, size_t bufsz,<br>              const wchar_t* format, ... );<br></code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int swprintf( wchar_t *restrict buffer, size_t bufsz,<br>              const wchar_t *restrict format, ... );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>int wprintf_s( const wchar_t *restrict format, ...);</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int fwprintf_s( FILE *restrict stream,<br>                const wchar_t *restrict format, ...);<br></code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int swprintf_s( wchar_t *restrict buffer, rsize_t bufsz,<br>                const wchar_t* restrict format, ...);<br></code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int snwprintf_s( wchar_t * restrict s, rsize_t n,<br>                 const wchar_t * restrict format, ...);<br></code></td><td> (7) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.<br></p><ul>1) Writes the results to <code>stdout</code>.</ul><ul>2) Writes the results to a file stream <code>stream</code>.</ul><ul>3) If <code>bufsz</code> is greater than zero, writes the results to a wide string <code>buffer</code>. At most <code>bufsz-1</code> wide characters are written followed by null wide character. If <code>bufsz</code> is zero, nothing is written (and <code>buffer</code> may be a null pointer), however the return value (number of wide characters that would be written) is still calculated and returned.</ul><ul>4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> the conversion specifier <code>%n</code> is present in <code>format</code></li><li> any of the arguments corresponding to <code>%s</code> is a null pointer</li><li> <code>format</code> or <code>buffer</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> encoding errors occur in any of string and character conversion specifiers</li><li> (only for <code>swprintf_s</code>) the number of wide characters to be written, including the null, would exceed <code>bufsz</code>.</li></ul></dd></dl></ul><ul>7) Same as (6), except it will truncate the result to fit within the array pointed to by s.<dl><dd>As all bounds-checked functions, <code>wprintf_s</code>, <code>wfprintf_s</code>, and <code>wsprintf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  output file stream to write to</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a wide character string to write to</td></tr><tr class="t-par"><td>  bufsz</td><td> -</td><td>  up to <code>bufsz-1</code> wide characters may be written, plus the null terminator</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated wide string specifying how to interpret the data.<p>The format string consists of ordinary wide characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) one or more flags that modify the behavior of the conversion:</li></ul><dl><dd><ul><li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified)</li><li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative)</li><li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present.</li><li> <code>#</code> : <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.</li><li> <code>0</code> : for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present.</li></ul></dd></dl></dd></dl><dl><dd><ul><li> (optional) integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.)</li></ul></dd></dl><dl><dd><ul><li> (optional) <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the argument</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="1"> Conversion<br> specifier<br></th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p><br></p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p><br></p></th><th> <code>j</code><p><br></p></th><th> <code>z</code><p><br></p></th><th> <code>t</code><p><br></p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td style="text-align:left;"> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td style="text-align:left;"><dl><dd> writes a <b>single character</b>.</dd></dl><p>The argument is first converted to <code>wchar_t</code> as if by calling <code>btowc</code>.If the <b>l</b> modifier is used, the <code>wint_t</code> argument is first converted to <code>wchar_t</code>.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>int</code></td><td> <code>wint_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td style="text-align:left;"><dl><dd> writes a <b>character string</b></dd></dl><p>The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to <code>mbrtowc</code> with zero-initialized conversion state.<i>Precision</i> specifies the maximum number of wide characters to be written. If <i>Precision</i> is not specified, writes every wide characters up to and not including the first null terminator.If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>char*</code></td><td> <code>wchar_t*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>d</code><br> <code>i</code><br></th><td style="text-align:left;"><dl><dd>converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br> If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.<br></p></td><td rowspan="1"> <code>signed char</code></td><td rowspan="1"> <code>short</code></td><td rowspan="1"> <code>int</code></td><td rowspan="1"> <code>long</code></td><td rowspan="1"> <code>long long</code></td><td rowspan="1"> <code>intmax_t</code></td><td rowspan="1"> signed <code>size_t</code></td><td rowspan="1"> <code>ptrdiff_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>o</code></th><td style="text-align:left;"><dl><dd>converts a <b>unsigned integer</b> into octal representation <i>oooo</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero.In that case if both the converted value and the precision are <code>​0​</code>, single <code>​0​</code> is written.</p></td><td rowspan="3"> <code>unsigned char</code></td><td rowspan="3"> <code>unsigned short</code></td><td rowspan="3"> <code>unsigned int</code></td><td rowspan="3"> <code>unsigned long</code></td><td rowspan="3"> <code>unsigned long long</code></td><td rowspan="3"> <code>uintmax_t</code></td><td rowspan="3"> <code>size_t</code></td><td rowspan="3"> unsigned version of <code>ptrdiff_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>x</code><br> <code>X</code><br></th><td style="text-align:left;"><dl><dd>converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.</dd></dl><p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br>For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>u</code></th><td style="text-align:left;"><dl><dd>converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>f</code><br> <code>F</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear after the decimal point character. The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="4"> <code>double</code></td><td rowspan="4"> <code>double</code> </td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="4"> <code>long double</code></td></tr><tr><th> <code>e</code> <br> <code>E</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the decimal exponent notation.</dd></dl><p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>±dd</i> is used.<br>For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>±dd</i> is used.<br>The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>​0​</code>, the exponent is also <code>​0​</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>a</code> <br> <code>A</code><p><br></p><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the hexadecimal exponent notation.</dd></dl><p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>±d</i> is used.<br>For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>±d</i> is used.<br>The first hexadecimal digit is <code>0</code> if the argument is not a normalized floating point value.If the value is <code>​0​</code>, the exponent is also <code>​0​</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is sufficient for exact representation of the value.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>g</code> <br> <code>G</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.</dd></dl><p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br>For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br>Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>​0​</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:<br></p><ul><li> if <i>P > X ≥ −4</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P − 1 − X</i>.</li><li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P − 1</i>.</li></ul><p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left.For infinity and not-a-number conversion style see notes.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>n</code></th><td style="text-align:left;"><dl><dd>returns the <b>number of characters written</b> so far by this call to the function.</dd></dl><p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>.</p></td><td> <code>signed char*</code></td><td> <code>short*</code></td><td> <code>int*</code></td><td> <code>long*</code></td><td> <code>long long*</code></td><td> <code>intmax_t*</code></td><td> signed <code>size_t*</code></td><td> <code>ptrdiff_t*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>p</code></th><td style="text-align:left;"> writes an implementation defined character sequence defining a <b>pointer</b>.</td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>void*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr></table><p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p><p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p><p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p><p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p><p>The correct conversion specifications for the fixed-width character types (<code>int8_t</code>, etc) are defined in the header <inttypes.h> (although <code>PRIdMAX</code>, <code>PRIuMAX</code>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p><p>There is a sequence point after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable and printing the value stored by <code>%n</code> earlier within the same call.</p><p>If a conversion specification is invalid, the behavior is undefined.<br></p><p><br></p></td></tr><tr class="t-par"><td>  ...</td><td> -</td><td>  arguments specifying data to print</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1,2) Number of wide characters written if successful or negative value if an error occurred.</ul><ul>3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than <code>size</code> (including when <code>size</code> is zero).</ul><ul>4,5) Number of wide characters written if successful or negative value if an error occurred.</ul><ul>6) Number of wide characters (not counting the terminating null) that were written to <code>buffer</code>. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.</ul><ul>7) Number of wide characters (not counting the terminating null) that would have been written to <code>buffer</code> had <code>bufsz</code> been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than <code>bufsz</code>)</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fwprintf.html
fwrite	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>size_t fwrite( const void *buffer, size_t size, size_t count,<br>               FILE *stream );<br></code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>size_t fwrite( const void *restrict buffer, size_t size, size_t count, <br>               FILE *restrict stream );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes <code>count</code> of objects from the given array <code>buffer</code> to the output stream <code>stream</code>. The objects are written as if by reinterepreting each object as an array of <code>unsigned char</code> and calling <code>fputc</code> <code>size</code> times for each object to write those <code>unsigned char</code>s into <code>stream</code>, in order. The file position indicator for the stream is advanced by the number of characters written.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to the first object in the array to be written</td></tr><tr class="t-par"><td>  size</td><td> -</td><td>  size of each object</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  the number of the objects to be written</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  pointer to the output stream</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The number of objects written successfully, which may be less than <code>count</code> if an error occurs.</p><p>If <code>size</code> or <code>count</code> is zero, <code>fwrite</code> returns zero and performs no other action.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fwrite.html
fwscanf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int wscanf( const wchar_t *format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int wscanf( const wchar_t *restrict format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(2)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int fwscanf( FILE *stream, const wchar_t *format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int fwscanf( FILE *restrict stream,<br>             const wchar_t *restrict format, ... );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(3)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int swscanf( const wchar_t *buffer, const wchar_t *format, ... );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int swscanf( const wchar_t *restrict buffer,<br>             const wchar_t *restrict format, ... );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>int wscanf_s( const wchar_t *restrict format, ...);</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int fwscanf_s( FILE *restrict stream,<br>               const wchar_t *restrict format, ...);<br></code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int swscanf_s( const wchar_t *restrict s,<br>               const wchar_t *restrict format, ...);<br></code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads data from the a variety of sources, interprets it according to <code>format</code> and stores the results into given locations.</p><ul>1) Reads the data from <code>stdin</code>.</ul><ul>2) Reads the data from file stream <code>stream</code>.</ul><ul>3) Reads the data from null-terminated wide string <code>buffer</code>. Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fwscanf</code></ul><ul>4-6) Same as (1-3), except that <code>%c</code>, <code>%s</code>, and <code>%[</code> conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> any of the arguments of pointer type is a null pointer</li><li> <code>format</code>, <code>stream</code>, or <code>buffer</code> is a null pointer</li><li> the number of characters that would be written by %c, %s, or %[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers</li><li> optionally, any other detectable error, such as unknown conversion specifier</li></ul></dd><dd>As all bounds-checked functions, <code>wscanf_s</code>, <code>fwscanf_s</code>, and <code>swscanf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><wchar.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  input file stream to read from</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a null-terminated wide string to read from</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated wide string specifying how to read the input. The format string consists of<ul><li> non-whitespace wide characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li><li> whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling <tt>iswspace</tt> in a loop). Note that there is no difference between <code>"\\n"</code>, <code>" "</code>, <code>"\\t\\t"</code>, or other whitespace in the format string.</li><li> conversion specifications. Each conversion specification has the following format:</li></ul><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) assignment-suppressing character <code>*</code>. If this option is present, the function does not assign the result of the conversion to any receiving argument.</li></ul></dd></dl><dl><dd><ul><li> (optional) integer number (greater than zero) that specifies <i>maximum field width</i>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided.</li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="1"> Conversion<br> specifier<br></th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p><br></p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p><br></p></th><th> <code>j</code><p><br></p></th><th> <code>z</code><p><br></p></th><th> <code>t</code><p><br></p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td style="text-align:left;"> matches literal <code>%</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td style="text-align:left;"><dl><dd> matches a <b>character</b> or a sequence of <b>characters</b></dd></dl><p>If a width specifier is used, matches exactly <i>width</i> wide characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.</p></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="3"> <code>char*</code></td><td rowspan="3"> <code>wchar_t*</code></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td style="text-align:left;"><dl><dd> matches a sequence of non-whitespace characters (a <b>string</b>)</dd></dl><p>If width specifier is used, matches up to <i>width</i> or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>[</code><i>set</i><code>]</code></th><td style="text-align:left;"><dl><dd>matches a non-empty sequence of character from <i>set</i> of characters.</dd></dl><p>If the first character of the set is <code>^</code>, then all characters not in the set are matched. If the set begins with <code>]</code> or <code>^]</code> then the <code>]</code> character is also included into the set. It is implementation-defined whether the character <code>-</code> in the non-initial position in the scanset may be indicating a range, as in <code>[0-9]</code>. If width specifier is used, matches only up to <i>width</i>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>d</code></th><td style="text-align:left;"><dl><dd>matches a <b>decimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstol()</tt> with the value <code>10</code> for the <code>base</code> argument</p></td><td rowspan="6"> <code>signed char*</code> or <code>unsigned char*</code></td><td rowspan="6"> <code>signed short*</code> or <code>unsigned short*</code></td><td rowspan="6"> <code>signed int*</code> or <code>unsigned int*</code></td><td rowspan="6"> <code>signed long*</code> or <code>unsigned long*</code></td><td rowspan="6"> <code>signed long long*</code> or <code>unsigned long long*</code></td><td rowspan="6"> <code>intmax_t*</code> or <code>uintmax_t*</code></td><td rowspan="6"> <code>size_t*</code></td><td rowspan="6"> <code>ptrdiff_t*</code></td><td class="table-na" rowspan="6" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>i</code></th><td style="text-align:left;"><dl><dd>matches an <b>integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstol()</tt> with the value <code>​0​</code> for the <code>base</code> argument (base is determined by the first characters parsed)</p></td></tr><tr><th> <code>u</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>decimal integer</b>. </dd></dl><p>The format of the number is the same as expected by <tt>wcstoul()</tt> with the value <code>10</code> for the <code>base</code> argument.</p></td></tr><tr><th> <code>o</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>octal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstoul()</tt> with the value <code>8</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>x</code>, <code>X</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>hexadecimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstoul()</tt> with the value <code>16</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>n</code></th><td style="text-align:left;"><dl><dd>returns the <b>number of characters read so far</b>.</dd></dl><p>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined<br></p></td></tr><tr><th> <code>a</code>, <code>A</code><br> <code>e</code>, <code>E</code><br> <code>f</code>, <code>F</code><br> <code>g</code>, <code>G</code><br></th><td style="text-align:left;"><dl><dd>matches a <b>floating-point number</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstof()</tt></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>float*</code></td><td> <code>double*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>long double*</code></td></tr><tr><th> <code>p</code></th><td style="text-align:left;"><dl><dd>matches implementation defined character sequence defining a <b>pointer</b>.</dd></dl><p><code>printf</code> family of functions should produce the same sequence using <code>%p</code> format specifier</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>void**</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr></table><p>For every conversion specifier other than <code>n</code>, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p><p>All conversion specifiers other than <code>[</code>, <code>c</code>, and <code>n</code> consume and discard all leading whitespace characters (determined as if by calling <tt>iswspace</tt>) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</p><p>If the length specifier <code>l</code> is not used, the conversion specifiers <code>c</code>, <code>s</code>, and <code>[</code> perform wide-to-multibyte character conversion as if by calling <tt>wcrtomb()</tt> with an <tt>mbstate_t</tt> object initialized to zero before the first character is converted.</p><p>The conversion specifiers <code>s</code> and <code>[</code> always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width.</p><p>The correct conversion specifications for the fixed-width integer types (<code>int8_t</code>, etc) are defined in the header <inttypes.h> (although <tt>SCNdMAX</tt>, <tt>SCNuMAX</tt>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>There is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same "sink" variable.</p><p>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing <code>"100er"</code> with the conversion specifier <code>%f</code>, the sequence <code>"100e"</code> (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with <code>"r"</code> remaining. Existing implementations do not follow this rule and roll back to consume only <code>"100"</code>, leaving <code>"er"</code>, e.g. glibc bug 1765</p><p><br></p></td></tr><tr class="t-par"><td>  ...</td><td> -</td><td>  receiving arguments</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1-3) Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned.</ul><ul>4-6) Same as (1-3), except that <code>EOF</code> is also returned if there is a runtime constraint violation.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/fwscanf.html
getchar	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int getchar(void);</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads the next character from <code>stdin</code>.</p><p>Equivalent to <code>getc(stdin)</code>.</p><h3><span class="prog__sub">Parameters</span></h3><p>(none)<br></p><h3><span class="prog__sub">Return value</span></h3><p>The obtained character on success or <code>EOF</code> on failure. </p><p>If the failure has been caused by end-of-file condition, additionally sets the <i>eof</i> indicator (see <code>feof()</code>) on <code>stdin</code>. If the failure has been caused by some other error, sets the <i>error</i> indicator (see <code>ferror()</code>) on <code>stdin</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/getchar.html
gets	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c11"><td> <code>char *gets( char *str );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>char *gets_s( char *str, rsize_t n );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(optional) <br></td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Reads <code>stdin</code> into the character array pointed to by <code>str</code> until a newline character is found or end-of-file occurs. A null character is written immediately after the last character read into the array. The newline character is discarded but not stored in the buffer.</ul><ul>2) Reads characters from <code>stdin</code> until a newline is found or end-of-file occurs. Writes only at most <code>n-1</code> characters into the array pointed to by <code>str</code>, and always writes the terminating null character (unless str is a null pointer). The newline character, if found, is discarded and does not count toward the number of characters written to the buffer.<dl><dd>The following errors are detected at runtime and call the currently installed constraint handler function:<ul><li> <code>n</code> is zero</li><li> <code>n</code> is greater than <code>RSIZE_MAX</code></li><li> <code>str</code> is a null pointer</li><li> endline or eof not encountered after storing <code>n-1</code> characters to the buffer.</li></ul></dd><dd>In any case, <code>gets_s</code> first finishes reading and discarding the characters from <code>stdin</code> until new-line character, end-of-file condition, or read error before calling the constraint handler.</dd><dd>As all bounds-checked functions, <code>gets_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  character string to be written</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>str</code> on success, <code>NULL</code> on failure.</p><p>If the failure has been caused by end of file condition, additionally sets the <i>eof</i> indicator (see <code>feof()</code>) on <code>stdin</code>. If the failure has been caused by some other error, sets the <i>error</i> indicator (see <code>ferror()</code>) on <code>stdin</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/gets.html
getwchar	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wint_t getwchar(void);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads the next wide character from <code>stdin</code>.</p><h3><span class="prog__sub">Parameters</span></h3><p>(none)<br></p><h3><span class="prog__sub">Return value</span></h3><p>the obtained wide character or <code>WEOF</code> if an error has occurred or the end of file reached</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/getwchar.html
perror	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void perror( const char *s );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Prints to <code>stderr</code> the contents of the null-terminated character string pointed to by <code>s</code> (unless <code>s</code> is a null pointer), followed by the two characters <code>": "</code>, followed by the implementation-defined error message describing the error code currently stored in the system variable <code>errno</code> (identical to the output of <code>strerror(errno)</code>), followed by <code>'\\n'</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  s</td><td> -</td><td>  pointer to a null-terminated string with explanatory message</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/perror.html
putchar	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int putchar( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes a character <code>ch</code> to <code>stdout</code>. Internally, the character is converted to <code>unsigned char</code> just before being written.</p><p>Equivalent to <code>putc(ch, stdout)</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to be written</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns the written character.<br></p><p>On failure, returns <code>EOF</code> and sets the <i>error</i> indicator (see <code>ferror()</code>) on <code>stdout</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/putchar.html
puts	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int puts( const char *str );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes every character from the null-terminated string <code>str</code> and one additional newline character <code>'\\n'</code> to the output stream <code>stdout</code>, as if by repeatedly executing <code>fputc</code>.</p><p>The terminating null character from <code>str</code> is not written.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  character string to be written</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns a non-negative value<br></p><p>On failure, returns <code>EOF</code> and sets the <i>error</i> indicator (see <code>ferror()</code>) on <code>stream</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/puts.html
putwchar	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wint_t putwchar( wchar_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Writes a wide character <code>ch</code> to <code>stdout</code></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character to be written</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>ch</code> on success, <code>WEOF</code> on failure.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/putwchar.html
remove	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int remove( const char *fname );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Deletes the file identified by character string pointed to by <code>fname</code>.</p><p>If the file is currently open by this or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name although the file system space is not reclaimed until the last running process closes the file; Windows does not allow the file to be deleted).<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  fname</td><td> -</td><td>  pointer to a null-terminated string containing the path identifying the file to delete</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> upon success or non-zero value on error.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/remove.html
rename	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int rename( const char *old_filename, const char *new_filename );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Changes the filename of a file. The file is identified by character string pointed to by <code>old_filename</code>. The new filename is identified by character string pointed to by <code>new_filename</code>.</p><p>If <code>new_filename</code> exists, the behavior is implementation-defined.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  old_filename</td><td> -</td><td>  pointer to a null-terminated string containing the path identifying the file to rename</td></tr><tr class="t-par"><td>  new_filename</td><td> -</td><td>  pointer to a null-terminated string containing the new path of the file</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> upon success or non-zero value on error.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/rename.html
rewind	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void rewind( FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Moves the file position indicator to the beginning of the given file stream. <br></p><p>The function is equivalent to <code>fseek(stream, 0, SEEK_SET);</code>, except that end-of-file and error indicators are cleared. </p><p>The function drops any effects from previous calls to <code>ungetc</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to modify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/rewind.html
setbuf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>void setbuf( FILE          *stream, char          *buffer );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>void setbuf( FILE *restrict stream, char *restrict buffer );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Sets the internal buffer to use for stream operations. It should be at least <code>BUFSIZ</code> characters long. </p><p>If <code>buffer</code> is not null, equivalent to <code>setvbuf(stream, buffer, _IOFBF, BUFSIZ)</code>.</p><p>If <code>buffer</code> is null, equivalent to <code>setvbuf(stream, NULL, _IONBF, 0)</code>, which turns off buffering.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  the file stream to set the buffer to</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a buffer for the stream to use. If <code>NULL</code> is supplied, the buffering is turned off</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>None.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/setbuf.html
setvbuf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>int setvbuf( FILE *         stream, char *         buffer, <br>             int mode, size_t size );<br></code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int setvbuf( FILE *restrict stream, char *restrict buffer, <br>             int mode, size_t size );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Changes the the buffering mode of the given file stream <code>stream</code> as indicated by the argument <code>mode</code>. In addition,</p><ul><li> If <code>buffer</code> is a null pointer, resizes of the internal buffer to <code>size</code>.</li><li> If <code>buffer</code> is not a null pointer, instructs the stream to use the user-provided buffer of size <code>size</code> beginning at <code>buffer</code>. The stream must be closed (with <code>fclose</code>) before the lifetime of the array pointed to by <code>buffer</code> ends. The contents of the array after a successful call to <code>setvbuf</code> are indeterminate and any attempt to use it is undefined behavior.</li></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  the file stream to set the buffer to or null pointer to change size and mode only</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a buffer for the stream to use</td></tr><tr class="t-par"><td>  mode</td><td> -</td><td> buffering mode to use. It can be one of the following values:<table class="wikitable"><tr><td> <code>_IOFBF</code></td><td> full buffering</td></tr><tr><td> <code>_IOLBF</code></td><td> line buffering</td></tr><tr><td> <code>_IONBF</code></td><td> no buffering</td></tr></table></td></tr><tr class="t-par"><td>  size</td><td> -</td><td>  size of the buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> on success or nonzero on failure.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/setvbuf.html
tmpfile	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>FILE *tmpfile(void);</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t tmpfile_s(FILE * restrict * restrict streamptr);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Creates and opens a temporary file. The file is opened as binary file for update (as if by <code>fopen</code> with <code>"wb+"</code> mode). The filename of the file is guaranteed to be unique within the filesystem. At least <code>TMP_MAX</code> files may be opened during the lifetime of a program (this limit may be shared with <code>tmpnam</code> and may be further limited by <code>FOPEN_MAX</code>).</ul><ul>2) Same as (1), except that at least <code>TMP_MAX_S</code> files may be opened (the limit may be shared with <code>tmpnam_s</code>), and if <code>streamptr</code> is a null pointer, the currently installed constraint handler function is called. <dl><dd>As all bounds-checked functions, <code>tmpfile_s</code> is only guaranteed to be available of <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><p>The temporary file created by this function is closed and deleted when the program exits normally. Whether it's deleted on abnormal termination is implementation-defined.<br></p><h3><span class="prog__sub">Parameters</span></h3><ul>1) (none)</ul><ul>2) pointer to a pointer that will be updated by this function call</ul><h3><span class="prog__sub">Return value</span></h3><ul>1) Pointer to the file stream associated with the file or null pointer if an error has occurred.</ul><ul>2) Zero if the file was created and open successfully, non-zero if the file was not created or open or if <code>streamptr</code> was a null pointer. In addition, pointer to the associated file stream is stored in <code>*streamptr</code> on success, and a null pointer value is stored in <code>*streamptr</code> on error.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/tmpfile.html
tmpnam	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>char *tmpnam( char *filename );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t tmpnam_s(char *filename_s, rsize_t maxsize);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Creates a unique valid file name (no longer than <code>L_tmpnam</code> in length) and stores it in character string pointed to by <code>filename</code>. The function is capable of generating up to <code>TMP_MAX</code> of unique filenames, but some or all of them may be in use in the filesystem and thus not suitable return values. </ul><ul>2) Same as (1), except that up to <code>TMP_MAX_S</code> names may be generated, no longer than <code>L_tmpnam_s</code> in length, and he following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>filename_s</code> is a null pointer</li><li> <code>maxsize</code> is greater than <code>RSIZE_MAX</code></li><li> <code>maxsize</code> is less than the generated file name string</li></ul></dd><dd>As all bounds-checked functions, <code>tmpnam_s</code> is only guaranteed to be available of <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><p><code>tmpnam</code> and <code>tmpnam_s</code> modify static state (which may be shared between these functions) and are not required to be thread-safe.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  filename</td><td> -</td><td>  pointer to the character array capable of holding at least <code>L_tmpnam</code> bytes, to be used as a result buffer. If null pointer is passed, a pointer to an internal static buffer is returned.</td></tr><tr class="t-par"><td>  filename_s</td><td> -</td><td>  pointer to the character array capable of holding at least <code>L_tmpnam_s</code> bytes, to be used as a result buffer.</td></tr><tr class="t-par"><td>  maxsize</td><td> -</td><td>  maximum number of characters the function is allowed to write (typically the size of the <code>filename_s</code> array).</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) <code>filename</code> if <code>filename</code> was not a null pointer. Otherwise a pointer to an internal static buffer is returned. If no suitable filename can be generated, null pointer is returned.</ul><ul>2) Returns zero and writes the file name to <code>filename_s</code> on success. On error, returns non-zero and writes the null character to <code>filename_s[0]</code> (only if <code>filename_s</code> is not null and <code>maxsize</code> is not zero and is not greater than <code>RSIZE_MAX</code>).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/tmpnam.html
ungetc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int ungetc( int ch, FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>If <code>ch</code> does not equal <code>EOF</code>, pushes the character <code>ch</code> (reinterpreted as <code>unsigned char</code>) into the input buffer associated with the stream <code>stream</code> in such a manner that subsequent read operation from <code>stream</code> will retrieve that character. The external device associated with the stream is not modified.</p><p>Stream repositioning operations <code>fseek</code>, <code>fsetpos</code>, and <code>rewind</code> discard the effects of <code>ungetc</code>.</p><p>If <code>ungetc</code> is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful <code>ungetc</code> were performed, read operations retrieve the pushed-back characters in reverse order of <code>ungetc</code></p><p>If <code>ch</code> equals <code>EOF</code>, the operation fails and the stream is not affected.</p><p>A successful call to <code>ungetc</code> clears the end of file status flag <code>feof</code>.</p><p>A successful call to <code>ungetc</code> on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</p><p>A successful call to <code>ungetc</code> on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before <code>ungetc</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to be pushed into the input stream buffer</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to put the character back to</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success <code>ch</code> is returned.</p><p>On failure <code>EOF</code> is returned and the given stream remains unchanged.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/ungetc.html
ungetwc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wint_t ungetwc( wint_t ch, FILE *stream );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>If <code>ch</code> does not equal <code>WEOF</code>, pushes the wide character <code>ch</code> into the input buffer associated with the stream <code>stream</code> in such a manner that subsequent read operation from <code>stream</code> will retrieve that wide character. The external device associated with the stream is not modified.</p><p>Stream repositioning operations <code>fseek</code>, <code>fsetpos</code>, and <code>rewind</code> discard the effects of <code>ungetwc</code>.</p><p>If <code>ungetwc</code> is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful <code>ungetwc</code> were performed, read operations retrieve the pushed-back wide characters in reverse order of <code>ungetwc</code></p><p>If <code>ch</code> equals <code>WEOF</code>, the operation fails and the stream is not affected.</p><p>A successful call to <code>ungetwc</code> clears the end of file status flag <code>feof</code>.</p><p>A successful call to <code>ungetwc</code> on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before <code>ungetwc</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character to be put back</td></tr><tr class="t-par"><td>  stream</td><td> -</td><td>  file stream to put the wide character back to</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success <code>ch</code> is returned.</p><p>On failure <code>WEOF</code> is returned and the given stream remains unchanged.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/ungetwc.html
vfprintf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>​int vprintf( const char *format, va_list vlist );​</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>​int vprintf( const char *restrict format, va_list vlist );​</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(2)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>int vfprintf( FILE *stream, const char *format, va_list vlist );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int vfprintf( FILE *restrict stream, const char *restrict format, <br>              va_list vlist );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(3)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>int vsprintf( char *buffer, const char *format, va_list vlist );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int vsprintf( char *restrict buffer, const char *restrict format, <br>              va_list vlist );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c99"><td> <code>int vsnprintf( char *restrict buffer, int bufsz, <br>               const char *restrict format, va_list vlist );<br></code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vprintf_s( const char *restrict format, va_list arg);</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vfprintf_s( FILE *restrict stream, const char *restrict format,<br>                va_list arg);<br></code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vsprintf_s( char *restrict buffer, rsize_t bufsz,<br>                const char *restrict format, va_list arg);<br></code></td><td> (7) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vsnprintf_s(char *restrict buffer, rsize_t bufsz,<br>                const char * restrict format, va_list arg);<br></code></td><td> (8) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Loads the data from the locations, defined by <code>vlist</code>, converts them to character string equivalents and writes the results to a variety of sinks.</p><ul>1) Writes the results to <code>stdout</code>.</ul><ul>2) Writes the results to a file stream <code>stream</code>.</ul><ul>3) Writes the results to a character string <code>buffer</code>.</ul><ul>4) Writes the results to a character string <code>buffer</code>. At most <code>buf_size</code> characters are written. The resulting character string will be terminated with a null character, unless <code>buf_size</code> is zero. If <code>buf_size</code> is zero, nothing is written and <code>buffer</code> may be a null pointer, however the return value (number of bytes that would be written) is still calculated and returned.</ul><ul>5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> the conversion specifier <code>%n</code> is present in <code>format</code></li><li> any of the arguments corresponding to <code>%s</code> is a null pointer</li><li> <code>format</code> or <code>buffer</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than <code>RSIZE_MAX</code></li><li> encoding errors occur in any of string and character conversion specifiers</li><li> (for <code>vsprintf_s</code> only), the string to be stored in <code>buffer</code> (including the trailing null)) would be exceed <code>bufsz</code></li></ul></dd><dd>As all bounds-checked functions, <code>vprintf_s</code>, <code>vfprintf_s</code>, <code>vsprintf_s</code>, and <code>vsnrintf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  output file stream to write to</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a character string to write to</td></tr><tr class="t-par"><td>  bufsz</td><td> -</td><td>  up to bufsz - 1 characters may be written, plus the null terminator</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated character string specifying how to interpret the data.<p>The format string consists of ordinary multibyte characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) one or more flags that modify the behavior of the conversion:</li></ul><dl><dd><ul><li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified)</li><li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative)</li><li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present.</li><li> <code>#</code> : <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.</li><li> <code>0</code> : for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present.</li></ul></dd></dl></dd></dl><dl><dd><ul><li> (optional) integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.)</li></ul></dd></dl><dl><dd><ul><li> (optional) <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the argument</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="1"> Conversion<br> specifier<br></th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p><br></p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p><br></p></th><th> <code>j</code><p><br></p></th><th> <code>z</code><p><br></p></th><th> <code>t</code><p><br></p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td style="text-align:left;"> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td style="text-align:left;"><dl><dd> writes a <b>single character</b>.</dd></dl><p>The argument is first converted to <code>unsigned char</code>.If the <b>l</b> modifier is used, the argument is first converted to a character string as if by <b>%ls</b> with a <code>wchar_t[2]</code> argument.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>int</code></td><td> <code>wint_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td style="text-align:left;"><dl><dd> writes a <b>character string</b></dd></dl><p>The argument must be a pointer to the initial element of an array of characters. <i>Precision</i> specifies the maximum number of bytes to be written. If <i>Precision</i> is not specified, writes every byte up to and not including the first null terminator.If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>, which is converted to char array as if by a call to <code>wcrtomb</code> with zero-initialized conversion state.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>char*</code></td><td> <code>wchar_t*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>d</code><br> <code>i</code><br></th><td style="text-align:left;"><dl><dd>converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br> If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.<br></p></td><td rowspan="1"> <code>signed char</code></td><td rowspan="1"> <code>short</code></td><td rowspan="1"> <code>int</code></td><td rowspan="1"> <code>long</code></td><td rowspan="1"> <code>long long</code></td><td rowspan="1"> <code>intmax_t</code></td><td rowspan="1"> signed <code>size_t</code></td><td rowspan="1"> <code>ptrdiff_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>o</code></th><td style="text-align:left;"><dl><dd>converts a <b>unsigned integer</b> into octal representation <i>oooo</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero.In that case if both the converted value and the precision are <code>​0​</code>, single <code>​0​</code> is written.</p></td><td rowspan="3"> <code>unsigned char</code></td><td rowspan="3"> <code>unsigned short</code></td><td rowspan="3"> <code>unsigned int</code></td><td rowspan="3"> <code>unsigned long</code></td><td rowspan="3"> <code>unsigned long long</code></td><td rowspan="3"> <code>uintmax_t</code></td><td rowspan="3"> <code>size_t</code></td><td rowspan="3"> unsigned version of <code>ptrdiff_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>x</code><br> <code>X</code><br></th><td style="text-align:left;"><dl><dd>converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.</dd></dl><p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br>For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>u</code></th><td style="text-align:left;"><dl><dd>converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>f</code><br> <code>F</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear after the decimal point character. The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="4"> <code>double</code></td><td rowspan="4"> <code>double</code> </td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="4"> <code>long double</code></td></tr><tr><th> <code>e</code> <br> <code>E</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the decimal exponent notation.</dd></dl><p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>±dd</i> is used.<br>For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>±dd</i> is used.<br>The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>​0​</code>, the exponent is also <code>​0​</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>a</code> <br> <code>A</code><p><br></p><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the hexadecimal exponent notation.</dd></dl><p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>±d</i> is used.<br>For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>±d</i> is used.<br>The first hexadecimal digit is <code>0</code> if the argument is not a normalized floating point value.If the value is <code>​0​</code>, the exponent is also <code>​0​</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is sufficient for exact representation of the value.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>g</code> <br> <code>G</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.</dd></dl><p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br>For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br>Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>​0​</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:<br></p><ul><li> if <i>P > X ≥ −4</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P − 1 − X</i>.</li><li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P − 1</i>.</li></ul><p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left.For infinity and not-a-number conversion style see notes.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>n</code></th><td style="text-align:left;"><dl><dd>returns the <b>number of characters written</b> so far by this call to the function.</dd></dl><p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>.</p></td><td> <code>signed char*</code></td><td> <code>short*</code></td><td> <code>int*</code></td><td> <code>long*</code></td><td> <code>long long*</code></td><td> <code>intmax_t*</code></td><td> signed <code>size_t*</code></td><td> <code>ptrdiff_t*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>p</code></th><td style="text-align:left;"> writes an implementation defined character sequence defining a <b>pointer</b>.</td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>void*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr></table><p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p><p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p><p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p><p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p><p>The correct conversion specifications for the fixed-width character types (<code>int8_t</code>, etc) are defined in the header <inttypes.h> (although <code>PRIdMAX</code>, <code>PRIuMAX</code>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p><p>There is a sequence point after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable and printing the value stored by <code>%n</code> earlier within the same call.</p><p>If a conversion specification is invalid, the behavior is undefined.<br></p><p><br></p></td></tr><tr class="t-par"><td>  vlist</td><td> -</td><td>  variable argument list containing the data to print</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1-3) The number of characters written if successful or negative value if an error occurred.</ul><ul>4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to <code>buf_size</code> limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed. </ul><ul>5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.</ul><ul>7) number of characters written to <code>buffer</code>, not counting the null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX</code>), or zero on runtime constraint violations, and negative value on encoding errors</ul><ul>8) number of characters not including the terminating null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX</code>), which would have been written to <code>buffer</code> if <code>bufsz</code> was ignored, or a negative value if a runtime constraints violation or an encoding error occurred</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/vfprintf.html
vfscanf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>​int vscanf( const char *restrict format, va_list vlist );​</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int vfscanf( FILE *restrict stream, const char *restrict format, <br>             va_list vlist );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int vsscanf( const char *restrict buffer, const char *restrict format, <br>             va_list vlist );<br></code></td><td> (3) </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>int vscanf_s(const char *restrict format, va_list vlist);</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vfscanf_s( FILE *restrict stream, const char *restrict format,<br>               va_list vlist);<br></code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vsscanf_s( const char *restrict buffer, const char *restrict format,<br>               va_list vlist);<br></code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads data from the a variety of sources, interprets it according to <code>format</code> and stores the results into locations defined by <code>vlist</code>.</p><ul>1) Reads the data from <code>stdin</code></ul><ul>2) Reads the data from file stream <code>stream</code></ul><ul>3) Reads the data from null-terminated character string <code>buffer</code>. Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fscanf</code></ul><ul>4-6) Same as (1-3), except that <code>%c</code>, <code>%s</code>, and <code>%[</code> conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a %c into a single char) and except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> any of the arguments of pointer type is a null pointer</li><li> <code>format</code>, <code>stream</code>, or <code>buffer</code> is a null pointer</li><li> the number of characters that would be written by %c, %s, or %[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers</li><li> optionally, any other detectable error, such as unknown conversion specifier</li></ul></dd><dd>As all bounds-checked functions, <code>vscanf_s</code>, <code>vfscanf_s</code>, and <code>vsscanf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><stdio.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  input file stream to read from</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a null-terminated character string to read from</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated character string specifying how to read the input.<p>The format string consists of <br></p><ul><li> non-whitespace multibyte characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li><li> whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling <tt>isspace</tt> in a loop). Note that there is no difference between <code>"\\n"</code>, <code>" "</code>, <code>"\\t\\t"</code>, or other whitespace in the format string.</li><li> conversion specifications. Each conversion specification has the following format:</li></ul><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) assignment-suppressing character <code>*</code>. If this option is present, the function does not assign the result of the conversion to any receiving argument.</li></ul></dd></dl><dl><dd><ul><li> (optional) integer number (greater than zero) that specifies <i>maximum field width</i>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided.</li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="1"> Conversion<br> specifier<br></th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p><br></p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p><br></p></th><th> <code>j</code><p><br></p></th><th> <code>z</code><p><br></p></th><th> <code>t</code><p><br></p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td style="text-align:left;"> matches literal <code>%</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td style="text-align:left;"><dl><dd> matches a <b>character</b> or a sequence of <b>characters</b></dd></dl><p>If a width specifier is used, matches exactly <i>width</i>  characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.</p></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="3"> <code>char*</code></td><td rowspan="3"> <code>wchar_t*</code></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td style="text-align:left;"><dl><dd> matches a sequence of non-whitespace characters (a <b>string</b>)</dd></dl><p>If width specifier is used, matches up to <i>width</i> or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>[</code><i>set</i><code>]</code></th><td style="text-align:left;"><dl><dd>matches a non-empty sequence of character from <i>set</i> of characters.</dd></dl><p>If the first character of the set is <code>^</code>, then all characters not in the set are matched. If the set begins with <code>]</code> or <code>^]</code> then the <code>]</code> character is also included into the set. It is implementation-defined whether the character <code>-</code> in the non-initial position in the scanset may be indicating a range, as in <code>[0-9]</code>. If width specifier is used, matches only up to <i>width</i>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>d</code></th><td style="text-align:left;"><dl><dd>matches a <b>decimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtol()</tt> with the value <code>10</code> for the <code>base</code> argument</p></td><td rowspan="6"> <code>signed char*</code> or <code>unsigned char*</code></td><td rowspan="6"> <code>signed short*</code> or <code>unsigned short*</code></td><td rowspan="6"> <code>signed int*</code> or <code>unsigned int*</code></td><td rowspan="6"> <code>signed long*</code> or <code>unsigned long*</code></td><td rowspan="6"> <code>signed long long*</code> or <code>unsigned long long*</code></td><td rowspan="6"> <code>intmax_t*</code> or <code>uintmax_t*</code></td><td rowspan="6"> <code>size_t*</code></td><td rowspan="6"> <code>ptrdiff_t*</code></td><td class="table-na" rowspan="6" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>i</code></th><td style="text-align:left;"><dl><dd>matches an <b>integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtol()</tt> with the value <code>​0​</code> for the <code>base</code> argument (base is determined by the first characters parsed)</p></td></tr><tr><th> <code>u</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>decimal integer</b>. </dd></dl><p>The format of the number is the same as expected by <tt>strtoul()</tt> with the value <code>10</code> for the <code>base</code> argument.</p></td></tr><tr><th> <code>o</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>octal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtoul()</tt> with the value <code>8</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>x</code>, <code>X</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>hexadecimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtoul()</tt> with the value <code>16</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>n</code></th><td style="text-align:left;"><dl><dd>returns the <b>number of characters read so far</b>.</dd></dl><p>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined<br></p></td></tr><tr><th> <code>a</code>, <code>A</code><br> <code>e</code>, <code>E</code><br> <code>f</code>, <code>F</code><br> <code>g</code>, <code>G</code><br></th><td style="text-align:left;"><dl><dd>matches a <b>floating-point number</b>.</dd></dl><p>The format of the number is the same as expected by <tt>strtof()</tt></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>float*</code></td><td> <code>double*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>long double*</code></td></tr><tr><th> <code>p</code></th><td style="text-align:left;"><dl><dd>matches implementation defined character sequence defining a <b>pointer</b>.</dd></dl><p><code>printf</code> family of functions should produce the same sequence using <code>%p</code> format specifier</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>void**</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr></table><p>For every conversion specifier other than <code>n</code>, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p><p>All conversion specifiers other than <code>[</code>, <code>c</code>, and <code>n</code> consume and discard all leading whitespace characters (determined as if by calling <tt>isspace</tt>) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</p><p>The conversion specifiers <code>lc</code>, <code>ls</code>, and <code>l[</code> perform multibyte-to-wide character conversion as if by calling <tt>mbrtowc()</tt> with an <tt>mbstate_t</tt> object initialized to zero before the first character is converted.</p><p>The conversion specifiers <code>s</code> and <code>[</code> always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width.</p><p>The correct conversion specifications for the fixed-width integer types (<code>int8_t</code>, etc) are defined in the header <inttypes.h> (although <tt>SCNdMAX</tt>, <tt>SCNuMAX</tt>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>There is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same "sink" variable.</p><p>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing <code>"100er"</code> with the conversion specifier <code>%f</code>, the sequence <code>"100e"</code> (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with <code>"r"</code> remaining. Existing implementations do not follow this rule and roll back to consume only <code>"100"</code>, leaving <code>"er"</code>, e.g. glibc bug 1765</p><p><br></p></td></tr><tr class="t-par"><td>  vlist</td><td> -</td><td>  variable argument list containing the receiving arguments</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1-3) Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned.</ul><ul>4-6) Same as (1-3), except that <code>EOF</code> is also returned if there is a runtime constraint violation.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/vfscanf.html
vfwprintf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int vwprintf( const wchar_t *format, va_list vlist );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int vwprintf( const wchar_t *restrict format, va_list vlist );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(2)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int vfwprintf( FILE* stream, const wchar_t *format, va_list vlist );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int vfwprintf( FILE *restrict stream,<br>               const wchar_t *restrict format, va_list vlist );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(3)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>int vswprintf( wchar_t *buffer, size_t bufsz,<br>               const wchar_t *format, va_list vlist );<br></code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>int vswprintf( wchar_t *restrict buffer, size_t bufsz,<br>               const wchar_t *restrict format, va_list vlist );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl"><td> <code>int vwprintf_s( const wchar_t *restrict format, va_list vlist);</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl"><td> <code>int vfwprintf_s( FILE * restrict stream,<br>                 const wchar_t *restrict format, va_list vlist);<br></code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl"><td> <code>int vswprintf_s( wchar_t *restrict buffer, rsize_t bufsz, <br>                 const wchar_t * restrict format, va_list vlist);<br></code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl"><td> <code>int vsnwprintf_s( wchar_t *restrict buffer, rsize_t bufsz,<br>                  const wchar_t *restrict format, va_list vlist);<br></code></td><td> (7) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Loads the data from locations, defined by <code>vlist</code>, converts them to wide string equivalents and writes the results to a variety of sinks.</p><ul>1) Writes the results to <code>stdout</code>.</ul><ul>2) Writes the results to a file stream <code>stream</code>.</ul><ul>3) Writes the results to a wide string <code>buffer</code>. At most <code>bufsz-1</code> wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless <code>bufsz</code> is zero.</ul><ul>4-7) Same as (1-3), except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> the conversion specifier <code>%n</code> is present in <code>format</code></li><li> any of the arguments corresponding to <code>%s</code> is a null pointer</li><li> <code>format</code> or <code>buffer</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> encoding errors occur in any of string and character conversion specifiers</li><li> (for <code>vswprintf_s</code> only), the string to be stored in <code>buffer</code> (including the trailing wide null)) would be exceed <code>bufsz</code></li></ul></dd></dl></ul><ul>8) Same as (7), except it will truncate the result to fit within the array pointed to by s.<dl><dd>As all bounds-checked functions, <code>vwprintf_s</code>, <code>vfwprintf_s</code>, <code>vswprintf_s</code>, and <code>vsnwprintf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><wchar.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  output wide stream to write to</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a wide string to write to</td></tr><tr class="t-par"><td>  bufsz</td><td> -</td><td>  maximum number of wide characters to write</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated wide string specifying how to interpret the data.<p>The format string consists of ordinary wide characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) one or more flags that modify the behavior of the conversion:</li></ul><dl><dd><ul><li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified)</li><li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative)</li><li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present.</li><li> <code>#</code> : <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.</li><li> <code>0</code> : for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present.</li></ul></dd></dl></dd></dl><dl><dd><ul><li> (optional) integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.)</li></ul></dd></dl><dl><dd><ul><li> (optional) <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the argument</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="1"> Conversion<br> specifier<br></th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p><br></p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p><br></p></th><th> <code>j</code><p><br></p></th><th> <code>z</code><p><br></p></th><th> <code>t</code><p><br></p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td style="text-align:left;"> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td style="text-align:left;"><dl><dd> writes a <b>single character</b>.</dd></dl><p>The argument is first converted to <code>wchar_t</code> as if by calling <code>btowc</code>.If the <b>l</b> modifier is used, the <code>wint_t</code> argument is first converted to <code>wchar_t</code>.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>int</code></td><td> <code>wint_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td style="text-align:left;"><dl><dd> writes a <b>character string</b></dd></dl><p>The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to <code>mbrtowc</code> with zero-initialized conversion state.<i>Precision</i> specifies the maximum number of wide characters to be written. If <i>Precision</i> is not specified, writes every wide characters up to and not including the first null terminator.If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>char*</code></td><td> <code>wchar_t*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>d</code><br> <code>i</code><br></th><td style="text-align:left;"><dl><dd>converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br> If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.<br></p></td><td rowspan="1"> <code>signed char</code></td><td rowspan="1"> <code>short</code></td><td rowspan="1"> <code>int</code></td><td rowspan="1"> <code>long</code></td><td rowspan="1"> <code>long long</code></td><td rowspan="1"> <code>intmax_t</code></td><td rowspan="1"> signed <code>size_t</code></td><td rowspan="1"> <code>ptrdiff_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>o</code></th><td style="text-align:left;"><dl><dd>converts a <b>unsigned integer</b> into octal representation <i>oooo</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero.In that case if both the converted value and the precision are <code>​0​</code>, single <code>​0​</code> is written.</p></td><td rowspan="3"> <code>unsigned char</code></td><td rowspan="3"> <code>unsigned short</code></td><td rowspan="3"> <code>unsigned int</code></td><td rowspan="3"> <code>unsigned long</code></td><td rowspan="3"> <code>unsigned long long</code></td><td rowspan="3"> <code>uintmax_t</code></td><td rowspan="3"> <code>size_t</code></td><td rowspan="3"> unsigned version of <code>ptrdiff_t</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>x</code><br> <code>X</code><br></th><td style="text-align:left;"><dl><dd>converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.</dd></dl><p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br>For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>u</code></th><td style="text-align:left;"><dl><dd>converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>​0​</code> the conversion results in no characters.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>f</code><br> <code>F</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear after the decimal point character. The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="4"> <code>double</code></td><td rowspan="4"> <code>double</code> </td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="4"> <code>long double</code></td></tr><tr><th> <code>e</code> <br> <code>E</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the decimal exponent notation.</dd></dl><p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>±dd</i> is used.<br>For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>±dd</i> is used.<br>The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>​0​</code>, the exponent is also <code>​0​</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>a</code> <br> <code>A</code><p><br></p><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to the hexadecimal exponent notation.</dd></dl><p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>±d</i> is used.<br>For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>±d</i> is used.<br>The first hexadecimal digit is <code>0</code> if the argument is not a normalized floating point value.If the value is <code>​0​</code>, the exponent is also <code>​0​</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is sufficient for exact representation of the value.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.<br></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>g</code> <br> <code>G</code><br></th><td style="text-align:left;"><dl><dd>converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.</dd></dl><p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br>For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br>Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>​0​</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:<br></p><ul><li> if <i>P > X ≥ −4</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P − 1 − X</i>.</li><li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P − 1</i>.</li></ul><p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left.For infinity and not-a-number conversion style see notes.</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>n</code></th><td style="text-align:left;"><dl><dd>returns the <b>number of characters written</b> so far by this call to the function.</dd></dl><p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>.</p></td><td> <code>signed char*</code></td><td> <code>short*</code></td><td> <code>int*</code></td><td> <code>long*</code></td><td> <code>long long*</code></td><td> <code>intmax_t*</code></td><td> signed <code>size_t*</code></td><td> <code>ptrdiff_t*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>p</code></th><td style="text-align:left;"> writes an implementation defined character sequence defining a <b>pointer</b>.</td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>void*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr></table><p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p><p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p><p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p><p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p><p>The correct conversion specifications for the fixed-width character types (<code>int8_t</code>, etc) are defined in the header <inttypes.h> (although <code>PRIdMAX</code>, <code>PRIuMAX</code>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p><p>There is a sequence point after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable and printing the value stored by <code>%n</code> earlier within the same call.</p><p>If a conversion specification is invalid, the behavior is undefined.<br></p><p><br></p></td></tr><tr class="t-par"><td>  vlist</td><td> -</td><td> variable argument list containing the data to print</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1-3) The number of wide characters written if successful or negative value if an error occurred.</ul><ul>4) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to <code>bufsz</code> limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed. </ul><ul>5,6) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.</ul><ul>7) number of wide characters written to <code>buffer</code>, not counting the null wide character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>), or zero on runtime constraint violations, and negative value on encoding errors</ul><ul>8) number of wide characters not including the terminating null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>), which would have been written to <code>buffer</code> if <code>bufsz</code> was ignored, or a negative value if a runtime constraints violation or an encoding error occurred</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/vfwprintf.html
vfwscanf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int vwscanf( const wchar_t *restrict format, va_list vlist );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int vfwscanf( FILE *restrict stream,<br>              const wchar_t *restrict format, va_list vlist );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int vswscanf( const wchar_t *restrict buffer,<br>              const wchar_t *restrict format, va_list vlist );<br></code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vwscanf_s( const wchar_t *restrict format, va_list vlist );</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vfwscanf_s( FILE *restrict stream,<br>                const wchar_t *restrict format, va_list vlist );<br></code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>int vswscanf_s( const wchar_t *restrict buffer,<br>                const wchar_t *restrict format, va_list vlist );<br></code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reads data from the a variety of sources, interprets it according to <code>format</code> and stores the results into locations defined by <code>vlist</code>.</p><ul>1) Reads the data from <code>stdin</code>.</ul><ul>2) Reads the data from file stream <code>stream</code>.</ul><ul>3) Reads the data from null-terminated wide string <code>buffer</code>. Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fwscanf</code></ul><ul>4-6) Same as (1-3), except that <code>%c</code>, <code>%s</code>, and <code>%[</code> conversion specifiers each expect two arguments (the usual pointer and a value of type <code>rsize_t</code> indicating the size of the receiving array, which may be 1 when reading with a %lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> any of the arguments of pointer type is a null pointer</li><li> <code>format</code>, <code>stream</code>, or <code>buffer</code> is a null pointer</li><li> the number of characters that would be written by %c, %s, or %[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers</li><li> optionally, any other detectable error, such as unknown conversion specifier</li></ul></dd><dd>As all bounds-checked functions, <code>vwscanf_s</code>, <code>vfwscanf_s</code>, and <code>vswscanf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code><wchar.h></code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  stream</td><td> -</td><td>  input file stream to read from</td></tr><tr class="t-par"><td>  buffer</td><td> -</td><td>  pointer to a null-terminated wide string to read from</td></tr><tr class="t-par"><td>  format</td><td> -</td><td>  pointer to a null-terminated wide string specifying how to read the input. The format string consists of<ul><li> non-whitespace wide characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li><li> whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling <tt>iswspace</tt> in a loop). Note that there is no difference between <code>"\\n"</code>, <code>" "</code>, <code>"\\t\\t"</code>, or other whitespace in the format string.</li><li> conversion specifications. Each conversion specification has the following format:</li></ul><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) assignment-suppressing character <code>*</code>. If this option is present, the function does not assign the result of the conversion to any receiving argument.</li></ul></dd></dl><dl><dd><ul><li> (optional) integer number (greater than zero) that specifies <i>maximum field width</i>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided.</li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="1"> Conversion<br> specifier<br></th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p><br></p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p><br></p></th><th> <code>j</code><p><br></p></th><th> <code>z</code><p><br></p></th><th> <code>t</code><p><br></p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td style="text-align:left;"> matches literal <code>%</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td style="text-align:left;"><dl><dd> matches a <b>character</b> or a sequence of <b>characters</b></dd></dl><p>If a width specifier is used, matches exactly <i>width</i> wide characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.</p></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td rowspan="3"> <code>char*</code></td><td rowspan="3"> <code>wchar_t*</code></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" rowspan="3" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td style="text-align:left;"><dl><dd> matches a sequence of non-whitespace characters (a <b>string</b>)</dd></dl><p>If width specifier is used, matches up to <i>width</i> or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>[</code><i>set</i><code>]</code></th><td style="text-align:left;"><dl><dd>matches a non-empty sequence of character from <i>set</i> of characters.</dd></dl><p>If the first character of the set is <code>^</code>, then all characters not in the set are matched. If the set begins with <code>]</code> or <code>^]</code> then the <code>]</code> character is also included into the set. It is implementation-defined whether the character <code>-</code> in the non-initial position in the scanset may be indicating a range, as in <code>[0-9]</code>. If width specifier is used, matches only up to <i>width</i>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>d</code></th><td style="text-align:left;"><dl><dd>matches a <b>decimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstol()</tt> with the value <code>10</code> for the <code>base</code> argument</p></td><td rowspan="6"> <code>signed char*</code> or <code>unsigned char*</code></td><td rowspan="6"> <code>signed short*</code> or <code>unsigned short*</code></td><td rowspan="6"> <code>signed int*</code> or <code>unsigned int*</code></td><td rowspan="6"> <code>signed long*</code> or <code>unsigned long*</code></td><td rowspan="6"> <code>signed long long*</code> or <code>unsigned long long*</code></td><td rowspan="6"> <code>intmax_t*</code> or <code>uintmax_t*</code></td><td rowspan="6"> <code>size_t*</code></td><td rowspan="6"> <code>ptrdiff_t*</code></td><td class="table-na" rowspan="6" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr><th> <code>i</code></th><td style="text-align:left;"><dl><dd>matches an <b>integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstol()</tt> with the value <code>​0​</code> for the <code>base</code> argument (base is determined by the first characters parsed)</p></td></tr><tr><th> <code>u</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>decimal integer</b>. </dd></dl><p>The format of the number is the same as expected by <tt>wcstoul()</tt> with the value <code>10</code> for the <code>base</code> argument.</p></td></tr><tr><th> <code>o</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>octal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstoul()</tt> with the value <code>8</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>x</code>, <code>X</code></th><td style="text-align:left;"><dl><dd>matches an unsigned <b>hexadecimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstoul()</tt> with the value <code>16</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>n</code></th><td style="text-align:left;"><dl><dd>returns the <b>number of characters read so far</b>.</dd></dl><p>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined<br></p></td></tr><tr><th> <code>a</code>, <code>A</code><br> <code>e</code>, <code>E</code><br> <code>f</code>, <code>F</code><br> <code>g</code>, <code>G</code><br></th><td style="text-align:left;"><dl><dd>matches a <b>floating-point number</b>.</dd></dl><p>The format of the number is the same as expected by <tt>wcstof()</tt></p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>float*</code></td><td> <code>double*</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>long double*</code></td></tr><tr><th> <code>p</code></th><td style="text-align:left;"><dl><dd>matches implementation defined character sequence defining a <b>pointer</b>.</dd></dl><p><code>printf</code> family of functions should produce the same sequence using <code>%p</code> format specifier</p></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td> <code>void**</code></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr></table><p>For every conversion specifier other than <code>n</code>, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p><p>All conversion specifiers other than <code>[</code>, <code>c</code>, and <code>n</code> consume and discard all leading whitespace characters (determined as if by calling <tt>iswspace</tt>) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</p><p>If the length specifier <code>l</code> is not used, the conversion specifiers <code>c</code>, <code>s</code>, and <code>[</code> perform wide-to-multibyte character conversion as if by calling <tt>wcrtomb()</tt> with an <tt>mbstate_t</tt> object initialized to zero before the first character is converted.</p><p>The conversion specifiers <code>s</code> and <code>[</code> always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width.</p><p>The correct conversion specifications for the fixed-width integer types (<code>int8_t</code>, etc) are defined in the header <inttypes.h> (although <tt>SCNdMAX</tt>, <tt>SCNuMAX</tt>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>There is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same "sink" variable.</p><p>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing <code>"100er"</code> with the conversion specifier <code>%f</code>, the sequence <code>"100e"</code> (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with <code>"r"</code> remaining. Existing implementations do not follow this rule and roll back to consume only <code>"100"</code>, leaving <code>"er"</code>, e.g. glibc bug 1765</p><p><br></p></td></tr><tr class="t-par"><td>  vlist</td><td> -</td><td>  variable argument list containing the receiving arguments</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1-3) Number of receiving arguments successfully assigned, or <code>EOF</code> if read failure occurs before the first receiving argument was assigned.</ul><ul>4-6) Same as (1-3), except that <code>EOF</code> is also returned if there is a runtime constraint violation.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/io/vfwscanf.html
_Alignas	A										<section class="prog__container"><p>Appears in the declaration syntax as one of the type specifiers to modify the alignment requirement of the object being declared.</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Alignas</code> <code>(</code> <i>expression</i> <code>)</code></td><td> (1)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Alignas</code> <code>(</code> <i>type</i> <code>)</code></td><td> (2)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any integer constant expression whose value is a valid alignment or zero</td></tr><tr class="t-par"><td> <i>type</i></td><td> -</td><td>  any type name</td></tr></table><p>This keyword is also available as convenience macro <tt>alignas</tt>, available in the header <code><stdalign.h></code>.</p><h3><span class="prog__sub">Explanation</span></h3><p>The alignas specifier can only be used when declaring objects that aren't bit fields, and don't have the register storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.</p><p>When used in a declaration, the declared object will have its alignment requirement set to </p><ul>1) the result of the <i>expression</i>, unless it is zero</ul><ul>2) to the alignment requirement of <i>type</i>, that is, to <code>alignof(type)</code></ul><p>except when this would weaken the alignment the type would have had naturally.<br></p><p>If <i>expression</i> evaluates to zero, this specifier has no effect.</p><p>When multiple alignas specifiers appear in the same declaration, the strictest one is used.<br></p><p>Alignas specifier only needs to appear on the definition of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/_Alignas.html
_Alignof	A										<section class="prog__container"><p>Queries the alignment requirement of its operand type.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Alignof(</code> <i>type-name</i> <code>)</code></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>This operator is typically used through the convenience macro <tt>alignof</tt>, which is provided in the header <code>stdalign.h</code></p><h3><span class="prog__sub">Explanation</span></h3><p>Returns the alignment requirement of the type named by <i>type-name</i>. If <i>type-name</i> is an array type, the result is the alignment requirement of the array element type. The <i>type-name</i> cannot be function type or an incomplete type.</p><p>The result is an integer constant of type <code>size_t</code>.</p><p>The operand is not evaluated (so external identifiers used in the operand do not have to be defined)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/_Alignof.html
_Noreturn	A										<section class="prog__container"><p>Specifies that the function does not return to its point of invocation.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Noreturn</code> <i>function_declaration</i></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The <code>_Noreturn</code> keyword appears in a function declaration and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing <code>longjmp</code>). If the function declared <code>_Noreturn</code> returns, the behavior is undefined. A compiler diagnostic is recommended if this can be detected.</p><p>The <code>_Noreturn</code> specifier may appear more than once in the same function declaration, the behavior is the same as if it appeared once.</p><p>This specifier is typically used through the convenience macro <tt>noreturn</tt>, which is provided in the header <code>stdnoreturn.h</code></p><h3><span class="prog__sub">Keywords</span></h3><p><tt>_Noreturn</tt></p><h3><span class="prog__sub">Standard library</span></h3><p>The following functions are <code>noreturn</code> in the standard library:</p><ul><li> <code>abort()</code></li><li> <code>exit()</code></li><li> <code>_Exit()</code></li><li> <code>quick_exit()</code></li><li> <code>thrd_exit()</code></li><li> <code>longjmp()</code></li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/_Noreturn.html
_Static_assert	A										<section class="prog__container"><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Static_assert</code> <code>(</code> <i>expression</i> <code>,</code> <i>message</i> <code>)</code></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any integer constant expression</td></tr><tr class="t-par"><td> <i>message</i></td><td> -</td><td>  any string literal</td></tr></table><p>This keyword is also available as convenience macro <tt>static_assert</tt>, available in the header <code><assert.h></code>.</p><h3><span class="prog__sub">Explanation</span></h3><p>The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display <i>message</i> as part of the error message (except that characters not in basic source character set aren't required to be displayed).</p><p>Otherwise, if <i>expression</i> does not equal zero, nothing happens; no code is emitted.</p><h3><span class="prog__sub">Keywords</span></h3><p><tt>_Static_assert</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/_Static_assert.html
alignas	A										<section class="prog__container"><p>Appears in the declaration syntax as one of the type specifiers to modify the alignment requirement of the object being declared.</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Alignas</code> <code>(</code> <i>expression</i> <code>)</code></td><td> (1)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Alignas</code> <code>(</code> <i>type</i> <code>)</code></td><td> (2)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any integer constant expression whose value is a valid alignment or zero</td></tr><tr class="t-par"><td> <i>type</i></td><td> -</td><td>  any type name</td></tr></table><p>This keyword is also available as convenience macro <tt>alignas</tt>, available in the header <code><stdalign.h></code>.</p><h3><span class="prog__sub">Explanation</span></h3><p>The alignas specifier can only be used when declaring objects that aren't bit fields, and don't have the register storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.</p><p>When used in a declaration, the declared object will have its alignment requirement set to </p><ul>1) the result of the <i>expression</i>, unless it is zero</ul><ul>2) to the alignment requirement of <i>type</i>, that is, to <code>alignof(type)</code></ul><p>except when this would weaken the alignment the type would have had naturally.<br></p><p>If <i>expression</i> evaluates to zero, this specifier has no effect.</p><p>When multiple alignas specifiers appear in the same declaration, the strictest one is used.<br></p><p>Alignas specifier only needs to appear on the definition of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/alignas.html
alignof	A										<section class="prog__container"><p>Queries the alignment requirement of its operand type.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Alignof(</code> <i>type-name</i> <code>)</code></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>This operator is typically used through the convenience macro <tt>alignof</tt>, which is provided in the header <code>stdalign.h</code></p><h3><span class="prog__sub">Explanation</span></h3><p>Returns the alignment requirement of the type named by <i>type-name</i>. If <i>type-name</i> is an array type, the result is the alignment requirement of the array element type. The <i>type-name</i> cannot be function type or an incomplete type.</p><p>The result is an integer constant of type <code>size_t</code>.</p><p>The operand is not evaluated (so external identifiers used in the operand do not have to be defined)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/alignof.html
analyzability	A										<section class="prog__container"><p>This optional extension to the C language limits the potential results of executing some forms of undefined behavior, which improves the effectiveness of static analysis of such programs. Analyzability is only guaranteed to be enabled if the predefined macro constant <code>__STDC_ANALYZABLE__</code> is defined by the compiler.</p><p>If the compiler supports analyzability, any language or library construct whose behavior is undefined is further classified between <i>critical</i> and <i>bounded</i> undefined behavior, and the behavior of all bounded UB cases is limited as specified below. </p><h3><span class="prog__sub">Critical undefined behavior</span></h3><p>Critical UB is undefined behavior that might perform a memory write or a volatile memory read out of bounds of any object. A program that has critical undefined behavior may be susceptible to security exploits.<br></p><p>Only the following undefined behaviors are critical:<br></p><ul><li> access to an object outside of its lifetime (e.g. through a dangling pointer)</li><li> write to an object whose declarations are not compatible</li><li> function call through a function pointer whose type is not compatible with the type of the function it points to</li><li> lvalue expression is evaluated, but does not designate an object</li><li> attempted modification of a string literal</li><li> dereferencing an invalid (null, indeterminate, etc) or  past-the-end pointer</li><li> modification of a const object through a non-const pointer</li><li> call to a standard library function or macro with an invalid argument</li><li> call to a variadic standard library function with unexpected argument type (e.g. call to <code>printf</code> with an argument of the type that doesn't match its conversion specifier)</li><li> <code>longjmp</code> where there is no <code>setjmp</code> up the calling scope, across threads, or from within the scope of a VM type.</li><li> any use of the pointer that was deallocated by <code>free</code> or <code>realloc</code></li><li> any string or wide string library function accesses an array out of bounds</li></ul><h3><span class="prog__sub">Bounded undefined behavior</span></h3><p>Bounded UB is undefined behavior that cannot perform an illegal memory write, although it may trap and may produce or store indeterminate values.<br></p><ul><li> All undefined behavior not listed as critical is bounded, including</li></ul><dl><dd><ul><li> multithreaded data races</li><li> use of a indeterminate values with automatic storage duration</li><li> strict aliasing violations</li><li> misaligned object access</li><li> signed integer overflow</li><li> unsequenced side-effects modify the same scalar or modify and read the same scalar</li><li> floating-to-integer or pointer-to-integer conversion overflow</li><li> bitwise shift by a negative or too large bit count</li><li> integer division by zero</li><li> use of a void expression</li><li> direct assignment or <code>memcpy</code> of inexactly-overlapped objects</li><li> restrict violations</li><li> etc.. ALL undefined behavior that's not in the critical list.</li></ul></dd></dl><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/analyzability.html
arithmetic_types	A										<section class="prog__container"><p><small>(See also type for type system overview and  the list of type-related utilities that are provided by the C library)</small></p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><h3><span class="prog__sub"> Boolean type</span></h3><dl><dd><ul><li> <code>_Bool</code> (also accessible as the macro bool) - type, capable of holding one of the two values: 1 and 0 (also accessible as the macros true and false).</li></ul></dd></dl><p>Note that conversion to _Bool does not work the same as conversion to other integer types: <code>(bool)0.5</code> evaluates to <code>1</code>, whereas <code>(int)0.5</code> evaluates to <code>​0​</code>.</p></td><td></td></tr></table><h3><span class="prog__sub">Character types</span></h3><dl><dd><ul><li><code>signed char</code> - type for signed character representation.</li><li><code>unsigned char</code> - type for unsigned character representation. Also used to inspect object representations (raw memory).</li><li><code>char</code> - type for character representation. Equivalent to either <code>signed char</code> or <code>unsigned char</code> (which one is implementation-defined and may be controlled by a compiler commandline switch), but <code>char</code> is a distinct type, different from both <code>signed char</code> both <code>unsigned char</code></li></ul></dd></dl><p>Note that the standard library also defines typedef names wchar_t <span>, char16_t, and char32_t</span> <span></span> to represent wide characters.</p><h3><span class="prog__sub">Integer types</span></h3><dl><dd><ul><li><code>short int</code> (also accessible as <code>short</code>, may use the keyword <code>signed</code>)</li><li><code>unsigned short int</code> (also accessible as <code>unsigned short</code>)</li><li><code>int</code> (also accessible as <code>signed int</code>)</li></ul><dl><dd> This is the most optimal integer type for the platform, and is guaranteed to be at least 16 bits. Most current systems use 32 bits (see Data models below).</dd></dl><ul><li><code>unsigned int</code> (also accessible as <code>unsigned</code>), the unsigned counterpart of <code>int</code>,  implementing modulo arithmetic. Suitable for bit manipulations.</li><li><code>long int</code> (also accessible as <code>long</code>)</li><li><code>unsigned long int</code> (also accessible as <code>unsigned long</code>)</li></ul></dd></dl><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><dl><dd><ul><li><code>long long int</code> (also accessible as <code>long long</code>)</li><li><code>unsigned long long int</code> (also accessible as <code>unsigned long long</code>)</li></ul></dd></dl></td><td></td></tr></table><p>Note: as with all type specifiers, any order is permitted: <code>unsigned long long int</code> and <code>long int unsigned long</code> name the same type.</p><p>The following table summarizes all available integer types and their properties:<br></p><table class="wikitable" style="text-align:center;"><tr><th rowspan="2"> Type specifier</th><th rowspan="2"> Equivalent type</th><th colspan="5"> Width in bits by data model</th></tr><tr><th> C standard</th><th> LP32</th><th> ILP32</th><th> LLP64</th><th> LP64</th></tr><tr><td> <code>short</code></td><td rowspan="4"> <code>short int</code></td><td rowspan="6"> at least<br> <b>16</b><br></td><td rowspan="6"> <b>16</b></td><td rowspan="6"> <b>16</b></td><td rowspan="6"> <b>16</b></td><td rowspan="6"> <b>16</b></td></tr><tr><td> <code>short int</code></td></tr><tr><td> <code>signed short</code></td></tr><tr><td> <code>signed short int</code></td></tr><tr><td> <code>unsigned short</code></td><td rowspan="2"> <code>unsigned short int</code></td></tr><tr><td> <code>unsigned short int</code></td></tr><tr><td> <code>int</code></td><td rowspan="3"> <code>int</code></td><td rowspan="5"> at least<br> <b>16</b><br></td><td rowspan="5"> <b>16</b></td><td rowspan="5"> <b>32</b></td><td rowspan="5"> <b>32</b></td><td rowspan="5"> <b>32</b></td></tr><tr><td> <code>signed</code></td></tr><tr><td> <code>signed int</code></td></tr><tr><td> <code>unsigned</code></td><td rowspan="2"> <code>unsigned int</code></td></tr><tr><td> <code>unsigned int</code></td></tr><tr><td> <code>long</code></td><td rowspan="4"> <code>long int</code></td><td rowspan="6"> at least<br> <b>32</b><br></td><td rowspan="6"> <b>32</b></td><td rowspan="6"> <b>32</b></td><td rowspan="6"> <b>32</b></td><td rowspan="6"> <b>64</b></td></tr><tr><td> <code>long int</code></td></tr><tr><td> <code>signed long</code></td></tr><tr><td> <code>signed long int</code></td></tr><tr><td> <code>unsigned long</code></td><td rowspan="2"> <code>unsigned long int</code></td></tr><tr><td> <code>unsigned long int</code></td></tr><tr><td> <code>long long</code></td><td rowspan="4"> <code>long long int</code> <br> <br></td><td rowspan="6"> at least<br> <b>64</b><br></td><td rowspan="6"> <b>64</b></td><td rowspan="6"> <b>64</b></td><td rowspan="6"> <b>64</b></td><td rowspan="6"> <b>64</b></td></tr><tr><td> <code>long long int</code></td></tr><tr><td> <code>signed long long</code></td></tr><tr><td> <code>signed long long int</code></td></tr><tr><td> <code>unsigned long long</code></td><td rowspan="2"> <code>unsigned long long int</code> <br> <br></td></tr><tr><td> <code>unsigned long long int</code></td></tr></table><p>Besides the minimal bit counts, the C Standard guarantees that<br></p><dl><dd><code>1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)</code>.</dd></dl><p>Note: this allows the extreme case in which bytes are sized 64 bits, all types (including <code>char</code>) are 64 bits wide, and <code>sizeof</code> returns 1 for every type.</p><p>Note: integer arithmetic is defined differently for the signed and unsigned integer types. See arithmetic operators, in particular  integer overflows.</p><h4>Data models</h4><p>The choices made by each implementation about the sizes of the fundamental types are collectively known as <i>data model</i>. Four data models found wide acceptance:</p><p>32 bit systems:<br></p><dl><dd><ul><li><b>LP32</b> or <b>2/4/4</b> (int is 16-bit, long and pointer are 32-bit)</li></ul><dl><dd><ul><li> Win16 API</li></ul></dd></dl><ul><li><b>ILP32</b> or <b>4/4/4</b> (int, long, and pointer are 32-bit);</li></ul><dl><dd><ul><li> Win32 API</li><li> Unix and Unix-like systems (Linux, Mac OS X)</li></ul></dd></dl></dd></dl><p>64 bit systems:<br></p><dl><dd><ul><li> <b>LLP64</b> or <b>4/4/8</b> (int and long are 32-bit, pointer is 64-bit)</li></ul><dl><dd><ul><li> Win64 API</li></ul></dd></dl><ul><li> <b>LP64</b> or <b>4/8/8</b> (int is 32-bit, long and pointer are 64-bit)</li></ul><dl><dd><ul><li> Unix and Unix-like systems (Linux, Mac OS X)</li></ul></dd></dl></dd></dl><p>Other models are very rare. For example, <b>ILP64</b> (<b>8/8/8</b>: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).</p><p>Note that exact-width integer types are available in <stdint.h> since C99</p><h3><span class="prog__sub">Real floating types</span></h3><p>C has three types for representing real floating-point values:<br></p><dl><dd><ul><li><code>float</code> - single precision floating point type. Matches IEEE-754 32 bit floating point type if supported.</li><li><code>double</code> - double precision floating point type. Matches IEEE-754 64 bit floating point type if supported</li><li><code>long double</code> - extended precision floating point type. Matches IEEE-754 extended floating-point type if supported, otherwise matches some non-standard extended floating-point type as long as its precision is better than <code>double</code> and range is at least as good as <code>double</code>, otherwise matches the type <code>double</code>. Some x86 and x86_64 implementations use the 80-bit x87 floating point type.</li></ul></dd></dl><p>Floating-point types may support special values:<br></p><ul><li> <i>infinity</i> (positive and negative), see <tt>INFINITY</tt></li><li> the <i>negative zero</i>, <code>-0.0</code>. It compares equal to the positive zero, but is meaningful in some arithmetic operations, e.g. <code>1.0/0.0 == INFINITY</code>, but <code>1.0/-0.0 == -INFINITY</code>)</li><li> <i>not-a-number</i> (NaN), which does not compare equal with anything (including itself). Multiple bit patterns represent NaNs, see <code>nan</code>, <tt>NAN</tt>. Note that C takes no special notice of signalling NaNs (specified by IEEE-754), and treates all NaNs as quiet.</li></ul><p>Real floating-point numbers may be used with arithmetic operators + - / * and various mathematical functions from math.h. Both built-in operators and library functions may raise floating-point exceptions and set <code>errno</code> as described in <tt>math_errhandling</tt></p><p>Floating-point expressions may have greater range and precision than indicated by their types, see <code>FLT_EVAL_METHOD</code>. Assignment, return, and cast force the range and precision to the one associated with the declared type. </p><p>Floating-point expressions may also be <i>contracted</i>, that is, calculated as if all intermediate values have infinite range and precision, see #pragma STDC FP_CONTRACT.</p><p>Some operations on floating-point numbers are affected by and modify the state of the floating-point environment (most notably, the rounding direction)</p><p>Implicit conversions are defined between real floating types and integer, complex, and imaginary types.</p><p>See Limits of floating point types and the math.h library for additional details, limits, and properties of the floating-point types.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><h3><span class="prog__sub"> Complex floating types</span></h3><p>Complex floating types model the mathematical complex numbers, that is the numbers that can be written as a sum of a real number and a real number multiplied by the imaginary unit: a + bi</p><p>The three complex types are<br></p><dl><dd><ul><li> <code>float _Complex</code> (also available as <code>float complex</code> if <complex.h> is included)</li><li> <code>double _Complex</code> (also available as <code>double complex</code> if <complex.h> is included)</li><li> <code>long double _Complex</code> (also available as <code>long double complex</code> if <complex.h> is included)</li></ul></dd></dl><p>Note: as with all type specifiers, any order is permitted: <code>long double complex</code>, <code>complex long double</code>, and even <code>double complex long</code> name the same type.</p>Run this code<pre><code>#include <complex.h>#include <stdio.h>int main(void){    double complex z = 1 + 2*I;    z = 1/z;    printf("1/(1.0+2.0i) = %.1f%+.1fi\\n", creal(z), cimag(z));}</code></pre><p>Output:<br></p><pre><code>1/(1.0+2.0i) = 0.2-0.4i</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td>If the macro constant <code>__STDC_NO_COMPLEX__</code> is defined by the implementation, the complex types (as well as the library header <code><complex.h></code>) are not provided.</td><td></td></tr></table><p>Each complex type has the same object representation and alignment requirements as an array of two elements of the corresponding real type (<code>float</code> for <code>float complex</code>, <code>double</code> for <code>double complex</code>, <code>long double</code> for <code>long double complex</code>). The first element of the array holds the real part, and the second element of the array holds the imaginary component.</p><pre><code>float a[4] = {1, 2, 3, 4};float complex z1, z2;memcpy(&amp;z1, a, sizeof z1); // z1 becomes 1.0 + 2.0imemcpy(&amp;z2, a+2, sizeof z2); // z2 becomes 3.0 + 4.0i</code></pre><p>Complex numbers may be used with arithmetic operators + - * and /, possibly mixed with imaginary and real numbers. There are many mathematical functions defined for complex numbers in complex.h. Both built-in operators and library functions may raise floating-point exceptions and set <code>errno</code> as described in <tt>math_errhandling</tt></p><p>Increment and decrement are not defined for complex types<br></p><p>Relational operators are not defined for complex types (there is no notion of "less than")<br></p><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: review other ops, link library <br></td></tr></table>Implicit conversions are defined between complex types and other arithmetic types.<p>In order to support the one-infinity model of complex number arithmetic, C regards any complex value with at least one infinite part as an infinity even if its other part is a NaN, guarantees that all operators and functions honor basic properties of inifinities and provides <code>cproj</code> to map all infinities to the canonical one (see arithmetic operators for the exact rules)</p>Run this code<pre><code>#include<stdio.h>#include <stdio.h>#include <complex.h>#include <math.h>int main(void){   double complex z = (1 + 0*I) * (INFINITY + I*INFINITY);// textbook formula would give// (1+i0)(∞+i∞) ⇒ (1×∞ – 0×∞) + i(0×∞+1×∞) ⇒ NaN + I*NaN// but C gives a complex infinity   printf("%f + i*%f\\n", creal(z), cimag(z)); // textbook formula would give// cexp(∞+iNaN) ⇒ exp(∞)×(cis(NaN)) ⇒ NaN + I*NaN// but C gives  ±∞+i*nan   double complex y = cexp(INFINITY + I*NAN);   printf("%f + i*%f\\n", creal(y), cimag(y)); }</code></pre><p>Possible output:<br></p><pre><code>inf + i*inf <br>inf + i*nan</code></pre><p>C also treats multiple infinities so as to preserve directional information where possible, despite the inherent limitations of the Cartesian representation:<br></p><p>multiplying the imaginary unit by real infinity gives the correctly-signed imaginary infinity: i × ∞ = i∞. Also, i × (∞ – i∞) = ∞ + i∞ indicates the reasonable quadrant<br></p><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: wording <br></td></tr></table><h3><span class="prog__sub"> Imaginary floating types</span></h3><p>Imaginary floating types model the mathematical imaginary numbers, that is numbers that can be written as a real number multiplied by the imaginary unit: biThe three imaginary types are</p><dl><dd><ul><li> <code>float _Imaginary</code> (also available as <code>float imaginary</code> if <complex.h> is included)</li><li> <code>double _Imaginary</code> (also available as <code>double imaginary</code> if <complex.h> is included)</li><li> <code>long double _Imaginary</code> (also available as <code>long double imaginary</code> if <complex.h> is included)</li></ul></dd></dl><p>Note: as with all type specifiers, any order is permitted: <code>long double imaginary</code>, <code>imaginary long double</code>, and even <code>double imaginary long</code> name the same type.</p>Run this code<pre><code>#include <complex.h>#include <stdio.h>int main(void){    double imaginary z = 3*I;    z = 1/z;    printf("1/(3.0i) = %+.1fi\\n", cimag(z));}</code></pre><p>Output:<br></p><pre><code>1/(3.0i) = -0.3i</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99 t-until-c11"><td><p>A compiler that defines <code>__STDC_IEC_559_COMPLEX__</code> is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro <code>_Imaginary_I</code> is defined to identify imaginary number support.</p></td><td><br/></td></tr><tr class="t-rev t-since-c11"><td><p>Imaginary numbers are supported if <code>__STDC_IEC_559_COMPLEX__</code> is defined.</p></td><td></td></tr></table><p>Each of the three imaginary types has the same object representation and alignment requirement as its <i>corresponding real type</i> (<code>float</code> for <code>float imaginary</code>, <code>double</code> for <code>double imaginary</code>, <code>long double</code> for <code>long double imaginary</code>). </p><p>Note: despite that, imaginary types are distinct and not compatible with their corresponding real types, which prohibits aliasing.</p><p>Imaginary numbers may be used with arithmetic operators + - * and /, possibly mixed with complex and real numbers. There are many mathematical functions defined for imaginary numbers in complex.h. Both built-in operators and library functions may raise floating-point exceptions and set <code>errno</code> as described in <tt>math_errhandling</tt></p><p>Increment and decrement are not defined for imaginary types<br></p><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: review other ops, link library <br></td></tr></table>Implicit conversions are defined between imaginary types and other arithmetic types.<p>The imaginary numbers make it possible to express all complex numbers using the natural notation <code>x + I*y</code> (where <code>I</code> is defined as <code>_Imaginary_I</code>). Without imaginary types, certain special complex values cannot be created naturally. For example, if <code>I</code> is defined as <code>_Complex_I</code>, then writing <code>0.0 + I*INFINITY</code> gives NaN as the real part, and <code>CMPLX(0.0, INFINITY)</code> must be used instead. Same goes for the numbers with the negative zero imaginary component, which are meaningful when working with the library functions with branch cuts, such as <code>csqrt</code>: <code>1.0 - 0.0*I</code> results in the positive zero imaginary component if <code>I</code> is defined as <code>_Complex_I</code> and the negative zero imaginary part requires the use of <code>CMPLX</code> or <code>conj</code>.</p><p>Imaginary types also simplify implementations; multiplication of an imaginary by a complex can be implemented straightforwardly with two multiplications if the imaginary types are supported, instead of four multiplications and two additions.<br></p></td><td></td></tr></table><h3><span class="prog__sub">Keywords</span></h3><p><tt>char</tt>, <tt>int</tt>,<tt>short</tt>,<tt>long</tt>,<tt>signed</tt>,<tt>unsigned</tt>,<tt>float</tt>,<tt>double</tt>.<tt>_Bool</tt>,<tt>_Complex</tt>,<tt>_Imaginary</tt></p><h3><span class="prog__sub">Range of values</span></h3><p>The following table provides a reference for the limits of common numeric representations. As the C Standard allows any signed integer representation, the table gives both the minimum guaranteed requirements (which correspond to the limits of one's complement or sign-and-magnitude) and the limits of the most commonly used implementation, two's complement. All popular data models (including all of ILP32, LP32, LP64, LLP64) use two's complement representation, though.</p><table class="wikitable" style="text-align:center;"><tr><th rowspan="2"> Type</th><th rowspan="2"> Size in bits</th><th rowspan="2"> Format</th><th colspan="2"> Value range</th></tr><tr><th> Approximate</th><th> Exact</th></tr><tr><th rowspan="3"> character</th><td rowspan="3"> 8</td><td> signed <span style="font-size:0.7em; line-height:130%">(one's complement)</span></td><td colspan="2"> <b>-127</b> to <b>127</b></td></tr><tr><td> signed <span style="font-size:0.7em; line-height:130%">(two's complement)</span></td><td colspan="2"> <b>-128</b> to <b>127</b></td></tr><tr><td> unsigned</td><td colspan="2"> <b>0</b> to <b>255</b></td></tr><tr><th rowspan="9"> integral</th><td rowspan="3"> 16</td><td> signed <span style="font-size:0.7em; line-height:130%">(one's complement)</span></td><td rowspan="2"> <b>± 3.27 · 10<sup>4</sup></b></td><td> <b>-32767</b> to <b>32767</b></td></tr><tr><td> signed <span style="font-size:0.7em; line-height:130%">(two's complement)</span></td><td> <b>-32768</b> to <b>32767</b></td></tr><tr><td> unsigned</td><td> <b>0</b> to <b>6.55 · 10<sup>4</sup></b></td><td> <b>0</b> to <b>65535</b></td></tr><tr><td rowspan="3"> 32</td><td> signed <span style="font-size:0.7em; line-height:130%">(one's complement)</span></td><td rowspan="2"> <b>± 2.14 · 10<sup>9</sup></b></td><td> <b>-2,147,483,647</b> to <b>2,147,483,647</b></td></tr><tr><td> signed <span style="font-size:0.7em; line-height:130%">(two's complement)</span></td><td> <b>-2,147,483,648</b> to <b>2,147,483,647</b></td></tr><tr><td> unsigned</td><td> <b>0</b> to <b>4.29 · 10<sup>9</sup></b></td><td> <b>0</b> to <b>4,294,967,295</b></td></tr><tr><td rowspan="3"> 64</td><td> signed <span style="font-size:0.7em; line-height:130%">(one's complement)</span></td><td rowspan="2"> <b>± 9.22 · 10<sup>18</sup></b></td><td> <b>-9,223,372,036,854,775,807</b> to <b>9,223,372,036,854,775,807</b></td></tr><tr><td> signed <span style="font-size:0.7em; line-height:130%">(two's complement)</span></td><td> <b>-9,223,372,036,854,775,808</b> to <b>9,223,372,036,854,775,807</b></td></tr><tr><td> unsigned</td><td> <b>0</b> to <b>1.84 · 10<sup>19</sup></b></td><td> <b>0</b> to <b>18,446,744,073,709,551,615</b></td></tr><tr><th rowspan="2"> floating<br> point<br></th><td> 32</td><td> IEEE-754</td><td> <b>± 3.4 · 10<sup>± 38</sup></b><br> <span style="font-size:0.7em; line-height:130%">(~7 digits)</span><br></td><td><ul><li>min subnormal: <b>± 1.401,298,4 · 10<sup>-47</sup></b></li><li>min normal: <b>± 1.175,494,3 · 10<sup>-38</sup></b></li><li>max: <b>± 3.402,823,4 · 10<sup>38</sup></b></li></ul></td></tr><tr><td> 64</td><td> IEEE-754</td><td> <b>± 1.7 · 10<sup>± 308</sup></b><br> <span style="font-size:0.7em; line-height:130%">(~15 digits)</span><br></td><td> <ul><li>min subnormal: <b>± 4.940,656,458,412 · 10<sup>-324</sup></b></li><li>min normal: <b>± 2.225,073,858,507,201,4 · 10<sup>-308</sup></b></li><li>max: <b>± 1.797,693,134,862,315,7 · 10<sup>308</sup></b></li></ul></td></tr></table><p>Note: actual (as opposed to guaranteed minimal) ranges are available in the library headers <limits.h> and <float.h></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/arithmetic_types.html
array	A										<section class="prog__container"><p>Array is a type consisting of a contiguously allocated nonempty sequence of objects with aparticular <i>element type</i>. The number of those objects (the array size) never changes during the array lifetime.</p><h3><span class="prog__sub">Syntax</span></h3><p>In the declaration grammar of an array declaration, the <i>type-specifier</i> sequence designates the <i>element type</i> (which must be a complete object type), and the <i>declarator</i> has the form:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>[</code> <code>static</code>(optional) <i>qualifiers</i>(optional) <i>expression</i>(optional) <code>]</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>[</code> <i>qualifiers</i>(optional) <code>static</code>(optional) <i>expression</i>(optional) <code>]</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>[</code> <i>qualifiers</i>(optional) <code>*</code> <code>]</code></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1,2) General array declarator syntax</ul><ul>3) Declarator for VLA of unspecified size (can appear in function prototype scope only)where</ul><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any expression other than comma operator, designates the number of elements in the array</td></tr><tr class="t-par"><td> <i>qualifiers</i></td><td> -</td><td>  any combination of const, restrict, or volatile qualifiers, only allowed in function parameter lists; this qualifies the pointer type to which this array parameter is transformed</td></tr></table><pre><code>float fa[11], *afp[17]; // fa is an array of 11 floats                        // afp is an array of 17 pointers to floats</code></pre><h3><span class="prog__sub">Explanation</span></h3><p>There are several variations of array types: arrays of known constant size, variable-length arrays, and arrays of unknown size.<br></p><h4>Arrays of constant known size</h4><p>If <i>expression</i> in an array declarator is an integer constant expression with a value greater than zero<span> and the element type is a type with a known constant size (that is, elements are not VLA)</span> <span></span>, then the declarator declares an array of constant known size:</p><pre><code>int n[10]; // integer constants are constant expressionschar o[sizeof(double)]; // sizeof is a constant expressionenum { MAX_SZ=100 };int n[MAX_SZ]; // enum constants are constant expressions</code></pre><p>Arrays of constant known size can use array initializers to provide their initial values:</p><pre><code>int a[5] = {1,2,3}; // declares int[5] initalized to 1,2,3,0,0char str[] = "abc"; // declares char[4] initialized to 'a','b','c','\\0'</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>In function parameter lists, additional syntax elements are allowed within the array declarators: the keyword <code>static</code> and <i>qualifiers</i>, which may appear in any order before the size expression (they may also appear even when the size expression is omitted).</p><p>In each function call to a function where a parameter of array type uses the keyword <code>static</code> between <code>[</code> and <code>]</code>, the value of the actual parameter must be a valid pointer to the first element of an array with at least as many elements as specified by <i>expression</i>:</p><pre><code>void fadd(double a[static 10], const double b[static 10]){     for (int i = 0; i < 10; i++) {        if (a[i] < 0.0) return;        a[i] += b[i];    }}// a call to fadd performs compile-time bounds checking// and also permits optimizations such as prefetching 10 doubles int main(void){    double a[10] = {0}, b[20] = {0};    fadd(a, b); // OK    double x[5] = {0};    fadd(x, b); // error: array argument is too small}</code></pre><p>If <i>qualifiers</i> are present, they qualify the pointer type to which the array parameter type is transformed:</p><pre><code>int f(const int a[20]){ // in this function, a has type const int* (pointer to const int)}int g(const int a[const 20]){ // in this function, a has type const int* const (const pointer to const int)}</code></pre><p>This is commonly used with the restrict type qualifier:</p><pre><code>void fadd(double a[static restrict 10],          const double b[static restrict 10]){    for (int i = 0; i < 10; i++) { // loop can be unrolled and reordered        if (a[i] < 0.0) break;        a[i] += b[i];    }}</code></pre><h4> Variable-length arrays</h4><p>If <i>expression</i> is not an integer constant expression, the declarator is for an array of variable size.</p><p>Each time the flow of control passes over the declaration, <i>expression</i> is evaluated (and it must always evaluate to a value greater than zero), and the array is allocated (correspondingly, lifetime of a VLA ends when the declaration goes out of scope). The size of each VLA instance does not change during its lifetime, but on another pass over the same code, it may be allocated with a different size.</p><pre><code>{   int n = 1;label:   int a[n]; // re-allocated 10 times, each with a different size   printf("The array has %zu elements\\n", sizeof a / sizeof *a);   if (n++ < 10) goto label; // leaving the scope of a VLA ends its lifetime}</code></pre><p>If the size is <code>*</code>, the declaration is for a VLA of unspecified size. Such declaration may only appear in a function prototype scope, and declares an array of a complete type. In fact, all VLA declarators in function prototype scope are treated as if <i>expression</i> were replaced by <code>*</code>.</p><pre><code>void foo(size_t x, int a[*]);void foo(size_t x, int a[x]) {    printf("%zu\\n", sizeof a); // same as sizeof(int*)}</code></pre><p>Variable-length arrays and the types derived from them (pointers to them, etc) are commonly known as "variably-modified types" (VM). Objects of any variably-modified type may only be declared at block scope or function prototype scope.<br></p><pre><code>extern int n;int A[n];            // Error: file scope VLAextern int (*p2)[n]; // Error: file scope VMint B[100];          // OK: file-scope array of constant known sizevoid fvla(int m, int C[m][m]); // OK: prototype-scope VLA</code></pre><p>VLA must have automatic storage duration. Pointers to VLA, but not VLA themselves may also have static storage duration. No VM type may have linkage.<br></p><pre><code>void fvla(int m, int C[m][m]) // OK: block scope/auto duration pointer to VLA{    typedef int VLA[m][m]; // OK: block scope VLA    int D[m];              // OK: block scope/auto duration VLA//  static int E[m]; // Error: static duration VLA//  extern int F[m]; // Error: VLA with linkage    int (*s)[m];     // OK: block scope/auto duration VM//  extern int (*r)[m]; // Error: VM with linkage    static int (*q)[m] = &amp;B; // OK: block scope/static duration VM}}</code></pre><p>Variably-modified types cannot be members of structs or unions.<br></p><pre><code>struct tag {    int z[n]; // Error: VLA struct member    int (*y)[n]; // Error: VM struct member};</code></pre></td><td></td></tr><tr class="t-rev t-since-c11"><td><p>If the compiler defines the macro constant <code>__STDC_NO_VLA__</code> to integer constant <code>1</code>, then VLA and VM types are not supported.</p></td><td></td></tr></table><h4>Arrays of unknown size</h4><p>If <i>expression</i> in an array declarator is omitted, it declares an array of unknown size. Except in function parameter lists (where such arrays are transformed to pointers) and when an  initializer is available, such type is an incomplete type<span> (note that VLA of unspecified size, declared with <code>*</code> as the size, is a complete type)</span> <span></span>:</p><pre><code>extern int x[]; // the type of x is "array of unknown bound of int"int a[] = {1,2,3}; // the type of a is "array of 3 int"</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>Within a struct definition, an array of unknown size may appear as the last member (as long as there is at least one other named member), in which case it is a special case known as <i>flexible array member</i>. See struct for details:</p><pre><code>struct s { int n; double d[]; }; // s.d is a flexible array member struct s *s1 = malloc(sizeof (struct s) + (sizeof (double) * 8)); // as if d was double d[8]</code></pre></td><td></td></tr></table><h3><span class="prog__sub">Qualifiers</span></h3><p>If an array type is declared with a const, volatile<span>, restrict</span> <span></span><span>, or _Atomic</span> <span></span> qualifier (which is possible through the use of typedef), the array type is not qualified, but its element type is:</p><pre><code>typedef int A[2][3];const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const intint* pi = a[0]; // Error: a[0] has type const int*</code></pre><h4>Assignment</h4><p>Objects of array type are not modifiable lvalues, and although their address may be taken, they cannot appear on the left hand side of an assignment operator. However, structs with array members are modifiable lvalues and can be assigned:</p><pre><code>int a[3] = {1,2,3}, b[3] = {4,5,6};int (*p)[3] = &amp;a; // okay, address of a can be taken// a = b;            // error, a is an arraystruct { int c[3]; } s1, s2 = {3,4,5};s1 = s2; // okay: can assign structs holding array members</code></pre><h4>Array to pointer conversion</h4><p>Any lvalue expression of array type, when used in any context other than </p><ul><li> as the operand of the address-of operator</li><li> as the operand of sizeof</li><li> as the string literal used for array initialization</li></ul><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><ul><li> as the operand of _Alignof</li></ul></td><td></td></tr></table><p>undergoes an implicit conversion to the pointer to its first element. The result is not an lvalue.</p><p>If the array was declared register, the behavior of the program that attempts such conversion is undefined.</p><pre><code>int a[3] = {1,2,3};int* p = a;printf("%zu\\n", sizeof a); // prints size of arrayprintf("%zu\\n", sizeof p); // prints size of a pointer</code></pre><p>When an array type is used in a function parameter list, it is transformed to the corresponding pointer type: <code>int f(int a[2])</code> and <code>int f(int* a)</code> declare the same function. Since the function's actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:</p><pre><code>void f(int a[], int sz) // actually declares int f(int* a, int sz){    for(int i = 0; i < sz; ++i)       printf("%d\\n", a[i]);}int main(void){    int a[10];    f(a, 10); // converts a to int*, passes the pointer}</code></pre><h4>Multidimensional arrays</h4><p>When the element type of an array is another array, it is said that the array is multidimensional:<br></p><pre><code>// array of 2 arrays of 3 ints eachint a[2][3] = {{1,2,3},  // can be viewed as a 2x3 matrix               {4,5,6}}; // with row-major layout</code></pre><p>Note that when array-to-pointer conversion is applied, a multidimensional array is converted to a pointer to its first element, e.g., pointer to the first row:<br></p><pre><code>int a[2][3]; // 2x3 matrixint (*p1)[3] = a; // pointer to the first 3-element rowint b[3][3][3]; // 3x3x3 cubeint (*p2)[3][3] = a; // pointer to the first 3x3 plane</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>Multidimensional arrays may be variably modified in every dimension:<br></p><pre><code>int n = 10;int a[n][2*n];</code></pre></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/array.html
array_initialization	A										<section class="prog__container"><p>When initializing an object of array type, the initializer must be either a string literal (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>=</code> <i>string_literal</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>=</code> <code>{ </code> <i>expression</i> <code>,</code> <code>...</code> <code>} </code><p><code>=</code> <code>{ </code> <i>designator</i>(optional) <i>expression</i> <code>,</code> <code>...</code> <code>} </code></p></td><td> (2)</td><td> (until C99)<br></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) string literal initializer for character and wide character arrays</ul><ul>2) comma-separated list of expressions that are initializers for array elements<span>, optionally using array designators of the form <code>[</code> <i>constant-expression</i> <code>]</code> <code>=</code> </span> <span></span></ul><p>Arrays of known size and arrays of unknown size may be initialized<span>, but not VLAs.</span> <span></span></p><p>All array elements that are not initialized explicitly are initialized implicitly the same way as objects that have static storage duration.</p><h3><span class="prog__sub">Initialization from strings</span></h3><p>string literal (optionally enclosed in braces) may be used as the initializer for an array of matching type:</p><ul><li> ordinary string literals<span> and UTF-8 string literals</span> <span></span> can initialize arrays of any character type (<code>char</code>, <code>signed char</code>, <code>unsigned char</code>)</li><li> L-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications) <code>wchar_t</code></li></ul><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><ul><li> u-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications) <code>char16_t</code></li><li> U-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications <code>char32_t</code></li></ul></td><td></td></tr></table><p>Successive bytes of the string literal or wide characters of the wide string literal, including the terminating null byte/character, initialize the elements of the array:<br></p><pre><code>char str[] = "abc"; // str has type char[4] and holds 'a', 'b'. 'c', '\\0'wchar_t wstr[4] = L"猫"; // str has type wchar_t[4] and holds L'猫', '\\0', '\\0', '\\0'</code></pre><p>If the size of the array is known, it may be one less than the size of the string literal, in which case the terminating null character is ignored:<br></p><pre><code>char str[3] = "abc"; // str has type char[3] and holds 'a', 'b', 'c'</code></pre><p>Note that the contents of such array are modifiable, unlike when accessing a string literal directly with <code>char* str = "abc";</code>.</p><h3><span class="prog__sub">Initialization from brace-enclosed lists</span></h3><p>When an array is initialized with a brace-enclosed list of initializers, the first initializer in the list initializes the array element at index zero<span> (unless a designator is specified)</span> <span></span>, and each subsequent initializers <span>without a designator </span> <span></span>initializes the array element at index one greater than the one initialized by the previous initializer.</p><pre><code>int x[] = {1,2,3}; // x has type int[3] and holds 1,2,3int y[5] = {1,2,3}; // y has type int[5] and holds 1,2,3,0,0int z[3] = {0}; // z has type int[3] and holds all zeroes</code></pre><p>It's an error to provide more initializers than elements when initializing an array of known size (except when initializing character arrays from string literals).<br></p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>A designator causes the following initializer to initialize of the array element described by the designator. Initialization then continues forward in order, beginning with the next element after the one described by the designator.<br></p><pre><code>int n[5] = {[4]=5,[0]=1,2,3,4} // holds 1,2,3,4,5 int a[MAX] = { // starts initializing a[0] = 1, a[1] = 3, ...    1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0}// for MAX=6,  array holds 1,8,6,4,2,0// for MAX=13, array holds 1,3,5,7,9,0,0,0,8,6,4,2,0 ("sparse array")</code></pre></td><td></td></tr></table><p>When initializing an array of unknown size, the largest subscript for which an initializer is specified determines the size of the array being declared.<br></p><h3><span class="prog__sub">Nested arrays</span></h3><p>If the elements of an array are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:<br></p><p>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding array element:<br></p><pre><code>int y[4][3] = { // array of 4 arrays of 3 ints each (4x3 matrix)    { 1 },      // row 0 initialized to {1, 0, 0}    { 0, 1 },   // row 1 initialized to {0, 1, 0}    { [2]=1 },  // row 2 initialized to {0, 0, 1}};              // row 3 initialized to {0, 0, 0}</code></pre><p>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the sub-array, struct or union; any remaining initializers are left to initialize the next array element:<br></p><pre><code>int y[4][3] = {    // array of 4 arrays of 3 ints each (4x2 matrix)1, 3, 5, 2, 4, 6, 3, 5, 7 // row 0 initialized to {1, 3, 5}};                        // row 1 initialized to {2, 4, 6}                          // row 2 initialized to {3, 5, 7}                          // row 3 initialized to {0, 0, 0} struct { int a[3], b; } w[] = { { 1 }, 2 }; // array of structs   // { 1 } is taken to be a fully-braced initializer for element #0 of the array   // that element is initialized to { {1, 0, 0}, 0}   // 2 is taken to be the first initialized for element #1 of the array   // that element is initialized { {2, 0, 0}, 0}</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>Array designators may be nested; the bracketed constant expression for nested arrays follows the bracketed constant expression for the outer array:<br></p><pre><code>int y[4][3] = {[0][0]=1, [1][1]=1, [2][0]=1};  // row 0 initialized to {1, 0, 0}                                               // row 1 initialized to {0, 1, 0}                                               // row 2 initialized to {1, 0, 0}                                               // row 3 initialized to {0, 0, 0}</code></pre></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/array_initialization.html
ascii	A										<section class="prog__container"><p>The following chart contains all 128 ASCII decimal <b>(dec)</b>, octal <b>(oct)</b>, hexadecimal <b>(hex)</b> and character <b>(ch)</b> codes.</p><table class="wikitable" style="text-align: left;"><tr><th> <code>dec</code> </th><th> <code>oct</code> </th><th> <code>hex</code></th><th style="text-align: left;"> <code>ch</code></th><td rowspan="33"></td><th> <code>dec</code> </th><th> <code>oct</code> </th><th> <code>hex</code></th><th style="text-align: left;"> <code>ch</code></th><td rowspan="33"></td><th> <code>dec</code> </th><th> <code>oct</code> </th><th> <code>hex</code></th><th style="text-align: left;"> <code>ch</code></th><td rowspan="33"></td><th> <code>dec</code> </th><th> <code>oct</code> </th><th> <code>hex</code></th><th style="text-align: left;"> <code>ch</code></th></tr><tr><td> <code> 0</code></td><td> <code>0</code></td><td><code>00</code></td><td><code>NUL</code> (null) </td><td> <code>32</code></td><td><code>40</code></td><td><code>20</code></td><td>(space) </td><td> <code>64</code></td><td><code>100</code></td><td><code>40</code></td><td><code>@</code> </td><td> <code> 96</code></td><td><code>140</code></td><td><code>60</code></td><td><code>`</code></td></tr><tr><td> <code> 1</code></td><td> <code>1</code></td><td><code>01</code></td><td><code>SOH</code> (start of header) </td><td> <code>33</code></td><td><code>41</code></td><td><code>21</code></td><td><code>!</code> </td><td> <code>65</code></td><td><code>101</code></td><td><code>41</code></td><td><code>A</code> </td><td> <code> 97</code></td><td><code>141</code></td><td><code>61</code></td><td><code>a</code></td></tr><tr><td> <code> 2</code></td><td> <code>2</code></td><td><code>02</code></td><td><code>STX</code> (start of text) </td><td> <code>34</code></td><td><code>42</code></td><td><code>22</code></td><td><code>"</code> </td><td> <code>66</code></td><td><code>102</code></td><td><code>42</code></td><td><code>B</code> </td><td> <code> 98</code></td><td><code>142</code></td><td><code>62</code></td><td><code>b</code></td></tr><tr><td> <code> 3</code></td><td> <code>3</code></td><td><code>03</code></td><td><code>ETX</code> (end of text) </td><td> <code>35</code></td><td><code>43</code></td><td><code>23</code></td><td><code>#</code> </td><td> <code>67</code></td><td><code>103</code></td><td><code>43</code></td><td><code>C</code> </td><td> <code> 99</code></td><td><code>143</code></td><td><code>63</code></td><td><code>c</code></td></tr><tr><td> <code> 4</code></td><td> <code>4</code></td><td><code>04</code></td><td><code>EOT</code> (end of transmission) </td><td> <code>36</code></td><td><code>44</code></td><td><code>24</code></td><td><code>$</code> </td><td> <code>68</code></td><td><code>104</code></td><td><code>44</code></td><td><code>D</code> </td><td> <code>100</code></td><td><code>144</code></td><td><code>64</code></td><td><code>d</code></td></tr><tr><td> <code> 5</code></td><td> <code>5</code></td><td><code>05</code></td><td><code>ENQ</code> (enquiry) </td><td> <code>37</code></td><td><code>45</code></td><td><code>25</code></td><td><code>%</code> </td><td> <code>69</code></td><td><code>105</code></td><td><code>45</code></td><td><code>E</code> </td><td> <code>101</code></td><td><code>145</code></td><td><code>65</code></td><td><code>e</code></td></tr><tr><td> <code> 6</code></td><td> <code>6</code></td><td><code>06</code></td><td><code>ACK</code> (acknowledge) </td><td> <code>38</code></td><td><code>46</code></td><td><code>26</code></td><td><code>&amp;</code> </td><td> <code>70</code></td><td><code>106</code></td><td><code>46</code></td><td><code>F</code> </td><td> <code>102</code></td><td><code>146</code></td><td><code>66</code></td><td><code>f</code></td></tr><tr><td> <code> 7</code></td><td> <code>7</code></td><td><code>07</code></td><td><code>BEL</code> (bell) </td><td> <code>39</code></td><td><code>47</code></td><td><code>27</code></td><td><code>'</code> </td><td> <code>71</code></td><td><code>107</code></td><td><code>47</code></td><td><code>G</code> </td><td> <code>103</code></td><td><code>147</code></td><td><code>67</code></td><td><code>g</code></td></tr><tr><td> <code> 8</code></td><td><code>10</code></td><td><code>08</code></td><td><code>BS</code> (backspace) </td><td> <code>40</code></td><td><code>50</code></td><td><code>28</code></td><td><code>(</code> </td><td> <code>72</code></td><td><code>110</code></td><td><code>48</code></td><td><code>H</code> </td><td> <code>104</code></td><td><code>150</code></td><td><code>68</code></td><td><code>h</code></td></tr><tr><td> <code> 9</code></td><td><code>11</code></td><td><code>09</code></td><td><code>HT</code> (horizontal tab) </td><td> <code>41</code></td><td><code>51</code></td><td><code>29</code></td><td><code>)</code> </td><td> <code>73</code></td><td><code>111</code></td><td><code>49</code></td><td><code>I</code> </td><td> <code>105</code></td><td><code>151</code></td><td><code>69</code></td><td><code>i</code></td></tr><tr><td> <code>10</code></td><td><code>12</code></td><td><code>0a</code></td><td><code>LF</code> (line feed - new line) </td><td> <code>42</code></td><td><code>52</code></td><td><code>2a</code></td><td><code>*</code> </td><td> <code>74</code></td><td><code>112</code></td><td><code>4a</code></td><td><code>J</code> </td><td> <code>106</code></td><td><code>152</code></td><td><code>6a</code></td><td><code>j</code></td></tr><tr><td> <code>11</code></td><td><code>13</code></td><td><code>0b</code></td><td><code>VT</code> (vertical tab) </td><td> <code>43</code></td><td><code>53</code></td><td><code>2b</code></td><td><code>+</code> </td><td> <code>75</code></td><td><code>113</code></td><td><code>4b</code></td><td><code>K</code> </td><td> <code>107</code></td><td><code>153</code></td><td><code>6b</code></td><td><code>k</code></td></tr><tr><td> <code>12</code></td><td><code>14</code></td><td><code>0c</code></td><td><code>FF</code> (form feed - new page) </td><td> <code>44</code></td><td><code>54</code></td><td><code>2c</code></td><td><code>,</code> </td><td> <code>76</code></td><td><code>114</code></td><td><code>4c</code></td><td><code>L</code> </td><td> <code>108</code></td><td><code>154</code></td><td><code>6c</code></td><td><code>l</code></td></tr><tr><td> <code>13</code></td><td><code>15</code></td><td><code>0d</code></td><td><code>CR</code> (carriage return) </td><td> <code>45</code></td><td><code>55</code></td><td><code>2d</code></td><td><code>-</code> </td><td> <code>77</code></td><td><code>115</code></td><td><code>4d</code></td><td><code>M</code> </td><td> <code>109</code></td><td><code>155</code></td><td><code>6d</code></td><td><code>m</code></td></tr><tr><td> <code>14</code></td><td><code>16</code></td><td><code>0e</code></td><td><code>SO</code> (shift out) </td><td> <code>46</code></td><td><code>56</code></td><td><code>2e</code></td><td><code>.</code> </td><td> <code>78</code></td><td><code>116</code></td><td><code>4e</code></td><td><code>N</code> </td><td> <code>110</code></td><td><code>156</code></td><td><code>6e</code></td><td><code>n</code></td></tr><tr><td> <code>15</code></td><td><code>17</code></td><td><code>0f</code></td><td><code>SI</code> (shift in) </td><td> <code>47</code></td><td><code>57</code></td><td><code>2f</code></td><td><code>/</code> </td><td> <code>79</code></td><td><code>117</code></td><td><code>4f</code></td><td><code>O</code> </td><td> <code>111</code></td><td><code>157</code></td><td><code>6f</code></td><td><code>o</code></td></tr><tr><td> <code>16</code></td><td><code>20</code></td><td><code>10</code></td><td><code>DLE</code> (data link escape) </td><td> <code>48</code></td><td><code>60</code></td><td><code>30</code></td><td><code>0</code> </td><td> <code>80</code></td><td><code>120</code></td><td><code>50</code></td><td><code>P</code> </td><td> <code>112</code></td><td><code>160</code></td><td><code>70</code></td><td><code>p</code></td></tr><tr><td> <code>17</code></td><td><code>21</code></td><td><code>11</code></td><td><code>DC1</code> (device control 1) </td><td> <code>49</code></td><td><code>61</code></td><td><code>31</code></td><td><code>1</code> </td><td> <code>81</code></td><td><code>121</code></td><td><code>51</code></td><td><code>Q</code> </td><td> <code>113</code></td><td><code>161</code></td><td><code>71</code></td><td><code>q</code></td></tr><tr><td> <code>18</code></td><td><code>22</code></td><td><code>12</code></td><td><code>DC2</code> (device control 2) </td><td> <code>50</code></td><td><code>62</code></td><td><code>32</code></td><td><code>2</code> </td><td> <code>82</code></td><td><code>122</code></td><td><code>52</code></td><td><code>R</code> </td><td> <code>114</code></td><td><code>162</code></td><td><code>72</code></td><td><code>r</code></td></tr><tr><td> <code>19</code></td><td><code>23</code></td><td><code>13</code></td><td><code>DC3</code> (device control 3) </td><td> <code>51</code></td><td><code>63</code></td><td><code>33</code></td><td><code>3</code> </td><td> <code>83</code></td><td><code>123</code></td><td><code>53</code></td><td><code>S</code> </td><td> <code>115</code></td><td><code>163</code></td><td><code>73</code></td><td><code>s</code></td></tr><tr><td> <code>20</code></td><td><code>24</code></td><td><code>14</code></td><td><code>DC4</code> (device control 4) </td><td> <code>52</code></td><td><code>64</code></td><td><code>34</code></td><td><code>4</code> </td><td> <code>84</code></td><td><code>124</code></td><td><code>54</code></td><td><code>T</code> </td><td> <code>116</code></td><td><code>164</code></td><td><code>74</code></td><td><code>t</code></td></tr><tr><td> <code>21</code></td><td><code>25</code></td><td><code>15</code></td><td><code>NAK</code> (negative acknowledge) </td><td> <code>53</code></td><td><code>65</code></td><td><code>35</code></td><td><code>5</code> </td><td> <code>85</code></td><td><code>125</code></td><td><code>55</code></td><td><code>U</code> </td><td> <code>117</code></td><td><code>165</code></td><td><code>75</code></td><td><code>u</code></td></tr><tr><td> <code>22</code></td><td><code>26</code></td><td><code>16</code></td><td><code>SYN</code> (synchronous idle) </td><td> <code>54</code></td><td><code>66</code></td><td><code>36</code></td><td><code>6</code> </td><td> <code>86</code></td><td><code>126</code></td><td><code>56</code></td><td><code>V</code> </td><td> <code>118</code></td><td><code>166</code></td><td><code>76</code></td><td><code>v</code></td></tr><tr><td> <code>23</code></td><td><code>27</code></td><td><code>17</code></td><td><code>ETB</code> (end of transmission block) </td><td> <code>55</code></td><td><code>67</code></td><td><code>37</code></td><td><code>7</code> </td><td> <code>87</code></td><td><code>127</code></td><td><code>57</code></td><td><code>W</code> </td><td> <code>119</code></td><td><code>167</code></td><td><code>77</code></td><td><code>w</code></td></tr><tr><td> <code>24</code></td><td><code>30</code></td><td><code>18</code></td><td><code>CAN</code> (cancel) </td><td> <code>56</code></td><td><code>70</code></td><td><code>38</code></td><td><code>8</code> </td><td> <code>88</code></td><td><code>130</code></td><td><code>58</code></td><td><code>X</code> </td><td> <code>120</code></td><td><code>170</code></td><td><code>78</code></td><td><code>x</code></td></tr><tr><td> <code>25</code></td><td><code>31</code></td><td><code>19</code></td><td><code>EM</code> (end of medium) </td><td> <code>57</code></td><td><code>71</code></td><td><code>39</code></td><td><code>9</code> </td><td> <code>89</code></td><td><code>131</code></td><td><code>59</code></td><td><code>Y</code> </td><td> <code>121</code></td><td><code>171</code></td><td><code>79</code></td><td><code>y</code></td></tr><tr><td> <code>26</code></td><td><code>32</code></td><td><code>1a</code></td><td><code>SUB</code> (substitute) </td><td> <code>58</code></td><td><code>72</code></td><td><code>3a</code></td><td><code>:</code> </td><td> <code>90</code></td><td><code>132</code></td><td><code>5a</code></td><td><code>Z</code> </td><td> <code>122</code></td><td><code>172</code></td><td><code>7a</code></td><td><code>z</code></td></tr><tr><td> <code>27</code></td><td><code>33</code></td><td><code>1b</code></td><td><code>ESC</code> (escape) </td><td> <code>59</code></td><td><code>73</code></td><td><code>3b</code></td><td><code>;</code> </td><td> <code>91</code></td><td><code>133</code></td><td><code>5b</code></td><td><code>[</code> </td><td> <code>123</code></td><td><code>173</code></td><td><code>7b</code></td><td><code>{</code></td></tr><tr><td> <code>28</code></td><td><code>34</code></td><td><code>1c</code></td><td><code>FS</code> (file separator) </td><td> <code>60</code></td><td><code>74</code></td><td><code>3c</code></td><td><code><</code> </td><td> <code>92</code></td><td><code>134</code></td><td><code>5c</code></td><td><code>\ </code> </td><td> <code>124</code></td><td><code>174</code></td><td><code>7c</code></td><td><code>|</code></td></tr><tr><td> <code>29</code></td><td><code>35</code></td><td><code>1d</code></td><td><code>GS</code> (group separator) </td><td> <code>61</code></td><td><code>75</code></td><td><code>3d</code></td><td><code>=</code> </td><td> <code>93</code></td><td><code>135</code></td><td><code>5d</code></td><td><code>]</code> </td><td> <code>125</code></td><td><code>175</code></td><td><code>7d</code></td><td><code>}</code></td></tr><tr><td> <code>30</code></td><td><code>36</code></td><td><code>1e</code></td><td><code>RS</code> (record separator) </td><td> <code>62</code></td><td><code>76</code></td><td><code>3e</code></td><td><code>></code> </td><td> <code>94</code></td><td><code>136</code></td><td><code>5e</code></td><td><code>^</code> </td><td> <code>126</code></td><td><code>176</code></td><td><code>7e</code></td><td><code>~</code></td></tr><tr><td> <code>31</code></td><td><code>37</code></td><td><code>1f</code></td><td><code>US</code> (unit separator) </td><td> <code>63</code></td><td><code>77</code></td><td><code>3f</code></td><td><code>?</code> </td><td> <code>95</code></td><td><code>137</code></td><td><code>5f</code></td><td><code>_</code> </td><td> <code>127</code></td><td><code>177</code></td><td><code>7f</code></td><td><code>DEL</code> (delete)</td></tr></table><p>Note: in Unicode, the ASCII character block is known as <code>U+0000..U+007F</code> Basic Latin.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/ascii.html
atomic	A										<section class="prog__container"><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Atomic</code> <code>(</code> <i>type-name</i> <code>)</code></td><td> (1)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Atomic</code> <i>type-name</i></td><td> (2)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) Use as a type specifier; this designates a new atomic type</ul><ul>2) Use as a type qualifier; this designates the atomic version of <i>type-name</i>. In this role, it may be mixed with const, volatile, and restrict), although unlike other qualifiers, the atomic version of <i>type-name</i> may have a different size, alignment, and object representation.</ul><table class="t-par-begin"><tr class="t-par"><td> <i>type-name</i></td><td> -</td><td>  any type other than array or function. For (1), <i>type-name</i> also cannot be atomic or cvr-qualified</td></tr></table><p>The header <code><stdatomic.h></code> defines 37 convenience macros, from <code>atomic_bool</code> to <code>atomic_uintmax_t</code>, which simplify the use of this keyword with built-in and library types.</p><pre><code>_Atomic const int * p1;  // p is a pointer to an atomic const intconst atomic_int * p2;   // sameconst _Atomic(int) * p3; // same</code></pre><h3><span class="prog__sub">Explanation</span></h3><p>Objects of atomic types are the only objects that are free from data races, that is, they may be modified by two threads concurrently or modified by one and read by another.</p><p>Each atomic object has its own associated <i>modification order</i>, which is a total order of modifications made to that object. If, from some thread's point of view, modification <code>A</code> of some atomic M happens-before modification <code>B</code> of the same atomic M, then in the modification order of M, A occurs before B.</p><p>Note that although each atomic object has its own modification order, it is not a total order; different threads may observe modifications to different atomic objects in different orders.<br></p><p>There are four coherences that are guaranteed for all atomic operations:<br></p><ul><li> <b>write-write coherence</b>: If an operation A that modifies an atomic object M <i>happens-before</i> an operation B that modifies M, then A appears earlier than B in the modification order of M.</li><li> <b>read-read coherence</b>: If a value computation A of an atomic object M happens before a value computation B of M, and A takes its value from a side effect X on M, then the value computed by B is either the value stored by X or is the value stored by a side effect Y on M, where Y appears later than X in the modification order of M.</li><li> <b>read-write coherence</b>: If a value computation A of an atomic object M <i>happens-before</i> an operation B on M, then A takes its value from a side effect X on M, where X appears before B in the modification order of M.</li><li> <b>write-read coherence</b>: If a side effect X on an atomic object M <i>happens-before</i> a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that appears after X in the modification order of M.</li></ul><p>Some atomic operations are also synchronization operations; they may have additional release semantics, acquire semantics, or sequentially-consistent semantics. See <code>memory_order</code>. </p><p>Built-in increment and decrement operators and compound assignment are read-modify-write atomic operations with total sequentially consistent ordering (as if using <code>memory_order_seq_cst</code>). If less strict synchronization semantics are desired, the standard library functions may be used instead.</p><p>Atomic properties are only meaningful for lvalue expressions. Lvalue-to-rvalue conversion (which models a memory read from an atomic location to a CPU register) strips atomicity along with other qualifiers.</p><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: more, review interaction with memory_order and atomic library pages <br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/atomic.html
basic_concepts	A										<section class="prog__container"><p>This section provides definitions for the specific terminology and the concepts used when describing the C programming language.<br></p><p>A C program is a sequence of text files (typically header and source files) that contain declarations. They undergo translation to become an executable program, which is executed when the OS calls its main function (unless it is itself the OS or another <i>freestanding</i> program, in which case the entry point is implementation-defined).</p><p>Certain words in a C program have special meaning, they are keywords. Others can be used as identifiers, which may be used to identify objects, functions, struct, union, or enumeration tags, their members, typedef names, labels, or  macros.</p><p>Each identifier (other than macro) is only valid within a part of the program called its scope and belongs to one of four kinds of name spaces. Some identifiers have linkage which makes them refer to the same entities when they appear in different scopes or translation units.</p><p>Definitions of functions include sequences of statements and declarations, some of which include expressions, which specify the computations to be performed by the program.</p><p>Declarations and expressions create, destroy, access, and manipulate objects. Each object, function, and expression in C is associated with a type.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/basic_concepts.html
behavior	A										<section class="prog__container"><p>The C language standard precisely specifies the observable behavior of C language programs, except for the ones in the following categories:</p><ul><li> <i>undefined behavior</i> - there are no restrictions on the behavior of the program. Examples of undefined behavior are memory accesses outside of array bounds, signed integer overflow, null pointer dereference, modification of the same scalar more than once in an expression without sequence points, access to an object through a pointer of a different type, etc. Compilers are not required to diagnose undefined behavior (although many simple situations are diagnosed), and the compiled program is not required to do anything meaningful.</li></ul><ul><li> <i>unspecified behavior</i> - two or more behaviors are permitted and the implementation is not required to document the effects of each behavior. For example, order of evaluation, whether identical string literals are distinct, etc. Each unspecified behavior results in one of a set of valid results and may produce a different result when repeated in the same program.</li></ul><ul><li> <i>implementation-defined behavior</i> - unspecified behavior where each implementation documents how the choice is made. For example, number of bits in a byte, or whether signed integer right shift is arithmetic or logical.</li></ul><ul><li> <i>locale-specific behavior</i> - implementation-defined behavior that depends on the currently chosen locale. For example, whether <code>islower</code> returns true for any character other than the 26 lowercase Latin letters.</li></ul><p>(Note: Strictly conforming programs do not depend on any unspecified, undefined, or implementation-defined behavior)</p><p>The compilers are required to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.<br></p><h3><span class="prog__sub">UB and optimization</span></h3><p>Because correct C programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:<br></p><p>For example, <br></p><h4>Signed overflow</h4><pre><code>int foo(int x) {    return x+1 > x; // either true or UB due to signed overflow}</code></pre><p>may be compiled as (demo)</p><pre><code>foo(int):        movl    $1, %eax        ret</code></pre><h4>Access out of bounds</h4><pre><code>int table[4] = {};int exists_in_table(int v){    // return true in one of the first 4 iterations or UB due to out-of-bounds access    for (int i = 0; i <= 4; i++) {        if (table[i] == v) return 1;    }    return 0;}</code></pre><p>May be compiled as (demo)</p><pre><code>exists_in_table(int):        movl    $1, %eax        ret</code></pre><h4>Uninitialized scalar</h4><pre><code>bool p; // uninitialized local variableif(p) // UB access to uninitialized scalar    puts("p is true");if(!p) // UB access to uninitialized scalar    puts("p is false");</code></pre><p>May produce the following output (observed with an older version of gcc):<br></p><pre><code>p is truep is false</code></pre>Run this code<pre><code>size_t f(int x){    size_t a;    if(x) // either x nonzero or UB        a = 42;    return a; }</code></pre><p><br></p><p>May be compiled as (demo)</p><pre><code>f(int):        mov     eax, 42        ret</code></pre><h4>Access to pointer passed to realloc</h4><p>Choose clang to observe the output shown<br></p>Run this code<pre><code>#include <stdio.h>#include <stdlib.h>int main(void) {    int *p = (int*)malloc(sizeof(int));    int *q = (int*)realloc(p, sizeof(int));    *p = 1; // UB access to a pointer that was passed to realloc    *q = 2;    if (p == q) // UB access to a pointer that was passed to realloc        printf("%d%d\\n", *p, *q);}</code></pre><p>Possible output:<br></p><pre><code>12</code></pre><h4>Infinite loop without side-effects</h4><p>Choose clang to observe the output shown<br></p>Run this code<pre><code>#include <stdio.h> int fermat() {  const int MAX = 1000;  int a=1,b=1,c=1;  // Endless loop with no side effects is UB  while (1) {    if (((a*a*a) == ((b*b*b)+(c*c*c)))) return 1;    a++;    if (a>MAX) { a=1; b++; }    if (b>MAX) { b=1; c++; }    if (c>MAX) { c=1;}  }  return 0;} int main(void) {  if (fermat())    puts("Fermat's Last Theorem has been disproved.");  else    puts("Fermat's Last Theorem has not been disproved.");}</code></pre><p>Possible output:<br></p><pre><code>Fermat's Last Theorem has been disproved.</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/behavior.html
bit_field	A										<section class="prog__container"><p>Declares a member with explicit width, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.<br></p><p>A bit field declaration is a struct or union member declaration which uses the following declarator:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>identifier</i>(optional) <code>:</code> <i>width</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>identifier</i></td><td> -</td><td>  the name of the bit field that is being declared. The name is optional: nameless bitfields introduce the specified number of bits of padding</td></tr><tr class="t-par"><td> <i>width</i></td><td> -</td><td>  an integer constant expression with a value greater or equal to zero and less or equal the number of bits in the underlying type. When greater than zero, this is the number of bits that this bit field will occupy. The value zero is only allowed for nameless bitfields and has special meaning: it specifies that the next bit field in the class definition will begin at an allocation unit's boundary.</td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>Bit fields can have only one of four types (possibly const or volatile qualified):</p><ul><li> <code>unsigned int</code>, for unsigned bit fields (<code>unsigned int b:3;</code> has the range <code>0..7</code>)</li><li> <code>signed int</code>, for signed bit fields (<code>signed int b:3;</code> has the range <code>-4..3</code>)</li><li> <code>int</code>, for bit fields with implementation-defined signedness (Note that this differs from the meaning of the keyword <code>int</code> everywhere else, where it means "signed int"). For example, <code>int b:3;</code> may have the range of values <code>0..7</code> or <code>-4..3</code>.</li><li> <code>_Bool</code>, for single-bit bit fields (<code>bool x:1;</code> has the range <code>0..1</code> and implicit conversions to and from it follow the boolean conversion rules.</li></ul><p>Additional implementation-defined types may be acceptable.<span> It is also implementation-defined whether a bit field may have atomic type.</span> <span></span>The number of bits in a bit field (<i>width</i>) sets the limit to the range of values it can hold:</p>Run this code<pre><code>#include <stdio.h>struct S { // three-bit unsigned field, // allowed values are 0...7 unsigned int b : 3;};int main(void){    struct S s = {7};    ++s.b; // unsigned overflow    printf("%d\\n", s.b); // output: 0}</code></pre><p><br></p><p>Multiple adjacent bit fields are permitted to be (and usually are) packed together:<br></p>Run this code<pre><code>#include <stdio.h>struct S {    // will usually occupy 4 bytes:    // 5 bits: value of b1    // 11 bits: unused    // 6 bits: value of b2    // 2 bits: value of b3    // 8 bits: unused    unsigned b1 : 5, : 11, b2 : 6, b3 : 2;};int main(void){    printf("%zu\\n",sizeof(struct S)); // usually prints 4}</code></pre><p><br></p><p>The special <i>unnamed bit field</i> of <i>width</i> zero breaks up padding: it specifies that the next bit field begins at the beginning of the next allocation unit:</p>Run this code<pre><code>#include <stdio.h>struct S {    // will usually occupy 8 bytes:    // 5 bits: value of b1    // 27 bits: unused    // 6 bits: value of b2    // 15 bits: value of b3    // 11 bits: unused    unsigned b1 : 5;    unsigned :0; // start a new unsigned int    unsigned b2 : 6;    unsigned b3 : 15;};int main(void){    printf("%zu\\n", sizeof(struct S)); // usually prints 8}</code></pre><p><br></p><p>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers to bit fields are not possible. Bit fields cannot be used with sizeof <span>and alignas </span> <span></span></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/bit_field.html
break	A										<section class="prog__container"><p>Causes the enclosing for, while or do-while loop or  switch statement to terminate.</p><p>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>break</code> <code>;</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>Appears only within the <i>statement</i> of a loop body (while, do, for) or within the <i>statement</i> of a switch.</p><h3><span class="prog__sub">Explanation</span></h3><p>After this statement the control is transferred to the statement or declaration immediately following the enclosing loop or switch, as if by goto.</p><h3><span class="prog__sub">Keywords</span></h3><p><tt>break</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/break.html
cast	A										<section class="prog__container"><p>Performs explicit type conversion<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>(</code> <i>type-name</i> <code>)</code> <i>expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><table class="t-par-begin"><tr class="t-par"><td> <i>type-name</i></td><td> -</td><td>  either the type <code>void</code> or any scalar type</td></tr><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any expression of scalar type (unless <i>type-name</i> is void, in which case it can be anything)</td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>If <i>type-name</i> is <code>void</code>, then <i>expression</i> is evaluated for its side-effects and its returned value is discarded, same as when <i>expression</i> is used on its own, as an expression statement.</p><p>Otherwise, if <i>type-name</i> is exactly the type of <i>expression</i>, nothing is done (except that if <i>expression</i> has floating type and is represented with greater range and precision than its type indicates -- see below)</p><p>Otherwise, the value of <i>expression</i> is converted to the type named by <i>type-name</i>, as follows:</p><p>Every implicit conversion as if by assignment is allowed. </p><p>In addition to the implicit conversions, the following conversions are allowed:<br></p><ul><li> Any integer can be cast to any pointer type. Except for the null pointer constants such as <code>NULL</code> (which doesn't need a cast), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a trap representation.</li><li> Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer)</li><li> Any pointer to object can be cast to any other pointer to object. If the value is not correctly aligned for the target type, the behavior is undefined. Otherwise, if the value is converted back to the original type, it compares equal to the original value. If a pointer to object is cast to pointer to any character type, the result points at the lowest byte of the object and may be incremented up to sizeof the target type (in other words, can be used to examine object representation or to make a copy via <code>memcpy</code> or <code>memmove</code>).</li><li> Any pointer to function can be cast to a pointer to any other function type. If the resulting pointer is converted back to the original type, it compares equal to the original value. If the converted pointer is used to make a function call, the behavior is undefined (unless the function types are compatible)</li><li> When casting between pointers (either object or function), if the original value is a null pointer value of its type, the result is the correct null pointer value for the target type.</li></ul><p>In any case (both when executing an implicit conversion and in the same-type cast), if <i>expression</i> and <i>type-name</i> are floating types and <i>expression</i> is represented with greater range and precision than its type indicates (see <code>FLT_EVAL_METHOD</code>, the range and precision are stripped off to match the target type.</p><p>The value category of the cast expression is always non-lvalue.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/cast.html
character_constant	A										<section class="prog__container"><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>'</code> <i>c-char</i> <code>'</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>u</code> <code>'</code> <i>c-char</i> <code>'</code> </td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>U</code> <code>'</code> <i>c-char</i> <code>'</code> </td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>L</code> <code>'</code> <i>c-char</i> <code>'</code></td><td> (4)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>'</code> <i>c-char-sequence</i> <code>'</code></td><td> (5)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><ul><li> <i>c-char</i> is either</li></ul><dl><dd><ul><li> a character from the basic source character set minus single-quote (<code>'</code>), backslash (<code>\</code>), or the newline character.</li><li> escape sequence: one of special character escapes <code>\'</code> <code>\"</code> <code>\?</code> <code>\\</code> <code>\a</code> <code>\b</code> <code>\f</code> <code>\\n</code> <code>\r</code> <code>\\t</code> <code>\v</code>, hex escapes <code>\\x...</code> or octal escapes <code>\...</code> as defined in escape sequences.</li><li> <table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>universal character name, <code>\u...</code> or <code>\U...</code> as defined in escape sequences.</p></td><td></td></tr></table><ul><li> <i>c-char-sequence</i> is a sequence of two or more <i>c-char</i>s.</li></ul><ul>1) single-byte integer character constant, e.g. <code>'a'</code> or <code>'\\n'</code> or <code>'\\13'</code>. Such constant has type <code>int</code> and a value equal to the representation of <i>c-char</i> in the execution character set as a value of type <code>char</code> mapped to <code>int</code>. If <i>c-char</i> is not representable as a single byte in the execution character set, the value is implementation-defined.</ul><ul>2) 16-bit wide character constant, e.g. <code>u'貓'</code>, but not <code>u'🍌'</code> (<code>u'\U0001f34c'</code>). Such constant has type <code>char16_t</code> and a value equal to the value of <i>c-char</i> in the 16-bit encoding produced by <code>mbrtoc16</code> (normally UTF-16). If <i>c-char</i> is not representable or maps to more than one 16-bit character, the behavior is implementation-defined.</ul><ul>3) 32-bit wide character constant, e.g. <code>U'貓'</code> or <code>U'🍌'</code>. Such constant has type <code>char32_t</code> and a value equal to the value of <i>c-char</i> in in the 32-bit encoding produced by <code>mbrtoc32</code> (normally UTF-32). If <i>c-char</i> is not representable or maps to more than one 32-bit character, the behavior is implementation-defined.</ul><ul>4) wide character constant, e.g. <code>L'β'</code> or <code>L'貓</code>. Such constant has type <code>wchar_t</code> and a value equal to the value of <i>c-char</i> in the execution wide character set (that is, the value that would be produced by <code>mbtowc</code>). If <i>c-char</i> is not representable or maps to more than one wide character (e.g. a non-BMP value on Windows where wchar_t is 16-bit), the behavior is implementation-defined .</ul><ul>5) multicharacter constant, e.g. <code>'AB'</code>, has type <code>int</code> and implementation-defined value.</ul></li></ul></dd></dl>  <style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/character_constant.html
compatible_type	A										<section class="prog__container"><p><small>(See also arithmetic types for the details on most built-in types and  the list of type-related utilities that are provided by the C library)</small></p><p>Objects, functions, and expressions have a property called <i>type</i>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</p><h3><span class="prog__sub">Type classification</span></h3><p>The C type system consists of the following types:<br></p><ul><li>the type <code>void</code></li><li>basic types</li></ul><dl><dd><ul><li>the type <code>char</code></li><li>signed integer types</li></ul><dl><dd><ul><li>standard: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> <span></span> <span></span></li><li>extended: implementation defined, e.g. <code>__int128</code></li></ul></dd></dl><ul><li>unsigned integer types</li></ul><dl><dd><ul><li>standard: <code>_Bool</code> <span></span> <span></span>, <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code> <span></span> <span></span></li><li>extended: implementation-defined, e.g. <code>__uint128</code></li></ul></dd></dl><ul><li>floating types</li></ul><dl><dd><ul><li>real floating types: <code>float</code>, <code>double</code>, <code>long double</code></li><li>complex types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code></li><li>imaginary types: <code>float _Imaginary</code>, <code>double _Imaginary</code>, <code>long double _Imaginary</code></li></ul></dd></dl></dd></dl><ul><li> enumerated types</li></ul><ul><li> derived types</li></ul><dl><dd><ul><li> array types</li><li> structure types</li><li> union types</li><li> function types</li><li> pointer types</li><li> atomic types</li></ul></dd></dl><p>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers (where allowed by the qualifier's semantics).</p><h4>Type groups</h4><ul><li> <i>object types</i>: all types that aren't function types</li><li> <i>character types</i>: <code>char</code>, <code>signed char</code>, <code>unsigned char</code></li><li> <i>integer types</i>: <code>char</code>, signed integer types, unsigned integer types, enumerated types</li><li> <i>real types</i>: integer types and real floating types </li><li> arithmetic types: integer types and floating types</li><li> <i>scalar types</i>: arithmetic types and pointer types</li><li> <i>aggregate types</i>: array types and structure types</li><li> <i>derived declarator types</i>: array types, function types, and pointer types </li></ul><h3><span class="prog__sub">Compatible types</span></h3><p>In a C program, the declarations referring to the same object or function in <i>different translation units</i> do not have to use the same type. They only have to use sufficiently similar types, formally known as <i>compatible types</i>. Same applies to function calls and lvalue accesses; argument types must be <i>compatible</i> with parameter types and lvalue expression type must be <i>compatible</i> with the object type that is accessed.</p><p>The types <code>T</code> and <code>U</code> are compatible, if</p><ul><li> they are the same type (same name or aliases introduced by a typedef)</li><li> they are identically cvr-qualified versions of compatible unqualified types</li><li> they are pointer types and are pointing to compatible types</li><li> they are array types, and</li></ul><dl><dd><ul><li> their element types are compatible, and</li><li> if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. <span>VLA is compatible with any array of compatible element type.</span> <span></span></li></ul></dd></dl><ul><li> they are both structure/union/enumeration types, and</li></ul><dl><dd><ul><li>if one is declared with a tag, the other must also be declared with the same tag.</li><li> if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.</li><li> additionally, if they are enumerations, corresponding members must also have the same values.</li><li> additionally, if they are structures or unions,</li></ul><dl><dd><ul><li> Corresponding members must be declared in the same order (structures only)</li><li> Corresponding bit fields must have the same widths.</li></ul></dd></dl></dd></dl><ul><li> one is an enumerated type and the other is that enumeration's underlying type</li><li> they are function types, and</li></ul><dl><dd><ul><li> their return types are compatible</li><li> they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, the corresponding parameters have compatible types</li><li> one is an old-style (parameter-less) definition, the other has a parameter list, the parameter list does not use an ellipsis and each parameter is compatible (after function parameter type adjustment) with the corresponding old-style parameter after default argument promotions</li><li> one is an old-style (parameter-less) declaration, the other has a parameter list, the parameter list does not use an ellipsis, and all parameters (after function parameter type adjustment) are unaffected by default argument promotions</li></ul></dd></dl><p>The type <code>char</code> is not compatible with <code>signed char</code> and not compatible with <code>unsigned char</code>.</p><p>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.<br></p><pre><code>// Translation Unit 1struct S {int a;};extern struct S *x;  // compatible with TU2's x, but not with TU3's x// Translation Unit 2struct S;extern struct S *x; // compatible with both x's// Translation Unit 3struct S {float a;};extern struct S *x; // compatible with TU2's x, but not with TU1's x // the behavior is undefined</code></pre><pre><code>// Translation Unit 1#include <stdio.h>struct s {int i;}; // compatible with TU3's s, but not TU2'sextern struct s x = {0}; // compatible with TU3's xextern void f(void); // compatible with TU2's fint main(){   f();   return x.i;}// Translation Unit 2struct s {float f;}; // compatible with TU4's s, but not TU1's sextern struct s y = {3.14}; // compatible with TU4's yvoid f() // compatible with TU1's f{   return;}// Translation Unit 3struct s {int i;}; // compatible with TU1's s, but not TU2's sextern struct s x; // compatible with TU1's x// Translation Unit 4struct s {float f;}; // compatible with TU2's s, but not TU1's sextern struct s y; // compatible iwth TU2's y // the behavior is well-defined: only multiple declarations// of objects and functions must have compatible types, not the types themselves</code></pre><p>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.<br></p><h3><span class="prog__sub">Composite types</span></h3><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete </td></tr></table><h3><span class="prog__sub">Incomplete types</span></h3><p>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.<br></p><p>The following types are incomplete:<br></p><ul><li> the type <code>void</code>. This type cannot be completed.</li><li> array type of unknown size. It can be completed by a later declaration that specifies the size.</li><li> structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.</li></ul><h3><span class="prog__sub">Type names</span></h3><p>A type may have to be named in context other than the declaration. In these situations, <i>type name</i> is used, which is, grammatically, exactly the same as a list of <i>type-specifiers</i> and <i>type-qualifiers</i>, followed by the <i>declarator</i> (see declarations) as would be used to declare a single object or function of this type, except that the identifier is omitted:</p><pre><code>int n; // declaration of an intsizeof(int); // use of type name int *a[3]; // declaration of an array of 3 pointers to intsizeof(int *[3]); // use of type name int (*p)[3]; // declaration of a pointer to array of 3 intsizeof(int (*)[3]); // use of type name int (*a)[*] // declaration of pointer to VLA (in a function parameter)sizeof(int (*)[*]) // use of type name (in a function parameter) int *f(void); // declaration of functionsizeof(int *(void)); // use of type name int (*p)(void); // declaration of pointer to functionsizeof(int (*)(void)); // use of type name int (*const a[])(unsigned int, ...) = {0}; // array of pointers to functionssizeof(int (*const [])(unsigned int, ...)); // use of type name</code></pre><p>Except the redundant parentheses around the identifier are meaningful in a type-name and represent "function with no parameter specification":<br></p><pre><code>int (n); // declares n of type intsizeof(int ()); // uses type "function returning int"</code></pre><p>Type names are used in the following situations:<br></p><ul><li> cast</li><li> sizeof</li></ul><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><ul><li> compound literal</li></ul></td><td></td></tr><tr class="t-rev t-since-c11"><td><ul><li> generic selection</li><li> alignof</li><li> alignas</li><li> _Atomic (when used as a type specifier)</li></ul></td><td></td></tr></table><p><br>A type name may introduce a new type: <br></p><pre><code>void* p = (void*)(struct X {int i;} *)0;// type name "struct X {int i;}*" used in the cast expression// introduces the new type "struct X"struct X x = {1}; // struct X is now in scope</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/compatible_type.html
compound_literal	A										<section class="prog__container"><p>Constructs an unnamed object of specified type in-place, used when a variable of array, struct, or union type would be needed only once.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>(</code> <i>type</i> <code>)</code> <code>{ </code> <i>initializer-list</i> <code>} </code></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><table class="t-par-begin"><tr class="t-par"><td> <i>type</i></td><td> -</td><td>  a type name specifying any complete object type or an array of unknown size, but not a VLA</td></tr><tr class="t-par"><td> <i>initializer-list</i></td><td> -</td><td>  list of initializers suitable for initialization of an object of <i>type</i></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The compound literal expression constructs an unnamed object of the type specified by <i>type</i> and initializes it as specified by <i>initializer-list</i>.</p><p>The type of the compound literal is <i>type</i> (except when <i>type</i> is an array of unknown size; its size is deduced from the <i>initializer-list</i> as in array initialization).</p><p>The value category of a compound literal is lvalue (its address can be taken).</p><p>The unnamed object to which the compound literal evaluates has static storage duration if the compound literal occurs at file scope and automatic storage duration if the compound literal occurs at block scope (in which case the object's lifetime ends at the end of the enclosing block).</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/compound_literal.html
conformance	A										<section class="prog__container"><p><i>Conformance</i> has a three-fold definition:</p><ul><li> <i>strictly conforming program</i> - uses only well-defined language constructs, that is constructs with a single behavior. It excludes unspecified, undefined, or implementation-defined behavior, and does not exceed any minimum implementation limit.</li><li> <i>conforming program</i> - acceptable to a conforming implementation.</li><li> <i>conforming implementation</i> - A conforming hosted implementation shall accept any strictly conforming program. A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers <float.h>, <iso646.h>, <limits.h>, <stdalign.h>, <stdarg.h>, <stdbool.h>, <stddef.h>, <stdint.h>, and <stdnoreturn.h>. A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any strictly conforming program.</li></ul><h3><span class="prog__sub">Explanation</span></h3><p>The standard does not define any minimum implementation limit on translation units. A hosted environment has an operating system; a freestanding environment does not. A program running in a hosted environment may use all features described in the library clause (clause 7); a program running in a freestanding environment may use a subset of library <br>features required by clause 4.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/conformance.html
const	A										<section class="prog__container"><p>Each individual type in the C type system has several <i>qualified</i> versions of that type, corresponding to one, two, or all three of the <i>const</i>, volatile, and, for pointers to object types, restrict qualifiers. This page describes the effects of the <i>const</i> qualifier.</p><p>Objects declared with const-qualified types may be placed in read-only memory by the compiler, and if the address of a const object is never taken in a program, it may not be stored at all. </p><p><code>const</code> semantics apply to lvalue expressions only; whenever a const lvalue expression is used in context that does not require an lvalue, its <code>const</code> qualifier is lost (note that volatile qualifier, if present, isn't lost).</p><p>The lvalue expressions that designate objects of const-qualified type and the lvalue expressions that designate objects of struct or union type with at least one member of const-qualified type (including members of recursively contained aggregates or unions), are not <i>modifiable lvalues</i>. In particular, they are not assignable:</p><pre><code>const int n = 1; // object of const typen = 2; // error: the type of n is const-qualified int x = 2; // object of unqualified typeconst int* p = &amp;x;*p = 3; // error: the type of the lvalue *p is const-qualified struct {int a; const int b; } s1 = {.b=1}, s2 = {.b=2};s1 = s2; // error: the type of s1 is unqualified, but it has a const member</code></pre><p>A member of a const-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the <code>.</code> operator or the <code>-></code> operator).</p><pre><code>struct s { int i; const int ci; } s;// the type of s.i is int, the type of s.ci is const intconst struct s cs;// the types of cs.i and cs.ci are both const int</code></pre><p>If an array type is declared with the const type qualifier (through the use of typedef), the array type is not const-qualified, but its element type is. If a function type is declared with the const type qualifier (through the use of typedef), the behavior is undefined.</p><pre><code>typedef int A[2][3];const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const intint* pi = a[0]; // Error: a[0] has type const int*</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>const-qualified compound literals do not necessarily designate distinct objects; they may share storage with other compound literals and with string literals that happen to have the same or overlapping representation.<br></p><pre><code>const int* p1 = (const int[]){1,2,3};const int* p2 = (const int[]){2,3,4}; // the value of p2 may equal p1+1bool b = "abd" == (const char[]){"abc"}; // the value of b may be 1</code></pre></td><td></td></tr></table><p>A pointer to an non-const type can be implicitly converted to a pointer to const-qualified version of the same or compatible type. The reverse conversion can be performed with a cast expression.</p><pre><code>int* p = 0;const int* cp = p; // OK: adds qualifiers (int to const int)p = cp; // Error: discards qualifiers (const int to int)p = (int*)cp; // OK: cast</code></pre><p>Note that pointer to pointer to <code>T</code> is not convertible to pointer to pointer to <code>const T</code>; for two types to be compatible, their qualifications must be identical.</p><pre><code>char *p = 0;const char **cpp = &amp;p; // Error: char* and const char* are not compatible typeschar * const *pcp = &amp;p; // OK, adds qualifiers (char* to char*const)</code></pre><p>Any attempt to modify an object whose type is const-qualified results in undefined behavior.<br></p><pre><code>const int n = 1; // object of const-qualified typeint* p = (int*)&amp;n;*p = 2; // undefined behavior</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>In a function declaration, the keyword <code>const</code> may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</p><p>The following two declarations declare the same function:<br></p><pre><code>void f(double x[const], const double y[const]);void f(double * const x, const double * const y);</code></pre></td><td></td></tr></table><h3><span class="prog__sub">Keywords</span></h3><p><tt>const</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/const.html
constant_expression	A										<section class="prog__container"><p>Several varieties of expressions are known as <i>constant expressions</i></p><h3><span class="prog__sub">Preprocessor constant expression</span></h3><p>The expression following #if or #elif must expand to</p><ul><li> operators other than assignment, increment, decrement, function-call, or comma whose arguments are preprocessor constant expressions</li><li> integer constants</li><li> character constants</li><li> the special preprocessor operator <code>defined</code></li></ul><p>Character constants, when evaluated in <code>#if</code>-expressions, may be interpreted in the sourcecharacter set, the execution character set, or some other implementation-defined character set.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>Integer arithmetic in <code>#if</code>-expressions is performed using the semantics of <code>intmax_t</code> for signed types and <code>uintmax_t</code> for unsigned types.</p></td><td></td></tr></table><h3><span class="prog__sub">Integer constant expression</span></h3><p>An integer constant expression is an expression that consists only of<br></p><ul><li> operators other than assignment, increment, decrement, function-call, or comma, except that cast operators can only cast arithmetic types to integer types</li><li> integer constants</li><li> enumeration constants</li><li> character constants</li><li> floating constants, but only if they are immediately used as operands of casts to integer type</li><li> sizeof operators <span>whose operands are not VLA</span> <span></span></li></ul><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><ul><li> _Alignof operators</li></ul></td><td></td></tr></table><p>Integer constant expressions are evaluated at compile time. The following contexts require expressions that are known as <i>integer constant expressions':</i></p><ul><li> The size of a bit field.</li><li> The value of an enumeration constant</li><li> The <code>case</code> label of a switch statement</li><li> The size of a <span> non-VLA</span> <span></span> array</li><li> Integer to pointer implicit conversion.</li></ul><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><ul><li> The index in an array designator</li></ul></td><td></td></tr><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><ul><li> The first argument of <code>_Static_assert</code></li><li> The integer argument of <code>_Alignas</code></li></ul></td><td></td></tr></table><h3><span class="prog__sub">Static initializer</span></h3><p>Expressions that are used in the initializers of objects with static and thread_local storage duration must be expressions that may be one of the following</p><ul>1) <i>arithmetic constant expression</i>, which is an expression of any arithmetic type that consists of<dl><dd><ul><li> operators other than assignment, increment, decrement, function-call, or comma, except that cast operators must be converting arithmetic types to other arithmetic types</li><li> integer constants</li><li> floating constants</li><li> enumeration constants</li><li> character constants</li><li> sizeof operators <span>whose operands are not VLA</span> <span></span></li></ul></dd></dl></ul><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><dl><dd><ul><li> _Alignof operators</li></ul></dd></dl></td><td></td></tr></table><ul>2) the null pointer constant <code>NULL</code></ul><ul>3) <i>address constant expression</i>, which is <dl><dd><ul><li> a null pointer</li><li> lvalue designating an object of static storage duration or a function designator, converted to a pointer either</li></ul><dl><dd><ul><li> by using the unary address-of operator</li><li> by casting an integer constant to a pointer</li><li> by array-to-pointer or function-to-pointer implicit conversion</li></ul></dd></dl></dd></dl></ul><ul>4) <i>address constant expression</i> of some complete object type, plus or minus an <i>integer constant expression</i></ul><p>Unlike with integer constant expressions, static initializer expressions are not required to be evaluated at compile time; the compiler is at liberty to turn such initializers into executable code which is invoked prior to program startup.<br></p><pre><code>static int i = 2 || 1 / 0; // initializes i to value 1</code></pre><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: other mini-examples <br></td></tr></table><p>The value of a floating-point static initializer is never less accurate than the value of the same expression executed at run time, but it may be better.<br></p><h3><span class="prog__sub">Floating-point constant expressions</span></h3><p>Arithmetic constant expressions of floating-point types that are not used in static initializers are always evaluated as-if during run-time and are affected by the current rounding (if FENV_ACCESS is on) and report errors as specified in math_errhandling.</p><pre><code>void f(void){#pragma STDC FENV_ACCESS ON    static float x = 0.0/0.0; // static initializer: does not raise an exception    float w[] = { 0.0/0.0 }; // raises an exception    float y = 0.0/0.0; // raises an exception    double z = 0.0/0.0; // raises an exception}</code></pre></table> Category: <ul><li>Todo with reason</li></ul> <style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/constant_expression.html
continue	A										<section class="prog__container"><p>Causes the remaining portion of the enclosing for, while or  do-while loop body to be skipped.</p><p>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>continue</code> <code>;</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The <code>continue</code> statement causes a jump, as if by goto, to the end of the loop body (it may only appear within the loop body of for, while, and do-while loops).</p><p>For while loop, it acts as</p><pre><code>while (/* ... */) {   // ...    continue; // acts as goto contin;   // ...    contin:;}</code></pre><p>For do-while loop, it acts as:</p><pre><code>do {    // ...     continue; // acts as goto contin;    // ...     contin:;} while (/* ... */);</code></pre><p>For for loop, it acts as:</p><pre><code>for (/* ... */) {    // ...     continue; // acts as goto contin;    // ...     contin:;}</code></pre><h3><span class="prog__sub">Keywords</span></h3><p><tt>continue</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/continue.html
conversion	A										<section class="prog__container"><p>When an expression is used in the context where a value of a different type is expected, <i>conversion</i> may occur:</p><pre><code>int n = 1L; // expression 1L has type long, int is expectedn = 2.1; // expression 2.1 has type double, int is expectedchar *p = malloc(10); // expression malloc(10) has type void*, char* is expected</code></pre><p>Conversions take place in the following situations:<br></p><h3><span class="prog__sub">Conversion as if by assignment</span></h3><ul><li> In the assignment operator, the value of the right-hand operand is converted to the unqualified type of the left-hand operand.</li><li> In scalar initialization, the value of the initializer expression is converted to the unqualified type of the object being initialized</li><li> In a function-call expression, to a function that has a prototype, the value of each argument expression is converted to the type of the unqualified declared types of the corresponding parameter</li><li> In a return statement, the value of the operand of <code>return</code> is converted to an object having the return type of the function</li></ul><p>Note that actual assignment, in addition to the conversion, also removes extra range and precision from floating-point types and prohibits overlaps; those characteristics do not apply to conversion as if by assignment.<br></p><h3><span class="prog__sub">Default argument promotions</span></h3><p>In a function call expression when the call is made to</p><ul>1) a function without a prototype</ul><ul>2) a variadic function, where the argument expression is one of the trailing arguments that are matched against the ellipsis parameter</ul><p>Each argument of integer type undergoes <i>integer promotion</i> (see below), and each argument of type <code>float</code> is implicitly converted to the type <code>double</code></p><pre><code>int add_nums(int count, ...);int sum = add_nums(2, 'c', true); // add_nums is called with three ints: (2, 99, 1)</code></pre><p>Note that <code>float complex</code> and <code>float imaginary</code> are not promoted to <code>double complex</code> and <code>double imaginary</code> in this context.</p><h3><span class="prog__sub">Usual arithmetic conversions</span></h3><p>The arguments of the following arithmetic operators undergo implicit conversions for the purpose of obtaining the <i>common real type</i>, which is the type in which the calculation is performed:</p><ul><li> binary arithmetic *, /, %, +, -</li><li> relational operators <, >, <=, >=, ==, !=</li><li> binary bitwise arithmetic &amp;, ^, |, </li><li> the conditional operator ?:</li></ul><ul>1) If one operand is <code>long double</code>, <code>long double complex</code>, or <code>long double imaginary</code>, the other operand is implicitly converted as follows:<dl><dd><ul><li>integer or real floating type to <code>long double</code></li><li>complex type to <code>long double complex</code></li><li>imaginary type to <code>long double imaginary</code></li></ul></dd></dl></ul><ul>2) Otherwise, if one operand is <code>double</code>, <code>double complex</code>, or <code>double imaginary</code>, the other operand is implicitly converted as follows:<dl><dd><ul><li>integer or real floating type to <code>double</code></li><li>complex type to <code>double complex</code></li><li>imaginary type to <code>double imaginary</code></li></ul></dd></dl></ul><ul>3) Otherwise, if one operand is <code>float</code>, <code>float complex</code>, or <code>float imaginary</code>, the other operand is implicitly converted as follows:<dl><dd><ul><li>integer type to <code>float</code> (the only real type possible is float, which remains as-is)</li><li>complex type remains <code>float complex</code></li><li>imaginary type remains <code>float imaginary</code></li></ul></dd></dl></ul><ul>4) Otherwise, both operands are integers. In that case, <dl><dd>First of all, both operands undergo <i>integer promotions</i> (see below). Then<ul><li> If the types after promotion are the same, that type is the common type</li><li> Otherwise, if both operands after promotion have the same signedness (both signed or both unsigned), the operand with the lesser <i>conversion rank</i> (see below) is implicitly converted to the type of the operand with the greater <i>conversion rank</i></li><li> Otherwise, the signedness is different: If the operand with the unsigned type has <i>conversion rank</i> greater or equal than the rank of the type of the signed operand, then the operand with the signed type is implicitly converted to the unsigned type</li><li> Otherwise, the signedness is different and the signed operand's rank is greater than unsigned operand's rank. In this case, if the signed type can represent all values of the unsigned type, then the operand with the unsigned type is implicitly converted to the type of the signed operand.</li><li> Otherwise, both operands undergo implicit conversion to the unsigned type counterpart of the signed operand's type.</li></ul></dd></dl><pre><code>1.f + 20000001; // int is converted to float, giving 20000000.00                // addition and then rounding to float gives 20000000.00(char)'a' + 1L; // First, char is promoted back to int.                // this is signed + signed case, different rank                // int is converted to long, the result is 98 signed long2u - 10; // signed / unsigned, same rank         // 10 is converted to unsigned, unsigned math is modulo UINT_MAX+1         // assuming 32 bit ints, result is 4294967288 of type unsigned int (aka UINT_MAX-7)0UL - 1LL; // signed/unsigned diff rank, rank of signed is greater.           // If sizeof(long) == sizeof(long long), signed cannot represent all unsigned           // this is the last case: both operands are converted to unsigned long long           // the result is 18446744073709551615 (ULLONG_MAX) of type unsigned long long</code></pre></ul><p>The result type is determined as follows:<br></p><ul><li> if both operands are complex, the result type is complex</li><li> if both operands are imaginary, the result type is imaginary </li><li> if both operands are real, the result type is real</li><li> if the two floating-point operands have different type domains (complex vs. real, complex vs imaginary, or imaginary vs. real), the result type is complex</li></ul><pre><code>double complex z = 1 + 2*I;double f = 3.0;z + f; // z remains as-is, f is converted to double, the result is double complex</code></pre><p>As always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see <code>FLT_EVAL_METHOD</code>).</p><p>Note: real and imaginary operands are not implicitly converted to complex because doing so would require extra computation, while producing undesirable results in certain cases involving infinities, NaNs and signed zeros. For example, if reals were converted to complex, 2.0×(3.0+i∞)  would evaluate as (2.0+i0.0)×(3.0+i∞) ⇒ (2.0×3.0–0.0×∞) + i(2.0×∞+0.0×3.0) ⇒ NaN+i∞ rather than the correct 6.0+i∞. If imaginaries were converted to complex, i2.0×(∞+i3.0) would evaluate as (0.0+i2.0) × (∞+i3.0) ⇒ (0.0×∞ – 2.0×3.0) + i(0.0×3.0 + 2.0×∞) ⇒ NaN + i∞ instead of –6.0 + i∞.<br></p><p>Note: regardless of usual arithmetic conversions, the calculation may always be performed in a narrower type than specifier by these rules under the as-if rule</p><h3><span class="prog__sub">Value transformations</span></h3><h4>Lvalue conversion</h4><p>Any lvalue expression of any non-array type, when used in any context other than </p><ul><li> as the operand of the address-of operator (if allowed)</li><li> as the operand of the pre/post increment and decrement operators.</li><li> as the left-hand operand of the member access (dot) operator.</li><li> as the left-hand operand of the assignment and compound assignment operators.</li><li> as the operand of sizeof</li></ul><p>undergoes <i>lvalue conversion</i>: the type remains the same, but loses const/volatile/restrict-qualifiers and atomic properties, if any. The value remains the same, but loses its lvalue properties (the address may no longer be taken). </p><p>If the lvalue has incomplete type, the behavior is undefined.<br></p><p>If the lvalue designates an object of automatic storage duration whose address was never taken and if that object was uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.<br></p><p>This conversion models the memory load of the value of the object from its location.<br></p><pre><code>volatile int n = 1;int x = n;            // lvalue conversion on n reads the value of nvolatile int* p = &amp;n; // no lvalue conversion: does not read the value of n</code></pre><h4>Array to pointer conversion</h4><p>Any lvalue expression of array type, when used in any context other than </p><ul><li> as the operand of the address-of operator</li><li> as the operand of sizeof</li><li> as the string literal used for array initialization</li></ul><p>undergoes a conversion to the non-lvalue pointer to its first element.<br></p><p>If the array was declared register, the behavior is undefined.</p><pre><code>int a[3], b[3][4];int* p = a;      // conversion to &amp;a[0]int (*q)[4] = b; // conversion to &amp;b[0]</code></pre><h4>Function  to pointer conversion</h4><p>Any function designator expression, when used in any context other than <br></p><ul><li> as the operand of the address-of operator</li><li> as the operand of sizeof</li></ul><p>undergoes a conversion to the non-lvalue pointer to the function designated by the expression.<br></p><pre><code>int f(int);int (*p)(int) = f; // conversion to &amp;f(***p)(1); // repeated dereference to f and conversion back to &amp;f</code></pre><h3><span class="prog__sub">Implicit conversion semantics</span></h3><p>Implicit conversion, whether <i>as if by assignment</i> or a <i>usual arithmetic conversion</i>, consists of two stages:</p><ul>1) value transformation (if applicable)</ul><ul>2) one of the conversions listed below (if it can produce the target type)</ul><h4>Compatible types</h4><p>Conversion of a value of any type to any compatible type is always a no-op and does not change the representation.</p><pre><code>uint8_t (*a)[10];         // if uint8_t is a typedef to unsigned charunsigned char (*b)[] = a; // then these pointer types are compatible</code></pre><h4>Integer promotions</h4><p>Integer promotion is the implicit conversion of a value of any integer type with <i>rank</i> less or equal to <i>rank</i> of int or of a bit field of type _Bool, int, signed int, unsigned int, to the value of type <code>int</code> or <code>unsigned int</code></p><p>If <code>int</code> can represent the entire range of values of the original type (or the range of values of the original bit field), the value is converted to type <code>int</code>. Otherwise the value is converted to <code>unsigned int</code>.</p><p>Integer promotions preserve the value, including the sign:<br></p><pre><code>int main(void) {   void f(); // old-style function declaration   char x = 'a'; // integer conversion from int to char   f(x); // integer promotion from char back to int}void f(x) int x; {} // the function expects int</code></pre><p><i>rank</i> above is a property of every integer type and is defined as follows:</p><ul>1) the ranks of all signed integer types are different and increase with their precision: rank of signed char < rank of short < rank of int < rank of long int < rank of long long int</ul><ul>2) the ranks of all signed integer types equal the ranks of the corresponding unsigned integer types</ul><ul>3) the rank of any standard integer type is greater than the rank of any extended integer type of the same size (that is, rank of __int64 < rank of long long int, but rank of long long < rank of __int128 due to the rule (1))</ul><ul>4) rank of char equals rank of signed char and rank of unsigned char</ul><ul>5) the rank of _Bool is less than the rank of any other standard integer type</ul><ul>6) the rank of any enumerated type equals the rank of its compatible integer type</ul><ul>7) ranking is transitive: if rank of T1 < rank of T2 and rank of T2 < rank of T3 then rank of T1 < rank of T3</ul><ul>8) any aspects of relative ranking of extended integer types not covered above are implementation defined</ul><p>Note: integer promotions are applied only<br></p><ul><li> as part of <i>usual arithmetic conversions</i> (see above)</li><li> as part of <i>default argument promotions</i> (see above)</li><li> to the operand of the unary arithmetic operators + and -</li><li> to the operand of the unary bitwise operator ~</li><li> to both operands of the shift operators << and >></li></ul><h4>Boolean conversion</h4><p>A value of any scalar type can be implicitly converted to _Bool. The values that compare equal to zero are converted to <code>​0​</code>, all other values are converted to <code>1</code></p><pre><code>bool b1 = 0.5;              // b1 == 1 (0.5 converted to int would be zero)bool b2 = 2.0*_Imaginary_I; // b2 == 1 (but converted to int would be zero)bool b3 = 0.0 + 3.0*I;      // b3 == 1 (but converted to int would be zero)bool b4 = 0.0/0.0;          // b4 == 1 (NaN does not compare equal to zero)</code></pre><h4>Integer conversions</h4><p>A value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:<br></p><ul><li> if the target type can represent the entire range of values of the source type, the value is unchanged</li><li> otherwise, if the target type is unsigned, the value 2<span class="t-su">b<br/></span>, where b is the number of bits in the target type, is repeatedly subtracted or added to the source value until the result fits in the target type. In other words, unsigned integers implement modulo arithmetic.</li><li> otherwise, if the target type is signed, the behavior is implementation-defined (which may include raising a signal)</li></ul><pre><code>char x = 'a'; // int -> char, result unchangedunsigned char n = -123456; // target is unsigned, result is 192 (that is, -123456+483*256)signed char m = 123456;    // target is signed, result is implementation-defined</code></pre><h4>Real floating-integer conversions</h4><p>A finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:<br></p><ul><li> The fractional part is discarded (truncated towards zero).</li></ul><dl><dd><ul><li> If the resulting value can be represented by the target type, that value is used</li><li> otherwise, the behavior is undefined </li></ul></dd></dl><pre><code>int n = 3.14; // n == 3int x = 1e10; // undefined behavior for 32-bit int</code></pre><p>A value of any integer type can be implicitly converted to any real floating type. <br></p><ul><li> if the value can be represented exactly by the target type, it is unchanged</li><li> if the value can be represented, but cannot be represented exactly, the result is the nearest higher or the nearest lower value (in other words, rounding direction is implementation-defined), although if IEEE arithmetic is supported, rounding is to nearest. It is unspecified whether <code>FE_INEXACT</code> is raised in this case.</li><li> if the value cannot be represented, the behavior is undefined, although if IEEE arithmetic is supported, <code>FE_INVALID</code> is raised and the result value is unspecified.</li></ul><p>The result of this conversion may have greater range and precision than its target type indicates (see <code>FLT_EVAL_METHOD</code>.</p><p>If control over <code>FE_INEXACT</code> is needed in floating-to-integer conversions, <code>rint</code> and <code>nearbyint</code> may be used.</p><pre><code>double d = 10; // d = 10.00float f = 20000001; // f = 20000000.00 (FE_INEXACT)float x = 1+(long long)FLT_MAX; // undefined behavior</code></pre><h4>Real floating point conversions</h4><p>A value of any real floating type can be implicitly converted to any other real floating type.<br></p><ul><li> If the value can be represented by the target type exactly, it is unchanged</li><li> if the value can be represented, but cannot be represented exactly, the result is the nearest higher or the nearest lower value (in other words, rounding direction is implementation-defined), although if IEEE arithmetic is supported, rounding is to nearest</li><li> if the value cannot be represented, the behavior is undefined <table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: check IEEE if appropriately-signed infinity is required <br></td></tr></table></li></ul><p>The result of this conversion may have greater range and precision than its target type indicates (see <code>FLT_EVAL_METHOD</code>.</p><pre><code>double d = 0.1; // d = 0.1000000000000000055511151231257827021181583404541015625float f = d;    // f = 0.100000001490116119384765625float x = 2*(double)FLT_MAX; // undefined</code></pre><h4>Complex type conversions</h4><p>A value of any complex type can be implicitly converted to any other complex type. The real part and the imaginary part individually follow the conversion rules for the real floating types.<br></p><pre><code>double complex d = 0.1 + 0.1*I;float complex f = d; // f is (0.100000001490116119384765625, 0.100000001490116119384765625)</code></pre><h4>Imaginary type conversions</h4><p>A value of any imaginary type can be implicitly converted to any other imaginary  type. The imaginary part follows the conversion rules for the real floating types.<br></p><pre><code>double imaginary d = 0.1*_Imaginary_I;float imaginary f = d; // f is 0.100000001490116119384765625*I</code></pre><h4>Real-complex conversions</h4><p>A value of any real floating type can be implicitly converted to any complex type. <br></p><ul><li> The real part of the result is determined by the conversion rules for the real floating types</li><li> The imaginary part of the result is positive zero (or unsigned zero on non-IEEE systems)</li></ul><p>A value of any complex type can be implicitly converted to any real floating type<br></p><ul><li> The real part is converted following the rules for the real floating types</li><li> The imaginary part is discarded</li></ul><p>Note: in complex-to-real conversion, a NaN in the imaginary part will not propagate to the real result.<br></p><pre><code> </code></pre><h4>Real-imaginary conversions</h4><p>A value of any imaginary type can be implicitly converted to any real type (integer or floating-point). The result is always a positive (or unsigned) zero, except when the target type is _Bool, in which case boolean conversion rules apply.<br></p><p>A value of any real type can be implicitly converted to any imaginary type. The result is always a positive imaginary zero.<br></p><pre><code> </code></pre><h4>Complex-imaginary conversions</h4><p>A value of any imaginary type can be implicitly converted to any complex type.<br></p><ul><li> The real part of the result is the positive zero</li><li> The imaginary part of the result follows the conversion rules for the corresponding real types</li></ul><p>A value of any complex type can be implicitly converted to any imaginary type<br></p><ul><li> The real part is discarded</li><li> The imaginary part of the result follows the conversion rules for the corresponding real types</li></ul><pre><code>double imaginary z = I * (3*I); // the complex result -3.0+0i loses real part, gives zero</code></pre><h4>Pointer conversions</h4><p>A pointer to <code>void</code> can be implicitly converted to and from any pointer to object type with the following semantics:</p><ul><li> If a pointer to object is converted to a pointer to void and back, its value compares equal to the original pointer.</li><li> No other guarantees are offered</li></ul><pre><code>int* p = malloc(10 * sizeof(int)); // malloc returns void*</code></pre><p>A pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, const, volatile, and restrict qualifiers can be added. The original pointer and the result compare equal.</p><pre><code>int n;const int* p = &amp;n; // &amp;n has type int*</code></pre><p>Any integer constant expression with value <code>​0​</code> as well as integer pointer expression with value zero cast to the type <code>void*</code> can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void* expression is known as <i>null pointer constant</i> and the standard library provides one definition of this constant as the macro <code>NULL</code> .</p><pre><code>int* p = 0;double* q = NULL;</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/conversion.html
declarations	A										<section class="prog__container"><p>A <i>declaration</i> is a C language construct that introduces one or more  identifiers into the program and specifies their meaning and properties.</p><p>Declarations may appear in any scope. Each declaration ends with a semicolon (just like a statement) and consists of two distinct parts:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>specifiers-and-qualifiers</i> <i>declarators-and-initializers</i> <code>;</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><table class="t-par-begin"><tr class="t-par"><td> <i>specifiers-and-qualifiers</i></td><td> -</td><td>  whitespace-separated list of, in any order,<ul><li> type specifiers:</li></ul><dl><dd><ul><li> <code>void</code></li><li> the name of an arithmetic type</li><li> the name of an atomic type</li><li> a name earlier introduced by a typedef declaration</li><li> struct, union, or enum specifier</li></ul></dd></dl><ul><li> zero or one storage-class specifiers: typedef, auto, register, static, extern, thread_local</li><li> zero or more type qualifiers: const, volatile, restrict, _Atomic</li><li> (only when declaring functions), zero or more function qualifiers: inline, noreturn</li><li> zero or more alignment specifiers: alignas</li></ul></td></tr><tr class="t-par"><td> <i>declarators-and-initializers</i></td><td> -</td><td>  comma-separated list of <i>declarators</i> (each declarator provides additional type information and/or the identifier to declare). Declarators may be accompanied by initializers. The enum, struct, and union declarations may omit <i>declarators</i>, in which case they only introduce the enumeration constants and/or tags.<p><br></p></td></tr></table><p>For example,<br></p><pre><code>int a, *b=NULL; // "int" is the type specifier,                // "a" is a declarator                // "*b" is a declarator and NULL is its initializerconst int *f(void); // "int" is the type specifier                    // "const" is the type qualifier                    // "*f(void)" is the declaratorenum COLOR {RED, GREEN, BLUE} c; // "enum COLOR {RED, GREEN, BLUE}" is the type specifier                                 // "c" is the declarator</code></pre><p>The type of each identifier introduced in a declaration is determined by a combination of the type specified by the <i>type specifier</i> and the type modifications applied by its <i>declarator</i>.</p><h3><span class="prog__sub">Declarators</span></h3><p>Each declarator is one of the following:<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>identifier</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>(</code> <i>declarator</i> <code>)</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>*</code> <i>qualifiers</i>(optional) <i>declarator</i></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>noptr-declarator</i> <code>[</code> <i>static</i>(optional) <i>qualifiers</i>(optional) <i>expression</i> <code>]</code><p><i>noptr-declarator</i> <code>[</code> <i>qualifiers</i>(optional) <code>*</code> <code>]</code></p></td><td> (4)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>noptr-declarator</i> <code>(</code> <i>parameters-or-identifiers</i> <code>)</code></td><td> (5)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) the identifier that this declarator introduces.</ul><ul>2) any declarator may be enclosed in parentheses; this is required to introduce pointers to arrays and pointers to functions.</ul><ul>3) pointer declarator: the declaration <code>S * cvr D</code>; declares <code>D</code> as a <i>cvr</i>-qualified pointer to the type determined by <code>S</code>.</ul><ul>4) array declarator: the declaration <code>S D[N]</code> declares <code>D</code> as an array of <code>N</code> objects of the type determined by <code>S</code>. <i>noptr-declarator</i> is any other declarator except unparenthesized pointer declarator.</ul><ul>5) function declarator: the declaration <code>S D(params)</code> declared <code>D</code> as a function taking the parameters <code>params</code> and returning <code>S</code>. <i>noptr-declarator</i> is any other declarator except unparenthesized pointer declarator.</ul><p>The reasoning behind this syntax is that when the identifier declared by the declarator appears in an expression of the same form as the declarator, it would have the type specified by the type specifier sequence.<br></p><pre><code>struct C {    int member; // "int" is the type specifier                 // "member" is the declarator} obj, *pObj = &amp;obj;// "struct C { int member; }" is the type specifier// declarator "obj" defines an object of type struct C// declarator "*pObj" declares a pointer to C,// initializer "= &amp;obj" provides the initial value for that pointer int a = 1, *p = NULL, f(void), (*pf)(double);// the type specifier is "int"// declarator "a" defines an object of type int//   initializer "=1" provides its initial value// declarator "*p" defines an object of type pointer to int//   initializer "=NULL" provides its initial value// declarator "f(void)" declares a function taking void and returning int// declarator "(*pf)(double)" defines an object of type pointer//   to function taking double and returning int int (*(*foo)(double))[3] = NULL;// the type specifier is int// 1. declarator "(*(*foo)(double))[3]" is an array declarator://    the type declared is "/nested declarator/ array of 3 int"// 2. the nested declarator is "*(*foo)(double))", which is a pointer declarator//    the type declared is "/nested declarator/ pointer to array of 3 int"// 3. the nested declarator is "(*foo)(double)", which is a function declarator//    the type declared is "/nested declarator/ function taking double and returning//        pointer to array of 3 int"// 4. the nested declarator is "(*foo)" which is a (parenthesized, as required by//        function declarator syntax) pointer declarator.//    the type declared is "/nested declarator/ pointer to function taking double//        and returning pointer to array of 3 int"// 5. the nested declarator is "foo", which is an identifier.// The declaration introduces the identifier "foo" to refer to an object of type// "pointer to function taking double and returning pointer to array of 3 int"// The initializer "= NULL" provides the initial value of this pointer. // If "foo" is used in an expression of the form of the declarator, its type would be// int.int x = (*(*foo)(1.2))[0];</code></pre><p>The end of every declarator that is not part of another declarator is a sequence point.</p><h3><span class="prog__sub">Definitions</span></h3><p>A <i>definition</i> is a declaration that provides all information about the identifiers it declares.</p><p>Every declaration of an enum or a typedef is a definition.</p><p>For functions, a declaration that includes the function body is a function definition:</p><pre><code>int foo(double); // declarationint foo(double x){ return x; } // definition</code></pre><p>For objects, a declaration that allocates storage (automatic or static, but not extern) is a definition, while a declaration that does not allocate storage (external declaration) is not.</p><pre><code>extern int n; // declarationint n = 10; // definition</code></pre><p>For structs and unions, declarations that specify the list of members are definitions:</p><pre><code>struct X; // declarationstruct X { int n; }; // definition</code></pre><h3><span class="prog__sub">Redeclaration</span></h3><p>A declaration cannot introduce an identifier if another declaration for the same identifier in the same scope appears earlier, except that</p><ul><li> Declarations of objects with linkage (external or internal) can be repeated:</li></ul><pre><code>extern int x;int x = 10; // OKextern int x; // OK static int n;static int n = 10; // OKstatic int n; // OK</code></pre><ul><li> Non-VLA typedef can be repeated as long as it names the same type:</li></ul><pre><code>typedef int int_t; typedef int int_t; // OK</code></pre><ul><li> struct and union declarations can be repeated:</li></ul><pre><code>struct X;struct X { int n; };struct X;</code></pre><p>These rules simplify the use of header files.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/declarations.html
do	A										<section class="prog__container"><p>Executes a <i>statement</i> repeatedly until the value of <i>condition</i> becomes false. The test takes place after each iteration.</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>do</code> <i>statement</i> <code>while (</code> <i>expression</i> <code>)</code> <code>;</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any expression of scalar type. This expression is evaluated after each iteration, and if it compares equal to zero, the loop is exited.</td></tr><tr class="t-par"><td> <i>statement</i></td><td> -</td><td>  any statement, typically a compound statement, which is the body of the loop</td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>A <code>do-while</code> statement causes the <i>statement</i> (also called <i>the loop body</i>) to be executed repeatedly until the <i>expression</i> (also called <i>controlling expression</i>) compares equal to 0. The repetition occurs regardless of whether the loop body is entered normally or by a goto into the middle of <i>statement</i>.</p><p>The evaluation of <i>expression</i> takes place after each execution of <i>statement</i> (whether entered normally or by a goto). If the controlling expression needs to be evaluated before the loop body, the while loop or the for loop may be used.</p><p>If the execution of the loop needs to be terminated at some point,  break statement can be used as terminating statement. </p><p>If the execution of the loop needs to be continued at the end of the loop body,  continue statement can be used as a shortcut.</p><p>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its <i>statement</i> or <i>expression</i>. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where <i>expression</i> is a constant expression; <code>do {...} while(true);</code> is always an endless loop.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>As with all other selection and iteration statements, the do-while statement establishes block scope: any identifier introduced in the <i>expression</i> goes out of scope after the statement.</p></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/do.html
enum	A										<section class="prog__container"><p>An <i>enumerated type</i> is a distinct type whose value is a value of its <i>underlying type</i> (see below), which includes the values of explicitly named constants (<i>enumeration constants</i>).</p><h3><span class="prog__sub">Syntax</span></h3><p>Enumerated type is declared using the following <i>enumeration specifier</i> as the <i>type specifier</i> in the declaration grammar:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>enum</code> <i>identifier</i>(optional) <code>{</code> <i>enumerator-list</i> <code></code>}</td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <i>enumerator-list</i> is a comma-separated list<span> (with trailing comma permitted)</span> <span></span> of <i>enumerators</i>, each of which has the form:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>enumerator</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>enumerator</i> <code>=</code> <i>constant-expression</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><table class="t-par-begin"><tr class="t-par"><td> <i>identifier</i>, <i>enumerator</i></td><td> -</td><td>  identifiers that are introduced by this declaration</td></tr><tr class="t-par"><td> <i>constant-expression</i></td><td> -</td><td> integer constant expression whose value is representable as a value of type <code>int</code></td></tr></table><p>As with struct or union, a declaration that introduced an enumerated type and one or more enumeration constants may also declare one or more objects of that type or type derived from it.</p><pre><code>enum color_t {RED, GREEN, BLUE}, c = RED, *cp = &amp;c; // introduces the type enum color_t // the integer constants RED, GREEN, BLUE  // the object c of type enum color_t // the object cp of type pointer to enum color_t</code></pre><h3><span class="prog__sub">Explanation</span></h3><p>Each <i>enumerator</i> that appears in the body of an enumeration specifier becomes an integer constant with type <code>int</code> in the enclosing scope and can be used whenever integer constants are required (e.g. as a case label or as a non-VLA array size).</p><pre><code>enum color_t { RED, GREEN, BLUE} r = RED;switch(r) {     case RED   : puts("red"); break;     case GREEN : puts("green"); break;     case BLUE  : puts("blue"); break;}</code></pre><p>If <i>enumerator</i> is followed by <i>= constant-expression</i>, its value is the value of that constant expression. If <i>enumerator</i> is not followed by <i>= constant-expression</i>, its value is the value one greater than the value of the previous enumerator in the same enumeration. The value of the first enumerator (if it does not use <i>= constant-expression</i>) is zero.</p><pre><code>enum Foo { A, B, C=10, D, E=1, F, G=F+C};//A=0, B=1, C=10, D=11, E=1, F=2, G=12</code></pre><p>The <i>identifier</i> itself, if used, becomes the name of the enumerated type in the tags name space and requires the use of the keyword enum (unless typedef'd into the ordinary name space).</p><pre><code>enum color_t { RED, GREEN, BLUE};enum color_t r = RED; // OK// color_t x = GREEN: // Error: color_t is not in ordinary name spacetypedef enum color_t color;color x = GREEN; // OK</code></pre><p>Each enumerated type is compatible with one of: <code>char</code>, a signed integer type, or an unsigned integer type. It is implementation-defined which type is compatible with any given enumerated type, but whatever it is, it must be capable of representing all enumerator values of that enumeration.</p><p>Enumerated types are integer types, and as such can be used anywhere other integer types can, including in implicit conversions and arithmetic operators.</p><pre><code>enum { ONE = 1, TWO } e;long n = ONE; // promotiondouble d = ONE; // conversione = 1.2; // conversion, e is now ONEe = e + 1; // e is now TWO</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/enum.html
escape	A										<section class="prog__container"><p>Escape sequences are used to represent certain special characters within string literals and character constants. </p><p>The following escape sequences are available. ISO C requires a diagnostic if the backslash is followed by any character not listed here:<br></p><table class="wikitable"><tr><th> Escape<br> sequence<br></th><th> Description</th><th> Representation</th></tr><tr><td> <code>\'</code></td><td> single quote</td><td> byte <code>0x27</code> (in ASCII encoding)</td></tr><tr><td> <code>\"</code></td><td> double quote</td><td> byte <code>0x22</code> (in ASCII encoding)</td></tr><tr><td> <code>\?</code></td><td> question mark</td><td> byte <code>0x3f</code> (in ASCII encoding)</td></tr><tr><td> <code>\\</code></td><td> backslash</td><td> byte <code>0x5c</code> (in ASCII encoding)</td></tr><tr><td> <code>\a</code></td><td> audible bell</td><td> byte <code>0x07</code> (in ASCII encoding)</td></tr><tr><td> <code>\b</code></td><td> backspace</td><td> byte <code>0x08</code> (in ASCII encoding)</td></tr><tr><td> <code>\f</code></td><td> form feed - new page</td><td> byte <code>0x0c</code> (in ASCII encoding)</td></tr><tr><td> <code>\\n</code></td><td> line feed - new line</td><td> byte <code>0x0a</code> (in ASCII encoding)</td></tr><tr><td> <code>\r</code></td><td> carriage return</td><td> byte <code>0x0d</code> (in ASCII encoding)</td></tr><tr><td> <code>\\t</code></td><td> horizontal tab</td><td> byte <code>0x09</code> (in ASCII encoding)</td></tr><tr><td> <code>\v</code></td><td> vertical tab</td><td> byte <code>0x0b</code> (in ASCII encoding)</td></tr><tr><td> <code><b>\<span style="font-size:0.7em; line-height:130%">nnn</span></b></code></td><td> arbitrary octal value</td><td> byte <code>nnn</code></td></tr><tr><td> <code><b>\\x<span style="font-size:0.7em; line-height:130%">nn</span></b></code></td><td> arbitrary hexadecimal value</td><td> byte <code>nn</code></td></tr><tr><td> <code><b>\u<span style="font-size:0.7em; line-height:130%">nnnn</span></b></code></td><td>  Unicode character that is not in the basic character set.<br>May result in several characters.<br></td><td> code point <code>U+nnnn</code></td></tr><tr><td> <code><b>\U<span style="font-size:0.7em; line-height:130%">nnnnnnnn</span></b></code></td><td>  Unicode character that is not in the basic character set.<br>May result in several characters.<br></td><td> code point <code>U+nnnnnnnn</code></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/escape.html
eval_order	A										<section class="prog__container"><p>Order of evaluation of the operands of any C operator, including the order of evaluation of function arguments in a function-call expression, and the order of evaluation of the subexpressions within any expression is unspecified (except where noted below). The compiler will evaluate them in any order, and may choose another order when the same expression is evaluated again.<br></p><p>There is no concept of left-to-right or right-to-left evaluation in C, which is not to be confused with left-to-right and right-to-left associativity of operators: the expression <code>f1() + f2() + f3()</code> is parsed as <code>(f1() + f2()) + f3()</code> due to left-to-right associativity of operator+, but the function call to <code>f3</code> may be evaluated first, last, or between <code>f1()</code> or <code>f2()</code> at run time.</p><h3><span class="prog__sub">Definitions</span></h3><h4>Evaluations</h4><p>There are two kinds of evaluations performed by the compiler for each expression or subexpression (both of which are optional):<br></p><ul><li> <i>value computation</i>: calculation of the value that is returned by the expression. This may involve determination of the identity of the object (lvalue evaluation) or reading the value previously assigned to an object (rvalue evaluation) </li><li> <i>side effect</i>: access (read or write) to an object designated by a volatile lvalue, modification (writing) to an object<span>, atomic synchronization</span> <span></span>, modifying a file, modifying the floating-point environment (if supported), or calling a function that does any of those operations.</li></ul><p>If no side effects are produced by an expression and the compiler can determine that the value is not used, the expression may not be evaluated.</p><h4>Ordering</h4><p>"sequenced-before" is an asymmetric, transitive, pair-wise relationship between evaluations within the same thread (it may extend across threads if atomic types and memory barriers are involved).<br></p><ul><li> If a <i>sequence point</i> is present between the subexpressions E1 and E2, then both value computation and side effects of E1 are <i>sequenced-before</i> every value computation and side effect of E2</li></ul><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><ul><li> If evaluation A is sequenced before evaluation B, then evaluation of A will be complete before evaluation of B begins.</li><li> If A is not sequenced before B and B is sequenced before A, then evaluation of B will be complete before evaluation of A begins.</li><li> If A is not sequenced before B and B is not sequenced before A, then two possibilities exist:<ul><li> evaluations of A and B are unsequenced: they may be performed in any order and may overlap (within a single thread of execution, the compiler may interleave the CPU instructions that comprise A and B)</li><li> evaluations of A and B are indeterminably-sequenced: they may be performed in any order but may not overlap: either A will be complete before B, or B will be complete before A. The order may be the opposite the next time the same expression is evaluated.</li></ul></li></ul></td><td></td></tr></table><h3><span class="prog__sub">Rules</span></h3><ul>1) There is a sequence point after the evaluation of all function arguments and of the function designator, and before the actual function call.</ul><ul>2) There is a sequence point after evaluation of the first (left) operand and before evaluation of the second (right) operand of the following binary operators: <code>&amp;&amp;</code> (logical AND), <code>||</code> (logical OR), and <code>,</code> (comma).</ul><ul>3) There is a sequence point after evaluation of the first (left) operand and before evaluation of the second or third operand (whichever is evaluated) of the conditional operator <code>?:</code></ul><ul>4) There is a sequence point after the evaluation of a full expression (an expression that is not a subexpression: typically something that ends with a semicolon or a controlling statement of if/switch/while/do) and before the next full expression.</ul><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><ul>5) There is a sequence point at the end of a full declarator.</ul><ul>6) There is a sequence point immediately before the return of a library function.</ul><ul>7) There is a sequence point after the action associated with each conversion specifier in formatted I/O (in particular, it is well-formed for <code>scanf</code> to write different fields into the same variable and for <code>printf</code> to read and modify or modify the same variable more than once using <code>%n</code>)</ul><ul>8) There are sequence points before and immediately after each call to a comparison function made by the library functions <code>qsort</code> and <code>bsearch</code>, as well as between any call to the comparison function and the movement of the associated objects made by <code>qsort</code></ul></td><td></td></tr><tr class="t-rev t-since-c11"><td><ul>9) The value computations (but not the side-effects) of the operands to any operator are sequenced before the value computation of the result of the operator (but not its side-effects).</ul><ul>10) The side effect (modification of the left argument) of the direct assignment operator and of all compound assignment operators is sequenced after the value computation (but not the side effects) of both left and right arguments.</ul><ul>11) The value computation of the postincrement and postdecrement operators is sequenced before its side-effect.</ul><ul>12) A function call that is not sequenced before or sequenced after another function call is indeterminately sequenced (CPU instructions that constitute different function calls cannot be interleaved, even if the functions are inlined)</ul><ul>13) In initialization list expressions, all evaluations are indeterminately sequenced</ul><ul>14) With respect to an indeterminately-sequenced function call, the operation of compound assignment operators, and both prefix and postfix forms of increment and decrement operators are single evaluations.</ul></td><td></td></tr></table><h3><span class="prog__sub">Undefined behavior</span></h3><ul>1) If a side effect on a scalar object is unsequenced relative to another side effect on the same scalar object, the behavior is undefined.<pre><code>i = ++i + i++; // undefined behaviori = i++ + 1; // undefined behaviorf(++i, ++i); // undefined behaviorf(i = -1, i = -1); // undefined behavior</code></pre></ul><ul>2) If a side effect on a scalar object is unsequenced relative to a value computation using the value of the same scalar object, the behavior is undefined.<pre><code>f(i, i++); // undefined behaviora[i] = i++; // undefined bevahior</code></pre></ul><ul>3) The above rules apply as long as at least one allowable ordering of subexpressions permits such an unsequenced side-effect.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/eval_order.html
expressions	A										<section class="prog__container"><p>An expression is a sequence of <i>operators</i> and their <i>operands</i>, that specifies a computation.</p><p>Expression evaluation may produce a result (e.g., evaluation of <code>2+2</code> produces the result <code>4</code>), may generate side-effects (e.g. evaluation of <code>printf("%d",4)</code> sends the character <code>'4'</code> to the standard output stream), and may designate objects or functions.</p><h4>General</h4><ul><li> value categories (lvalue, non-lvalue object, function designator) classify expressions by their values</li><li> order of evaluation of arguments and subexpressions specifies the order in which intermediate results are obtained</li></ul><h3><span class="prog__sub">Operators</span></h3><table class="wikitable"><tr style="text-align:center"><th colspan="7"> Common operators</th></tr><tr style="text-align:center"><td>  assignment</td><td>  increment<br>decrement<br></td><td>  arithmetic</td><td>  logical</td><td>  comparison</td><td>  member<br>access<br></td><td>  other</td></tr><tr style="text-align:center"><td><p><code>a = b<br>a += b<br>a -= b<br>a *= b<br>a /= b<br>a %= b<br>a &amp;= b<br>a |= b<br>a ^= b<br>a <<= b<br>a >>= b<br></code></p></td><td><p><code>++a<br>--a<br>a++<br>a--<br></code></p></td><td><p><code>+a<br>-a<br>a + b<br>a - b<br>a * b<br>a / b<br>a % b<br>~a<br>a &amp; b<br>a | b<br>a ^ b<br>a << b<br>a >> b<br></code></p></td><td><p><code>!a<br>a &amp;&amp; b<br>a || b<br></code></p></td><td><p><code>a == b<br>a != b<br>a < b<br>a > b<br>a <= b<br>a >= b<br></code></p></td><td><p><code>a[b]<br>*a<br>&amp;a<br>a->b<br>a.b<br></code></p></td><td><p><code>a(...)<br>a, b<br>(type) a<br>? :<br>sizeof<br>_Alignof<br></code> </p></td></tr></table><ul><li>  operator precedence defines the order in which operators are bound to their arguments</li><li>  alternative representations are alternative spellings for some operators </li></ul><h4>Conversions</h4><ul><li> Implicit conversions take place when types of operands do not match the expectations of operators</li><li> Casts may be used to explicitly convert values from one type to another.</li></ul><h4>Other</h4><ul><li> constant expressions can be evaluated at compile time and used in compile-time context (non-VLA array sizes, static initializers, etc)</li><li> generic selections can execute different expressions depending on the types of the arguments</li><li> Floating-point expressions may raise exceptions and report errors as specified in math_errhandling</li><li> The standard #pragmas <code>FENV_ACCESS</code>, <code>FP_CONTRACT</code>, and <code>CX_LIMITED_RANGE</code> as well as the floating-point evaluation precision and rounding direction control the way floating-point expressions are executed.</li></ul><h3><span class="prog__sub">Primary expressions</span></h3><p>The operands of any operator may be other expressions or they may be <i>primary expressions</i> (e.g. in <code>1+2*3</code>, the operands of operator+ are the subexpression <code>2*3</code> and the primary expression <code>1</code>).</p><p>Primary expressions are any of the following:<br></p><ul>1) Constants and literals (e.g. <code>2</code> or <code>"Hello, world"</code>)</ul><ul>2) Suitably declared identifiers (e.g. <code>n</code> or <code>printf</code>)</ul><ul>3) Generic selections</ul><p>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator.<br></p><h4>Constants and literals</h4><p>Constant values of certain types may be embedded in the source code of a C program using specialized expressions known as literals (for lvalue expressions) and constants (for non-lvalue expressions)<br></p><ul><li> integer constants are decimal, octal, or hexadecimal numbers of integer type.</li><li> character constants are individual characters of type int suitable for conversion to a character type or of type <span><code>char16_t</code>, <code>char32_t</code>, </span> <span></span>or <code>wchar_t</code></li><li> floating constants are values of type <code>float</code>, <code>double</code>, or <code>long double</code></li><li> string literals are sequences of characters of type <code>char[]</code>, <code>char16_t[]</code>, <code>char32_t[]</code>, or <code>wchar_t[]</code> that represent null-terminated strings</li><li> compound literals are values of struct, union, or array type directly embedded in program code</li></ul><h3><span class="prog__sub">Unevaluated expressions</span></h3><p>The operands of the sizeof operator <span>, the _Alignof operator, and the controlling expression of a generic selection,</span> <span></span> are expressions that are not evaluated<span> (unless they are VLAs)</span> <span></span>. Thus, <code>size_t n = sizeof(printf("%d", 4));</code> does not perform console output.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/expressions.html
extern	A										<section class="prog__container"><p>At the top level of a translation unit (that is, a source file with all the #includes after the preprocessor), every C program is a sequence of declarations, which declare functions and objects with external linkage. These declarations are known as <i>external declarations</i> because they appear outside of any function.</p><pre><code>extern int n; // external declaration with external linkageint b = 1;    // external definition with external linkagestatic const char *c = "abc"; // external definition with internal linkageint f(void) {  // external definition with external linkage    int a = 1; // non-external    return b; }static void x(void) { // external definition with internal linkage}</code></pre><p>Objects declared with an external declaration have static storage duration, and as such cannot use <code>auto</code> or <code>register</code> specifiers. The identifiers introduced by external declarations have file scope.</p><h3><span class="prog__sub">Tentative definitions</span></h3><p>A <i>tentative definition</i> is an external declaration without an initializer, andeither without a storage-class specifier or with the specifier <code>static</code>.</p><p>A <i>tentative definition</i> is a declaration that may or may not act as a definition. If an actual external definition is found earlier or later in the same translation unit, then the tentative definition just acts as a declaration.</p><pre><code>int i1 = 1;     // definition, external linkageint i1;         // tentative definition, acts as declaration because i1 is definedextern int i1;  // declaration, refers to the earlier definition extern int i2 = 3; // definition, external linkageint i2;            // tentative definition, acts as declaration because i2 is definedextern int i2;     // declaration, refers to the external linkage definition</code></pre><p>If there are no definitions in the same translation unit, then the tentative definition acts as an actual definition with the initializer <code>= 0</code> (or, for array types, <code>= {0}</code>).</p><pre><code>int i3;        // tentative definition, external linkageint i3;        // tentative definition, external linkageextern int i3; // declaration, external linkage// in this translation unit, i3 is defined as if by "int i3 = 0;"</code></pre><p>Unlike the extern declarations, which don't change the linkage of an identifier if a previous declaration established it, tentative definitions may disagree in linkage with another declaration of the same identifier. If two declarations for the same identifier are in scope and have different linkage, the behavior is undefined:</p><pre><code>static int i4 = 2; // definition, internal linkageint i4;            // Undefined behavior: linkage disagreement with previous lineextern int i4;     // declaration, refers to the internal linkage definition static int i5; // tentative definition, internal linkageint i5;        // Undefined behavior: linkage disagreement with previous lineextern int i5; // refers to previous, whose linkage is internal</code></pre><p>A tentative definition with internal linkage must have complete type.<br></p><pre><code>static int i[]; // Error, incomplete type in a static tentative definitionint i[]; // OK, equivalent to int i[1] = {0}; unless redeclared later in this file</code></pre><h3><span class="prog__sub">One definition rule</span></h3><p>Each translation unit may have zero or one external definition of every identifier with internal linkage (a <code>static</code> global).</p><p>If an identifier with internal linkage is used in any expression other than a <span>non-VLA</span> <span></span>, sizeof, or <span>alignof </span> <span></span>, there must be one and only one external definition for that identifier in the translation unit.</p><p>The entire program may have zero or one external definition of every identifier<span> (other than an inline function)</span> <span></span> with external linkage.</p><p>If an identifier with external linkage is used in any expression other than a <span>non-VLA</span> <span></span>, sizeof, or <span>alignof </span> <span></span>, there must be one and only one external definition for that identifier somewhere in the entire program.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/extern.html
file_scope	A										<section class="prog__container"><p>If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit.<br></p><p>So, placement of an identifier's declaration (in a declarator or type specifier) outside any block or list of parameters means that the identifier has file scope. File scope of an identifier extends from the declaration to the end of the translation unit in which the declaration appears.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/file_scope.html
floating_constant	A										<section class="prog__container"><p>Allows values of floating type to be used directly in expressions.<br></p><h3><span class="prog__sub">Syntax</span></h3><p>A floating constant is a non-lvalue expression having the form:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>significand</i> <i>exponent</i>(optional) <i>suffix</i>(optional)</td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>Where the <i>significand</i> has the form</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>whole-number</i>(optional) <code>.</code>(optional) <i>fraction</i>(optional)</td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>The <i>exponent</i> has the form</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>e</code> | <code>E</code> <i>exponent-sign</i>(optional) <i>digit-sequence</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>p</code> | <code>P</code> <i>exponent-sign</i>(optional) <i>digit-sequence</i></td><td> (2)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) The exponent syntax for a decimal floating-point constant</ul><ul>2) The exponent syntax for hexadecimal floating-point constant</ul><h3><span class="prog__sub">Explanation</span></h3><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>If the <i>significand</i> begins with the character sequence <code>0x</code> or <code>0X</code>, the floating constant is a <i>hexadecimal floating constant</i>. Otherwise, it is a <i>decimal floating constant</i>.</p><p>For a <i>hexadecimal floating constant</i>, the <i>significand</i> is interpreted as a hexadecimal rational number, and the <i>digit-sequence</i> of the exponent is interpreted as the integer power of 2 to which the significand has to be scaled.</p><pre><code>double d = 0x1.2p3; // hex fraction 1.2 (decimal 1.125) scaled by 2^3, that is 9.0</code></pre></td><td></td></tr></table><p>For a <i>decimal floating constant</i>, the <i>significand</i> is interpreted as a decimal rational number, and the <i>digit-sequence</i> of the exponent is interpreted as the integer power of 10 to which the significand has to be scaled.</p><pre><code>double d = 1.2e3; // decimal fraction 1.2 scaled by 10^3, that is 1200.0</code></pre><p>An unsuffixed floating constant has type <code>double</code>. If <i>suffix</i> is the letter <code>f</code> or <code>F</code>, the floating constant has type <code>float</code>. If <i>suffix</i> is the letter <code>l</code> or <code>L</code>, the floating constant has type <code>long double</code>.</p><p>The result of evaluating a floating constant is either the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner (in other words, default rounding direction during translation is implementation-defined).</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>Floating-point constants may convert to more range and precision than is indicated by their type, if indicated by <code>FLT_EVAL_METHOD</code>. For example, the constant <code>0.1f</code> may act as if it were <code>0.1L</code> in an expression.</p></td><td></td></tr></table><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>The result of evaluating a hexadecimal floating constant, if FLT_RADIX is 2, is the exact value represented by the floating constant, correctly rounded to the target type.<br></p></td><td></td></tr></table><p>If the exponent is present and fractional part is not used, the decimal separator may be omitted:<br></p><pre><code>double x = 1e0; // floating-point 1.0 (period not used)</code></pre><p>For decimal floating constants, the <i>exponent</i> part is optional. If it is omitted, the period is not optional, and either the <i>whole-number</i> or the <i>fraction</i> must be present.</p><pre><code>double x = 1.; // floating-point 1.0 (fractional part optional)double y = .1; // floating-point 0.1 (whole-number part optional)</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>For hexadecimal floating constants, the exponent is not optional to avoid ambiguity resulting from an f suffix being mistaken as a hexadecimal digit.<br></p></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/floating_constant.html
for	A										<section class="prog__container"><p>Executes a loop.<br></p><p>Used as a shorter equivalent of while loop.</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>for (</code> <i>init_clause</i> <code>;</code> <i>cond_expression</i> <code>;</code> <i>iteration_expression</i> <code>)</code> <i>loop_statement</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>Behaves as follows:<br></p><ul><li> <i>init_clause</i> may be an expression or a declaration</li></ul><dl><dd><ul><li> If it is an expression, it is evaluated once, before the first evaluation of <i>cond_expression</i> and its result is discarded.</li><li>  If it is a declaration, it is in scope in the entire loop body, including the remainder of <i>init_clause</i>, the entire <i>cond_expression</i>, the entire <i>iteration_expression</i> and the entire <i>loop_statement</i>. Only <code>auto</code> and <code>register</code> storage classes are allowed for the variables declared in this declaration.</li></ul></dd></dl><ul><li> <i>cond_expression</i> is evaluated before the loop body. If the result of the expression is zero, the loop statement is exited immediately.</li><li> <i>iteration_expression</i> is evaluated after the loop body and its result is discarded. After evaluating <i>iteration_expression</i>, control is transferred to <i>cond_expression</i>.</li></ul><p><i>init_clause</i>, <i>cond_expression</i>, and <i>iteration_expression</i> are all optional:</p><pre><code>for(;;) {   printf("endless loop!");}</code></pre><p><i>loop_statement</i> is not optional, but it may be a null statement:</p><pre><code>for(int n = 0; n < 10; ++n, printf("%d\\n", n))    ; // null statement</code></pre><p>If the execution of the loop needs to be terminated at some point, a  break statement can be used anywhere within the <i>loop_statement</i>.</p><p>The  continue statement used anywhere within the <i>loop_statement</i> transfers control to <i>iteration_expression</i>.</p><p>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its <i>cond_expression</i>, <i>iteration_expression</i> or <i>loop_statement</i>. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where <i>cond_expression</i> is omitted or is a constant expression; <code>for(;;)</code> is always an endless loop.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>As with all other selection and iteration statements, the for statement establishes block scope: any identifier introduced in the <i>init_clause</i>, <i>cond_expression</i>, or <i>iteration_expression</i> goes out of scope after the <i>loop_statement</i>.</p></td><td></td></tr></table><h3><span class="prog__sub">Keywords</span></h3><p><tt>for</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/for.html
function_declaration	A										<section class="prog__container"><p>A function declaration introduces an identifier that designates a function and, optionally, specifies the types of the function parameters (the <i>prototype</i>). Function declarations (unlike definitions) may appear at block scope as well as file scope.</p><h3><span class="prog__sub">Syntax</span></h3><p>In the declaration grammar of a function declaration, the <i>type-specifier</i> sequence, possibly modified by the declarator, designates the <i>return type</i> (which may be any type other than array or function type), and the <i>declarator</i> has one of two forms:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>noptr-declarator</i> <code>(</code> <i>parameter-list</i> <code>)</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>noptr-declarator</i> <code>(</code> <i>identifier-list</i>(optional) <code>)</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><table class="t-par-begin"><tr class="t-par"><td> <i>noptr-declarator</i></td><td> -</td><td>  any declarator except unparenthesized pointer declarator. The identifier that is contained in this declarator is the identifier that becomes the function designator.</td></tr><tr class="t-par"><td> <i>parameter-list</i></td><td> -</td><td>  either the single keyword <code>void</code> or a comma-separated list of <i>parameters</i>, which may end with an ellipsis parameter</td></tr><tr class="t-par"><td> <i>identifier-list</i></td><td> -</td><td>  comma-separated list of identifiers (only if this declarator is used as part of old-style function definition), must be omitted for old-style declarations that are not definitions.</td></tr></table><ul>1) New-style (C89) function declaration. This declaration both introduces the function designator itself and also serves as a function prototype for any future function call expressions, forcing conversions from argument expressions to the declared parameter types and compile-time checks for the number of arguments.<pre><code>int max(int a, int b); // declarationint n = max(12.01, 3.14); // OK, conversion from double to int</code></pre></ul><ul>2) Old-style (K&amp;R) function declaration. This declaration does not behave as a prototype and any future function call expressions will perform default argument promotions and will invoke undefined behavior if the number of arguments doesn't match the number of parameters.<pre><code>int max();int n = max(true, (char)'a'); // calls max with two int args (after promotions)int n = max(12.01f, 3.14); // calls max with two double args (after promotions)int max(a, b) int a, b; { return a>b?a:b; } // definition expects ints; the second call is undefined</code></pre></ul><h3><span class="prog__sub">Explanation</span></h3><p>The return type of the function, determined by the type specifier in <i>specifiers-and-qualifiers</i> and possibly modified by the <i>declarator</i> as usual in declarations, must be a complete non-array object type or the type <code>void</code>.</p><pre><code>void f(char *s); // return type is voidint sum(int a, int b); // return type of sum is int.int (*foo(const void *p))[3]; // return type is pointer to array of 3 int</code></pre><p>Function declarators can be combined with other declarators as long as they can share their type specifiers and qualifiers<br></p><pre><code>int f(void), *fip(), (*pfi)(), *ap[3]; // declares two functions and two objectsinline int g(int), n; // error: inline qualifier is for functions onlytypedef int array_t[3];array_t a, h(); // error: array type cannot be a return type for a function</code></pre><p>If a function declaration appears outside of any function, the identifier it introduces has file scope and external linkage, unless <code>static</code> is used or an earlier static declaration is visible. If the declaration occurs inside another function, the identifier has block scope (and also either internal or external linkage).</p><pre><code>int main(void){    int f(int); // external linkage, file scope    f(1); // definition needs to be available somewhere in the program}</code></pre><p>The parameters in a declaration that is not part of a function definition do not need to be named:</p><pre><code>int f(int, int); // declaration// int f(int, int) { return 7; } // Error, parameters must be named in definitions</code></pre><p>Each parameter in a <i>parameter-list</i> is a declaration that introduced a single variable, with the following additional properties:</p><ul><li> the identifier in the declarator is optional (except if this function declaration is part of a function definition)</li></ul><pre><code>int f(int, double); // OKint g(int a, double b); // also OKint f(int, double) { return 1; } // Error: definition must name parameters</code></pre><ul><li> the only storage class specifier allowed for parameters is <code>register</code>, and it is ignored in function declarations that are not definitions</li></ul><pre><code>int f(static int x); // Errorint f(int [static 10]); // OK (array index static is not a storage class specifier)</code></pre><ul><li> any parameter of array type is adjusted to the corresponding pointer type<span>, which may be qualified if there are qualifiers between the square brackets of the array declarator</span> <span></span></li></ul><pre><code>int f(int[]); // declares int f(int*)int g(const int[10]); // declares int g(const int*)int h(int[const volatile]); // declares int h(int * const volatile)int x(int[*]); // declares int x(int*)</code></pre><ul><li> any parameter of function type is adjusted to the corresponding pointer type</li></ul><pre><code>int f(char g(double)); // declares int f(char (*g)(double))int h(int(void)); // declares int h(int (*)(void))</code></pre><ul><li> the parameter list may terminate with <code>, ...</code>, see variadic functions for details.</li></ul><pre><code>int f(int, ...);</code></pre><ul><li> parameters cannot have type <code>void</code> (but can have type pointer to void). The special parameter list that consists entirely of the keyword <code>void</code> is used to declare functions that take no parameters.</li></ul><pre><code>int f(void); // OKint g(void x); // Error</code></pre><ul><li> any identifier that appears in a parameter list that could be treated as a typedef name or as a parameter name is treated as a typedef name: <code>int f(size_t, uintptr_t)</code> is parsed as a new-style declarator for a function taking two unnamed parameters of type size_t and uintptr_t, not an old-style declarator that begins the definition of a function taking two parameters named "size_t" and "uintptr_t"</li><li> parameters may have incomplete type<span> and may use the VLA notation [*]</span> <span></span> (except that in a function definition, the parameter types after array-to-pointer and functino-to-pointer adjustment must be complete)</li></ul><p>See function call operator for other details on the mechanics of a function call and return for returning from functions.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/function_declaration.html
function_definition	A										<section class="prog__container"><p>A function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list. Unlike function declaration, function definitions are allowed at file scope only (there are no nested functions).</p><p>C supports two different forms of function definitions:<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>specifiers-and-qualifiers</i> <i>parameter-list-declarator</i> <i>function-body</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>specifiers-and-qualifiers</i> <i>identifier-list-declarator</i> <i>declaration-list</i> <i>function-body</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><table class="t-par-begin"><tr class="t-par"><td> <i>specifiers-and-qualifiers</i></td><td> -</td><td>  a combination of<ul><li> type specifiers that, possibly modified by the declarator, form the <i>return type</i></li><li> storage class specifiers, which determine the linkage of the identifier (<code>static</code>, <code>extern</code>, or none)</li><li> function specifiers inline, noreturn, or none </li></ul></td></tr><tr class="t-par"><td> <i>parameter-list-declarator</i></td><td> -</td><td>  a declarator for a function type which uses a parameter list to designate function parameters</td></tr><tr class="t-par"><td> <i>identifier-list-declarator</i></td><td> -</td><td>  a declarator for a function type which uses a identifier list to designate function parameters</td></tr><tr class="t-par"><td> <i>declaration-list</i></td><td> -</td><td>  sequence of declarations that declare every identifier in <i>identifier-list-declarator</i>. These declarations cannot use initializers and the only storage-class specifier allowed is <code>register</code>.</td></tr><tr class="t-par"><td> <i>function-body</i></td><td> -</td><td>  a compound statement, that is a brace-enclosed sequence of declarations and statements, that is executed whenever this function is called</td></tr></table><ul>1) New-style (C89) function definition. This definition both introduces the function itself and serves as a function prototype for any future function call expressions, forcing conversions from argument expressions to the declared parameter types.<pre><code>int max(int a, int b){    return a>b?a:b;} double g(void){    return 0.1;}</code></pre></ul><ul>2) Old-style (K&amp;R) function definition. This definition does not behave as a prototype and any future function call expressions will perform default argument promotions.<pre><code>int max(a, b)int a, b;{    return a>b?a:b;}double g(){    return 0.1;}</code></pre></ul><h3><span class="prog__sub">Explanation</span></h3><p>As with function declarations, the return type of the function, determined by the type specifier in <i>specifiers-and-qualiifiers</i> and possibly modified by the <i>declarator</i> as usual in declarations, must be a complete non-array object type or the type <code>void</code>.</p><pre><code>void f(char *s) { puts(s); } // return type is voidint sum(int a, int b) { return a+b: } // return type is intint (*foo(const void *p))[3] { // return type is pointer to array of 3 int    return malloc(sizeof(int[3]));}</code></pre><p>As with function declarations, the types of the parameters are adjusted from functions to pointers and from arrays to pointers and their top-level qualifiers are stripped for the purpose of constructing the function type.</p><p>Unlike function declarations, unnamed formal parameters are not allowed, they must be named even if they are not used within the function. The only exception is the special parameter list <code>(void)</code></p><pre><code>int f(int, int); // declaration// int f(int, int) { return 7; } // Errorint f(int a, int b) { return 7; } // definitionint g(void) { return 8; } // OK, void doesn't declare a parameter</code></pre><p>Within the function body, every parameter is an lvalue expression, they have automatic storage duration and block scope. The layout of the parameters in memory (or if they are stored in memory at all) is unspecified: it is a part of the calling convention.</p><pre><code>int main(int ac, char **av){    ac = 2; // parameters are lvalues    av = (char *[]){"abc", "def", NULL};    f(ac, av);}</code></pre><p>See function call operator for other details on the mechanics of a function call and return for returning from functions.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><h3><span class="prog__sub"> __func__</span></h3><p>WIthin every <i>function-body</i>, the special predefined variable <code>__func__</code> with block scope and static storage duration is available,  as if defined immediately after the opening brace by</p><pre><code>static const char __func__[] = "function name";</code></pre><p>This special identifier is sometimes used in combination with the predefined macro constants <code>__FILE__</code> and <code>__LINE__</code>, for example, by <code>assert</code>.</p></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/function_definition.html
functions	A										<section class="prog__container"><p>A function is a C language construct that associates a compound statement (the function body) with an identifier (the function name). Every C program begins execution from the main function, which either terminates, or invokes other, user-defined or library functions.</p><pre><code>// function definition.// defines a function with the name "sum" and with the body "{ return x+y; }"int sum(int x, int y) {    return x + y;}</code></pre><p>Functions may accept zero or more <i>parameters</i>, which are initialized from the <i>arguments</i> of a function call operator, and may return a value to its caller by means of the return statement.</p><pre><code>int n = sum(1, 2); // parameters x and y are initialized with the arguments 1 and 2</code></pre><p>The body of a function is provided in a function definition. Each function must be defined only once in a program, unless the function is inline.</p><p>There are no nested functions (except where allowed through non-standard compiler extensions): each function definition must appear at file scope, and functions have no access to the local variables from the caller:<br></p><pre><code>int main(void) // the main function definition{    int sum(int, int); // function declaration (may appear at any scope)    int x = 1;  // local variable in main    sum(1, 2); // function call //    int sum(int a, int b) // error: no nested functions//    {//        return  a + b; //    }}int sum(int a, int b) // function definition{//    return x + a + b; //  error: main's x is not accessible within sum    return a + b;}</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/functions.html
generic	A										<section class="prog__container"><p>Provides a way to choose one of several expressions at compile time, based on a type of a controlling expression<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Generic</code> <code>(</code> <i>controlling-expression</i> <code>,</code> <i>association-list</i> <code>)</code></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <i>association-list</i> is a comma-separated list of associations, each of which has the syntax</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>type-name</i> <code>:</code> <i>expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>default</code> <code>:</code> <i>expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><table class="t-par-begin"><tr class="t-par"><td> <i>type-name</i></td><td> -</td><td>  any complete object type that isn't variably-modified (that is, not VLA or pointer to VLA).</td></tr><tr class="t-par"><td> <i>controlling-expression</i></td><td> -</td><td>  any expression (except for the comma operator) whose type must be compatible with one of the <i>type-name</i>s if the <code>default</code> association is not used</td></tr><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any expression (except for the comma operator) of any type and value category</td></tr></table><p>No two <i>type-name</i>s in the <i>association-list</i> may specify compatible types. There may be only one association that uses the keyword <code>default</code>. If <code>default</code> is not used and none of the <i>type-name</i>s are compatible with the type of the controlling expression, the program will not compile.</p><h3><span class="prog__sub">Explanation</span></h3><p>The type of <i>controlling-expression</i> (after applying lvalue conversions if applicable and if supported -- see notes below), is compared with <i>type-name</i>s from the list of associations.</p><p>If the type is compatible with the <i>type-name</i> of one of the associations, then the type, value, and value category of the generic selection are the type, value, and value category of the  <i>expression</i> that appears after the colon for that <i>type-name</i>.</p><p>If none of the <i>type-name</i>s are compatible with the type of the <i>controlling-expression</i>, and the <code>default</code> association is provided, then the type, value, and value category of the generic selection are the type, value, and value category of the expression after the <code>default :</code> label.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/generic.html
goto	A										<section class="prog__container"><p>Transfers control unconditionally to the desired location.<br></p><p>Used when it is otherwise impossible to transfer control to the desired location using conventional constructs.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>goto</code> <i>label</i> <code>;</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>label</i> <code>:</code> <i>statement</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The <code>goto</code> statement causes an unconditional jump (transfer of control) to the statement prefixed by the named <i>label</i> (which must appear in the same function as the goto statement)<span>, except when this jump would enter the scope of a variable-length array or another variably-modified type.</span> <span></span></p><p>A <i>label</i> is an identifier followed by a colon (:) and a statement. Labels are the only identifiers that have <i>function scope</i>: they can be used (in a goto statement) anywhere in the same function in which they appear. There may be multiple labels before any statement.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>Entering the scope of a non-variably modified variable is permitted:<br></p><pre><code>goto lab1; // OK: going into the scope of a regular variable    int n = 5;lab1:; // Note, n is uninitialized, as if declared by int n; //   goto lab2;   // Error: going into the scope of two VM types     double a[n]; // a VLA     int (*p)[n]; // a VM pointerlab2:</code></pre><p>If <code>goto</code> leaves the scope of a VLA, it is deallocated (and may be reallocated if its initialization is executed again): </p><pre><code>{   int n = 1;label:;   int a[n]; // re-allocated 10 times, each with a different size   if (n++ < 10) goto label; // leaving the scope of a VM}</code></pre></td><td></td></tr></table><h3><span class="prog__sub">Keywords</span></h3><p><tt>goto</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/goto.html
history	A										<section class="prog__container"><h2>Early C</h2><ul><li> 1969: B created, based on BCPL, to replace PDP-7 assembler as the system programming language for Unix</li></ul><dl><dd><ul><li> added operators ++, --, compound assignment, remained a typeless language like BCPL</li></ul></dd></dl><ul><li> 1971: NB ("new B") created when porting B to PDP-11</li></ul><dl><dd><ul><li> types (int, char, arrays and pointers), array-to-pointer conversion, compilation to machine code</li></ul></dd></dl><ul><li> 1972: Language renamed to C</li></ul><dl><dd><ul><li> structs, operators &amp;&amp; and ||, preprocessor, portable I/O</li></ul></dd></dl><ul><li> 1973: Unix re-written in C</li></ul><dl><dd><ul><li> unsigned, long, unions, enumerations, increased type safety</li></ul></dd></dl><ul><li> 1978: The C Programming Language, 1st edition</li></ul><h2>Standard C</h2><ul><li> 1983: ANSI established X3J11 committee</li><li> 1988: The C Programming Language, 2nd edition</li><li> 1989: <code>C89</code>, the ANSI C standard published</li></ul><ol><li> codified existing practices</li><li> new features: volatile, enum, signed, void, locales</li><li> From C++: const, function prototypes</li></ol><ul><li> 1990: <code>C90</code>, the ANSI C standard accepted as ISO/IEC 9899-1990</li><li> 1995: <code>C95</code> (ISO/IEC 9899 AM1) (online store)</li></ul><ol><li> multibyte character support (wchar_t and all wide and multibyte character functions, wchar.h, wctype.h, and those added to existing headers and corresponding changes to stream I/O, etc)</li><li> digraphs, iso646.h, </li></ol><ul><li> 1995: Technical corrigendum 1 (ISO/IEC 9899 TCOR1)</li></ul><dl><dd><ul><li> 44 small changes</li></ul></dd></dl><ul><li> 1996: Technical corrigendum 2 (ISO/IEC 9899 TCOR2)</li></ul><dl><dd><ul><li> 24 small changes</li></ul></dd></dl><ul><li> 1999: <code>C99</code> (ISO/IEC 9899:1999)</li></ul><ol><li> new features: bool, long long, stdint.h, inttypes.h, restrict, compound literals, variable length arrays, flexible array members, designated initializers, fenv.h, variadic macros, complex numbers, __func__, hexadecimal floating point format (%a), monetary formatting in lconv, isblank, concatenation of narrow and wide string literals, trailing comma in enumerations, empty arguments in function-like macros, STDC_* pragmas, va_copy, null return of tmpnam, null pointer in setvbuf, hh and ll lengthspecifiers in printf, snprintf, _Exit, tgmath.h, POSIX-like strftime specifiers</li><li> from C++: inline, mix declarations and code, declarations in the init clause of the for loop, <code>//</code> comments, universal character names in source code</li><li> removed implicit functions and implicit int</li></ol><ul><li> 2001: Technical corrigendum 1 (ISO/IEC 9899:1999/Cor.1:2001(E))</li></ul><dl><dd><ul><li> 11 defects fixed</li></ul></dd></dl><ul><li> 2004: Technical corrigendum 2 (ISO/IEC 9899:1999/Cor.2:2004(E))</li><li> 2004: Unicode TR (ISO/IEC TR 19769:2004) (ISO store) (November 7, 2003 draft)</li><li> 2007: Technical corrigendum 3 (ISO/IEC 9899:1999/Cor.3:2007(E)) (September 7, 2007 draft)</li></ul><dl><dd><ul><li> deprecated <code>gets</code></li></ul></dd></dl><ul><li> 2007: Bounds-checking interfaces TR (ISO/IEC TR 24731-1:2007) (ISO store) (March 28, 2007 draft)</li><li> 2008: Embedded TR (ISO/IEC TR 18037:2008) (ISO store) (September 24, 2003 draft)</li><li> 2009: Decimal floating-point TR (ISO/IEC TR 24732:2009) (ISO store) (July 5, 2007 draft)</li><li> 2009: Mathematical special functions TR (ISO/IEC TR 24747:2009) (ISO store) (August 2, 2006 draft)</li><li> 2010: Dynamic allocations functions TR (ISO/IEC TR 24731-2:2010) (ISO store) (August 15, 2007 draft)</li><li> 2011: <code>C11</code> (ISO/IEC 9899:2011) (ISO store) (ANSI store) (April 12, 2011 draft)</li></ul><ol><li> thread-aware memory model, stdatomic.h, threads.h, type-generic functions, alignas/alignof, noreturn, static assert, analyzability extensions, extensions to complex and imaginary types, anonymous structures and unions, exclusive file open mode. quick_exit</li><li> removed <code>gets</code></li><li> from Bounds-checking interfaces TR: bounds-checking interfaces, </li><li> from Unicode TR: char16_t, char32_t, and uchar.h</li></ol><ul><li> 2012: Technical corrigendum 1 (ISO/IEC 9899:2011/Cor 1:2012) (ISO store)</li></ul><dl><dd><ul><li> 2 minor bug fixes</li></ul></dd></dl><ul><li> 2013: Secure Coding Rules TS (ISO/IEC TS 17961:2013) (ISO store) (June 26, 2012)</li><li> 2014: FP TS part 1: Binary floating-point arithmetic (ISO/IEC TS 18661-1:2014) (ISO store) (2013 draft )</li></ul><ol><li> provides changes to C11 (mostly to Annex F) that cover all basic requirements and some recommendations of IEC 60559:2011 (C11 was built on IEC 60559:1989)</li></ol><ul><li> 2015: FP TS part 2: Decimal floating-point arithmetic (ISO/IEC TS 18661-2:2015) (ISO store) (2015 draft)</li></ul><ol><li> provides changes to C11 to support all the requirements, plus some basic recommendations, of IEC 60559:2011 for decimal floating-point arithmetic. This supersedes ISO/IEC TR 24732:2009.</li></ol><ul><li> 2015: FP TS part 3: Interchange and extended types (ISO/IEC TS 18661-3:2015) (ISO store) (2015 draft)</li></ul><ol><li> provides changes to C11 to support the recommendations of IEC 60559:2011 for extended floating‐point formats and the interchange formats, both arithmetic and non-arithmetic.</li></ol><ul><li> 2015: FP TS part 4: Supplementary functions (ISO/IEC TS 18661-4:2015) (ISO store) (2015 draft)</li></ul><ol><li> provides changes to C11 to support all mathematical operations recommended by IEC 60559:2011, including trigonometry in π units, inverse square root, compounded interest, etc.</li></ol><ul><li> 2016: FP TS part 5: Supplementary attributes (ISO/IEC TS 18661-5:2016) (ISO store)(2016 draft)</li></ul><ol><li> provides changes to C11 to support all supplementary attributes (evaluation model, exception handling, reproducibility, etc) recommended by IEC 60559:2011</li></ol><h3><span class="prog__sub">Future development</span></h3><ul><li> Parallelism TS (Draft n2017 2016-03-10)</li><li> Transactional Memory TS (Draft n1961 2015-09-23)</li><li> <code>C2x</code> Next C language standard revision </li></ul><dl><dd><ul><li> List of C11 defect reports: n2059  (august 2016)</li><li> List of issues that were not granted DR status: n2087 (september 2016)</li></ul></dd></dl><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/history.html
identifier	A										<section class="prog__container"><p>An <i>identifier</i> is an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters<span>, and Unicode characters specified using <code>\u</code> and <code>\U</code> escape notation</span> <span></span>. A valid identifier must begin with a non-digit character (Latin letter, underscore<span>, or Unicode non-digit character</span> <span></span>). Identifiers are case-sensitive (lowercase and uppercase letters are distinct).</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td> It is implementation-defined if raw (not escaped) Unicode characters are allowed in identifiers:<pre><code>char *\U0001f431 = "cat"; // supportedchar *🐱 = "cat"; // implementation-defined (e.g. works with Clang, but not GCC)</code></pre></td><td></td></tr></table><p>Identifiers can denote the following types of entities:<br></p><ul><li> objects</li><li> functions</li><li> tags (struct, union, or enumerations)</li><li> structure or union members</li><li> enumeration constants</li><li> typedef names</li><li> label names</li><li> macro names</li><li> macro parameter names</li></ul><p>Every identifier other than macro name or macro parameter name has scope, belongs to a name space, and may have linkage. The same identifier can denote different entities at different points in the program, or may denote different entities at the same point if the entities are in different name spaces.</p><h3><span class="prog__sub">Reserved identifiers</span></h3><p>The following identifiers are <i>reserved</i> and may not be declared in a program (doing so invokes undefined behavior):</p><ul>1) The identifiers that are keywords cannot be used for other purposes. In particular #define or #undef of an identifier that is identical to a keyword is not allowed.</ul><ul>2) All external identifiers that begin with an underscore.</ul><ul>3) All identifiers that begin with an underscore followed by a capital letter or by another underscore (these reserved identifiers allow the library to use numerous behind-the-scenes non-external macros and functions)</ul><ul>4) All external identifiers defined by the standard library (in hosted environment). This means that no user-supplied external names are allowed to match any library names, not even if declaring a function that is identical to a library function.</ul><ul>5) Identifiers declared as reserved for future use by the standard library, namely<dl><dd><ul><li> <i>function names</i></li></ul><dl><dd><ul><li> <code>cerf</code>, <code>cerfc</code>, <code>cexp2</code>, <code>cexpm1</code>, <code>clog10</code>, <code>clog1p</code>, <code>clog2</code>, <code>clgamma</code>, <code>ctgamma</code> and their -f and -l suffixed variants, in <tt><complex.h></tt></li><li> beginning with <code>is</code> or <code>to</code> followed by a lowercase letter, in <tt><ctype.h></tt> and <tt>wctype.h</tt></li><li> beginning with <code>str</code> followed by a lowercase letter, in <tt><stdlib.h></tt></li><li> beginning with <code>str</code>, <code>mem</code> or <code>wcs</code> followed by a lowercase letter, in <tt><string.h></tt></li><li> beginning with <code>wcs</code> followed by a lowercase letter, in <tt><wchar.h></tt></li><li> beginning with <code>atomic_</code> followed by a lowercase letter, in <tt><stdatomic.h></tt></li><li> beginning with <code>cnd_</code>, <code>mtx_</code>, <code>thrd_</code> or <code>tss_</code> followed by a lowercase letter, in <tt><threads.h></tt></li></ul></dd></dl><ul><li> <i>typedef names</i></li></ul><dl><dd><ul><li> beginning with <code>int</code> or <code>uint</code> and ending with <code>_t</code>, in <tt><stdint.h></tt></li><li> beginning with <code>atomic_</code> or <code>memory_</code> followed by a lowercase letter, in <tt><stdatomic.h></tt></li><li> beginning with <code>cnd_</code>, <code>mtx_</code>, <code>thrd_</code> or <code>tss_</code> followed by a lowercase letter, in <tt><threads.h></tt></li></ul></dd></dl><ul><li> <i>macro names</i></li></ul><dl><dd><ul><li> beginning with <code>E</code> followed by a digit or an uppercase letter, in <tt><errno.h></tt></li><li> beginning with <code>FE_</code> followed by an uppercase letter, in <tt><fenv.h></tt></li><li> beginning with <code>INT</code> or <code>UINT</code> and ending with <code>_MAX</code>, <code>_MIN</code>, or <code>_C</code>, in <tt><stdint.h></tt></li><li> beginning with <code>PRI</code> or <code>SCN</code> followed by lowercase letter or the letter <code>X</code>, in <tt><stdint.h></tt></li><li> beginning with <code>LC_</code> followed by an uppercase letter, in <tt><locale.h></tt></li><li> beginning with <code>SIG</code> or <code>SIG_</code> followed by an uppercase letter, in <tt><signal.h></tt></li><li> beginning with <code>TIME_</code> followed by an uppercase letter, in <time.h></li><li> beginning with <code>ATOMIC_</code> followed by an uppercase letter, in <tt><stdatomic.h></tt></li></ul></dd></dl><ul><li> <i>enumeration constants</i></li></ul><dl><dd><ul><li> beginning with <code>memory_order_</code> followed by a lowercase letter, in <tt><stdatomic.h></tt></li><li> beginning with <code>cnd_</code>, <code>mtx_</code>, <code>thrd_</code> or <code>tss_</code> followed by a lowercase letter, in <tt><threads.h></tt></li></ul></dd></dl></dd></dl></ul><p>All other identifiers are available, with no fear of unexpected collisions when moving programs from one compiler and library to another.<br></p><p>Note: in C++, identifiers with a double underscore anywhere are reserved everywhere; in C, only the ones that begin with a double underscore are reserved.<br></p><h3><span class="prog__sub">Translation limits</span></h3><p>Even though there is no specific limit on the length of identifiers, early compilers had limits on the number of significant initial characters in identifiers and the linkers imposed stricter limits on the names with external linkage. C requires that at least the following limits are supported by any standard-compliant implementation:</p><table class="t-rev-begin"><tr class="t-rev t-until-c99"><td><ul><li>31 significant initial characters in an internal identifier or a macro name</li><li>6 significant initial characters in an external identifier</li><li>511 external identifiers in one translation unit</li><li>127 identifiers with block scope declared in one block</li><li>1024 macro identifiers simultaneously defined in one preprocessing translation unit</li></ul></td><td>(until C99)</td></tr><tr class="t-rev t-since-c99"><td><ul><li>63 significant initial characters in an internal identifier or a macro name</li><li>31 significant initial characters in an external identifier</li><li>4095 external identifiers in one translation unit</li><li>511 identifiers with block scope declared in one block</li><li>4095 macro identifiers simultaneously defined in one preprocessing translation unit</li></ul></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/identifier.html
if	A										<section class="prog__container"><p>Conditionally executes code.<br></p><p>Used where code needs to be executed only if some condition is true.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>if (</code> <i>expression</i> <code>)</code> <i>statement_true</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>if (</code> <i>expression</i> <code>)</code> <i>statement_true</i> <code>else</code> <i>statement_false</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p><i>expression</i> must be an expression of any scalar type.</p><p>If <i>expression</i> compares not equal to the integer zero, <i>statement_true</i> is executed.</p><p>In the form (2), if <i>expression</i> compares equal to the integer zero, <i>statement_false</i> is executed.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>As with all other selection and iteration statements, the entire if-statement has its own block scope:<br></p><pre><code>enum {a, b};int different(void){    if (sizeof(enum {b, a}) != sizeof(int))        return a; // a == 1    return b; // b == 0 in C89, b == 1 in C99}</code></pre></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/if.html
initialization	A										<section class="prog__container"><p>A declaration of an object may provide its initial value through the process known as <i>initialization</i>.</p><p>For each declarator, the initializer, if not omitted, may be one of the following:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>=</code> <i>expression</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>=</code> <code>{ </code> <i>initializer-list</i> <code>} </code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <i>initializer-list</i> is a non-empty comma-separated list of <i>initializer</i>s (with an optional trailing comma), where each initializer has one of three possible forms:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>expression</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>{ </code> <i>initializer-list</i> <code>} </code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>designator-list</i> <code>=</code> <i>initializer</i></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <i>designator-list</i> is a list of either array designators of the form <code>[</code> <i>constant-expression</i> <code>]</code> or struct/union member designators of the form <code>.</code> <i>identifier</i>; see array initialization and struct initialization.</p><h3><span class="prog__sub">Explanation</span></h3><p>The initializer specifies the initial value stored in an object.<br></p><h4>Explicit initialization</h4><p>If an initializer is provided, see<br></p><ul><li> scalar initialization for the initialization of scalar types</li><li> array initialization for the initialization of array types</li><li> struct initialization for the initialization of struct and union types.</li></ul><h4>Implicit initialization</h4><p>If an initializer is not provided:<br></p><ul><li> objects with automatic storage duration are initialized to indeterminate values (which may be trap representations)</li><li> objects with static and thread-local storage duration are initialized as follows</li></ul><dl><dd><ul><li> pointers are initialized to null pointer values of their types</li><li> objects of integral types are initialized to unsigned zero</li><li> objects of floating types are initialized to positive zero</li><li> members of arrays, structs, and unions are initialized as described above, recursively, plus all padding bits are initialized to zero</li></ul></dd><dd>(on platforms where null pointers and floating zeroes have all-bit-zero representations, this form of initialization for statics is normally implemented by allocating them in the .bss section of the program image)</dd></dl><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/initialization.html
inline	A										<section class="prog__container"><p>Declares an inline function.</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>inline</code> <i>function_declaration</i></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The intent of the <code>inline</code> specifier is to serve as a hint for the compiler to perform optimizations, such as function inlining, which require the definition of a function to be visible at the call site. The compilers can (and usually do) ignore presence or absence of the <code>inline</code> specifier for the purpose of optimization.</p><p>If the compiler performs function inlining, it replaces a call of that function with its body, avoiding the overhead of a function call (placing data on stack and retrieving the result), which may result in a larger executable as the code for the function has to be repeated multiple times. The result is similar to function-like macros, except that identifiers and macros used in the function refer to the definitions visible at the point of definition, not at the point of call.</p><p>Regardless of whether inlining takes place, the following semantics of inline functions are guaranteed:<br></p><p>Any function with internal linkage may be declared <code>static inline</code> with no other restrictions.</p><p>A non-static inline function cannot define a non-const function-local static and cannot refer to a file-scope static.<br></p><pre><code>static int x;inline void f(void){    static int n = 1; // error: non-const static in a non-static inline function    int k = x; // error: non-static inline function accesses a static variable}</code></pre><p>If a non-static function is declared <code>inline</code>, then it must be defined in the same translation unit. The inline definition that does not use <code>extern</code> is not externally visible and does not prevent other translation units from defining the same function. This makes the <code>inline</code> keyword an alternative to <code>static</code> for defining functions inside header files, which may be included in multiple translation units of the same program.</p><p>If a function is declared <code>inline</code> in some translation units, it does not need to be declared inline everywhere: at most one translation unit may also provide a regular, non-inline non-static function, or a function declared <code>extern inline</code>. This one translation unit is said to provide the <i>external definition</i>. One external definition must exist in the program if the name of the function with external linkage is used in an expression, see one definition rule. </p><p>If the external definition exists in the program, the address of the function is always the address of the external function, but when this address is used to make a function call, it's unspecified whether the <i>inline definition</i> (if present in the translation unit) or the <i>external definition</i> is called. The static objects defined within an inline definition are distinct from the static objects defined within the external definition:</p><pre><code>inline const char *saddr(void) // the inline definition for use in this file{    static const char name[] = "saddr";    return name;}int compare_name(void){    return saddr() == saddr(); // unspecified behavior, one call could be external}extern const char *saddr(void); // an external definition is generated, too</code></pre><p>A valid C program must not depend on whether the inline version or the external version of a function is called.<br></p><h3><span class="prog__sub">Keywords</span></h3><p><tt>inline</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/inline.html
integer_constant	A										<section class="prog__container"><p>Allows values of integer type to be used in expressions directly.<br></p><h3><span class="prog__sub">Syntax</span></h3><p>An integer constant is a non-lvalue expression of the form</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>decimal-constant</i> <i>integer-suffix</i>(optional)</td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>octal-constant</i> <i>integer-suffix</i>(optional)</td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>hex-constant</i> <i>integer-suffix</i>(optional)</td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><ul><li> <i>decimal-constant</i> is a non-zero decimal digit (<code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>), followed by zero or more decimal digits (<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>)</li><li> <i>octal-constant</i> is the digit zero (<code>0</code>) followed by zero or more octal digits (<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>)</li><li> <i>hex-constant</i> is the character sequence <code>0x</code> or the character sequence <code>0X</code> followed by one or more hexadecimal digits (<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>, <code>a</code>, <code>A</code>, <code>b</code>, <code>B</code>, <code>c</code>, <code>C</code>, <code>d</code>, <code>D</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>)</li><li> <i>integer-suffix</i>, if provided, may contain one or both of the following (if both are provided, they may appear in any order:</li></ul><dl><dd><ul><li> <i>unsigned-suffix</i> (the character <code>u</code> or the character <code>U</code>)</li><li> <i>long-suffix</i> (the character <code>l</code> or the character <code>L</code>) <span>or the <i>long-long-suffix</i> (the character sequence <code>ll</code> or the character sequence <code>LL</code>)</span> <span></span></li></ul></dd></dl><h3><span class="prog__sub">Explanation</span></h3><ul>1) Decimal integer constant (base 10, the first digit is the most significant).</ul><ul>2) Octal integer constant (base 8, the first digit is the most significant).</ul><ul>3) Hexadecimal integer constant (base 16, the first digit is the most significant, the letters 'a' through 'f' represent the decimal values 10 through 15).</ul><p>The following variables are initialized to the same value:<br></p><pre><code>int d = 42;int o = 052;int x = 0x2a;int X = 0X2A;</code></pre><h3><span class="prog__sub">The type of the integer constant</span></h3><p>The type of the integer constant is the first type in which the value can fit, from the list of types which depends on which numeric base and which <i>integer-suffix</i> was used.</p><table class="wikitable"><tr style="text-align:center"><th colspan="3"> Types allowed for integer constants</th></tr><tr style="text-align:center"><td> suffix</td><td> decimal bases</td><td> hexadecimal or octal bases</td></tr><tr style="text-align:left"><td> no suffix</td><td> <code>int</code><p><code>long int</code><br><code>unsigned long int</code> (until C99)<br><code>long long int</code> <br></p></td><td> <code>int</code><p><code>unsigned int</code><br><code>long int</code><br><code>unsigned long int</code><br><code>long long int</code><br><code>unsigned long long int</code><br></p></td></tr><tr><td> <code>u</code> or <code>U</code></td><td> <code>unsigned int</code><p><code>unsigned long int</code><br><code>unsigned long long int</code><br></p></td><td> <code>unsigned int</code><p><code>unsigned long int</code><br><code>unsigned long long int</code><br></p></td></tr><tr><td> <code>l</code> or <code>L</code></td><td> <code>long int</code><p><code>unsigned long int</code>(until C99)<br><code>long long int</code><br></p></td><td> <code>long int</code><p><code>unsigned long int</code><br><code>long long int</code><br><code>unsigned long long int</code><br></p></td></tr><tr><td> both <code>l</code>/<code>L</code> and <code>u</code>/<code>U</code></td><td> <code>unsigned long int</code><p><code>unsigned long long int</code></p></td><td> <code>unsigned long int</code><p><code>unsigned long long int</code></p></td></tr><tr><td> <code>ll</code> or <code>LL</code></td><td> <code>long long int</code></td><td> <code>long long int</code><p><code>unsigned long long int</code></p></td></tr><tr><td> both <code>ll</code>/<code>LL</code> and <code>u</code>/<code>U</code></td><td> <code>unsigned long long int</code></td><td> <code>unsigned long long int</code></td></tr></table><p>If the value of the integer constant is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as <code>__int128</code>), the constant may be given the extended integer type; otherwise, the program is ill-formed.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/integer_constant.html
lifetime	A										<section class="prog__container"><p>Every object in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate)<span>, and, for VLA, retains its size</span> <span></span> over a portion of program execution known as this object's <i>lifetime</i>.</p><p>For the objects that are declared with automatic, static, and thread storage duration, lifetime equals their storage duration (note the difference between non-VLA and VLA automatic storage duration).</p><p>For the objects with allocated storage duration, the lifetime begins when the allocation function returns (including the return from <code>realloc</code>) and ends when the <code>realloc</code> or deallocation function is called. Note that since allocated objects have no declared type, the type of the lvalue expression first used to access this object becomes its effective type.</p><p>Accessing an object outside of its lifetime is undefined behavior.<br></p><pre><code>int* foo(void) {    int a = 17; // a has automatic storage duration    return &amp;a;}  // lifetime of a endsint main(void) {    int* p = foo(); // p points to an object past lifetime ("dangling pointer")    int n = *p; // undefined behavior}</code></pre><p>A pointer to an object (or one past the object) whose lifetime ended has indeterminate value.<br></p><h3><span class="prog__sub">Temporary lifetime</span></h3><p>Struct and union objects with array members (either direct or members of nested struct/union members) that are designated by non-lvalue expressions, have <i>temporary lifetime</i>. Temporary lifetime begins when the expression that refers to such object is evaluated and ends <span>at the next sequence point</span> <span></span><span>when the containing full expression or full declarator ends</span> <span></span>.</p><p>Any attempt to modify an object with temporary lifetime results in undefined behavior.<br></p><pre><code>struct T { double a[4]; };struct T f(void) { return (struct T){3.15}; }double g1(double* x) { return *x; }void g2(double* x) { *x = 1.0; }int main(void){    double d = g1(f().a); // C99: UB access to a[0] in g1 whose lifetime ended                          //      at the sequence point at the start of g1                          // C11: OK, d is 3.15    g2(f().a); // C99: UB modification of a[0] whose lifetime ended at the sequence point               // C11: UB attempt to modify a temporary object}</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/lifetime.html
main_function	A										<section class="prog__container"><p>Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function called <code>main</code>, which is the designated start of the program.</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>int</code> <code>main</code> <code>(void)</code> <code>{</code> <i>body</i> <code>} </code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>int</code> <code>main</code> <code>(</code><code>int</code> <i>argc</i><code>,</code> <code>char</code> <code>*</code><i>argv</i><code>[]</code><code>)</code> <code>{</code> <i>body</i> <code>} </code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>int</code> <code>main</code> <code>(</code><code>int</code> <i>argc</i><code>,</code> <code>char</code> <code>*</code><i>argv</i><code>[]</code> <code>,</code> <i>other_parameters</i> <code>)</code> <code>{</code> <i>body</i> <code>} </code></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>/* another implementation-defined signature */</code></td><td> (4)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p><br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  argc</td><td> -</td><td>  Non-negative value representing the number of arguments passed to the program from the environment in which the program is run.</td></tr><tr class="t-par"><td>  argv</td><td> -</td><td>  Pointer to an array of pointers to null-terminated multibyte strings that represent the arguments passed to the program from the execution environment (<code>argv[0]</code> through <code>argv[argc-1]</code>). The value of <code>argv[argc]</code> is guaranteed to be <code>​0​</code>.</td></tr><tr class="t-par"><td>  body</td><td> -</td><td>  The body of the main function</td></tr><tr class="t-par"><td> <i>other_parameters</i></td><td> -</td><td>  Implementations may allow additional forms of the main function. A very common extension is passing a third argument of type <code>char*[]</code> pointing at an array of pointers to the execution environment variables.</td></tr></table><p>The names <code>argc</code> and <code>argv</code> are arbitrary, as well as the representation of the types of the parameters: <code>int main(int ac, char** av)</code> is equally valid.</p><h3><span class="prog__sub">Return value</span></h3><p>If the return statement is used, the return value is used as the argument to the implicit call to <code>exit()</code> (see below for details). The values zero and <code>EXIT_SUCCESS</code> indicate successful termination, the value <code>EXIT_FAILURE</code> indicates unsuccessful termination.</p><h3><span class="prog__sub">Explanation</span></h3><p>The <code>main</code> function is called at program startup, after all objects with static storage duration are initialized. It is the designated entry point to a program that is executed in <i>hosted</i> environment (that is, with an operating system). The name and type of the entry point to any <i>freestanding</i> program (boot loaders, OS kernels, etc) are implementation-defined.</p><p>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as <i>command line arguments</i>). The pointers <code>argv[1] .. argv[argc-1]</code> point at the first characters in each of these strings. <code>argv[0]</code> is the pointer to the initial character of a null-terminated multibyte strings that represents the name used to invoke the program itself (or, if this is not supported by the execution environment, argv[0][0] is guaranteed to be zero). </p><p>If the execution environment cannot distinguish between uppercase and lowercase letters, the command line arguments are converted to lower case.<br></p><p>The strings are modifiable, and any modifications made persist until program termination, although these modifications do not propagate back to the execution environment: they can be used, for example, with <code>strtok</code>.</p><p>The size of the array pointed to by <code>argv</code> is at least <code>argc+1</code>, and the last element, <code>argv[argc]</code>, is guaranteed to be a null pointer.</p><p>The <code>main</code> function has several special properties:</p><ul>1) A prototype for this function cannot be supplied by the program</ul><ul>2) If the return type of the main function is compatible with <code>int</code>, then the return from the initial call to main (but not the return from any subsequent, recursive, call) is equivalent to executing the <code>exit</code> function, with the value that the main function is returning passed as the argument (which then calls the functions registered with <code>atexit</code>, flushes and closes all streams, and deletes the files created with <code>tmpfile</code>, and returns control to the execution environment).</ul><ul>3) If the return type of the main function is not compatible with <code>int</code> (e.g. <code>void main(void)</code>), the value returned to the execution environment is unspecified</ul><ul>4) The body of the main function does not need to contain the return statement: if control reaches the end of <code>main</code> without encountering a return statement, the effect is that of executing <code>return 0;</code>.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/main_function.html
memory_model	A										<section class="prog__container"><p>Defines the semantics of computer memory storage for the purpose of the C abstract machine.<br></p><p>The data storage (memory) available to a C program is one or more contiguous sequences of <i>bytes</i>. Each byte in memory has a unique <i>address</i>.</p><h3><span class="prog__sub">Byte</span></h3><p>A <i>byte</i> is the smallest addressable unit of memory. It is defined as a contiguous sequence of bits, large enough to hold any member of the <i>basic execution character set</i> (the 96 characters that are required to be single-byte). C supports bytes of sizes 8 bits and greater.</p><p>The types <code>char</code>, <code>unsigned char</code>, and <code>signed char</code> use one byte for both storage and value representation. The number of bits in a byte is accessible as <code>CHAR_BIT</code>.</p><h3><span class="prog__sub">Memory location</span></h3><p>A <i>memory location</i> is </p><ul><li> an object of scalar type (arithmetic type, pointer type, enumeration type)</li><li> or the largest contiguous sequence of bit fields of non-zero length</li></ul><pre><code>struct S {    char a;     // memory location #1    int b : 5;  // memory location #2    int c : 11, // memory location #2 (continued)          : 0,        d : 8;  // memory location #3    struct {        int ee : 8; // memory location #4    } e;} obj; // The object 'obj' consists of 4 separate memory locations</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><h3><span class="prog__sub"> Threads and data races</span></h3><p>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by <code>thrd_create</code> or other means.</p><p>Any thread can potentially access any object in the program (objects with automatic and thread-local storage duration may still be accessed by another thread through a pointer).</p><p>Different threads of execution are always allowed to access (read and modify) different <i>memory locations</i> concurrently, with no interference and no synchronization requirements. (note that it is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (non-zero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be)</p><p>When an evaluation of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to <i>conflict</i>. A program that has two conflicting evaluations has a <i>data race</i> unless either</p><ul><li> both conflicting evaluations are atomic operations</li><li> one of the conflicting evaluations <i>happens-before</i> another (see <code>memory_order</code>)</li></ul><p>If a data race occurs, the behavior of the program is undefined.<br></p>(in particular, <code>mtx_unlock</code> is <i>synchronized-with</i>, and therefore, <i>happens-before</i> <code>mtx_lock</code> of the same mutex by another thread, which makes it possible to use mutex locks to guard against data races) <table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: small example or two <br></td></tr></table><h3><span class="prog__sub"> Memory order</span></h3><p>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See <code>memory_order</code> for details on the order in which writes made from threads become visible to other threads.</p></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/memory_model.html
name_space	A										<section class="prog__container"><p>When an identifier is encountered in a C program, a lookup is performed to locate the declaration that introduced that identifier and that is currently in scope. C allows more than one declaration for the same identifier to be in scope simultaneously if these identifiers belong to different categories, called <i>name spaces</i>:</p><ul>1) Label name space: all identifiers declared as labels.</ul><ul>2) Tag names: all identifiers declared as names of structs, unions and enumerated types. Note that all three kinds of tags share one name space.</ul><ul>3) Member names: all identifiers declared as members of any one struct or union. Every struct and union introduces its own name space of this kind.</ul><ul>4) All other identifiers, called <i>ordinary identifiers</i> to distinguish from (1-3) (function names, object names, typedef names, enumeration constants).</ul><p>At the point of lookup, the name space of an identifier is determined by the manner in which it is used:<br></p><ul>1) identifier appearing as the operand of a goto statement is looked up in the label name space.</ul><ul>2) identifier that follows the keyword <code>struct</code>, <code>union</code>, or <code>enum</code> is looked up in the tag name space.</ul><ul>3) identifier that follows the member access or member access through pointer operator is looked up in the name space of members of the type determined by the left-hand operand of the member access operator.</ul><ul>4) all other identifiers are looked up in the name space of ordinary identifiers.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/name_space.html
noreturn	A										<section class="prog__container"><p>Specifies that the function does not return to its point of invocation.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Noreturn</code> <i>function_declaration</i></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The <code>_Noreturn</code> keyword appears in a function declaration and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing <code>longjmp</code>). If the function declared <code>_Noreturn</code> returns, the behavior is undefined. A compiler diagnostic is recommended if this can be detected.</p><p>The <code>_Noreturn</code> specifier may appear more than once in the same function declaration, the behavior is the same as if it appeared once.</p><p>This specifier is typically used through the convenience macro <tt>noreturn</tt>, which is provided in the header <code>stdnoreturn.h</code></p><h3><span class="prog__sub">Keywords</span></h3><p><tt>_Noreturn</tt></p><h3><span class="prog__sub">Standard library</span></h3><p>The following functions are <code>noreturn</code> in the standard library:</p><ul><li> <code>abort()</code></li><li> <code>exit()</code></li><li> <code>_Exit()</code></li><li> <code>quick_exit()</code></li><li> <code>thrd_exit()</code></li><li> <code>longjmp()</code></li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/noreturn.html
object	A										<section class="prog__container"><p>C programs create, destroy, access, and manipulate objects.<br></p><p>An object, in C, is region of data storage in the execution environment, the contents of which can represent <i>values</i> (a value is the meaning of the contents of an object, when interpreted as having a specific type).</p><p>Every object has<br></p><ul><li> size (can be determined with sizeof)</li><li> alignment requirement<span> (can be determined by alignof)</span> <span></span></li><li> storage duration (automatic, static, allocated, thread-local)</li><li> lifetime (equal to storage duration or temporary)</li><li> effective type (see below)</li><li> value (which may be indeterminate)</li><li> optionally, an identifier that denotes this object</li></ul><p>Objects are created by declarations, allocation functions, string literals, compound literals, and by non-lvalue expressions that return structures or unions with array members.</p><h3><span class="prog__sub">Object representation</span></h3><p>Except for bit fields, objects are composed of contiguous sequences of one or more bytes, each consisting of <code>CHAR_BIT</code> bits, and can be copied with <code>memcpy</code> into an object of type <code>unsigned char[n]</code>, where <code>n</code> is the size of the object. The contents of the resulting array are known as <i>object representation</i>.</p><p>If two objects have the same object representation, they compare equal (except if they are floating-point NaNs). The opposite is not true: two objects that compare equal may have different object representations because not every bit of the object representation needs to participate in the value. Such bits may be used for padding to satisfy alignment requirement, for parity checks, to indicate trap representations, etc.<br></p><p>If an object representation does not represent any value of the object type, it is known as <i>trap representation</i>. Accessing a trap representation in any way other than reading it through an lvalue expression of character type is undefined behavior. The value of a structure or union is never a trap representation even if any particular member is one.</p><p>For the objects of type char, signed char, and unsigned char, every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).<br></p><h3><span class="prog__sub">Effective type</span></h3><p>Every object has an <i>effective type</i>, which determines which lvalue accesses are valid and which violate the strict aliasing rules.</p><p>If the object was created by a declaration, the declared type of that object is the object's <i>effective type</i>.</p><p>If the object was created by an allocation function (including <code>realloc</code>), it has no declared type. Such object acquires an effective type as follows:</p><ul><li> The first write to that object through an lvalue that has a type other than character type, at which time the type of that lvalue becomes this object's <i>effective type</i> for that write and all subsequent reads.</li><li> <code>memcpy</code> or <code>memmove</code> copy another object into that object, at which time the effective type of the source object (if it had one) becomes the effective type of this object for that write and all subsequent reads.</li><li> Any other access to the object with no declared type, the effective type is the type of the lvalue used for the access.</li></ul><h3><span class="prog__sub">Strict aliasing</span></h3><p>Given an object with <i>effective type</i> T1, using an lvalue expression (typically, dereferencing a pointer) of a different type T2 is undefined behavior, unless:</p><ul><li> T2 and T1 are compatible types.</li><li> T2 is cvr-qualified version of a type that is compatible with T1.</li><li> T2 is a signed or unsigned version of a type that is compatible with T1.</li><li> T2 is an aggregate type or union type type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union).</li><li> T2 is a character type (char, signed char, or unsigned char).</li></ul><pre><code>int i = 7;char* pc = (char*)(&amp;i);if(pc[0] == '\\x7') // aliasing through char is ok    puts("This system is little-endian");else    puts("This system is big-endian"); float* pf = (float*)(&amp;i);float d = *pf; // UB: float lvalue *p cannot be used to access int</code></pre><p>Note that type-punning may also be performed through the inactive member of a union.</p><h3><span class="prog__sub">Alignment</span></h3><p>Every complete object type has a property called <i>alignment requirement</i>, which is an integer value of type <code>size_t</code> representing the number of bytes between successive addresses at which objects of this type can be allocated. The valid alignment values are non-negative integral powers of two.</p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p>The alignment requirement of a type can be queried with alignof.</p></td><td></td></tr></table><p>In order to satisfy alignment requirements of all  members of a struct, padding may be inserted after some of its members.<br></p>Run this code<pre><code>#include <stdio.h>#include <stdalign.h> // objects of struct S can be allocated at any address// because both S.a and S.b can be allocated at any addressstruct S {  char a; // size: 1, alignment: 1  char b; // size: 1, alignment: 1}; // size: 2, alignment: 1 // objects of struct X must be allocated at 4-byte boundaries// because X.n must be allocated at 4-byte boundaries// because int's alignment requirement is (usually) 4struct X {  int n;  // size: 4, alignment: 4  char c; // size: 1, alignment: 1  // three bytes padding}; // size: 8, alignment: 4 int main(void){    printf("sizeof(struct S) = %zu\\n", sizeof(struct S));    printf("alignof(struct S) = %zu\\n", alignof(struct S));    printf("sizeof(struct X) = %zu\\n", sizeof(struct X));    printf("alignof(struct X) = %zu\\n", alignof(struct X));}</code></pre><p>Possible output:<br></p><pre><code>sizeof(struct S) = 2<br>alignof(struct S) = 1<br>sizeof(struct X) = 8<br>alignof(struct X) = 4</code></pre><p>Each object type imposes its alignment requirement on every object of that type. The strictest (largest) fundamental alignment of any type is the alignment of <code>max_align_t</code>. The weakest (smallest) alignment is the alignment of the types <code>char</code>, <code>signed char</code>, and <code>unsigned char</code>, and equals 1.</p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td>If an object's alignment is made stricter (larger) than <code>max_align_t</code> using alignas, it has <i>extended alignment requirement</i>. A struct or union type whose member has extended alignment is an <i>over-aligned type</i>. It is implementation-defined if over-aligned types are supported, and their support may be different in each kind of storage duration.</td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/object.html
operator_alternative	A										<section class="prog__container"><p>C source code may be written in any non-ASCII 7-bit character set that includes the ISO 646:1983 invariant character set. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: <code>{, }, [, ], #, \, ^, |, ~</code>. To be able to use character encodings where some or all of these symbols do not exist (such as the German DIN 66003), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.</p><h2>Operator macros</h2><p>There are alternative spellings for the operators that use non-ISO646 characters, defined in <code><iso646.h></code> as macros:</p><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><iso646.h></code> </td></tr><tr class="t-dsc-hitem"><td>  Primary</td><td>  Alternative</td></tr><tr class="t-dsc"><td> <code>&amp;&amp;</code></td><td> <code>and</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>&amp;=</code></td><td> <code>and_eq</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>&amp;</code></td><td> <code>bitand</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>|</code></td><td> <code>bitor</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>~</code></td><td> <code>compl</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>!</code></td><td> <code>not</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>!=</code></td><td> <code>not_eq</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>||</code></td><td> <code>or</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>|=</code></td><td> <code>or_eq</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>^</code></td><td> <code>xor</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>^=</code></td><td> <code>xor_eq</code> <br> (macro constant)<br></td></tr></table><p>The characters <code>&amp;</code> and <code>!</code> are invariant under ISO-646, but alternatives are provided for the operators that use these characters anyway to accommodate even more restrictive historical charsets.</p><p>There is no alternative spelling (such as <code>eq</code>) for the equality operator <code>==</code> because the character <code>=</code> was present in all supported charsets.</p><h2>Alternative tokens</h2><p>The following alternative tokens are part of the core language, and, in all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the stringification operator can make the spelling visible). The two-letter alternative tokens are sometimes called "digraphs"</p><p><br></p><table class="wikitable"><tr style="text-align: left;"><th> Primary</th><th> Alternative</th></tr><tr><td> <code>{</code> </td><td> <code><%</code></td></tr><tr><td> <code></code>} </td><td> <code>%></code></td></tr><tr><td> <code>[</code> </td><td> <code><:</code></td></tr><tr><td> <code>]</code> </td><td> <code>:></code></td></tr><tr><td> <code>#</code> </td><td> <code>%:</code></td></tr><tr><td> <code>##</code> </td><td> <code>%:%:</code></td></tr></table><h2>Trigraphs</h2><p>The following three-character groups (trigraphs) are parsed before comments and string literals are recognized, and each appearance of a trigraph is replaced by the corresponding primary character:</p><table class="wikitable"><tr style="text-align: left;"><th> Primary</th><th> Trigraph</th></tr><tr><td> <code>{</code> </td><td> <code>??<</code></td></tr><tr><td> <code></code>} </td><td> <code>??></code></td></tr><tr><td> <code>[</code> </td><td> <code>??(</code></td></tr><tr><td> <code>]</code> </td><td> <code>??)</code></td></tr><tr><td> <code>#</code> </td><td> <code>??=</code></td></tr><tr><td> <code>\</code> </td><td> <code>??/</code></td></tr><tr><td> <code>^</code> </td><td> <code>??'</code></td></tr><tr><td> <code>|</code> </td><td> <code>??!</code></td></tr><tr><td> <code>~</code> </td><td> <code>??-</code></td></tr></table><p>Because trigraphs are processed early, a comment such as <code>// Will the next line be executed?????/</code> will effectively comment out the following line, and the string literal such as <code>"What's going on??!"</code> is parsed as <code>"What's going on|"</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_alternative.html
operator_arithmetic	A										<section class="prog__container"><p>Arithmetic operators apply standard mathematical operations to their operands.<br></p><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: consider a more general-purpose ToC for this and other tables that cover multiple topics <br></td></tr></table><table class="wikitable" style="font-size:85%;"><tr style="text-align:center"><th> Operator</th><th> Operator name</th><th> Example</th><th> Result</th></tr><tr style="text-align:center"><td> <code>+</code></td><td> unary plus</td><td> <code>+a</code></td><td> the value of <b>a</b> after promotions</td></tr><tr style="text-align:center"><td> <code>-</code></td><td> unary minus</td><td> <code>-a</code></td><td> the negative of <b>a</b></td></tr><tr style="text-align:center"><td> <code>+</code></td><td> addition</td><td> <code>a + b</code></td><td> the addition of <b>a</b> and <b>b</b></td></tr><tr style="text-align:center"><td> <code>-</code></td><td> subtraction</td><td> <code>a - b</code></td><td> the subtraction of <b>b</b> from <b>a</b></td></tr><tr style="text-align:center"><td> <code>*</code></td><td> product</td><td> <code>a * b</code></td><td> the product of <b>a</b> and <b>b</b></td></tr><tr style="text-align:center"><td> <code>/</code></td><td> division</td><td> <code>a / b</code></td><td> the division of <b>a</b> by <b>b</b></td></tr><tr style="text-align:center"><td> <code>%</code></td><td> modulo</td><td> <code>a % b</code></td><td> the remainder of <b>a</b> divided by <b>b</b></td></tr><tr style="text-align:center"><td> <code>~</code></td><td> bitwise NOT</td><td> <code>~a</code></td><td> the bitwise NOT of <b>a</b></td></tr><tr style="text-align:center"><td> <code>&amp;</code></td><td> bitwise AND</td><td> <code>a &amp; b</code></td><td> the bitwise AND of <b>a</b> and <b>b</b></td></tr><tr style="text-align:center"><td> <code>|</code></td><td> bitwise OR</td><td> <code>a | b</code></td><td> the bitwise OR of <b>a</b> and <b>b</b></td></tr><tr style="text-align:center"><td> <code>^</code></td><td> bitwise XOR</td><td> <code>a ^ b</code></td><td> the bitwise XOR of <b>a</b> and <b>b</b></td></tr><tr style="text-align:center"><td> <code><<</code></td><td> bitwise left shift</td><td> <code>a << b</code></td><td> <b>a</b> left shifted by <b>b</b></td></tr><tr style="text-align:center"><td> <code>>></code></td><td> bitwise right shift</td><td> <code>a >> b</code></td><td> <b>a</b> right shifted by <b>b</b></td></tr></table><h3><span class="prog__sub">Overflows</span></h3><p>Unsigned integer arithmetic is always performed modulo 2<span class="t-su">n<br/></span> where n is the number of bits in that particular integer. E.g. for <code>unsigned int</code>, adding one to <code>UINT_MAX</code> gives <code>​0​</code>, and subtracting one from <code>​0​</code> gives <code>UINT_MAX</code>.</p><p>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. <code>-ftrapv</code> in GCC and Clang), or may be completely optimized out by the compiler.</p><h4>Floating-point environment</h4><p>If <tt>#pragma STDC FENV_ACCESS</tt> is set to <code>ON</code>, all floating-point arithmetic operators obey the current floating-point rounding direction and report floating-point arithmetic errors as specified in math_errhandling unless part of a static initializer (in which case floating-point exceptions are not raised and the rounding mode is to nearest)</p><h4>Floating-point contraction</h4><p>Unless <tt>#pragma STDC FP_CONTRACT</tt> is set to <code>OFF</code>, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of <code>(x*y) + z</code> with a single fused multiply-add CPU instruction or optimization of <code>a = x*x*x*x;</code> as <code>tmp = x*x; a = tmp*tmp</code>.</p><p>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see <code>FLT_EVAL_METHOD</code></p><h3><span class="prog__sub">Unary arithmetic</span></h3><p>The unary arithmetic operator expressions have the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>+</code> <i>expression</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>-</code> <i>expression</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) unary plus (promotion)</ul><ul>2) unary minus (negation)<p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  expression of any arithmetic type</td></tr></table></ul><p>Both unary plus and unary minus first apply integral promotions to their operand, and then</p><ul><li> unary plus returns the value after promotion</li><li> unary minus returns the negative of the value after promotion (except that the negative of a NaN is another NaN)</li></ul><p>The type of the expression is the type after promotion, and the value category is non-lvalue.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_arithmetic.html
operator_assignment	A										<section class="prog__container"><p>Assignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right.<br></p><table class="wikitable" style="font-size:85%;"><tr style="text-align:center"><th> Operator</th><th> Operator name</th><th> Example</th><th> Description</th><th> Equivalent of</th></tr><tr style="text-align:center"><td> <code>=</code></td><td> basic assignment</td><td> <code>a = b</code></td><td> <b>a</b> becomes equal to <b>b</b></td><td class="table-na" style="background: #ececec; color: grey; vertical-align: middle; text-align: center;"> <small>N/A</small></td></tr><tr style="text-align:center"><td> <code>+=</code></td><td> addition assignment</td><td> <code>a += b</code></td><td> <b>a</b> becomes equal to the addition of <b>a</b> and <b>b</b></td><td> <code>a = a + b</code></td></tr><tr style="text-align:center"><td> <code>-=</code></td><td> subtraction assignment</td><td> <code>a -= b</code></td><td> <b>a</b> becomes equal to the subtraction of <b>b</b> from <b>a</b></td><td> <code>a = a - b</code></td></tr><tr style="text-align:center"><td> <code>*=</code></td><td> multiplication assignment</td><td> <code>a *= b</code></td><td> <b>a</b> becomes equal to the product of <b>a</b> and <b>b</b></td><td> <code>a = a * b</code></td></tr><tr style="text-align:center"><td> <code>/=</code></td><td> division assignment</td><td> <code>a /= b</code></td><td> <b>a</b> becomes equal to the division of <b>a</b> by <b>b</b></td><td> <code>a = a / b</code></td></tr><tr style="text-align:center"><td> <code>%=</code></td><td> modulo assignment</td><td> <code>a %= b</code></td><td> <b>a</b> becomes equal to the remainder of <b>a</b> divided by <b>b</b></td><td> <code>a = a % b</code></td></tr><tr style="text-align:center"><td> <code>&amp;=</code></td><td> bitwise AND assignment</td><td> <code>a &amp;= b</code></td><td> <b>a</b> becomes equal to the bitwise AND of <b>a</b> and <b>b</b></td><td> <code>a = a &amp; b</code></td></tr><tr style="text-align:center"><td> <code>|=</code></td><td> bitwise OR assignment</td><td> <code>a |= b</code></td><td> <b>a</b> becomes equal to the bitwise OR of <b>a</b> and <b>b</b></td><td> <code>a = a | b</code></td></tr><tr style="text-align:center"><td> <code>^=</code></td><td> bitwise XOR assignment</td><td> <code>a ^= b</code></td><td> <b>a</b> becomes equal to the bitwise XOR of <b>a</b> and <b>b</b></td><td> <code>a = a ^ b</code></td></tr><tr style="text-align:center"><td> <code><<=</code></td><td> bitwise left shift assignment</td><td> <code>a <<= b</code></td><td> <b>a</b> becomes equal to <b>a</b> left shifted by <b>b</b></td><td> <code>a = a << b</code></td></tr><tr style="text-align:center"><td> <code>>>=</code></td><td> bitwise right shift assignment</td><td> <code>a >>= b</code></td><td> <b>a</b> becomes equal to <b>a</b> right shifted by <b>b</b></td><td> <code>a = a >> b</code></td></tr></table><h3><span class="prog__sub">Simple assignment</span></h3><p>The simple assignment operator expressions have the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>lhs</i> <code>=</code> <i>rhs</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>lhs</i></td><td> -</td><td> modifiable lvalue expression of any complete object type</td></tr><tr class="t-par"><td> <i>rhs</i></td><td> -</td><td>  expression of any type implicitly convertible to <i>lhs</i> or compatible with <i>lhs</i></td></tr></table><p>Assignment performs implicit conversion from the value of <i>rhs</i> to the type of <i>rhs</i> and then replaces the value in the object designated by <i>lhs</i> with the converted value of <i>rhs</i>.</p><p>Assignment also returns the same value as what was stored in <code>lhs</code> (so that expressions such as <code>a = b = c</code> are possible). The value category of the assignment operator is non-lvalue (so that expressions such as <code>(a=b)=c</code> are invalid).</p><p><i>rhs</i> and <i>lhs</i> must satisfy one of the following:</p><ul><li> both <i>lhs</i> and <i>rhs</i> have compatible struct or union type, or..</li><li> <i>rhs</i> must be implicitly convertible to <i>lhs</i>, which implies</li></ul><dl><dd><ul><li> both <i>lhs</i> and <i>rhs</i> have arithmetic types, in which case <i>lhs</i> may be volatile-qualified or atomic</li><li> both <i>lhs</i> and <i>rhs</i> have pointer to compatible (ignoring qualifiers) types, or one of the pointers is a pointer to void, and the conversion would not add qualifiers to the pointed-to type. <i>lhs</i> may be volatile or restrict-qualified or atomic.</li><li> <i>lhs</i> is a pointer (possibly qualified or atomic) and <i>rhs</i> is a null pointer constant such as <code>NULL</code></li><li> <i>lhs</i> has type <code>_Bool</code> (possibly qualified or atomic) and <i>rhs</i> is a pointer</li></ul></dd></dl><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_assignment.html
operator_comparison	A										<section class="prog__container"><p>Comparison operators are binary operators that test a condition and return <b>1</b> if that condition is logically <b>true</b> and <b>0</b> if that condition is <b>false</b>..</p><table class="wikitable" style="font-size:85%;"><tr style="text-align:center"><th> Operator</th><th> Operator name</th><th> Example</th><th> Description</th></tr><tr style="text-align:center"><td> <code>==</code></td><td> equal to</td><td> <code>a == b</code></td><td> <b>a</b> is equal to <b>b</b></td></tr><tr style="text-align:center"><td> <code>!=</code></td><td> not equal to</td><td> <code>a != b</code></td><td> <b>a</b> is not equal to <b>b</b></td></tr><tr style="text-align:center"><td> <code><</code></td><td> less than</td><td> <code>a < b</code></td><td> <b>a</b> is less than <b>b</b></td></tr><tr style="text-align:center"><td> <code>></code></td><td> greater than</td><td> <code>a > b</code></td><td> <b>a</b> is greater than <b>b</b></td></tr><tr style="text-align:center"><td> <code><=</code></td><td> less than or equal to</td><td> <code>a <= b</code></td><td> <b>a</b> is less than or equal to <b>b</b></td></tr><tr style="text-align:center"><td> <code>>=</code></td><td> greater than or equal to</td><td> <code>a >= b</code></td><td> <b>a</b> is greater than or equal to <b>b</b></td></tr></table><h3><span class="prog__sub">Relational operators</span></h3><p>The relational operator expressions have the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>lhs</i> <code><</code> <i>rhs</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>lhs</i> <code>></code> <i>rhs</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>lhs</i> <code><=</code> <i>rhs</i></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>lhs</i> <code>>=</code> <i>rhs</i></td><td> (4)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) less-than expression</ul><ul>2) greater-than expression</ul><ul>3) less or equal expression</ul><ul>4) greater or equal expression<p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>lhs</i>, <i>rhs</i></td><td> -</td><td>  expressions that both have real type or both have pointer to object type</td></tr></table></ul><p>The type of any relational operator expression is <code>int</code>, and its value (which is not an lvalue) is <code>1</code> when the specified relationship holds true and <code>​0​</code> when the specified relationship does not hold.</p><p>If <i>lhs</i> and <i>rhs</i> are expressions of any real type, then</p><ul><li> if <i>lhs</i> and <i>rhs</i> have arithmetic type, usual arithmetic conversions are performed</li><li> the values of the operands after conversion are compared in the usual mathematical sense (except that positive and negative zeroes compare equal and any comparison involving a NaN value returns zero)</li></ul><p>Note that complex and imaginary numbers cannot be compared with these operators.<br></p><p>If <i>lhs</i> and <i>rhs</i> are expressions of pointer type, they must be both pointers to objects of compatible types, except that qualifications of the pointed-to objects are ignored.</p><ul><li> a pointer to an object that is not an element of an array is treated as if it were pointing to an element of an array with one element</li><li> if two pointers point to the same object, or both point one past the end of the same array, they compare equal</li><li> if two pointers point to different elements of the same array, the one pointing at the element with the larger index compares greater.</li><li> if one pointer points to the element of an array and the other pointer points one past the end of the same array, the one-past-the-end pointer compares greater</li><li> if the two pointers point to members of the same struct, the pointer to the member declared later in the struct definition compares greater than then pointer to the member declared earlier.</li><li> pointers to members of the same union compare equal</li><li> all other pointer comparisons invoke undefined behavior</li></ul>Run this code<pre><code>#include <assert.h>int main(void){    assert(1 < 2);    assert(2+2 <= 4.0); // int converts to double, two 4.0's compare equal     struct { int x,y; } s;    assert(&amp;s.x < &amp;s.y); // struct members compare in order of declaration     double d = 0.0/0.0; // NaN    assert( !(d < d) );    assert( !(d > d) );    assert( !(d >= d) );    assert( !(d >= d) );     float f = 0.1; // f = 0.100000001490116119384765625    double g = 0.1; // g = 0.1000000000000000055511151231257827021181583404541015625    assert(f > g); // different values}</code></pre><p><br></p><h3><span class="prog__sub">Equality operators</span></h3><p>The equality operator expressions have the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>lhs</i> <code>==</code> <i>rhs</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>lhs</i> <code>!=</code> <i>rhs</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) equal-to expression</ul><ul>2) not equal to expression<p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>lhs</i>, <i>rhs</i></td><td> -</td><td>  expressions that<ul><li> both have any arithmetic types (including complex and imaginary)</li><li> both are pointers to objects or functions of compatible types, ignoring qualifiers of the pointed-to types</li><li> one is a pointer to object and the other is a pointer to (possibly qualified) <code>void</code></li><li> one is a pointer to object or function and the other is a null pointer constant such as <code>NULL</code></li></ul><p><br></p></td></tr></table></ul><p>The type of any equality operator expression is <code>int</code>, and its value (which is not an lvalue) is <code>1</code> when the specified relationship holds true and <code>​0​</code> when the specified relationship does not hold.</p><ul><li> if both operands have arithmetic types, usual arithmetic conversions are performed and the resulting values are compared in the usual mathematical sense (except that positive and negative zeroes compare equal and any comparison involving a NaN value, including equality with itself, returns zero). In particular, values of complex type are equal if their real parts compare equal and their imaginary parts compare equal.</li><li> if one operand is a pointer and the other is a null pointer constant, the null pointer constant is first converted to the type of the pointer (which gives a null pointer value), and the two pointers are compared as described below</li><li> if one operand is a pointer and the other is a pointer to void, the non-void pointer is converted to the pointer to void and the two pointers are compared as described below</li><li> two pointers compare equal if any of the following is true:</li></ul><dl><dd><ul><li> they are both null pointer values of their type</li><li> they are both pointers to the same object</li><li> one pointer is to a struct/union/array object and the other is to its first member/any member/first element</li><li> they are both pointing one past the last element of the same array</li><li> one is one past the end of an array, and the other is at the start of a different array (of the same type) that follows the first in a larger array or in a struct with no padding</li></ul></dd></dl><p>(as with relational operators, pointers to objects that aren't elements of any array behave as pointers to elements of arrays of size 1)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_comparison.html
operator_incdec	A										<section class="prog__container"><p>Increment/decrement operators are unary operators that increment/decrement the value of a variable by 1. <br></p><p>They can have postfix form:<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>expr</i> <code>++</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>expr</i> <code>--</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>As well as the prefix form:<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>++</code> <i>expr</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>--</code> <i>expr</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>The operand <i>expr</i> of both prefix and postfix increment or decrement must be a modifiable lvalue of integer type (including <code>_Bool</code> and enums), real floating type, or a pointer type. It may be cvr-qualified, unqualified, or atomic.</p><p>The result of the postfix increment and decrement operators is the value of <i>expr</i>. </p><p>The result of the prefix increment operator is the result of adding the value <code>1</code> to the value of <i>expr</i>: the expression <code>++e</code> is equivalent to <code>e+=1</code>. The result of the prefix decrement operator is the result of subtracting the value <code>1</code> from the value of <i>expr</i>: the expression <code>--e</code> is equivalent to <code>e-=1</code>.</p><p>Increment operators initiate the side-effect of adding the value <code>1</code> of appropriate type to the operand. Decrement operators initiate the side-effect of subtracting the value <code>1</code> of appropriate type from the operand. As with any other side-effects, these operations complete at or before the next sequence point.<code>int a = 1;<br>int b = a++; // stores 1+a (which is 2) to a<br>             // returns the value of a (which is 1)<br>             // After this line, b == 1 and a == 2<br>a = 1;<br>int c = ++a; // stores 1+a (which is 2) to a<br>             // returns 1+a (which is 2)<br>             // after this line, c == 2 and a == 2<br></code></p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p>Post-increment or post-decrement on any atomic variable is an atomic read-modify-write operation with memory order <code>memory_order_seq_cst</code>.</p></td><td></td></tr></table><p>See arithmetic operators for limitations on pointer arithmetic, as well as for implicit conversions applied to the operands.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_incdec.html
operator_logical	A										<section class="prog__container"><p>Logical operators apply standard boolean algebra operations to their operands.<br></p><table class="wikitable" style="font-size:85%;"><tr style="text-align:center"><th> Operator</th><th> Operator name</th><th> Example</th><th> Result</th></tr><tr style="text-align:center"><td> <code>!</code></td><td> logical NOT</td><td> <code>!a</code></td><td> the logical negation of <b>a</b></td></tr><tr style="text-align:center"><td> <code>&amp;&amp;</code></td><td> logical AND</td><td> <code>a &amp;&amp; b</code></td><td> the logical AND of <b>a</b> and <b>b</b></td></tr><tr style="text-align:center"><td> <code>||</code></td><td> logical OR</td><td> <code>a || b</code></td><td> the logical OR of <b>a</b> and <b>b</b></td></tr></table><h3><span class="prog__sub">Logical NOT</span></h3><p>The logical NOT expression has the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>!</code> <i>expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  an expression of any scalar type</td></tr></table><p>The logical NOT operator has type <code>int</code>. Its value is <code>​0​</code> if <i>expression</i> evaluates to a value that compares unequal to zero. Its value is <code>1</code> if <i>expression</i> evaluates to a value that compares equal to zero. (so <code>!E</code> is the same as <code>(0==E)</code>)</p>Run this code<pre><code>#include <stdbool.h>#include <stdio.h>#include <ctype.h>int main(void){    bool b = !(2+2 == 4); // not true    printf("!(2+2==4) = %s\\n", b ? "true" : "false");     int n = isspace('a'); // zero if 'a' is a space, nonzero otherwise    int x = !!n; // "bang-bang", common C idiom for mapping integers to [0,1]                 // (all non-zero values become 1)    char *a[2] = {"nonspace", "space"};    printf("%s\\n", a[x]); // now x can be safely used as an index to array of 2 ints}</code></pre><p>Output:<br></p><pre><code>!(2+2==4) = false<br>nonspace</code></pre><h3><span class="prog__sub">Logical AND</span></h3><p>The logical AND expression has the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>lhs</i> <code>&amp;&amp;</code> <i>rhs</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>lhs</i></td><td> -</td><td>  an expression of any scalar type</td></tr><tr class="t-par"><td> <i>rhs</i></td><td> -</td><td>  an expression of any scalar type, which is only evaluated if <i>lhs</i> does not compare equal to <code>​0​</code></td></tr></table><p>The logical-AND operator has type <code>int</code> and the value <code>1</code> if both <i>lhs</i> and <i>rhs</i> compare unequal to zero. It has the value <code>​0​</code> otherwise (if either <i>lhs</i> or <i>rhs</i> or both compare equal to zero).</p><p>There is a sequence point after the evaluation of <i>lhs</i>. If the result of <i>lhs</i> compares equal to zero, then <i>rhs</i> is not evaluated at all (so-called <i>short-circuit evaluation</i>)</p>Run this code<pre><code>#include <stdbool.h>#include <stdio.h>int main(void){    bool b = 2+2==4 &amp;&amp; 2*2==4; // b == true     1 > 2 &amp;&amp; puts("this won't print");     char *p = "abc";    if(p &amp;&amp; *p) // common C idiom: if p is not null                // AND if p does not point at the end of the string    {           // (note that thanks to short-circuit evaluation, this                //  will not attempt to dereference a null pointer)    // ...      // ... then do some string processing    }}</code></pre><p><br></p><h3><span class="prog__sub">Logical OR</span></h3><p>The logical OR expression has the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>lhs</i> <code>||</code> <i>rhs</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>lhs</i></td><td> -</td><td>  an expression of any scalar type</td></tr><tr class="t-par"><td> <i>rhs</i></td><td> -</td><td>  an expression of any scalar type, which is only evaluated if <i>lhs</i> compares equal to <code>​0​</code></td></tr></table><p>The logical-OR operator has type <code>int</code> and the value <code>1</code> if either <i>lhs</i> or <i>rhs</i> compare unequal to zero. It has value <code>​0​</code> otherwise (if both <i>lhs</i> and <i>rhs</i> compare equal to zero).</p><p>There is a sequence point after the evaluation of <i>lhs</i>. If the result of <i>lhs</i> compares unequal to zero, then <i>rhs</i> is not evaluated at all (so-called <i>short-circuit evaluation</i>)</p>Run this code<pre><code>#include <stdbool.h>#include <stdio.h>#include <string.h>#include <errno.h>int main(void){    bool b = 2+2 == 4 || 2+2 == 5; // true    printf("true or false = %s\\n", b ? "true" : "false");     // logical OR can be used simialar to perl's "or die", as long as rhs has scalar type    fopen("test.txt", "r") || printf("could not open test.txt: %s\\n", strerror(errno));}</code></pre><p>Possible output:<br></p><pre><code>true or false = true<br>could not open test.txt: No such file or directory</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_logical.html
operator_member_access	A										<section class="prog__container"><p>Member access operators allow access to the members of their operands.<br></p><table class="wikitable" style="font-size:85%;"><tr style="text-align:center"><th> Operator</th><th> Operator name</th><th> Example</th><th> Description</th></tr><tr style="text-align:center"><td> <code>[]</code></td><td> array subscript</td><td> <code>a[b]</code></td><td> access the <b>b</b>th element of array <b>a</b></td></tr><tr style="text-align:center"><td> <code>*</code></td><td> pointer dereference</td><td> <code>*a</code></td><td> dereference the pointer <b>a</b> to access the object or function it refers to</td></tr><tr style="text-align:center"><td> <code>&amp;</code></td><td> address of</td><td> <code>&amp;a</code></td><td> create a pointer that refers to the object or function <b>a</b></td></tr><tr style="text-align:center"><td> <code>.</code></td><td> member access</td><td> <code>a.b</code></td><td> access member <b>b</b> of struct or union <b>a</b></td></tr><tr style="text-align:center"><td> <code>-></code></td><td> member access through pointer</td><td> <code>a->b</code></td><td> access member <b>b</b> of struct or union pointed to by <b>a</b></td></tr></table><h3><span class="prog__sub">Subscript</span></h3><p>The array subscrpt expression has the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>pointer-expression</i> <code>[</code> <i>integer-expression</i> <code>]</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>integer-expression</i> <code>[</code> <i>pointer-expression</i> <code>]</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>pointer-expression</i></td><td> -</td><td>  an expression of type pointer to complete object</td></tr><tr class="t-par"><td> <i>integer-expression</i></td><td> -</td><td>  an expression of integer type</td></tr></table><p>The subscript operator expression is is lvalue expression whose type is the type of the object pointed to by <i>pointer-expression</i>.</p><p>By definition, the subscript operator <code>E1[E2]</code> is exactly identical to <code>*((E1)+(E2))</code>.  If <i>pointer-expression</i> is an array expression, it undergoes lvalue-to-rvalue conversion and becomes a pointer to the first element of the array.</p><p>Due to the definition of the addition between a pointer and an integer, the result is the element of the array with the index equal to the result of <i>integer-expression</i> (or, if <i>pointer-expression</i> was pointing at ith element of some array, the result is i plus the result of <i>integer-expression</i>)</p><p>Note: see array for the details on multidimensional arrays.</p>Run this code<pre><code>#include <stdio.h>int main(void){    int a[3] = {1,2,3};    printf("%d %d\\n", a[2],  // n == 3                      2[a]); // same, n == 3    a[2] = 7; // subscripts are lvalues     int n[2][3] = {1,2,3,4,5,6};    int (*p)[3] = &amp;n[1]; // elements of n are arrays    int x = n[1][2]; // applying [] again to the array n[1]     printf("%c %c\\n", "abc"[2], 2["abc"]); // string literals are arrays too}</code></pre><p>Output:<br></p><pre><code>3 3<br>c c</code></pre><h3><span class="prog__sub">Dereference</span></h3><p>The <i>dereference</i> or <i>indirection</i> expression has the form </p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>*</code> <i>pointer-expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>pointer-expression</i></td><td> -</td><td>  an expression of any pointer type</td></tr></table><p>If <i>pointer-expression</i> is a pointer to function, the result of the dereference operator is a function designator for that function.</p><p>If <i>pointer-expression</i> is a pointer to object, the result is an lvalue expression that designates the pointed-to object.</p><p>Dereferencing a null pointer, a pointer to an object outside of its lifetime (a dangling pointer), a misaligned pointer, or a pointer with indeterminate value is undefined behavior, except when the dereference operator is nullified by applying the address-of operator to its result, as in <code>&amp;*E</code></p>Run this code<pre><code>#include <stdio.h>int main(void){    int n = 1;    int* p = &amp;n;    printf("*p = %d\\n", *p); // the value of *p is what's stored in n    *p = 7; // *p is lvalue    printf("*p = %d\\n", *p);}</code></pre><p>Output:<br></p><pre><code>*p = 1<br>*p = 7</code></pre><h3><span class="prog__sub">Address of</span></h3><p>The address-of expression has the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>&amp;</code> <i>function</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>&amp;</code> <i>lvalue-expression</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>&amp;</code> <code>*</code> <i>expression</i></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>&amp;</code> <i>expression</i> <code>[</code> <i>expression</i> <code>]</code></td><td> (4)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) address of a function</ul><ul>2) address of an object</ul><ul>3) special case: &amp; and * cancel each other, neither one is evaluated</ul><ul>4) special case: &amp; and the * that is implied in [] cancel each other, only the addition implied in [] is evaluated<p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>lvalue-expression</i></td><td> -</td><td>  an lvalue expression of any type that is not a bit field and does not have register storage class</td></tr></table></ul><p>The address-of operator produces the non-lvalue address of its operand, suitable for initializing a pointer to the type of the operand. If the operand is a function designator ((1)), the result is a pointer to function. If the operand is an object ((2)), the result is a pointer to object.</p><p>If the operand is the dereference operator, no action is taken (so it's okay to apply &amp;* to a null pointer), except that the result is not an lvalue.<br></p><p>If the operand is an array index expression, no action is taken other than the array-to-pointer conversion and the addition, so &amp;a[N] is valid for an array of size N (obtaining a pointer one past the end is okay, dereferencing it is not, but dereference cancels out in this expression).<br></p>Run this code<pre><code>int f(char c) { return c;}int main(void){   int n = 1;   int *p = &amp;n; // address of object n   int (*fp)(char) = &amp;f; // address of function f   int a[3] = {1,2,3};   int *beg=a, *end=&amp;a[3]; // same as end = n+3}</code></pre><p><br></p><h3><span class="prog__sub">Member access</span></h3><p>The member access expression has the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>expression</i> <code>.</code> <i>member-name</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  an expression of struct or union type</td></tr><tr class="t-par"><td> <i>member-name</i></td><td> -</td><td>  an identifier that names a member of the struct or union designated by <i>expression</i></td></tr></table><p>The member access expression designates the named member of the struct or union designated by its left operand. It has the same value category as its left operand. </p><p>If the left operand is const or volatile qualified, the result is also qualified. If the left operand is atomic, the behavior is undefined.</p><p>Note: besides identifiers that name objects of struct or union type, the following expressions may have struct or union types: assignment, function call, comma operator, conditional operator, and compound literal.</p>Run this code<pre><code>#include <stdio.h>struct s {int x;};struct s f(void) { return (struct s){1}; }int main(void){    struct s s;    s.x = 1; // ok, changes the member of s    int n = f().x; // f() is an expression of type struct s//  f().x = 1; // Error: this member access expression is not an lvalue     const struct s sc;//  sc.x = 3;  // Error: sc.x is const, can't be assigned     union { int x; double d; } u = {1};    u.d = 0.1; // changes the active member of the union}</code></pre><p><br></p><h3><span class="prog__sub">Member access through pointer</span></h3><p>The member access expression has the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>expression</i> <code>-></code> <i>member-name</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  an expression of type pointer to struct or union</td></tr><tr class="t-par"><td> <i>member-name</i></td><td> -</td><td>  an identifier that names a member of the struct or union pointed by <i>expression</i></td></tr></table><p>The member access through pointer expression designates the named member of the struct or union type pointed to by its left operand. Its value category is always lvalue</p><p>If the type pointed to by the left operand is const or volatile qualified, the result is also qualified. If the type pointed to by the left operand is atomic, the behavior is undefined.</p>Run this code<pre><code>#include <stdio.h>struct s {int x;};int main(void){    struct s s={1}, *p = &amp;s;    p->x = 7; // changes the value of s.x through the pointer    printf("%d\\n", p->x); // prints 7}</code></pre><p><br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_member_access.html
operator_other	A										<section class="prog__container"><p>A collection of operators that do not fit into any of the other major categories.<br></p><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: consider a more general-purpose ToC for this and other tables that cover multiple topics <br></td></tr></table><table class="wikitable" style="font-size:85%;"><tr style="text-align:center"><th> Operator</th><th> Operator name</th><th> Example</th><th> Description</th></tr><tr style="text-align:center"><td> <code>(...)</code></td><td> function call</td><td> <code>f(...)</code></td><td> call the function <b>f</b>(), with zero or more arguments</td></tr><tr style="text-align:center"><td> <code>,</code></td><td> comma operator</td><td> <code>a, b</code></td><td> evaluate expression <b>a</b>, disregard its return value and complete any side-effects, then evaluate expression <b>b</b>, returning the type and the result of this evaluation</td></tr><tr style="text-align:center"><td> <code>(type)</code></td><td> type cast</td><td> <code>(type)a</code></td><td> cast the type of <b>a</b> to <b>type</b></td></tr><tr style="text-align:center"><td> <code>? :</code></td><td> conditional operator</td><td> <code>a ? b : c</code></td><td> if <b>a</b> is logically true (does not evaluate to zero) then evaluate expression <b>b</b>, otherwise evaluate expression <b>c</b></td></tr><tr style="text-align:center"><td> <code>sizeof</code></td><td> sizeof operator</td><td> <code>sizeof a</code></td><td> the size in bytes of <b>a</b></td></tr><tr style="text-align:center"><td> <code>_Alignof</code> </td><td> _Alignof operator</td><td> <code>_Alignof(type)</code></td><td> the alignment required of <b>type</b></td></tr></table><h3><span class="prog__sub">Function call</span></h3><p>The function call expression has the form <br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <i>expression</i> <code>(</code> <i>argument-list</i>(optional) <code>)</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <br></p><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td> any expression of pointer-to-function type (after lvalue conversions)</td></tr><tr class="t-par"><td> <i>argument-list</i></td><td> -</td><td>  comma-separated list of expressions (which cannot be comma operators) of any complete object type. May be omitted when calling functions that take no arguments.</td></tr></table><p>The behavior of the function call expression depends on whether the prototype of the function being called is in scope at the point of call. </p><h4>Call to a function with a prototype</h4><ul>1) The number of parameters must equal the number of arguments (unless the ellipsis parameter is used).</ul><ul>2) The type of each parameter must he a type such that implicit conversion as if by assignment exists that converts the unqualified type of the corresponding argument to the type of the parameter.</ul><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><ul> Additionally, for every parameter of array type that uses the keyword <code>static</code> between <code>[</code> and <code>]</code>, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter.</ul></td><td></td></tr></table><ul>3) The arguments are evaluated in unspecified order and without sequencing.</ul><ul>4) <span>Assignment</span> <span></span><span>Initialization</span> <span></span> is performed to copy the value of each argument to the corresponding function parameter (note; the function can modify its parameters, and those changes do not affect the arguments; C function calls are only call-by-value).<dl><dd><ul><li> if there is a trailing ellipsis parameter,  Default argument promotions are performed on the remaining arguments, which are made available to <code>va_list</code>.</li></ul></dd></dl></ul><ul>5) Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression)<pre><code>void f(char* p, int x) {}int main(void){    f("abc", 3.14); // array to pointer and float to int conversions}</code></pre></ul><h4>Call to a function without a prototype</h4><ul>1) The arguments are evaluated in unspecified order and without sequencing.</ul><ul>2) Default argument promotions are performed on every argument expression.</ul><ul>3) <span>Assignment</span> <span></span><span>Initialization</span> <span></span> is performed to copy the value of each argument to the corresponding function parameter.</ul><ul>4) Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression)<pre><code>void f(); // no prototypeint main(void){    f(1, 1.0f); // UB unless f is defined to take an int and a double}void f(int a, double c) {}</code></pre></ul><p>The behavior of a function call to a function without a prototype is undefined if<br></p><ul><li> the number of arguments does not match the number of parameters.</li><li> the promoted types of the arguments are not compatible with the promoted types of the parameters except that</li></ul><dl><dd><ul><li> signed and unsigned versions of the same integer type are considered compatible if the value of the argument is representable by both types.</li><li> pointers to void and pointers to (possibly cvr-qualified) character types are considered compatible</li></ul></dd></dl><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_other.html
operator_precedence	A										<section class="prog__container"><p>The following table lists the precedence and associativity of C operators. Operators are listed top to bottom, in descending precedence.<br></p><table class="wikitable"><tr><th style="text-align: left"> Precedence</th><th style="text-align: left"> Operator</th><th style="text-align: left"> Description</th><th style="text-align: left"> Associativity</th></tr><tr><th rowspan="6"> 1</th><td style="border-bottom-style: none"> <code>++</code> <code>--</code></td><td style="border-bottom-style: none"> Suffix/postfix increment and decrement</td><td rowspan="6" style="vertical-align: top"> Left-to-right</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>()</code></td><td style="border-bottom-style: none; border-top-style: none"> Function call</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>[]</code></td><td style="border-bottom-style: none; border-top-style: none"> Array subscripting</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>.</code></td><td style="border-bottom-style: none; border-top-style: none"> Structure and union member access</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>-></code></td><td style="border-bottom-style: none; border-top-style: none"> Structure and union member access through pointer</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>(<i>type</i>){<i>list</i>}</code></td><td style="border-bottom-style: none; border-top-style: none"> Compound literal</td></tr><tr><th rowspan="8"> 2</th><td style="border-bottom-style: none"> <code>++</code> <code>--</code></td><td style="border-bottom-style: none"> Prefix increment and decrement</td><td rowspan="8" style="vertical-align: top"> Right-to-left</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>+</code> <code>-</code></td><td style="border-bottom-style: none; border-top-style: none"> Unary plus and minus</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>!</code> <code>~</code></td><td style="border-bottom-style: none; border-top-style: none"> Logical NOT and bitwise NOT</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>(<i>type</i>)</code></td><td style="border-bottom-style: none; border-top-style: none"> Type cast</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>*</code></td><td style="border-bottom-style: none; border-top-style: none"> Indirection (dereference)</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>&amp;</code></td><td style="border-bottom-style: none; border-top-style: none"> Address-of</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>sizeof</code></td><td style="border-bottom-style: none; border-top-style: none"> Size-of</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>_Alignof</code></td><td style="border-bottom-style: none; border-top-style: none"> Alignment requirement</td></tr><tr><th> 3</th><td> <code>*</code> <code>/</code> <code>%</code></td><td> Multiplication, division, and remainder</td><td rowspan="11" style="vertical-align: top"> Left-to-right</td></tr><tr><th> 4</th><td> <code>+</code> <code>-</code></td><td> Addition and subtraction</td></tr><tr><th> 5</th><td> <code><<</code> <code>>></code></td><td> Bitwise left shift and right shift</td></tr><tr><th rowspan="2"> 6</th><td style="border-bottom-style: none"> <code><</code> <code><=</code></td><td style="border-bottom-style: none"> For relational operators < and ≤ respectively</td></tr><tr><td style="border-top-style: none"> <code>></code> <code>>=</code></td><td style="border-top-style: none"> For relational operators > and ≥ respectively</td></tr><tr><th> 7</th><td> <code>==</code> <code>!=</code></td><td> For relational = and ≠ respectively</td></tr><tr><th> 8</th><td> <code>&amp;</code></td><td> Bitwise AND</td></tr><tr><th> 9</th><td> <code>^</code></td><td> Bitwise XOR (exclusive or)</td></tr><tr><th> 10</th><td> <code>|</code></td><td> Bitwise OR (inclusive or)</td></tr><tr><th> 11</th><td> <code>&amp;&amp;</code></td><td> Logical AND</td></tr><tr><th> 12</th><td> <code>||</code></td><td> Logical OR</td></tr><tr><th> 13<sup class="reference" id="cite_ref-1">[note 1]</sup></th><td> <code>?:</code></td><td> Ternary conditional<sup class="reference" id="cite_ref-2">[note 2]</sup></td><td rowspan="6" style="vertical-align: top"> Right-to-Left</td></tr><tr><th rowspan="5"> 14</th><td style="border-bottom-style: none"> <code>=</code></td><td style="border-bottom-style: none"> Simple assignment</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>+=</code> <code>-=</code></td><td style="border-bottom-style: none; border-top-style: none"> Assignment by sum and difference</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code>*=</code> <code>/=</code> <code>%=</code></td><td style="border-bottom-style: none; border-top-style: none"> Assignment by product, quotient, and remainder</td></tr><tr><td style="border-bottom-style: none; border-top-style: none"> <code><<=</code> <code>>>=</code></td><td style="border-bottom-style: none; border-top-style: none"> Assignment by bitwise left shift and right shift</td></tr><tr><td style="border-top-style: none"> <code>&amp;=</code> <code>^=</code> <code>|=</code></td><td style="border-top-style: none"> Assignment by bitwise AND, XOR, and OR</td></tr><tr><th> 15</th><td> <code>,</code></td><td> Comma</td><td> Left-to-right</td></tr></table><ol class="references"><li id="cite_note-1">↑ Fictional precedence level, see Notes below</li><li id="cite_note-2">↑ The expression in the middle of the conditional operator (between <code>?</code> and <code>:</code>) is parsed as if parenthesized: its precedence relative to <code>?:</code> is ignored.</li></ol><p>When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression <code>*p++</code> is parsed as <code>*(p++)</code>, and not as <code>(*p)++</code>.</p><p>Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression <code>a=b=c</code> is parsed as <code>a=(b=c)</code>, and not as <code>(a=b)=c</code> because of right-to-left associativity.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/operator_precedence.html
pointer	A										<section class="prog__container"><p>Pointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers. Pointer may also refer to nothing, which is indicated by the special null pointer value.<br></p><h3><span class="prog__sub">Syntax</span></h3><p>In the declaration grammar of a pointer declaration, the <i>type-specifier</i> sequence designates the pointed-to type (which may be function or object type and may be incomplete), and the <i>declarator</i> has the form:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>*</code> <i>qualifiers</i>(optional) <i>declarator</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <i>declarator</i> may be the identifier that names the pointer being declared, including another pointer declarator (which would indicate a pointer to a pointer):</p><pre><code>float *p, **pp; // p is a pointer to float                // pp is a pointer to a pointer to floatint (*fp)(int); // fp is a pointer to function with type int(int)</code></pre><p>The <i>qualifiers</i> that appear between <code>*</code> and the identifier (or other nested declarator) qualify the type of the pointer that is being declared:</p><pre><code>int n;const int * pc = &amp;n; // pc is a non-const pointer to a const int// *pc = 2; // Error: n cannot be changed through p without a castpc = NULL; // OK: pc itself can be changed int * const cp = &amp;n; // cp is a const pointer to a non-const int*cp = 2; // OK to change n through cp// cp = NULL; // Error: cp itself cannot be changed int * const * pcp = &amp;cp; // non-const pointer to const pointer to non-const int</code></pre><h3><span class="prog__sub">Explanation</span></h3><p>Pointers are used for indirection, which is a ubiquitous programming technique; they can be used to implement pass-by-reference semantics, to access objects with dynamic storage duration, to implement "optional" types (using the null pointer value), aggregation relationship between structs, callbacks (using pointers to functions), generic interfaces (using pointers to void), and much more.</p><h4>Pointers to objects</h4><p>A pointer to object can be initialized with the result of the address-of operator applied to an expression of object type (which may be incomplete):</p><pre><code>int n;int *np = &amp;n; // pointer to intint *const *npp = &amp;np; // non-const pointer to const pointer to non-const int int a[2];int (*ap)[2] = &amp;a; // pointer to array of int struct S { int n; } s = {1}int* sp = &amp;s.n; // pointer to the int that is a member of s</code></pre><p>Pointers may appear as operands to the indirection operator (unary <code>*</code>), which returns the lvalue identifying the pointed-to object:</p><pre><code>int n;int* p = &amp;n;     // pointer p is pointing to n*p = 7;         // stores 7 in nprintf("%d\\n", *p); // lvalue-to-rvalue conversion reads the value from n</code></pre><p>Pointers to objects of struct and union type may also appear as the left-hand operands of the member access through pointer operator <code>-></code>.</p><p>Because of the array-to-pointer implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</p><pre><code>int a[2];int *p = a; // pointer to a[0] int b[3][3];int (*row)[3] = b; // pointer to b[0]</code></pre><p>Certain addition, subtraction, compound assignment, increment, and decrement operators are defined for pointers to elements of arrays.</p><p>Comparison operators are defined for pointers to objects in some situations: two pointers that represent the same address compare equal, two null pointer values compare equal, pointers to elements of the same array compare the same as the array indexes of those elements, and pointers to struct members compare in order of declaration of those members.</p><p>Many implementations also provide strict total ordering of pointers of random origin, e.g. if they are implemented as addresses within continuous ("flat") virtual address space. </p><h4>Pointers to functions</h4><p>A pointer to function can be initialized with an address of a function. Because of the function-to-pointer conversion, the address-of operator is optional:</p><pre><code>void f(int);void (*pf1)(int) = &amp;f;void (*pf2)(int) = f; // same as &amp;f</code></pre><p>Unlike functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, passed to other functions as arguments, etc.<br></p><p>A pointer to function can be used on the left-hand side of the function call operator; this invokes the pointed-to function:</p><pre><code>#include <stdio.h>int f(int n){    printf("%d\\n", n);    return n*n;}int main(void){    int (*p)(int) = f;    int x = p(7);}</code></pre><p>Dereferencing a function pointer yields the function designator for the pointed-to function:<br></p><pre><code>int f();int (*p)() = f;    // pointer p is pointing to f(*p)(); // function f invoked through the function designatorp();    // function f invoked directly through the pointer</code></pre><p>Equality comparison operators are defined for pointers to functions (they compare equal if pointing to the same function).</p><h4>Pointers to void</h4><p>Pointer to object of any type can be implicitly converted to pointer to <code>void</code> (optionally const or volatile-qualified), and vice versa:</p><pre><code>int n=1, *p=&amp;n;void* pv = p; // int* to void*int* p2 = pv; // void* to int*printf("%d\\n", *p2); // prints 1</code></pre><p>Pointers to void are used to pass objects of unknown type, which is common in generic interfaces: <code>malloc</code> returns <code>void*</code>, <code>qsort</code> expects a user-provided callback that accepts two <code>const void*</code> arguments. pthread_create expects a user-provided callback that accepts and returns <code>void*</code>. In all cases, it is the caller's responsibility to convert the pointer to the correct type before use.</p><h3><span class="prog__sub">Null pointers</span></h3><p>Pointers of every type have a special value known as <i>null pointer value</i> of that type. A pointer whose value is null does not point to an object or a function (dereferencing a null pointer is undefined behavior), and compares equal to all pointers of the same type whose value is also <i>null</i>.</p><p>To initialize a pointer to null or to assign the null value to an existing pointer, a null pointer constant (<code>NULL</code>, or any other integer constant with the value zero) may be used. static initialization also initializes pointers to their null values.</p><p>Null pointers can indicate the absence of an object or can be used to indicate other types of error conditions. In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, <code>free</code> does nothing when a null pointer is passed).</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/pointer.html
restrict	A										<section class="prog__container"><p>Each individual type in the C type system has several <i>qualified</i> versions of that type, corresponding to one, two, or all three of the const, volatile, and, for pointers to object types, <i>restrict</i> qualifiers. This page describes the effects of the <i>restrict</i> qualifier.</p><p>Only pointers to object types may be restrict-qualified (in particular, <code>int restrict *p</code> and <code>float (* restrict f9)(void)</code> are errors).</p><p>restrict semantics apply to lvalue expressions only; for example, a cast to restrict-qualified pointer or a function call returning a restrict-qualified pointer are not lvalues and the qualifier has no effect.<br></p><p>During each execution of a block in which a restricted pointer <code>P</code> is declared (typically each execution of a function body in which <code>P</code> is a function parameter), if some object that is accessible through <code>P</code> (directly or indirectly) is modified, by any means, then all accesses to that object (both reads and writes) in that block must occur through <code>P</code> (directly or indirectly), otherwise the behavior is undefined:</p><pre><code>void f(int n, int * restrict p, int * restrict q){    while(n-- > 0)        *p++ = *q++; // none of the objects modified through *p is the same                     // as any of the objects read through *q                     // compiler free to optimize, vectorize, page map, etc.}void g(void){    extern int d[100];    f(50, d + 50, d); // OK    f(50, d + 1, d); // Undefined behavior: d[1] is accessed through both p and q in f}</code></pre><p>If the object is never modified, it may be aliased and accessed through different restrict-qualified pointers (note that if the objects pointed to by aliased restrict-qualified pointers are, in turn, pointers, this aliasing can inhibit optimization).<br></p><p>Assignment from one restricted pointer to another is undefined behavior, except when assigning from a pointer to an object in some outer block to a pointer in some inner block (including using a restricted pointer argument when calling a function with a restricted pointer parameter) or when returning from a function (and otherwise when the block of the from-pointer ended):<br></p><pre><code>int* restrict p1 = &amp;a;int* restrict p2 = &amp;b;p1 = p2; // undefined behavior</code></pre><p>Restricted pointers can be assigned to unrestricted pointers freely, the optimization opportunities remain in place as long as the compiler is able to analyze the code:<br></p><pre><code>void f(int n, float * restrict r, float * restrict s) {   float * p = r, * q = s; // OK   while(n-- > 0) *p++ = *q++; // almost certainly optimized just like *r++ = *s++}</code></pre><p>If an array type is declared with the restrict type qualifier (through the use of typedef), the array type is not restrict-qualified, but its element type is:</p><pre><code>typedef int *array_t[10];restrict array_t a; // the type of a is int *restrict[10]</code></pre><p>In a function declaration, the keyword <code>restrict</code> may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed:</p><pre><code>void f(int m, int n, float a[restrict m][n], float b[restrict m][n]);void g12(int n, float (*p)[n]) {   f(10, n, p, p+10); // OK   f(20, n, p, p+10); // possibly undefined behavior (depending on what f does)}</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/restrict.html
return	A										<section class="prog__container"><p>Terminates current function and returns specified value to the caller function.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>return</code> <i>expression</i> <code>;</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>return</code> <code>;</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><ul>1) Evaluates the <i>expression</i>, terminates the current function and returns the result of the <i>expression</i> to the caller (the value returned becomes the value of the function call expression). Only valid if the function return type is not <code>void</code>.</ul><ul>2) Terminates the current function. Only valid if the function return type is <code>void</code>.</ul><p>If the type of the <i>expression</i> is different from the return type of the function, its value is converted as if by assignment to an object whose type is the return type of the function, except that overlap between object representations is permitted:</p><pre><code>struct s { double i; } f(void); // function returning struct sunion { struct { int f1; struct s f2; } u1;        struct { struct s f3; int f4; } u2; } g;struct s f(void){    return g.u1.f2;}int main(void){// g.u2.f3 = g.u1.f2; // undefined behavior (overlap in assignment)   g.u2.f3 = f();     // well-defined}</code></pre><p>If the return type is a real floating type, the result may be represented in greater range and precision than implied by the new type.</p><p>Reaching the end of a function other than <code>main</code> is equivalent to <code>return;</code>. Reaching the end of the main function is equivalent to <code>return 0;</code>. Reaching the end of any other value-returning function is undefined behavior, but only if the result of the function is used in an expression.</p><p>Executing the <code>return</code> statement in a no-return function is undefined behavior.</p><h3><span class="prog__sub">Keywords</span></h3><p><tt>return</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/return.html
scalar_initialization	A										<section class="prog__container"><p>When initializing an object of scalar type, the initializer must be a single expression</p><p>The initializer for a scalar (an object of integer type including booleans and enumerated types, floating type including complex and imaginary, and pointer type including pointer to function) must be a single expression, optionally enclosed in braces:<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>=</code> <i>expression</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>=</code> <code>{ </code> <i>expression</i> <code>} </code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>The expression is evaluated, and its value, after conversion as if by assignment to the type of the object, becomes the initial value of the object being initialized.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/scalar_initialization.html
scope	A										<section class="prog__container"><p>Each identifier that appears in a C program is <i>visible</i> (that is, may be used) only in some possibly discontiguous portion of the source code called its <i>scope</i>.</p><p>Within a scope, an identifier may designate more than one entity only if the entities are in different name spaces.</p><p>C has four kinds of scopes: <br></p><dl><dd><ul><li> block scope</li><li> file scope</li><li> function scope</li><li> function prototype scope</li></ul></dd></dl><h3><span class="prog__sub">Nested scopes</span></h3><p>If two different entities named by the same identifier are in scope at the same time, and they belong to the same name space, the scopes are nested (no other form of scope overlap is allowed), and the declaration that appears in the inner scope hides the declaration that appears in the outer scope:</p><pre><code>// The name space here is ordinary identifiers. int a;   // file scope of name a begins here void f(void){    int a = 1; // the block scope of the name a begins here; hides file-scope a    {      int a = 2;         // the scope of the inner a begins here, outer a is hidden      printf("%d\\n", a); // inner a is in scope, prints 2    }                    // the block scope of the inner a ends here    printf("%d\\n", a);   // the outer a is in scope, prints 1}                        // the scope of the outer a ends here void g(int a);   // name a has function prototype scope; hides file-scope a</code></pre><h3><span class="prog__sub">Block scope</span></h3><p>The scope of any identifier declared inside a compound statement, including function bodies, <span>or in any expression, declaration, or statement appearing in if, switch, for, while, or do-while statement</span> <span></span>, or within the parameter list of a function definition begins at the point of declaration and ends at the end of the block or statement in which it was declared.</p><pre><code>void f(int n)  // scope of the function parameter 'n' begins{         // the body of the function begins   ++n;   // 'n' is in scope and refers to the function parameter// int n = 2; // error: cannot redeclare identifier in the same scope   for(int n = 0; n<10; ++n) { // scope of loop-local 'n' begins       printf("%d\\n", n); // prints 0 1 2 3 4 5 6 7 8 9   } // scope of the loop-local 'n' ends     // the function parameter 'n' is back in scope   printf("%d\\n", n); // prints the value of the parameter} // scope of function parameter 'n' endsint a = n; // Error: name 'n' is not in scope</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>Until C99, selection and iteration statements did not establish their own block scopes (although if a compound statement was used in the statement, it had its usual block scope):<br></p><pre><code>enum {a, b};int different(void){    if (sizeof(enum {b, a}) != sizeof(int))        return a; // a == 1    return b; // b == 0 in C89, b == 1 in C99}</code></pre></td><td></td></tr></table><p>Block-scope variables have no linkage and automatic storage duration by default. Note that storage duration for non-VLA local variables begins when the block is entered, but until the declaration is seen, the variable is not in scope and cannot be accessed.</p><h3><span class="prog__sub">File scope</span></h3><p>The scope of any identifier declared outside of any block or parameter list begins at the point of declaration and ends at the end of the translation unit.<br></p><pre><code>int i; // scope of i beginsstatic int g(int a) { return a; } // scope of g begins (note, "a" has block scope)int main(void){    i = g(2); // i and g are in scope}</code></pre><p>File-scope identifiers have external linkage and static storage duration by default.</p><h3><span class="prog__sub">Function scope</span></h3><p>A label (and only a label) declared inside a function is in scope everywhere in that function, in all nested blocks, before and after its own declaration. Note: a label is declared implicitly, by using an otherwise unused identifier before the colon character before any statement.</p><pre><code>void f(){   {          goto label; // label in scope even though declared laterlabel:;   }   goto label; // label ignores block scope} void g(){    goto label; // error: label not in scope in g()}</code></pre><h3><span class="prog__sub">Function prototype scope</span></h3><p>The scope of a name introduced in the parameter list of a function declaration that is not a definition ends at the end of the function declarator.</p><pre><code>int f(int n,      int a[n]); // n is in scope and refers to the first parameter</code></pre><p>Note that if there are multiple or nested declarators in the declaration, the scope ends at the end of the nearest enclosing function declarator:<br></p><pre><code>void f ( // function name 'f' is at file scope long double f,            // the identifier 'f' is now in scope, file-scope 'f' is hidden char (**a)[10 * sizeof f] // 'f' refers to the first parameter, which is in scope); enum{ n = 3 };int (*(*g)(int n))[n]; // the scope of the function parameter 'n'                       // ends at the end of its function declarator                       // in the array declarator, global n is in scope// (this declares a pointer to function returning a pointer to an array of 3 int)</code></pre><h3><span class="prog__sub">Point of declaration</span></h3><p>The scope of structure, union, and enumeration tags begins immediately after the appearance of the tag in a type specifier that declares the tag.<br></p><pre><code>struct Node {   struct Node* next; // Node is in scope and refers to this struct};</code></pre><p>The scope of enumeration constant begins immediately after the appearance of its defining enumerator in an enumerator list.<br></p><pre><code>enum { x = 12 };{    enum { x = x + 1, // new x is not in scope until the comma, x is initialized to 13           y = x + 1  // the new enumerator x is now in scope, y is initialized to 14         };}</code></pre><p>The scope of any other identifier begins just after the end of its declarator and before the initializer, if any:<br></p><pre><code>int x = 2; // scope of the first 'x' begins{    int x[x]; // scope of the newly declared x begins after the declarator (x[x]).              // Within the declarator, the outer 'x' is still in scope.              // This declares a VLA array of 2 int.} unsigned char x = 32; // scope of the outer 'x' begins{    unsigned char x = x;            // scope of the inner 'x' begins before the initializer (= x)            // this does not initialize the inner 'x' with the value 32,             // this initializes the inner 'x' with its own, indeterminate, value} unsigned long factorial(unsigned long n)// declarator ends, 'factorial' is in scope from this point{   return n<2 ? 1 : n*factorial(n-1); // recursive call}</code></pre><p>As a special case, the scope of a type name that is not a declaration of an identifier is considered to begin just after the place within the type name where the identifier would appear were it not omitted.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/scope.html
sizeof	A										<section class="prog__container"><p>Queries size of the object or type<br></p><p>Used when actual size of the object must be known<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>sizeof(</code> <i>type</i> <code>)</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>sizeof</code> <i>expression</i> <code></code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>Both versions return a value of type <code>size_t</code>. </p><h3><span class="prog__sub">Explanation</span></h3><ul>1) Returns the size, in bytes, of the object representation of <i>type</i></ul><ul>2) Returns the size, in bytes, of the object representation of the type of <i>expression</i></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/sizeof.html
statements	A										<section class="prog__container"><p>Statements are fragments of the C program that are executed in sequence. The body of any function is a compound statement, which, in turn is a sequence of statements and declarations:<br></p><pre><code>int main(void){ // start of a compound statement    int n = 1; // declaration (not a statement)    n = n+1; // expression statement    printf("n = %d\\n", n); // expression statement    return 0; // return statement} // end of compound statement, end of function body</code></pre><p><br>There are five types of statements:<br></p><ul>1) compound statements</ul><ul>2) expression statements</ul><ul>3) selection statements</ul><ul>4) iteration statements</ul><ul>5) jump statements</ul><h3><span class="prog__sub">Labels</span></h3><p>Any statement can be <i>labeled</i>, by providing a name followed by a colon before the statement itself.</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>identifier</i> <code>:</code> <i>statement</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>case</code> <i>constant_expression</i> <code>:</code> <i>statement</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>default</code> <code>:</code> <i>statement</i></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) Target for goto.</ul><ul>2) Case label in a switch statement.</ul><ul>3) Default label in a switch statement.</ul><p>Any statement (but not a declaration) may be preceded by any number of <i>labels</i>, each of which declares <i>identifier</i> to be a label name, which must be unique within the enclosing function (in other words, label names have function scope).</p><p>Label declaration has no effect on its own, does not alter the flow of control, or modify the behavior of the statement that follows in any way.<br></p><h3><span class="prog__sub">Compound statements</span></h3><p>A compound statement, or <i>block</i>, is a brace-enclosed sequence of statements and declarations.</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>{</code> <i>statement</i> <code>|</code> <i>declaration</i>...(optional) <code>} </code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>The compound statement allows a set of declarations and statements to be grouped into one unit that can be used anywhere a single statement is expected (for example, in an if statement or an iteration statement):</p><pre><code>if (expr) // start of if-statement{ // start of block  int n = 1; // declaration  printf("%d\\n", n); // expression statement} // end of block, end of if-statement</code></pre><p>Each compound statement introduces its own block scope.</p><p>The initializers of the variables with automatic storage duration declared inside a block and the VLA declarators are executed when flow of control passes over these declarations in order, as if they were statements:</p><pre><code>int main(void){ // start of block  { // start of block       puts("hello"); // expression statement       int n = printf("abc\\n"); // declaration, prints "abc", stores 4 in n       int a[n*printf("1\\n")]; // declaration, prints "1", allocates 8*sizeof(int)       printf("%zu\\n", sizeof(a)); // expression statement  } // end of block, scope of n and a ends  int n = 7; // n can be reused}</code></pre><h3><span class="prog__sub">Expression statements</span></h3><p>An expression followed by a semicolon is a statement.<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <i>expression</i>(optional) <code>;</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>Most statements in a typical C program are expression statements, such as assignments or function calls.<br></p><p>An expression statement without an expression is called a <i>null statement</i>. It is often used to provide an empty body to a for or while loop. It can also be used to carry a label in the end of a compound statement or before a declaration:</p><pre><code>puts("hello"); // expression statementchar *s;while (*s++ != '\\0')    ; // null statement</code></pre><h3><span class="prog__sub">Selection statements</span></h3><p>The selection statements choose between one of several statements depending on the value of an expression.<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>if</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>if</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i> <code>else</code> <i>statement</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>switch</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) if statement</ul><ul>2) if statement with an else clause</ul><ul>3) switch statement</ul><h3><span class="prog__sub">Iteration statements</span></h3><p>The iteration statements repeatedly execute a statement.<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>while</code> <code>(</code> <i>expression</i> <code>)</code> <i>statement</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>do</code> <i>statement</i> <code>while</code> <code>(</code> <i>expression</i> <code>)</code> <code>;</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>for</code> <code>(</code> <i>init_clause</i> <code>;</code> <i>expression</i>(optional) <code>;</code> <i>expression</i>(optional) <code>)</code> <i>statement</i></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) while loop</ul><ul>2) do-while loop</ul><ul>3) for loop</ul><h3><span class="prog__sub">Jump statements</span></h3><p>The jump statements unconditionally transfer flow control.<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>break</code> <code>;</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>continue</code> <code>;</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>return</code> <i>expression</i>(optional) <code>;</code></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>goto</code> <i>identifier</i> <code>;</code></td><td> (4)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) break statement</ul><ul>2) continue statement</ul><ul>3) return statement with an optional expression</ul><ul>4) goto statement</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/statements.html
static_assert	A										<section class="prog__container"><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Static_assert</code> <code>(</code> <i>expression</i> <code>,</code> <i>message</i> <code>)</code></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any integer constant expression</td></tr><tr class="t-par"><td> <i>message</i></td><td> -</td><td>  any string literal</td></tr></table><p>This keyword is also available as convenience macro <tt>static_assert</tt>, available in the header <code><assert.h></code>.</p><h3><span class="prog__sub">Explanation</span></h3><p>The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display <i>message</i> as part of the error message (except that characters not in basic source character set aren't required to be displayed).</p><p>Otherwise, if <i>expression</i> does not equal zero, nothing happens; no code is emitted.</p><h3><span class="prog__sub">Keywords</span></h3><p><tt>_Static_assert</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/static_assert.html
static_storage_duration	A										<section class="prog__container"><p>An object whose identifier is declared without the storage-class specifier <code>_Thread_local</code>, and either with external or internal linkage or with the storage-class specifier <code>static</code>, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/static_storage_duration.html
storage_duration	A										<section class="prog__container"><p>Specify <i>storage duration</i> and <i>linkage</i> of objects and functions:</p><dl><dd><ul><li><code>auto</code> - automatic duration and no linkage</li><li><code>register</code> - automatic duration and no linkage; address of this variable cannot be taken</li><li><code>static</code> - static duration and internal linkage (unless at block scope)</li><li><code>extern</code> - static duration and external linkage (unless already declared internal)</li></ul></dd></dl><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><dl><dd><ul><li><code>_Thread_local</code> - thread storage duration</li></ul></dd></dl></td><td></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>Storage-class specifiers appear in declarations. At most one specifier may be used<span>, except that <code>_Thread_local</code> may be combined with <code>static</code> or <code>extern</code> to adjust linkage</span> <span></span>. The storage-class specifiers determine two independent properties of the names they declare: <i>storage duration</i> and <i>linkage</i>.</p><ul>1) The <code>auto</code> specifier is only allowed for objects declared at block scope (except function parameter lists). It indicates automatic storage duration and no linkage, which are the defaults for these kinds of declarations.</ul><ul>2) The <code>register</code> specifier is only allowed for objects declared at block scope, including function parameter lists. It indicates automatic storage duration and no linkage (which is the default for these kinds of declarations), but additionally hints the optimizer to store the value of this variable in a CPU register if possible. Regardless of whether this optimization takes place or not, variables declared <code>register</code> cannot be used as arguments to the address-of operator<span>, cannot use alignas</span> <span></span>, and <code>register</code> arrays are not convertible to pointers.</ul><ul>3) The <code>static</code> specifier specifies both static storage duration<span> (unless combined with <code>_Thread_local</code>)</span> <span></span> and internal linkage (unless used at block scope). It can be used with functions at file scope and with variables at both file and block scope, but not in function parameter lists.</ul><ul>4) The <code>extern</code> specifier specifies static storage duration<span> (unless combined with <code>_Thread_local</code>)</span> <span></span> and external linkage. It can be used with function and object declarations in both file and block scope (excluding function parameter lists). If <code>extern</code> appears on a redeclaration of an identifier that was already declared with internal linkage, the linkage remains internal. Otherwise (if the prior declaration was external, no-linkage, or is not in scope), the linkage is external.</ul><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><ul>5) <code>_Thread_local</code> indicates <i>thread storage duration</i>. It cannot be used with function declarations. If it is used on a declaration of an object, it must be present on every declaration of the same object. If it is used on a block-scope declaration, it must be combined with either <code>static</code> or <code>extern</code> to decide linkage.</ul></td><td></td></tr></table><p>If no storage-class specifier is provided, the defaults are:<br></p><dl><dd> <code>extern</code> for all functions</dd><dd> <code>extern</code> for objects at file scope</dd><dd> <code>auto</code> for objects at block scope</dd></dl><p>For any struct or union declared with a storage-class specifier, the storage duration (but not linkage) applies to their members, recursively.<br></p><p>Function declarations at block scope can use <code>extern</code> or none at all. Function declarations at file scope can use <code>extern</code> or <code>static</code>.</p><p>Function parameters cannot use any storage-class specifiers other than <code>register</code>. Note that <code>static</code> has special meaning in function parameters of array type.</p><h3><span class="prog__sub">Storage duration</span></h3><p>Every object has a property called <i>storage duration</i>, which limits the object lifetime. There are four kinds of storage duration in C:</p><dl><dd><ul><li><i><b>automatic</b></i> storage duration. The storage is allocated when the block in which the object was declared is entered and deallocated when it is exited by any means (goto, return, reaching the end). <span>One exception is the VLAs; their storage is allocated when the declaration is executed, not on block entry, and deallocated when the declaration goes out of scope, not than when the block is exited</span> <span></span>. If the block is entered recursively, a new allocation is performed for every recursion level. All function parameters and non-<code>static</code> block-scope objects have this storage duration, as well as compound literals used at block scope.</li></ul></dd></dl><dl><dd><ul><li><i><b>static</b></i> storage duration. The storage duration is the entire execution of the program, and the value stored in the object is initialized only once, prior to main function. All objects declared <code>static</code> and all objects with either internal or external linkage<span> that aren't declared <code>_Thread_local</code></span> <span></span> have this storage duration.</li></ul></dd></dl><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><dl><dd><ul><li><i><b>thread</b></i> storage duration. The storage duration is the entire execution of the thread in which it was created, and the value stored in the object is initialized when the thread is started. Each thread has its own, distinct, object. If the thread that executes the expression that accesses this object is not the thread that executed its initialization, the behavior is implementation-defined. All objects declared <code>_Thread_local</code> have this storage duration.</li></ul></dd></dl></td><td></td></tr></table><dl><dd><ul><li><i><b>allocated</b></i> storage duration. The storage is allocated and deallocated on request, using dynamic memory allocation functions.</li></ul></dd></dl><h4>Linkage</h4><p>Linkage refers to the ability of an identifier (variable or function) to be referred to in other scopes. If a variable or function with the same identifier is declared in several scopes, but cannot be referred to from all of them, then several instances of the variable are generated. The following linkages are recognized:<br></p><dl><dd><ul><li><i><b>no linkage</b></i>. The identifier can be referred to only from the scope it is in. All function parameters and all non-<code>extern</code> block-scope variables (including the ones declared <code>static</code>) have this linkage.</li></ul></dd></dl><dl><dd><ul><li><i><b>internal linkage</b></i>. The identifier can be referred to from all scopes in the current translation unit. All <code>static</code> identifiers (both functions and variables) have this linkage.</li></ul></dd></dl><dl><dd><ul><li><i><b>external linkage</b></i>. The identifier can be referred to from any other translation units in the entire program. All non-<code>static</code> functions, all <code>extern</code> variables (unless earlier declared <code>static</code>), and all file-scope non-<code>static</code> variables have this linkage.</li></ul></dd></dl><p>If the same identifier appears with both internal and external linkage in the same translation unit, the behavior is undefined. This is possible when tentative definitions are used.</p><h4>Linkage and libraries</h4><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: should this be a separate top-level entry in c/language under Miscellaneous? <br></td></tr></table><p>Declarations with external linkage are commonly made available in header files so that all  translation units that #include the file may refer to the same identifier that are defined elsewhere.</p><p>Any declaration with internal linkage that appears in a header file results in a separate and distinct object in each translation unit that includes that file.<br></p><p>Library interface:<br></p><pre><code>// flib.h#ifndef FLIB_H#define FLIB_Hvoid f(void);              // function declaration with external linkageextern int state;          // variable declaration with external linkagestatic const int size = 5; // definition of a read-only variable with internal linkageenum { MAX = 10 };         // constant definitioninline int sum (int a, int b) { return a+b; } // inline function definition#endif // FLIB_H</code></pre><p>Library implementation:<br></p><pre><code>// flib.c#include "flib.h"static void local_f(int s) {}  // definition with internal linkage (only used in this file)static int local_state;        // definition with internal linkage (only used in this file) int state;                     // definition with external linkage (used by main.c)void f(void) {local_f(state);} // definition with external linkage (used by main.c)</code></pre><p>Application code:<br></p><pre><code>// main.c #include "flib.h"int main(void){    int x[MAX] = {size}; // uses the constant and the read-only variable    state = 7;           // modifies state in flib.c    f();                 // calls f() in flib.c}</code></pre><h3><span class="prog__sub">Keywords</span></h3><p><tt>auto</tt>,<tt>register</tt>,<tt>static</tt>,<tt>extern</tt>,<tt>_Thread_local</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/storage_duration.html
string_literal	A										<section class="prog__container"><p>Constructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>"</code> <i>s-char-sequence</i> <code>"</code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>u8</code> <code>"</code> <i>s-char-sequence</i> <code>"</code></td><td> (2)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>u</code> <code>"</code> <i>s-char-sequence</i> <code>"</code></td><td> (3)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>U</code> <code>"</code> <i>s-char-sequence</i> <code>"</code></td><td> (4)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>L</code> <code>"</code> <i>s-char-sequence</i> <code>"</code></td><td> (5)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where<br></p><table class="t-par-begin"><tr class="t-par"><td> <i>s-char-sequence</i></td><td> -</td><td>  zero or more characters, each of which is either a multibyte character from the source character set (excluding (<code>"</code>), <code>\</code>, and newline), or character escape, hex escape, octal escape<span>, or unified character name</span> <span></span> as defined in escape sequences.<p><br></p></td></tr></table><ul>1) <i>character string literal</i>: The type of the literal is <code>char[]</code>, each character in the array is initialized from the next character in <i>s-char-sequence</i> using the execution character set.</ul><ul>2) <i>UTF-8 string literal</i>: The type of the literal is <code>char[]</code>, each character in the array is initialized from the next multibyte character in <i>s-char-sequence</i> using UTF-8 encoding.</ul><ul>3) 16-bit wide string literal: The type of the literal is <code>char16_t[]</code>, each char16_t element in the array is initialized as if by executing <code>mbrtoc16</code> in implementation-defined locale.</ul><ul>4) 32-bit wide string literal: The type of the literal is <code>char32_t[]</code>, each char32_t element in the array is initialized as if by executing <code>mbrtoc32</code> in implementation-defined locale.</ul><ul>5) wide string literal: The type of the literal is <code>wchar_t[]</code>, each wchar_t element in the array is initialized as if by executing <code>mbstowcs</code> in implementation-defined locale.</ul><h3><span class="prog__sub">Explanation</span></h3><p>First, at translation phase 6 (after macro expansion), the adjacent string literals (that is, string literals separated by whitespace only) are concatenated.</p><table class="t-rev-begin"><tr class="t-rev t-until-c99"><td><p>Only two narrow or two wide string literals may be concatenated.<br></p></td><td>(until C99)</td></tr><tr class="t-rev t-since-c99"><td><p>If one literal is unprefixed, the resulting string literal has the width/encoding specified by the prefixed literal. If the two string literals have different encoding prefixes, concatenation is implementation-defined. <br></p><pre><code>L"Δx = %" PRId16 // at phase 4, PRId16 expands to "d"                 // at phase 6, L"Δx = %" and "d" form L"Δx = %d"</code></pre></td><td></td></tr></table><p>Secondly, at translation phase 7, a terminating null character is added to each string literal, and then each literal initializes an unnamed array with static storage duration and length just enough to contain the contents of the string literal plus one the null terminator.</p><pre><code>char* p = "\\x12" "3"; // creates a static char[3] array holding {'\\x12', '3', '\\0'}                       // sets p to point to the first element of the array</code></pre><p>String literals are <b>not modifiable</b> (and in fact may be placed in read-only memory such as <code>.rodata</code>). If a program attempts to modify the static array formed by a string literal, the behavior is undefined.</p><pre><code>char* p = "Hello";p[1] = 'M'; // Undefined behavior</code></pre><p>It is neither required nor forbidden for identical string literals to refer to the same location in memory. Moreover, overlapping string literals or string literals that are substrings of other string literals may be combined.<br></p><pre><code>"def" == 3+"abcdef"; // may be 1 or 0, implementation-defined</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/string_literal.html
struct	A										<section class="prog__container"><p>A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps).<br></p><p>The type specifier for a struct is identical to the  <code>union</code> type specifier except for the keyword used:</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>struct</code> <i>name</i>(optional) <code>{ </code> <i>struct-declaration-list</i> <code>} </code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>struct</code> <i>name</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) Struct definition: introduces the new type struct <i>name</i> and defines its meaning</ul><ul>2) If used on a line of its own, as in <code>struct</code> <i>name</i> <code>;</code>, <i>declares</i> but doesn't define the struct <code>name</code> (see forward declaration below). In other contexts, names the previously-declared struct.</ul><table class="t-par-begin"><tr class="t-par"><td> <i>name</i></td><td> -</td><td>  the name of the struct that's being defined</td></tr><tr class="t-par"><td> <i>struct-declaration-list</i></td><td> -</td><td>  any number of variable declarations, bit field declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed (except for the flexible array member described below)</td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>Within a struct object, addresses of its elements (and the addresses of the bit field allocation units) increase in order in which the members were defined. A pointer to a struct can be cast to a pointer to its first member (or, if the member is a bit field, to its allocation unit). Likewise, a pointer to the first member of a struct can be cast to a pointer to the enclosing struct. There may be unnamed padding between any two members of a struct or after the last member, but not before the first member. The size of a struct is at least as large as the sum of the sizes of its members.<br></p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>If a struct defines at least one named member, it is allowed to additionally declare its last member with incomplete array type. When an element of the flexible array member is accessed (in an expression that uses operator <code>.</code> or <code>-></code> with the flexible array member's name as the right-hand-side operand), then the struct behaves as if the array member had the longest size fitting in the memory allocated for this object. If no additional storage was allocated, it behaves as if an array with 1 element, except that the behavior is undefined if that element is accessed or a pointer one past that element is produced. Initialization, <code>sizeof</code>, and the assignment operator ignore the flexible array member. Structures with flexible array members (or unions whose last member is a structure with flexible array member) cannot appear as array elements or as members of other structures.</p><pre><code>struct s { int n; double d[]; }; // s.d is a flexible array member      struct s t1 = { 0 };         // OK, d is as if double d[1], but UB to access    struct s t2 = { 1, { 4.2 } }; // error: initialization ignores flexible array     // if sizeof (double) == 8    struct s *s1 = malloc(sizeof (struct s) + 64); // as if d was double d[8]    struct s *s2 = malloc(sizeof (struct s) + 46); // as if d was double d[5]     s1 = malloc(sizeof (struct s) + 10); // now as if d was double d[1]    s2 = malloc(sizeof (struct s) + 6);  // same, but UB to access    double *dp = &amp;(s1->d[0]);    //  OK    *dp = 42;                    //  OK    dp = &amp;(s2->d[0]);            //  OK    *dp = 42;                    //  undefined behavior     *s1 = *s2; // only copies s.n, not any element of s.d               // except those caught in sizeof (struct s)</code></pre></td><td></td></tr></table><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p>Similar to union, an unnamed member of a struct whose type is a struct without <i>name</i> is known as <i>anonymous struct</i>. Every member of an anonymous struct is considered to be a member of the enclosing struct or union. This applies recursively if the enclosing struct or union is also anonymous.</p><pre><code>struct v {   union { // anonymous union      struct { int i, j; }; // anonymous structure      struct { long k, l; } w;   };   int m;} v1; v1.i = 2;   // validv1.k = 3;   // invalid: inner structure is not anonymousv1.w.k = 5; // valid</code></pre><p>Similar to union, the behavior of the program is undefined if struct is defined without any named members (including those obtained via anonymous nested structs or unions).<br></p></td><td></td></tr></table><h3><span class="prog__sub">Forward declaration</span></h3><p>A declaration of the following form<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>struct</code> <i>name</i> <code>;</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>hides any previously declared meaning for the name <i>name</i> in the tag name space and declares <i>name</i> as a new struct name in current scope, which will be defined later. Until the definition appears, this struct name has incomplete type.</p><p>This allows structs that refer to each other:<br></p><pre><code>struct y;struct x { struct y *p; /* ... */ };struct y { struct x *q; /* ... */ };</code></pre><p>Note that a new struct name may also be introduced just by using a struct tag within another declaration, but if a previously declared struct with the same name exists in the tag name space, the tag would refer to that name</p><pre><code>struct s* p = NULL; // tag naming an unknown struct declares itstruct s { int a; }; // definition for the struct pointed to by pvoid g(void){    struct s; // forward declaration of a new, local struct s              // this hides global struct s until the end of this block    struct s *p;  // pointer to local struct s                  // without the forward declaration above,                  // this would point at the file-scope s    struct s { char* p; }; // definitions of the local struct s}</code></pre><p><br></p><h3><span class="prog__sub">Keywords</span></h3><p><tt>struct</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/struct.html
struct_initialization	A										<section class="prog__container"><p>When initializing an object of struct or union type, the initializer must be a non-empty, brace-enclosed, comma-separated list of initializers for the members:</p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>=</code> <code>{ </code> <i>expression</i> <code>,</code> <code>...</code> <code>} </code></td><td class="t-sdsc-nopad"></td><td> (until C99)</td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>=</code> <code>{ </code> <i>designator</i>(optional) <i>expression</i> <code>,</code> <code>...</code> <code>} </code></td><td class="t-sdsc-nopad"></td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where the <i>designator</i> is a sequence (whitespace-separated or adjacent) of individual member designators of the form <code>.</code> <i>member</i> and array designators of the form <code>[</code> <i>index</i> <code>]</code>.</p><p>All members that are not initialized explicitly are initialized implicitly the same way as objects that have static storage duration.</p><h3><span class="prog__sub">Explanation</span></h3><p>When initializing a union, the initializer list must have only one member, which initializes the first member of the union<span> unless a designated initializer is used</span> <span></span>.</p><pre><code>union { int x; char c[4]; }  u = {1},           // makes u.x active with value 1 u2 = { .c={'\\1'} }; // makes u2.c active with value {'\\1','\\0','\\0','\\0'}</code></pre><p>When initializing a struct, the first initializer in the list initializes the first declared member<span> (unless a designator is specified)</span> <span></span>, and all subsequent initializers <span>without designators </span> <span></span>initialize the struct members declared after the one initialized by the previous expression.</p><pre><code>struct point {double x,y,z;} p = {1.2, 1.3}; // p.x=1.2, p.y=1.3, p.z=0.0div_t answer = {.quot = 2, .rem = -1 };      // order of elements in div_t may vary</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>A designator causes the following initializer to initialize the struct member described by the designator. Initialization then continues forward in order of declaration, beginning with the next element declared after the one described by the designator.<br></p><pre><code>struct {int sec,min,hour,day,mon,year;} z   = {.day=31,12,2014,.sec=30,15,17}; // initializes z to {30,15,17,31,12,2014}</code></pre></td><td></td></tr></table><p>It's an error to provide more initializers than members.<br></p><h3><span class="prog__sub">Nested initialization</span></h3><p>If the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:<br></p><p>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new <i>current object</i>. The members of the current object are initialized in their natural order<span>, unless designators are used</span> <span></span>: array elements in subscript order, struct members in declaration order, only the first declared member of any union. The subobjects within the current object that aren't explicitly initialized by the closing brace are implicitly initialized.</p><pre><code>struct example {    struct addr_t {       uint32_t port;    } addr;    union {       uint8_t a8[4];       uint16_t a16[2];    } in_u;};struct example ex = { // start of initializer list for struct example                     { // start of initializer list for ex.addr                        80 // initialized struct's only member                     }, // end of initializer list for ex.addr                     { // start of initializer-list for ex.in_u                        {127,0,0,1} // initializes first element of the union                     } };</code></pre><p>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:<br></p><pre><code>struct example ex = {80, 127, 0, 0, 1}; // 80 initializes ex.addr.port                                        // 127 initializes ex.in_u.a8[0]                                        // 0 initializes ex.in_u.a8[1]                                        // 0 initializes ex.in_u.a8[2]                                        // 1 initializes ex.in_u.a8[3]</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>When designators are nested, the designators for the members follow the designators for the enclosing structs/unions/arrays. Within any nested bracketed initializer list, the outermost designator refers to the <i>current object</i> and selects the subobject to be initialized within the <i>current object</i> only.</p><pre><code>struct example ex2 = { // current object is ex2, designators are for members of example                       .in_u.a8[0]=127, 0, 0, 1, .addr=80}; struct example ex3 = {80, .in_u={ // changes current object to the union ex.in_u                           127,                           .a8[2]=1 // this designator refers to the member of in_u                      } };</code></pre><p>If any subobject is explicitly initialized twice (which may happen when designators are used), the initializer that appears later in the list is the one used (the earlier initializer may not be evaluated):<br></p><pre><code>struct {int n;} s = {printf("a\\n"), // this may be printed or skipped                     .n=printf("b\\n")}; // always printed</code></pre><p>Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list:<br></p>Run this code<pre><code>#include <stdio.h>typedef struct { int k; int l; int a[2]; } T;typedef struct { int i;  T t; } S;T x = {.l = 43, .k = 42, .a[1] = 19, .a[0] = 18 }; // x initialized to {42, 43, {18, 19} }int main(void){    S l = { 1,          // initializes l.i to 1           .t = x,      // initializes l.t to {42, 43, {18, 19} }           .t.l = 41,   // changes l.t to {42, 41, {18, 19} }           .t.a[1] = 17 // changes l.t to {42, 41, {18, 17} }          };    printf("l.t.k is %d\\n", l.t.k); // .t = x sets l.t.k to 42 explicitly                                    // .t.l = 42 would zero out l.t.k implicitly}</code></pre><p>Output:<br></p><pre><code>l.t.k is 42</code></pre><p>However, when an initializer begins with a left open brace, its <i>current object</i> is fully re-initialized and any prior explicit initializers for any of its subobjects are ignored:</p><pre><code>struct fred { char s[4]; int n; };struct fred x[ ] = { { { "abc" }, 1 }, // inits x[0] to { {'a','b','c','\\0'}, 1 }                      [0].s[0] = 'q'   // changes x[0] to { {'q','b','c','\\0'}, 1 }                   };struct fred y[ ] = { { { "abc" }, 1 }, // inits y[0] to { {'a','b','c','\\0'}, 1 }                     [0] = { // current object is now the entire y[0] object                             .s[0] = 'q'                             } // replaces y[0] with { {'q','\\0','\\0','\\0'}, 0 }                    };</code></pre></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/struct_initialization.html
switch	A										<section class="prog__container"><p>Executes code according to the value of an integral argument.<br></p><p>Used where one or several out of many branches of code need to be executed according to an integral value.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>switch (</code> <i>expression</i> <code>)</code> <i>statement</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any expression of integer type (char, signed or unsigned integer, or enumeration)</td></tr><tr class="t-par"><td> <i>statement</i></td><td> -</td><td>  any statement (typically a compound statement). <code>case:</code> and <code>default:</code> labels are permitted in <i>statement</i>, and <code>break;</code> statement has special meaning.</td></tr></table><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>case</code> <i>constant_expression</i> <code>:</code> <i>statement</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>default</code> <code>:</code> <i>statement</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>constant_expression</i></td><td> -</td><td>  any integer constant expression</td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The body of a switch statement may have an arbitrary number of <code>case:</code> labels, as long as the values of all <i>constant_expressions</i> are unique (after conversion to the promoted type of <i>expression</i>). At most one <code>default:</code> label may be present (although nested switch statements may use their own <code>default:</code> labels or have <code>case:</code> labels whose constants are identical to the ones used in the enclosing switch).</p><p>If <i>expression</i> evaluates to the value that is equal to the value of one of <i>constant_expression</i>s after conversion to the promoted type of <i>expression</i>, then control is transferred to the statement that is labeled with that <i>constant_expression</i>.</p><p>If <i>expression</i> evaluates to a value that doesn't match any of the <code>case:</code> labels, and the <code>default:</code> label is present, control is transferred to the statement labeled with the <code>default:</code> label.</p><p>If <i>expression</i> evaluates to a value that doesn't match any of the <code>case:</code> labels, and the <code>default:</code> label is not present, none of the switch body is executed.</p><p>The break statement, when encountered anywhere in <i>statement</i>, exits the switch statement:</p><pre><code>switch(1) {    case 1 : puts("1"); // prints "1",    case 2 : puts("2"); // then prints "2" ("fall-through")}</code></pre><pre><code>switch(1) {    case 1 : puts("1"); // prints "1"             break;     // and exits the switch    case 2 : puts("2");             break;}</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>As with all other selection and iteration statements, the switch statement establishes block scope: any identifier introduced in the <i>expression</i> goes out of scope after the <i>statement</i>.</p><p>If a VLA or another identifier with variably-modified type has a <code>case:</code> or a <code>default:</code> label within its scope, the entire switch statement must be in its scope (in other words, a VLA must be declared either before the entire switch or after the last label):</p><pre><code>switch (expr){    int i = 4; // not a VLA; OK to declare here    f(i); // never called//  int a[i]; // error: VLA cannot be declared here  case 0:    i = 17;default:;    int a[i]; // OK to declare VLA here    printf("%d\\n", i); // prints 17 if expr == 0, prints indeterminate value otherwise}</code></pre></td><td></td></tr></table><p><br></p><h3><span class="prog__sub">Keywords</span></h3><p><tt>switch</tt>,<tt>case</tt>,<tt>default</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/switch.html
thread_storage_duration	A										<section class="prog__container"><p>An object whose identifier is declared with the storage-class specifier <code>_Thread_local</code>  has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/thread_storage_duration.html
translation_phases	A										<section class="prog__container"><p>The C source file is processed by the compiler <i>as if</i> the following phases take place, in this exact order. Actual implementation may combine these actions or process them differently as long as the behavior is the same.</p><h3><span class="prog__sub">Phase 1</span></h3><ul>1) The individual bytes of the source code file (which is generally a text file in some multibyte encoding such as UTF-8) are mapped, in implementation defined manner, to the characters of the <i>source character set</i>. In particular, OS-dependent end-of-line indicators are replaced by newline characters.<dl><dd>The <i>source character set</i> is a multibyte character set which includes the <i>basic source character set</i> as a single-byte subset, consisting of the following 96 characters:</dd></dl></ul><ul>a) 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)</ul><ul>b) 10 digit characters from <code>'0'</code> to <code>'9'</code></ul><ul>c) 52 letters from <code>'a'</code> to <code>'z'</code> and from <code>'A'</code> to <code>'Z'</code></ul><ul>d) 29 punctuation characters: <code>_ { } [ ] # ( ) < > % : ; . ? * + - / ^ &amp; | ~ ! = , \ " ’</code></ul><ul>2) Trigraph sequences are replaced by corresponding single-character representations.</ul><h3><span class="prog__sub">Phase 2</span></h3><ul>1) Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation: a line ending in two backslashes followed by an empty line does not combine three lines into one. </ul><ul>2) If a non-empty source file does not end with a newline character after this step (whether it had no newline originally, or it ended with a backslash), the behavior is undefined.</ul><h3><span class="prog__sub">Phase 3</span></h3><ul>1) The source file is decomposed into comments, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and <i>preprocessing tokens</i>, which are the following</ul><ul>a) header names: <code><stdio.h></code> or <code>"myfile.h"</code></ul><ul>b) identifiers</ul><ul>c) numbers</ul><ul>d) character constants and string literals</ul><ul>e) operators and punctuators (including alternative tokens), such as <code>+</code>, <code><<=</code>, <code><%</code>, <code>##</code>, or <code>and</code>.</ul><ul>f) individual non-whitespace characters that do not fit in any other category</ul><ul>2) Each comment is replaced by one space character</ul><ul>3) Newlines are kept, and it's implementation-defined whether non-newline whitespace sequences may be collapsed into single space characters.</ul><h3><span class="prog__sub">Phase 4</span></h3><ul>1) Preprocessor is executed.</ul><ul>2) Each file introduced with the #include directive goes through phases 1 through 4, recursively.</ul><ul>3) At the end of this phase, all preprocessor directives are removed from the source.</ul><h3><span class="prog__sub">Phase 5</span></h3><ul>1) All characters and escape sequences in character constants and string literals are converted from <i>source character set</i> to <i>execution character set</i> (which may be a multibyte character set such as UTF-8, as long as all 96 characters from the <i>basic source character set</i> listed in phase 1 have single-byte representations). If the character specified by an escape sequence isn't a member of the execution character set, the result is implementation-defined, but is guaranteed to not be a null (wide) character.</ul><p>Note: the conversion performed at this stage can be controlled by command line options in some implementations: gcc and clang use <code>-finput-charset</code> to specify the encoding of the source character set, <code>-fexec-charset</code> and <code>-fwide-exec-charset</code> to specify the encodings of the execution character set in the string and character literals <span>that don't have an encoding prefix</span> <span></span>.</p><h3><span class="prog__sub">Phase 6</span></h3><p>Adjacent string literals are concatenated.</p><h3><span class="prog__sub">Phase 7</span></h3><p>Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a translation unit.<br></p><h3><span class="prog__sub">Phase 8</span></h3><p>Linking takes place: Translation units and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment (the OS).<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/translation_phases.html
type	A										<section class="prog__container"><p><small>(See also arithmetic types for the details on most built-in types and  the list of type-related utilities that are provided by the C library)</small></p><p>Objects, functions, and expressions have a property called <i>type</i>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</p><h3><span class="prog__sub">Type classification</span></h3><p>The C type system consists of the following types:<br></p><ul><li>the type <code>void</code></li><li>basic types</li></ul><dl><dd><ul><li>the type <code>char</code></li><li>signed integer types</li></ul><dl><dd><ul><li>standard: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> <span></span> <span></span></li><li>extended: implementation defined, e.g. <code>__int128</code></li></ul></dd></dl><ul><li>unsigned integer types</li></ul><dl><dd><ul><li>standard: <code>_Bool</code> <span></span> <span></span>, <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code> <span></span> <span></span></li><li>extended: implementation-defined, e.g. <code>__uint128</code></li></ul></dd></dl><ul><li>floating types</li></ul><dl><dd><ul><li>real floating types: <code>float</code>, <code>double</code>, <code>long double</code></li><li>complex types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code></li><li>imaginary types: <code>float _Imaginary</code>, <code>double _Imaginary</code>, <code>long double _Imaginary</code></li></ul></dd></dl></dd></dl><ul><li> enumerated types</li></ul><ul><li> derived types</li></ul><dl><dd><ul><li> array types</li><li> structure types</li><li> union types</li><li> function types</li><li> pointer types</li><li> atomic types</li></ul></dd></dl><p>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers (where allowed by the qualifier's semantics).</p><h4>Type groups</h4><ul><li> <i>object types</i>: all types that aren't function types</li><li> <i>character types</i>: <code>char</code>, <code>signed char</code>, <code>unsigned char</code></li><li> <i>integer types</i>: <code>char</code>, signed integer types, unsigned integer types, enumerated types</li><li> <i>real types</i>: integer types and real floating types </li><li> arithmetic types: integer types and floating types</li><li> <i>scalar types</i>: arithmetic types and pointer types</li><li> <i>aggregate types</i>: array types and structure types</li><li> <i>derived declarator types</i>: array types, function types, and pointer types </li></ul><h3><span class="prog__sub">Compatible types</span></h3><p>In a C program, the declarations referring to the same object or function in <i>different translation units</i> do not have to use the same type. They only have to use sufficiently similar types, formally known as <i>compatible types</i>. Same applies to function calls and lvalue accesses; argument types must be <i>compatible</i> with parameter types and lvalue expression type must be <i>compatible</i> with the object type that is accessed.</p><p>The types <code>T</code> and <code>U</code> are compatible, if</p><ul><li> they are the same type (same name or aliases introduced by a typedef)</li><li> they are identically cvr-qualified versions of compatible unqualified types</li><li> they are pointer types and are pointing to compatible types</li><li> they are array types, and</li></ul><dl><dd><ul><li> their element types are compatible, and</li><li> if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. <span>VLA is compatible with any array of compatible element type.</span> <span></span></li></ul></dd></dl><ul><li> they are both structure/union/enumeration types, and</li></ul><dl><dd><ul><li>if one is declared with a tag, the other must also be declared with the same tag.</li><li> if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.</li><li> additionally, if they are enumerations, corresponding members must also have the same values.</li><li> additionally, if they are structures or unions,</li></ul><dl><dd><ul><li> Corresponding members must be declared in the same order (structures only)</li><li> Corresponding bit fields must have the same widths.</li></ul></dd></dl></dd></dl><ul><li> one is an enumerated type and the other is that enumeration's underlying type</li><li> they are function types, and</li></ul><dl><dd><ul><li> their return types are compatible</li><li> they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, the corresponding parameters have compatible types</li><li> one is an old-style (parameter-less) definition, the other has a parameter list, the parameter list does not use an ellipsis and each parameter is compatible (after function parameter type adjustment) with the corresponding old-style parameter after default argument promotions</li><li> one is an old-style (parameter-less) declaration, the other has a parameter list, the parameter list does not use an ellipsis, and all parameters (after function parameter type adjustment) are unaffected by default argument promotions</li></ul></dd></dl><p>The type <code>char</code> is not compatible with <code>signed char</code> and not compatible with <code>unsigned char</code>.</p><p>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.<br></p><pre><code>// Translation Unit 1struct S {int a;};extern struct S *x;  // compatible with TU2's x, but not with TU3's x// Translation Unit 2struct S;extern struct S *x; // compatible with both x's// Translation Unit 3struct S {float a;};extern struct S *x; // compatible with TU2's x, but not with TU1's x // the behavior is undefined</code></pre><pre><code>// Translation Unit 1#include <stdio.h>struct s {int i;}; // compatible with TU3's s, but not TU2'sextern struct s x = {0}; // compatible with TU3's xextern void f(void); // compatible with TU2's fint main(){   f();   return x.i;}// Translation Unit 2struct s {float f;}; // compatible with TU4's s, but not TU1's sextern struct s y = {3.14}; // compatible with TU4's yvoid f() // compatible with TU1's f{   return;}// Translation Unit 3struct s {int i;}; // compatible with TU1's s, but not TU2's sextern struct s x; // compatible with TU1's x// Translation Unit 4struct s {float f;}; // compatible with TU2's s, but not TU1's sextern struct s y; // compatible iwth TU2's y // the behavior is well-defined: only multiple declarations// of objects and functions must have compatible types, not the types themselves</code></pre><p>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.<br></p><h3><span class="prog__sub">Composite types</span></h3><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete </td></tr></table><h3><span class="prog__sub">Incomplete types</span></h3><p>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.<br></p><p>The following types are incomplete:<br></p><ul><li> the type <code>void</code>. This type cannot be completed.</li><li> array type of unknown size. It can be completed by a later declaration that specifies the size.</li><li> structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.</li></ul><h3><span class="prog__sub">Type names</span></h3><p>A type may have to be named in context other than the declaration. In these situations, <i>type name</i> is used, which is, grammatically, exactly the same as a list of <i>type-specifiers</i> and <i>type-qualifiers</i>, followed by the <i>declarator</i> (see declarations) as would be used to declare a single object or function of this type, except that the identifier is omitted:</p><pre><code>int n; // declaration of an intsizeof(int); // use of type name int *a[3]; // declaration of an array of 3 pointers to intsizeof(int *[3]); // use of type name int (*p)[3]; // declaration of a pointer to array of 3 intsizeof(int (*)[3]); // use of type name int (*a)[*] // declaration of pointer to VLA (in a function parameter)sizeof(int (*)[*]) // use of type name (in a function parameter) int *f(void); // declaration of functionsizeof(int *(void)); // use of type name int (*p)(void); // declaration of pointer to functionsizeof(int (*)(void)); // use of type name int (*const a[])(unsigned int, ...) = {0}; // array of pointers to functionssizeof(int (*const [])(unsigned int, ...)); // use of type name</code></pre><p>Except the redundant parentheses around the identifier are meaningful in a type-name and represent "function with no parameter specification":<br></p><pre><code>int (n); // declares n of type intsizeof(int ()); // uses type "function returning int"</code></pre><p>Type names are used in the following situations:<br></p><ul><li> cast</li><li> sizeof</li></ul><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><ul><li> compound literal</li></ul></td><td></td></tr><tr class="t-rev t-since-c11"><td><ul><li> generic selection</li><li> alignof</li><li> alignas</li><li> _Atomic (when used as a type specifier)</li></ul></td><td></td></tr></table><p><br>A type name may introduce a new type: <br></p><pre><code>void* p = (void*)(struct X {int i;} *)0;// type name "struct X {int i;}*" used in the cast expression// introduces the new type "struct X"struct X x = {1}; // struct X is now in scope</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/type.html
typedef	A										<section class="prog__container"><p>The <i>typedef declaration</i> provides a way to declare an identifier as a type alias, to be used to replace a possibly complex type name</p><p>The keyword <code>typedef</code> is used in a declaration, in the grammatical position of a storage-class specifier, except that it does not affect storage or linkage:</p><pre><code>typedef int int_t; // declares int_t to be an alias for the type inttypedef char char_t, *char_p, (*fp)(void); // declares char_t to be an alias for char                                           // char_p to be an alias for char*                                           // fp to be an alias for char(*)(void)</code></pre><h3><span class="prog__sub">Explanation</span></h3><p>If a declaration uses <code>typedef</code> as storage-class specifier, every declarator in it defines an identifier as an alias to the type specified. Since only one storage-class specifier is permitted in a declaration, typedef declaration cannot be static or extern.</p><p>typedef declaration does not introduce a distinct type, it only establishes a synonym for an existing type, thus typedef names are compatible with the types they alias. Typedef names share the name space with ordinary identifiers such as enumerators, variables and function.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>A typedef for a VLA can only appear at block scope. The length of the array is evaluated each time the flow of control passes over the typedef declaration, as opposed to the declaration of the array itself:<br></p><pre><code>void copyt(int n){    typedef int B[n]; // B is a VLA, its size is n, evaluated now    n += 1;    B a; // size of a is n from before +=1    int b[n]; // a and b are different sizes    for (int i = 1; i < n; i++)        a[i-1] = b[i];}</code></pre></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/typedef.html
types	A										<section class="prog__container"><p><small>(See also arithmetic types for the details on most built-in types and  the list of type-related utilities that are provided by the C library)</small></p><p>Objects, functions, and expressions have a property called <i>type</i>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</p><h3><span class="prog__sub">Type classification</span></h3><p>The C type system consists of the following types:<br></p><ul><li>the type <code>void</code></li><li>basic types</li></ul><dl><dd><ul><li>the type <code>char</code></li><li>signed integer types</li></ul><dl><dd><ul><li>standard: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> <span></span> <span></span></li><li>extended: implementation defined, e.g. <code>__int128</code></li></ul></dd></dl><ul><li>unsigned integer types</li></ul><dl><dd><ul><li>standard: <code>_Bool</code> <span></span> <span></span>, <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code> <span></span> <span></span></li><li>extended: implementation-defined, e.g. <code>__uint128</code></li></ul></dd></dl><ul><li>floating types</li></ul><dl><dd><ul><li>real floating types: <code>float</code>, <code>double</code>, <code>long double</code></li><li>complex types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code></li><li>imaginary types: <code>float _Imaginary</code>, <code>double _Imaginary</code>, <code>long double _Imaginary</code></li></ul></dd></dl></dd></dl><ul><li> enumerated types</li></ul><ul><li> derived types</li></ul><dl><dd><ul><li> array types</li><li> structure types</li><li> union types</li><li> function types</li><li> pointer types</li><li> atomic types</li></ul></dd></dl><p>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers (where allowed by the qualifier's semantics).</p><h4>Type groups</h4><ul><li> <i>object types</i>: all types that aren't function types</li><li> <i>character types</i>: <code>char</code>, <code>signed char</code>, <code>unsigned char</code></li><li> <i>integer types</i>: <code>char</code>, signed integer types, unsigned integer types, enumerated types</li><li> <i>real types</i>: integer types and real floating types </li><li> arithmetic types: integer types and floating types</li><li> <i>scalar types</i>: arithmetic types and pointer types</li><li> <i>aggregate types</i>: array types and structure types</li><li> <i>derived declarator types</i>: array types, function types, and pointer types </li></ul><h3><span class="prog__sub">Compatible types</span></h3><p>In a C program, the declarations referring to the same object or function in <i>different translation units</i> do not have to use the same type. They only have to use sufficiently similar types, formally known as <i>compatible types</i>. Same applies to function calls and lvalue accesses; argument types must be <i>compatible</i> with parameter types and lvalue expression type must be <i>compatible</i> with the object type that is accessed.</p><p>The types <code>T</code> and <code>U</code> are compatible, if</p><ul><li> they are the same type (same name or aliases introduced by a typedef)</li><li> they are identically cvr-qualified versions of compatible unqualified types</li><li> they are pointer types and are pointing to compatible types</li><li> they are array types, and</li></ul><dl><dd><ul><li> their element types are compatible, and</li><li> if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. <span>VLA is compatible with any array of compatible element type.</span> <span></span></li></ul></dd></dl><ul><li> they are both structure/union/enumeration types, and</li></ul><dl><dd><ul><li>if one is declared with a tag, the other must also be declared with the same tag.</li><li> if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.</li><li> additionally, if they are enumerations, corresponding members must also have the same values.</li><li> additionally, if they are structures or unions,</li></ul><dl><dd><ul><li> Corresponding members must be declared in the same order (structures only)</li><li> Corresponding bit fields must have the same widths.</li></ul></dd></dl></dd></dl><ul><li> one is an enumerated type and the other is that enumeration's underlying type</li><li> they are function types, and</li></ul><dl><dd><ul><li> their return types are compatible</li><li> they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, the corresponding parameters have compatible types</li><li> one is an old-style (parameter-less) definition, the other has a parameter list, the parameter list does not use an ellipsis and each parameter is compatible (after function parameter type adjustment) with the corresponding old-style parameter after default argument promotions</li><li> one is an old-style (parameter-less) declaration, the other has a parameter list, the parameter list does not use an ellipsis, and all parameters (after function parameter type adjustment) are unaffected by default argument promotions</li></ul></dd></dl><p>The type <code>char</code> is not compatible with <code>signed char</code> and not compatible with <code>unsigned char</code>.</p><p>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.<br></p><pre><code>// Translation Unit 1struct S {int a;};extern struct S *x;  // compatible with TU2's x, but not with TU3's x// Translation Unit 2struct S;extern struct S *x; // compatible with both x's// Translation Unit 3struct S {float a;};extern struct S *x; // compatible with TU2's x, but not with TU1's x // the behavior is undefined</code></pre><pre><code>// Translation Unit 1#include <stdio.h>struct s {int i;}; // compatible with TU3's s, but not TU2'sextern struct s x = {0}; // compatible with TU3's xextern void f(void); // compatible with TU2's fint main(){   f();   return x.i;}// Translation Unit 2struct s {float f;}; // compatible with TU4's s, but not TU1's sextern struct s y = {3.14}; // compatible with TU4's yvoid f() // compatible with TU1's f{   return;}// Translation Unit 3struct s {int i;}; // compatible with TU1's s, but not TU2's sextern struct s x; // compatible with TU1's x// Translation Unit 4struct s {float f;}; // compatible with TU2's s, but not TU1's sextern struct s y; // compatible iwth TU2's y // the behavior is well-defined: only multiple declarations// of objects and functions must have compatible types, not the types themselves</code></pre><p>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.<br></p><h3><span class="prog__sub">Composite types</span></h3><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete </td></tr></table><h3><span class="prog__sub">Incomplete types</span></h3><p>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.<br></p><p>The following types are incomplete:<br></p><ul><li> the type <code>void</code>. This type cannot be completed.</li><li> array type of unknown size. It can be completed by a later declaration that specifies the size.</li><li> structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.</li></ul><h3><span class="prog__sub">Type names</span></h3><p>A type may have to be named in context other than the declaration. In these situations, <i>type name</i> is used, which is, grammatically, exactly the same as a list of <i>type-specifiers</i> and <i>type-qualifiers</i>, followed by the <i>declarator</i> (see declarations) as would be used to declare a single object or function of this type, except that the identifier is omitted:</p><pre><code>int n; // declaration of an intsizeof(int); // use of type name int *a[3]; // declaration of an array of 3 pointers to intsizeof(int *[3]); // use of type name int (*p)[3]; // declaration of a pointer to array of 3 intsizeof(int (*)[3]); // use of type name int (*a)[*] // declaration of pointer to VLA (in a function parameter)sizeof(int (*)[*]) // use of type name (in a function parameter) int *f(void); // declaration of functionsizeof(int *(void)); // use of type name int (*p)(void); // declaration of pointer to functionsizeof(int (*)(void)); // use of type name int (*const a[])(unsigned int, ...) = {0}; // array of pointers to functionssizeof(int (*const [])(unsigned int, ...)); // use of type name</code></pre><p>Except the redundant parentheses around the identifier are meaningful in a type-name and represent "function with no parameter specification":<br></p><pre><code>int (n); // declares n of type intsizeof(int ()); // uses type "function returning int"</code></pre><p>Type names are used in the following situations:<br></p><ul><li> cast</li><li> sizeof</li></ul><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><ul><li> compound literal</li></ul></td><td></td></tr><tr class="t-rev t-since-c11"><td><ul><li> generic selection</li><li> alignof</li><li> alignas</li><li> _Atomic (when used as a type specifier)</li></ul></td><td></td></tr></table><p><br>A type name may introduce a new type: <br></p><pre><code>void* p = (void*)(struct X {int i;} *)0;// type name "struct X {int i;}*" used in the cast expression// introduces the new type "struct X"struct X x = {1}; // struct X is now in scope</code></pre><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/types.html
union	A										<section class="prog__container"><p>A union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence). The value of at most one of the members can be stored in a union at any one time.<br></p><p>The type specifier for a union is identical to the  <code>struct</code> type specifier except for the keyword used:</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>union</code> <i>name</i>(optional) <code>{ </code> <i>struct-declaration-list</i> <code>} </code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>union</code> <i>name</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>name</i></td><td> -</td><td>  the name of the union that's being defined</td></tr><tr class="t-par"><td> <i>struct-declaration-list</i></td><td> -</td><td>  any number of variable declarations, bit field declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed.</td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The union is only as big as necessary to hold its largest member (additional unnamed trailing padding may also be added). The other members are allocated in the same bytes as part of that largest member. <br></p><p>A pointer to a union can be cast to a pointer to each of its members (if a union has bit field members, the pointer to a union can be cast to the pointer to the bit field's underlying type). Likewise, a pointer to any member of a union can be cast to a pointer to the enclosing union. <br></p><p>If the member used to access the contents of a union is not the same as the member last used to store a value, the object representation of the value that was stored is reinterpreted as an object representation of the new type (this is known as <i>type punning</i>). If the size of the new type is larger than the size of the last-written type, the contents of the excess bytes are unspecified (and may be a trap representation) </p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p>Similar to struct, an unnamed member of a union whose type is a union without <i>name</i> is known as <i>anonymous union</i>. Every member of an anonymous union is considered to be a member of the enclosing struct or union. This applies recursively if the enclosing struct or union is also anonymous.</p><pre><code>struct v {   union { // anonymous union      struct { int i, j; }; // anonymous structure      struct { long k, l; } w;   };   int m;} v1; v1.i = 2;   // validv1.k = 3;   // invalid: inner structure is not anonymousv1.w.k = 5; // valid</code></pre><p>Similar to struct, the behavior of the program is undefined if union is defined without any named members (including those obtained via anonymous nested structs or unions).<br></p></td><td></td></tr></table><h3><span class="prog__sub">Keywords</span></h3><p><tt>union</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/union.html
value_category	A										<section class="prog__container"><p>Each expression in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a type and a value category.</p><p>Every expression belongs to one of three value categories: lvalue, non-lvalue object (rvalue), and function designator.<br></p><h3><span class="prog__sub">Lvalue expressions</span></h3><p>Lvalue expression is any expression with object type other than the type <code>void</code>, which potentially designates an object (the behavior is undefined if an lvalue does not actually designate an object when it is evaluated). In other words, lvalue expression evaluates to the <i>object identity</i>. The name of this value category ("left value") is historic and reflects the use of lvalue expressions as the left-hand operand of the assignment operator in the CPL programming language.</p><p>Lvalue expressions can be used in the following <i>lvalue contexts</i>:</p><ul><li> as the operand of the address-of operator (except if the lvalue designates a bit field or was declared register).</li><li> as the operand of the pre/post increment and decrement operators.</li><li> as the left-hand operand of the member access (dot) operator.</li><li> as the left-hand operand of the assignment and compound assignment operators.</li></ul><p>If an lvalue expression is used in any context other than sizeof, _Alignof, or the operators listed above, non-array lvalues of any complete type undergo lvalue conversion, which models the memory load of the value of the object from its location. Similarly, array lvalues undergo array-to-pointer conversion when used in any context other than <code>sizeof</code>, <code>_Alignof</code>, address-of operator, or array initialization from a string literal.</p><p>The semantics of const/volatile/restrict-qualifiers and atomic types apply to lvalues only (lvalue conversion strips the qualifiers and removes atomicity).</p><p>The following expressions are lvalues:<br></p><ul><li> identifiers, including function parameters, provided they were declared as designating objects (and not functions)</li><li> string literals</li><li>  compound literals</li><li> parenthesized expression if the unparenthesized expression is an lvalue</li><li> the result of a member access (dot) operator if its left-hand argument is lvalue</li><li> the result of a member access through pointer <code>-></code> operator</li><li> the result of the indirection (unary <code>*</code>) operator applied to a pointer to object</li><li> the result of the subscription operator (<code>[]</code>)</li></ul><h4>Modifiable lvalue expressions</h4><p>A <i>modifiable lvalue</i> is any lvalue expression of complete, non-array type which is not const-qualified, and, if it's a struct/union, has no members that are const-qualified, recursively.</p><p>Only modifiable lvalue expressions may be used as arguments to increment/decrement, and as left-hand arguments of assignment and compound assignment operators.<br></p><h3><span class="prog__sub">Non-lvalue object expressions</span></h3><p>Colloquially known as <i>rvalues</i>, non-lvalue object expressions are the expressions of object types that do not designate objects, but rather values that have no object identity or storage location. The address of a non-lvalue object expression cannot be taken.</p><p>The following expressions are non-lvalue object expressions:<br></p><ul><li> integer, character, and floating constants</li><li> all operators not specified to return lvalues, including</li></ul><dl><dd><ul><li> any function call expression</li><li> any cast expression (note that compound literals, which look similar, are lvalues)</li><li> member access operator (dot) applied to a non-lvalue structure/union, <code>f().x</code>, <code>(x,s1).a</code>, <code>s1=s2).m</code></li><li> all arithmetic, relational, logical, and bitwise operators</li><li> increment and decrement operators (note: pre- forms are lvalues in C++)</li><li> assignment and compound assignment operators (note: they are lvalues in C++)</li><li> the conditional operator (note: may be lvalue in C++)</li><li> the comma operator (note: may be lvalue in C++)</li><li> the address-of operator, even it if is neutralized by being applied to the result of the unary <code>*</code> operator</li></ul></dd></dl><p>As a special case, expressions of type <code>void</code> are assumed to be non-lvalue object expressions that yield a value which has no representation and requires no storage.</p><p>Note that a struct/union rvalue that has a member (possibly nested) of array type does in fact designate an object with temporary lifetime. This object can be accessed through lvalue expressions that form by indexing the array member or by indirection through the pointer obtained by array-to-pointer conversion of the array member.</p><h3><span class="prog__sub">Function designator expression</span></h3><p>A function designator (the identifier introduced by a function declaration) is an expression of function type. When used in any context other than the address-of operator, sizeof, and _Alignof (the last two generate compile errors when applied to functions), the function designator is always converted to a non-lvalue pointer to function. Note that the function-call operator is defined for pointers to functions and not for function designators themselves.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/value_category.html
variadic	A										<section class="prog__container"><p>Variadic functions are functions that may be called with different number of arguments. <br></p><p>Only new-style (prototyped)  function declarations may be variadic. This is indicated by the parameter of the form <code>...</code> which must appear last in the parameter list and must follow at least one named parameter.</p><pre><code>//New-style declarationint printx(const char* fmt, ...); // function declared this wayprintx("hello world"); // may be called with oneprintx("a=%d b=%d", a, b); // or more arguments // int printy(..., const char* fmt); // Error: ... must be the last// int printz(...); // Error: ... must follow at least one named parameter</code></pre><p>At the function call, each argument that is a part of the variable argument list undergoes special implicit conversions known as default argument promotions.</p><p>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the <stdarg.h> library facilities:</p><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdarg.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>va_start</td></tr></table></code></td><td>   enables access to variadic function arguments <br> (function macro) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>va_arg</td></tr></table></code></td><td>   accesses the next variadic function argument <br> (function macro) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>va_copy</td></tr></table></code><table><tr><td></td></tr></table></td><td>   makes a copy of the variadic function arguments  <br> (function macro) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>va_end</td></tr></table></code></td><td>   ends traversal of the variadic function arguments <br> (function macro) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>va_list</td></tr></table></code></td><td>   holds the information needed by va_start, va_arg, va_end, and va_copy <br> (typedef) <br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/variadic.html
volatile	A										<section class="prog__container"><p>Each individual type in the C type system has several <i>qualified</i> versions of that type, corresponding to one, two, or all three of the const, <i>volatile</i>, and, for pointers to object types, restrict qualifiers. This page describes the effects of the <i>volatile</i> qualifier.</p><p>Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a sequence point from the volatile access.</p><p>A cast of a non-volatile value to a volatile type has no effect. To access a non-volatile object using volatile semantics, its address must be cast to a pointer-to-volatile and then the access must be made through that pointer.<br></p><p>Any attempt to read or write to an object whose type is volatile-qualified through a non-volatile lvalue results in undefined behavior:<br></p><pre><code>volatile int n = 1; // object of volatile-qualified typeint* p = (int*)&amp;n;int val = *p; // undefined behavior</code></pre><p>A member of a volatile-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the <code>.</code> operator or the <code>-></code> operator):</p><pre><code>struct s { int i; const int ci; } s;// the type of s.i is int, the type of s.ci is const intvolatile struct s vs;// the types of vs.i and vs.ci are volatile int and const volatile int</code></pre><p>If an array type is declared with the volatile type qualifier (through the use of typedef), the array type is not volatile-qualified, but its element type is. If a function type is declared with the volatile type qualified (through the use of typedef), the behavior is undefined.</p><pre><code>typedef int A[2][3];volatile A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of volatile intint* pi = a[0]; // Error: a[0] has type volatile int*</code></pre><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>In a function declaration, the keyword <code>volatile</code> may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</p><p>The following two declarations declare the same function:<br></p><pre><code>void f(double x[volatile], const double y[volatile]);void f(double * volatile x, const double * volatile y);</code></pre></td><td></td></tr></table><p>A pointer to a non-volatile type can be implicitly converted to a pointer to the volatile-qualified version of the same or compatible type. The reverse conversion can be performed with a cast expression.</p><pre><code>int* p = 0;volatile int* vp = p; // OK: adds qualifiers (int to volatile int)p = vp; // Error: discards qualifiers (volatile int to int)p = (int*)vp; // OK: cast</code></pre><p>Note that pointer to pointer to <code>T</code> is not convertible to pointer to pointer to <code>volatile T</code>; for two types to be compatible, their qualifications must be identical:</p><pre><code>char *p = 0;volatile char **vpp = &amp;p; // Error: char* and volatile char* are not compatible typeschar * volatile *pvp = &amp;p; // OK, adds qualifiers (char* to char*volatile)</code></pre><h3><span class="prog__sub">Uses of volatile</span></h3><ul>1) static <code>volatile</code> objects model memory-mapped I/O ports, and <code>static</code> <code>const</code> <code>volatile</code> objects model memory-mapped input ports, such as a real-time clock:<pre><code>volatile short *ttyport = (volatile short*)TTYPORT_ADDR;for(int i = 0; i < N; ++i)    *ttyport = a[i]; // *ttyport is an lvalue of type volatile short</code></pre></ul><ul>2) <code>static</code> <code>volatile</code> objects of type <code>sig_atomic_t</code> are used for communication with <code>signal</code> handlers.</ul><ul>3) <code>volatile</code> variables that are local to a function that contains an invocation of the <code>setjmp</code> macro are the only local variables guaranteed to retain their values after <code>longjmp</code> returns.</ul><ul>4) In addition, volatile variables can be used to disable certain forms of optimization, e.g. to disable dead store elimination or constant folding for microbenchmarks.</ul><p>Note that volatile variables are not suitable for communication between threads; they do not offer atomicity, synchronization, or memory ordering. A read from a volatile variable that is modified by another thread without synchronization or concurrent modification from two unsynchronized threads is undefined behavior due to a data race.<br></p><h3><span class="prog__sub">Keywords</span></h3><p><tt>volatile</tt></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/volatile.html
while	A										<section class="prog__container"><p>Executes a <i>statement</i> repeatedly, until the value of <i>expression</i> becomes equal to zero. The test takes place before each iteration.</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>while (</code> <i>expression</i> <code>)</code> <i>statement</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><table class="t-par-begin"><tr class="t-par"><td> <i>expression</i></td><td> -</td><td>  any expression of scalar type. This expression is evaluated before each iteration, and if it compares equal to zero, the loop is exited.</td></tr><tr class="t-par"><td> <i>statement</i></td><td> -</td><td>  any statement, typically a compound statement, which serves as the body of the loop</td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>A <code>while</code> statement causes the <i>statement</i> (also called <i>the loop body</i>) to be executed repeatedly until the <i>expression</i> (also called <i>controlling expression</i>) compares equal to zero. The repetition occurs regardless of whether the loop body is entered normally or by a goto into the middle of <i>statement</i>.</p><p>The evaluation of <i>expression</i> takes place before each execution of <i>statement</i> (unless entered by a goto). If the controlling expression needs to be evaluated after the loop body, the do-while loop may be used.</p><p>If the execution of the loop needs to be terminated at some point,  break statement can be used as a terminating statement. </p><p>If the execution of the loop needs to be continued at the end of the loop body,  continue statement can be used as a shortcut.</p><p>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its <i>statement</i> or <i>expression</i>. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where <i>expression</i> is a constant expression; <code>while(true)</code> is always an endless loop.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>As with all other selection and iteration statements, the while statement establishes block scope: any identifier introduced in the <i>expression</i> goes out of scope after the <i>statement</i>.</p></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/language/while.html
libs	A										<section class="prog__container"><p>The objective of this page is to build a comprehensible list of open source C libraries, so that when one needs an implementation of particular functionality, one need not waste time searching on Google.<br></p><p>If you know a library that might be useful to others, please add a link to it here. There are no restrictions on what can be included except that it must be possible to download the source of the library.<br></p><p>The page is provided 'as is' - with the hope of being useful, but without any warranties. Outdated, misleading or wrong links might appear here. If you've noticed one of these, it would be great if you fixed the error.<br></p><h2>Operating system</h2><dl><dt> Access control</dt></dl><ul><li>acl<span style="color: #BBB; font-size: 0.7em;"></span></li><li>apparmor<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> Extended attributes</dt></dl><ul><li>attr<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Graphic user interface</h2><ul><li>IUP<span style="color: #BBB; font-size: 0.7em;"></span></li><li>tiny file dialogs<span style="color: #BBB; font-size: 0.7em;"></span> -  a single C cross-platform file (no init, no main loop, 6 modal function calls)</li></ul><h2>Gtk+ widgets</h2><ul><li>gtk+<span style="color: #BBB; font-size: 0.7em;"></span></li><li>gtkhtml<span style="color: #BBB; font-size: 0.7em;"></span></li><li>appmenu-gtk<span style="color: #BBB; font-size: 0.7em;"></span></li><li>ghex<span style="color: #BBB; font-size: 0.7em;"></span></li><li>gtkspell<span style="color: #BBB; font-size: 0.7em;"></span></li><li>gtksourceview<span style="color: #BBB; font-size: 0.7em;"></span></li><li>gtkhotkey<span style="color: #BBB; font-size: 0.7em;"></span></li><li>gucharmap<span style="color: #BBB; font-size: 0.7em;"></span></li><li>goocanvas<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Audio</h2><dl><dt> Codecs</dt></dl><ul><li>aften<span style="color: #BBB; font-size: 0.7em;"></span></li><li>faad2<span style="color: #BBB; font-size: 0.7em;"></span></li><li>wavpack<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> Infrastructure</dt></dl><ul><li>alsa-lib<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> CD</dt></dl><ul><li>cdparanoia<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt>Speech synthesis</dt></dl><ul><li>espeak<span style="color: #BBB; font-size: 0.7em;"></span>--</li><li>flite<span style="color: #BBB; font-size: 0.7em;"></span> --</li></ul><h2>Video</h2><dl><dt> Codecs</dt></dl><ul><li>schroedinger<span style="color: #BBB; font-size: 0.7em;"></span>--</li><li>video4linux<span style="color: #BBB; font-size: 0.7em;"></span>--</li></ul><h2>Files</h2><ul><li>gmime<span style="color: #BBB; font-size: 0.7em;"></span></li><li>caos<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Maths</h2><ul><li>gsl<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> Integer Multi-Dimensional Interpolation</dt></dl><ul><li>argyll<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> Linear algebra</dt></dl><ul><li>atlas<span style="color: #BBB; font-size: 0.7em;"></span></li><li>blas<span style="color: #BBB; font-size: 0.7em;"></span></li><li>eigen<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> Finance</dt></dl><ul><li>ta-lib<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> FFT</dt></dl><ul><li>fftw3<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> Multiprecision</dt></dl><ul><li>gmp<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><dl><dt> Signal Processing</dt></dl><ul><li>liquid-dsp<span style="color: #BBB; font-size: 0.7em;"></span></li><li>vsipl<span style="color: #BBB; font-size: 0.7em;"></span></li><li>vsipl++<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Graphics</h2><ul><li>cairo<span style="color: #BBB; font-size: 0.7em;"></span></li><li>babl<span style="color: #BBB; font-size: 0.7em;"></span></li><li>SIGIL (Sound, Input, and Graphics Integration Library)<span style="color: #BBB; font-size: 0.7em;"></span> -  extremely easy-to-use, cross-platform library for 2D graphics, input, and audio</li></ul><h2>Interprocess</h2><ul><li>dbus-glib<span style="color: #BBB; font-size: 0.7em;"></span></li><li>dbus<span style="color: #BBB; font-size: 0.7em;"></span></li><li>dee<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Databases</h2><ul><li>berkeley db<span style="color: #BBB; font-size: 0.7em;"></span></li><li>lmdb<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Communications</h2><ul><li>libcurl<span style="color: #BBB; font-size: 0.7em;"></span></li><li>zeromq<span style="color: #BBB; font-size: 0.7em;"></span></li><li>cpp-netlib<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Compression</h2><ul><li>bzip2<span style="color: #BBB; font-size: 0.7em;"></span></li><li>zlib<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>libc</h2><ul><li>bstrlib<span style="color: #BBB; font-size: 0.7em;"></span></li><li>eglibc<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>XML</h2><ul><li>expat<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Javascript</h2><ul><li>gjs<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><h2>Metrics</h2><ul><li>edlib<span style="color: #BBB; font-size: 0.7em;"></span></li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/links/libs.html
LC_categories	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><locale.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define LC_ALL      /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define LC_COLLATE  /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define LC_CTYPE    /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define LC_MONETARY /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define LC_NUMERIC  /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define LC_TIME     /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of <code>setlocale</code>.</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>LC_ALL</code></td><td>  selects the entire C locale</td></tr><tr class="t-dsc"><td> <code>LC_COLLATE</code></td><td>  selects the collation category of the C locale</td></tr><tr class="t-dsc"><td> <code>LC_CTYPE</code></td><td>  selects the character classification category of the C locale</td></tr><tr class="t-dsc"><td> <code>LC_MONETARY</code></td><td>  selects the monetary formatting category of the C locale</td></tr><tr class="t-dsc"><td> <code>LC_NUMERIC</code></td><td>  selects the numeric formatting category of the C locale</td></tr><tr class="t-dsc"><td> <code>LC_TIME</code></td><td>  selects the time formatting category of the C locale</td></tr></table><p>Additional macro constants, with names that begin with <code>LC_</code> followed by at least one uppercase letter, may be defined in <code>locale.h</code>. For example, the POSIX specification requires LC_MESSAGES (which controls, among other things, <code>perror</code> and <code>strerror</code>), and the GNU C library additionally defines LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT, and LC_IDENTIFICATION.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/locale/LC_categories.html
lconv	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><locale.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>struct lconv;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The struct <code>lconv</code> contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with <code>localeconv</code>. The members of <code>lconv</code> are values of type <code>char</code> and of type <code>char*</code>. Each <code>char*</code> member except <code>decimal_point</code> may be pointing at a null character (that is, at an empty C-string). The members of type <code>char</code> are all non-negative numbers, any of which may be <code>CHAR_MAX</code> if the corresponding value is not available in the current C locale.</p><h3><span class="prog__sub">Member objects</span></h3><h4>Non-monetary numeric formatting parameters</h4><table class="t-dsc-begin"><tr class="t-dsc"><td> <code><table><tr><td>char* decimal_point</td></tr></table></code></td><td>   the character used as the decimal point <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char* thousands_sep</td></tr></table></code></td><td>   the character used to separate groups of digits before the decimal point <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char* grouping</td></tr></table></code></td><td>   a string whose elements indicate the sizes of digit groups <br> (public member object)<br></td></tr></table><h4>Monetary numeric formatting parameters</h4><table class="t-dsc-begin"><tr class="t-dsc"><td> <code><table><tr><td>char* mon_decimal_point</td></tr></table></code></td><td>   the character used as the decimal point <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char* mon_thousands_sep</td></tr></table></code></td><td>   the character used to separate groups of digits before the decimal point <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char* mon_grouping</td></tr></table></code></td><td>   a string whose elements indicate the sizes of digit groups <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char* positive_sign</td></tr></table></code></td><td>   a string used to indicate non-negative monetary quantity <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char* negative_sign</td></tr></table></code></td><td>   a string used to indicate negative monetary quantity <br> (public member object)<br></td></tr></table><h4>Local monetary numeric formatting parameters</h4><table class="t-dsc-begin"><tr class="t-dsc"><td> <code><table><tr><td>char* currency_symbol</td></tr></table></code></td><td>   the symbol used for currency in the current C locale <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char frac_digits</td></tr></table></code></td><td>   the number of digits after the decimal point to display in a monetary quantity <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char p_cs_precedes</td></tr></table></code></td><td> <code>1</code> if currency_symbol is placed before non-negative value, <code>​0​</code> if after <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char n_cs_precedes</td></tr></table></code></td><td> <code>1</code> if currency_symbol is placed before negative value, <code>​0​</code> if after <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char p_sep_by_space</td></tr></table></code></td><td>   indicates the separation of <code>currency_symbol</code>, <code>positive_sign</code>, and the non-negative monetary value <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char n_sep_by_space</td></tr></table></code></td><td>   indicates the separation of <code>currency_symbol</code>, <code>negative_sign</code>, and the negative monetary value <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char p_sign_posn</td></tr></table></code></td><td>   indicates the position of <code>positive_sign</code> in a non-negative monetary value <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char n_sign_posn</td></tr></table></code></td><td>   indicates the position of <code>negative_sign</code> in a negative monetary value <br> (public member object)<br></td></tr></table><h4>International monetary numeric formatting parameters</h4><table class="t-dsc-begin"><tr class="t-dsc"><td> <code><table><tr><td>char* int_curr_symbol</td></tr></table></code></td><td>   the string used as international currency name in the current C locale  <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char int_frac_digits</td></tr></table></code></td><td>   the number of digits after the decimal point to display in an international monetary quantity <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char int_p_cs_precedes</td></tr></table></code><table><tr><td></td></tr></table></td><td> <code>1</code> if currency_symbol is placed before non-negative international monetary value, <code>​0​</code> if after <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char int_n_cs_precedes</td></tr></table></code><table><tr><td></td></tr></table></td><td> <code>1</code> if currency_symbol is placed before negative international monetary value, <code>​0​</code> if after <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char int_p_sep_by_space</td></tr></table></code><table><tr><td></td></tr></table></td><td>   indicates the separation of <code>currency_symbol</code>, <code>positive_sign</code>, and the non-negative international monetary value <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char int_n_sep_by_space</td></tr></table></code><table><tr><td></td></tr></table></td><td>   indicates the separation of <code>currency_symbol</code>, <code>negative_sign</code>, and the negative international monetary value <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char int_p_sign_posn</td></tr></table></code><table><tr><td></td></tr></table></td><td>   indicates the position of <code>positive_sign</code> in a non-negative international monetary value <br> (public member object)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>char int_n_sign_posn</td></tr></table></code><table><tr><td></td></tr></table></td><td>   indicates the position of <code>negative_sign</code> in a negative international monetary value <br> (public member object)<br></td></tr></table><p><br>The characters of the C-strings pointed to by <code>grouping</code> and <code>mon_grouping</code> are interpreted according to their numeric values. When the terminating <code>'\\0'</code> is encountered, the last value seen is assumed to repeat for the remainder of digits. If <code>CHAR_MAX</code> is encountered, no further digits are grouped. the typical grouping of three digits at a time is <code>"\\003"</code>.<br></p><p>The values of <code>p_sep_by_space</code>, <code>n_sep_by_space</code>, <code>int_p_sep_by_space</code>, <code>int_n_sep_by_space</code> are interpreted as follows:</p><table class="t-dsc-begin"><tr class="t-dsc"><td> 0</td><td> no space separates the currency symbol and the value</td></tr><tr class="t-dsc"><td> 1</td><td> sign sticks to the currency symbol, value is separated by a space</td></tr><tr class="t-dsc"><td> 2</td><td> sign sticks to the value. Currency symbol is separated by a space</td></tr></table><p>The values of <code>p_sign_posn</code>, <code>n_sign_posn</code>, <code>int_p_sign_posn</code>, <code>int_n_sign_posn</code> are interpreted as follows:</p><table class="t-dsc-begin"><tr class="t-dsc"><td> 0</td><td> parentheses around the value and the currency symbol are used to represent the sign</td></tr><tr class="t-dsc"><td> 1</td><td> sign before the value and the currency symbol</td></tr><tr class="t-dsc"><td> 2</td><td> sign after the value and the currency symbol</td></tr><tr class="t-dsc"><td> 3</td><td> sign before the currency symbol</td></tr><tr class="t-dsc"><td> 4</td><td> sign after the currency symbol</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/locale/lconv.html
localeconv	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><locale.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>lconv* localeconv();</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>localeconv</code> function obtains a pointer to a static object of type <code>lconv</code>, which represents numeric and monetary formatting rules of the current C locale.</p><h3><span class="prog__sub">Parameters</span></h3><p>(none)<br></p><h3><span class="prog__sub">Return value</span></h3><p>pointer to the current <code>lconv</code> object. </p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/locale/localeconv.html
setlocale	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><locale.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>char* setlocale( int category, const char* locale);</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>setlocale</code> function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to <code>setlocale</code>. If <code>locale</code> is a null pointer, <code>setlocale</code> queries the current C locale without modifying it.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  category</td><td> -</td><td>  locale category identifier, one of the LC_xxx macros. May be null.</td></tr><tr class="t-par"><td>  locale</td><td> -</td><td>  system-specific locale identifier. Can be <code>""</code> for the user-preferred locale or <code>"C"</code> for the minimal locale</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>pointer to a narrow null-terminated string identifying the C locale after applying the changes, if any, or null pointer on failure.<br></p><p>A copy of the returned string along with the category used in this call to <code>setlocale</code> may be used later in the program to restore the locale back to the state at the end of this call.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/locale/setlocale.html
aligned_alloc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void *aligned_alloc( size_t alignment, size_t size );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Allocate <code>size</code> bytes of uninitialized storage whose alignment is specified by <code>alignment</code>. The <code>size</code> parameter must be an integral multiple of <code>alignment</code>.</p><p><code>aligned_alloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A previous call to <code>free</code> or <code>realloc</code> that deallocates a region of memory <i>synchronizes-with</i> a call to <code>aligned_alloc</code> that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>aligned_alloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p><h3><span class="prog__sub"> Parameters </span></h3><table class="t-par-begin"><tr class="t-par"><td>  alignment</td><td> -</td><td>  specifies the alignment.  Must be a valid alignment supported by the implementation.</td></tr><tr class="t-par"><td>  size</td><td> -</td><td>  number of bytes to allocate.  An integral multiple of <code>alignment</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns the pointer to the beginning of newly allocated memory. The returned pointer must be deallocated with <code>free()</code> or <code>realloc()</code>.</p><p>On failure, returns a null pointer.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/memory/aligned_alloc.html
calloc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void* calloc( size_t num, size_t size );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Allocates memory for an array of <code>num</code> objects of size <code>size</code> and initializes all bytes in the allocated storage to zero. </p><p>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.<br></p><p>If <code>size</code> is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage)</p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p><code>calloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A previous call to <code>free</code> or <code>realloc</code> that deallocates a region of memory <i>synchronizes-with</i> a call to <code>calloc</code> that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>calloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p></td><td></td></tr></table><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  num</td><td> -</td><td>  number of objects</td></tr><tr class="t-par"><td>  size</td><td> -</td><td>  size of each object</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns the pointer to the beginning of newly allocated memory. The returned pointer must be deallocated with <code>free()</code> or <code>realloc()</code>.</p><p>On failure, returns a null pointer.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/memory/calloc.html
free	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void free( void* ptr );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Deallocates the space previously allocated by <code>malloc()</code>, <code>calloc()</code><span>, <code>aligned_alloc</code>,</span> <span></span> or <code>realloc()</code>.</p><p>If <code>ptr</code> is a null pointer, the function does nothing.</p><p>The behavior is undefined if the value of <code>ptr</code> does not equal a value returned earlier by <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code><span>, or <code>aligned_alloc()</code></span> <span></span>.</p><p>The behavior is undefined if the memory area referred to by <code>ptr</code> has already been deallocated, that is, <code>free()</code> or <code>realloc()</code> has already been called with <code>ptr</code> as the argument and no calls to <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code> resulted in a pointer equal to <code>ptr</code> afterwards.</p><p>The behavior is undefined if after <code>free()</code> returns, an access is made through the pointer <code>ptr</code> (unless another allocation function happened to result in a pointer value equal to <code>ptr</code>)</p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p><code>free</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A call to <code>free</code> that deallocates a region of memory <i>synchronizes-with</i> a call to any subsequent allocation function that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by the allocation function. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p></td><td></td></tr></table><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to the memory to deallocate</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/memory/free.html
malloc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void* malloc( size_t size );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Allocates <code>size</code> bytes of uninitialized storage.</p><p>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.<br></p><p>If <code>size</code> is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to <code>free</code>).</p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p><code>malloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A previous call to <code>free</code> or <code>realloc</code> that deallocates a region of memory <i>synchronizes-with</i> a call to <code>malloc</code> that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>malloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p></td><td></td></tr></table><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  size</td><td> -</td><td>  number of bytes to allocate</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns the pointer to the beginning of newly allocated memory. The returned pointer must be deallocated with <code>free()</code> or <code>realloc()</code>.</p><p>On failure, returns a null pointer.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/memory/malloc.html
realloc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void *realloc( void *ptr, size_t new_size );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Reallocates the given area of memory. It must be previously allocated by <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code> and not yet freed with a call to <code>free</code> or <code>realloc</code>. Otherwise, the results are undefined.</p><p>The reallocation is done by either:<br></p><ul>a) expanding or contracting the existing area pointed to by <code>ptr</code>, if possible. The contents of the area remain unchanged up to the lesser of the new and old sizes. If the area is expanded, the contents of the new part of the array are undefined. </ul><ul>b) allocating a new memory block of size <code>new_size</code> bytes, copying memory area with size equal the lesser of the new and the old sizes, and freeing the old block.</ul><p>If there is not enough memory, the old memory block is not freed and null pointer is returned.<br></p><p>If <code>ptr</code> is <code>NULL</code>, the behavior is the same as calling <code>malloc</code>(<code>new_size</code>).</p><p>If <code>new_size</code> is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage).</p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p><code>realloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A previous call to <code>free</code> or <code>realloc</code> that deallocates a region of memory <i>synchronizes-with</i> a call to any allocation function, including <code>realloc</code> that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>realloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p></td><td></td></tr></table><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to the memory area to be reallocated</td></tr><tr class="t-par"><td>  new_size</td><td> -</td><td>  new size of the array</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns the pointer to the beginning of newly allocated memory. The returned pointer must be deallocated with <code>free()</code> or <code>realloc()</code>. The original pointer <code>ptr</code> is invalidated and any access to it is undefined behavior (even if reallocation was in-place).</p><p>On failure, returns a null pointer. The original pointer <code>ptr</code> remains valid and may need to be deallocated with <code>free()</code> or <code>realloc()</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/memory/realloc.html
complex	A										<section class="prog__container"><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td>If the macro constant <code>__STDC_NO_COMPLEX__</code> is defined by the implementation, the complex types, the header <code><complex.h></code> and all of the names listed here are not provided.</td><td></td></tr></table><p>The C programming language, as of C99, supports complex number math with the three built-in types <code>double _Complex</code>, <code>float _Complex</code>, and <code>long double _Complex</code> (see _Complex). When the header <code><complex.h></code> is included, the three complex number types are also accessible as <code>double complex</code>, <code>float complex</code>, <code>long double complex</code>.</p><p>In addition to the complex types, the three imaginary types may be supported: <code>double _Imaginary</code>, <code>float _Imaginary</code>, and <code>long double _Imaginary</code> (see _Imaginary). When the header <code><complex.h></code> is included, the three imaginary types are also accessible as <code>double imaginary</code>, <code>float imaginary</code>, and <code>long double imaginary</code>.</p><p>Standard arithmetic operators <code>+, -, *, /</code> can be used with real, complex, and imaginary types in any combination. </p><table class="t-rev-begin"><tr class="t-rev t-since-c99 t-until-c11"><td><p>A compiler that defines <code>__STDC_IEC_559_COMPLEX__</code> is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro <code>_Imaginary_I</code> is defined to identify imaginary number support.</p></td><td><br/></td></tr><tr class="t-rev t-since-c11"><td><p>Imaginary numbers are supported if <code>__STDC_IEC_559_COMPLEX__</code> is defined.</p></td><td></td></tr></table><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><complex.h></code> </td></tr><tr><td colspan="2"> <h5>   Types </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>imaginary</td></tr></table></code><table><tr><td></td></tr></table></td><td>   imaginary type macro   <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>complex</td></tr></table></code><table><tr><td></td></tr></table></td><td>   complex type macro  <br> (macro constant) <br></td></tr><tr><td colspan="2"> <h5>   The imaginary constant </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>_Imaginary_I</td></tr></table></code><table><tr><td></td></tr></table></td><td>   the imaginary unit constant i <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>_Complex_I</td></tr></table></code><table><tr><td></td></tr></table></td><td>   the complex unit constant i <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>I</td></tr></table></code><table><tr><td></td></tr></table></td><td>   the complex or imaginary unit constant i <br> (macro constant) <br></td></tr><tr><td colspan="2"> <h5>   Manipulation </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>CMPLX</td></tr><tr><td>CMPLXF</td></tr><tr><td>CMPLXL</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   constructs a complex number from real and imaginary parts  <br> (function macro) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>creal</td></tr><tr><td>crealf</td></tr><tr><td>creall</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the real part of a complex number  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cimag</td></tr><tr><td>cimagf</td></tr><tr><td>cimagl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the imaginary part a complex number  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cabs</td></tr><tr><td>cabsf</td></tr><tr><td>cabsl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the magnitude of a complex number  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>carg</td></tr><tr><td>cargf</td></tr><tr><td>cargl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the phase angle of a complex number  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>conj</td></tr><tr><td>conjf</td></tr><tr><td>conjl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex conjugate  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cproj</td></tr><tr><td>cprojf</td></tr><tr><td>cprojl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the projection on Riemann sphere  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Exponential functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cexp</td></tr><tr><td>cexpf</td></tr><tr><td>cexpl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex base-e exponential <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>clog</td></tr><tr><td>clogf</td></tr><tr><td>clogl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex natural logarithm <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Power functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cpow</td></tr><tr><td>cpowf</td></tr><tr><td>cpowl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex power function  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>csqrt</td></tr><tr><td>csqrtf</td></tr><tr><td>csqrtl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex square root  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Trigonometric functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>csin</td></tr><tr><td>csinf</td></tr><tr><td>csinl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex sine <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ccos</td></tr><tr><td>ccosf</td></tr><tr><td>ccosl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex cosine <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ctan</td></tr><tr><td>ctanf</td></tr><tr><td>ctanl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex tangent <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>casin</td></tr><tr><td>casinf</td></tr><tr><td>casinl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex arc sine <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cacos</td></tr><tr><td>cacosf</td></tr><tr><td>cacosl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex arc cosine <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>catan</td></tr><tr><td>catanf</td></tr><tr><td>catanl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex arc tangent <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Hyperbolic functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>csinh</td></tr><tr><td>csinhf</td></tr><tr><td>csinhl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex hyperbolic sine <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ccosh</td></tr><tr><td>ccoshf</td></tr><tr><td>ccoshl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex hyperbolic cosine <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ctanh</td></tr><tr><td>ctanhf</td></tr><tr><td>ctanhl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex hyperbolic tangent <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>casinh</td></tr><tr><td>casinhf</td></tr><tr><td>casinhl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex arc hyperbolic sine <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cacosh</td></tr><tr><td>cacoshf</td></tr><tr><td>cacoshl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex arc hyperbolic cosine <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>catanh</td></tr><tr><td>catanhf</td></tr><tr><td>catanhl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes the complex arc hyperbolic tangent <br> (function) <br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex.html
fenv	A										<section class="prog__container"><p>The floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local, each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.<br></p><p>The floating-point environment access and modification is only meaningful when <tt>#pragma STDC FENV_ACCESS</tt> is set to <code>ON</code>. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, and IBM XL, support the <code>#pragma</code> explicitly, but most compilers allow meaningful access to the floating-point environment anyway.</p><h3><span class="prog__sub">Types</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><fenv.h></code> </td></tr><tr class="t-dsc"><td> <code>fenv_t</code></td><td>  The type representing the entire floating-point environment</td></tr><tr class="t-dsc"><td> <code>fexcept_t</code></td><td>  The type representing all floating-point status flags collectively</td></tr></table><h3><span class="prog__sub">Functions</span></h3><table class="t-dsc-begin"><tr class="t-dsc"><td> <code> <table><tr><td>feclearexcept</td></tr></table></code><table><tr><td></td></tr></table></td><td>   clears the specified floating-point status flags <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fetestexcept</td></tr></table></code><table><tr><td></td></tr></table></td><td>   determines which of the specified floating-point status flags are set <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>feraiseexcept</td></tr></table></code><table><tr><td></td></tr></table></td><td>   raises the specified floating-point exceptions <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fegetexceptflag</td></tr><tr><td>fesetexceptflag</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>  copies the state of the specified floating-point status flags from or to the floating-point environment <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fegetround</td></tr><tr><td>fesetround</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   gets or sets rounding  direction  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fegetenv</td></tr><tr><td>fesetenv</td></tr></table></code><table><tr><td></td></tr></table></td><td>    saves or restores the current floating point environment <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>feholdexcept</td></tr></table></code><table><tr><td></td></tr></table></td><td>   saves the environment, clears all status flags and ignores all future errors <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>feupdateenv</td></tr></table></code><table><tr><td></td></tr></table></td><td>   restores the floating-point environment and raises the previously raise exceptions <br> (function) <br></td></tr></table><h3><span class="prog__sub">Macros</span></h3><table class="t-dsc-begin"><tr class="t-dsc"><td> <code> <table><tr><td>FE_ALL_EXCEPT</td></tr><tr><td>FE_DIVBYZERO</td></tr><tr><td>FE_INEXACT</td></tr><tr><td>FE_INVALID</td></tr><tr><td>FE_OVERFLOW</td></tr><tr><td>FE_UNDERFLOW</td></tr></table></code><table><tr><td></td></tr></table></td><td>   floating-point exceptions  <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>FE_DOWNWARD</td></tr><tr><td>FE_TONEAREST</td></tr><tr><td>FE_TOWARDZERO</td></tr><tr><td>FE_UPWARD</td></tr></table></code><table><tr><td></td></tr></table></td><td>   floating-point rounding direction <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>FE_DFL_ENV</td></tr></table></code><table><tr><td></td></tr></table></td><td>   default floating-point environment <br> (macro constant) <br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv.html
math	A										<section class="prog__container"><h3><span class="prog__sub">Functions</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdlib.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>abs</td></tr><tr><td>labs</td></tr><tr><td>llabs</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes absolute value of an integral value (|x|)  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>div</td></tr><tr><td>ldiv</td></tr><tr><td>lldiv</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes quotient and remainder of integer division  <br> (function) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><inttypes.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>imaxabs</td></tr></table></code><table><tr><td></td></tr></table></td><td>   computes absolute value of an integral value (|x|)  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>imaxdiv</td></tr></table></code><table><tr><td></td></tr></table></td><td>   computes quotient and remainder of integer division  <br> (function) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><math.h></code> </td></tr><tr><td colspan="2"> <h5>   Basic operations </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fabs</td></tr><tr><td>fabsf</td></tr><tr><td>fabsl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes absolute value of a floating-point value (|x|) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fmod</td></tr><tr><td>fmodf</td></tr><tr><td>fmodl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes remainder of the floating-point division operation  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>remainder</td></tr><tr><td>remainderf</td></tr><tr><td>remainderl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes signed remainder of the floating-point division operation  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>remquo</td></tr><tr><td>remquof</td></tr><tr><td>remquol</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes signed remainder as well as the three last bits of the division operation  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fma</td></tr><tr><td>fmaf</td></tr><tr><td>fmal</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes fused multiply-add operation  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fmax</td></tr><tr><td>fmaxf</td></tr><tr><td>fmaxl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   determines larger of two floating-point values  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fmin</td></tr><tr><td>fminf</td></tr><tr><td>fminl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   determines smaller of two floating-point values  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fdim</td></tr><tr><td>fdimf</td></tr><tr><td>fdiml</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   determines positive difference of two floating-point values (max(0, x-y))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>nan</td></tr><tr><td>nanf</td></tr><tr><td>nanl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   returns a NaN (not-a-number)  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Exponential functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>exp</td></tr><tr><td>expf</td></tr><tr><td>expl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes <i>e</i> raised to the given power (e<sup>x</sup>)  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>exp2</td></tr><tr><td>exp2f</td></tr><tr><td>exp2l</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes <i>2</i> raised to the given power (2<sup>x</sup>)  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>expm1</td></tr><tr><td>expm1f</td></tr><tr><td>expm1l</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes <i>e</i> raised to the given power, minus one (e<sup>x</sup>-1)  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>log</td></tr><tr><td>logf</td></tr><tr><td>logl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes natural (base-<i>e</i>) logarithm (ln(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>log10</td></tr><tr><td>log10f</td></tr><tr><td>log10l</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes common (base-<i>10</i>) logarithm (log<sub>10</sub>(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>log2</td></tr><tr><td>log2f</td></tr><tr><td>log2l</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes base-2 logarithm (log<sub>2</sub>(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>log1p</td></tr><tr><td>log1pf</td></tr><tr><td>log1pl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes natural (base-<i>e</i>) logarithm of 1 plus the given number (ln(1+x))  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Power functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>pow</td></tr><tr><td>powf</td></tr><tr><td>powl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes a number raised to the given power (x<sup>y</sup>)  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>sqrt</td></tr><tr><td>sqrtf</td></tr><tr><td>sqrtl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes square root (<span>√</span><span>x</span>)  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cbrt</td></tr><tr><td>cbrtf</td></tr><tr><td>cbrtl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes cubic root  (<span>3</span><span>√</span><span>x</span>)  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>hypot</td></tr><tr><td>hypotf</td></tr><tr><td>hypotl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes square root of the sum of the squares of two given numbers (<span>√</span><span>x<span class="t-su">2<br/></span>+y<span class="t-su">2<br/></span></span>)  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Trigonometric functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>sin</td></tr><tr><td>sinf</td></tr><tr><td>sinl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes sine (sin(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cos</td></tr><tr><td>cosf</td></tr><tr><td>cosl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes cosine (cos(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>tan</td></tr><tr><td>tanf</td></tr><tr><td>tanl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes tangent (tan(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>asin</td></tr><tr><td>asinf</td></tr><tr><td>asinl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes arc sine (arcsin(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>acos</td></tr><tr><td>acosf</td></tr><tr><td>acosl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes arc cosine (arccos(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>atan</td></tr><tr><td>atanf</td></tr><tr><td>atanl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>  computes arc tangent (arctan(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>atan2</td></tr><tr><td>atan2f</td></tr><tr><td>atan2l</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes arc tangent, using signs to determine quadrants  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Hyperbolic functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>sinh</td></tr><tr><td>sinhf</td></tr><tr><td>sinhl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes hyperbolic sine (sh(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>cosh</td></tr><tr><td>coshf</td></tr><tr><td>coshl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes hyperbolic cosine (ch(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>tanh</td></tr><tr><td>tanhf</td></tr><tr><td>tanhl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes hyperbolic tangent  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>asinh</td></tr><tr><td>asinhf</td></tr><tr><td>asinhl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>  computes inverse hyperbolic sine (arsinh(x)) <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>acosh</td></tr><tr><td>acoshf</td></tr><tr><td>acoshl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes inverse hyperbolic cosine (arcosh(x))  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>atanh</td></tr><tr><td>atanhf</td></tr><tr><td>atanhl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes inverse hyperbolic tangent (artanh(x))  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Error and gamma functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>erf</td></tr><tr><td>erff</td></tr><tr><td>erfl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes error function  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>erfc</td></tr><tr><td>erfcf</td></tr><tr><td>erfcl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes complementary error function  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>tgamma</td></tr><tr><td>tgammaf</td></tr><tr><td>tgammal</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes gamma function  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>lgamma</td></tr><tr><td>lgammaf</td></tr><tr><td>lgammal</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes natural (base-<i>e</i>) logarithm of the gamma function  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Nearest integer floating-point operations </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ceil</td></tr><tr><td>ceilf</td></tr><tr><td>ceill</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes smallest integer not less than the given value  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>floor</td></tr><tr><td>floorf</td></tr><tr><td>floorl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes largest integer not greater than the given value  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>trunc</td></tr><tr><td>truncf</td></tr><tr><td>truncl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   rounds to nearest integer not greater in magnitude than the given value  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>round</td></tr><tr><td>lround</td></tr><tr><td>llround</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   rounds to nearest integer, rounding away from zero in halfway cases  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>nearbyint</td></tr><tr><td>nearbyintf</td></tr><tr><td>nearbyintl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   rounds to an integer using current rounding mode  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>rint</td></tr><tr><td>rintf</td></tr><tr><td>rintl</td></tr><tr><td>lrint</td></tr><tr><td>lrintf</td></tr><tr><td>lrintl</td></tr><tr><td>llrint</td></tr><tr><td>llrintf</td></tr><tr><td>llrintl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   rounds to an integer using current rounding mode with <br> exception if the result differs  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Floating-point manipulation functions </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>frexp</td></tr><tr><td>frexpf</td></tr><tr><td>frexpl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   breaks a number into significand and a power of <code>2</code> <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ldexp</td></tr><tr><td>ldexpf</td></tr><tr><td>ldexpl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   multiplies a number by <code>2</code> raised to a power  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>modf</td></tr><tr><td>modff</td></tr><tr><td>modfl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   breaks a number into integer and fractional parts  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>scalbn</td></tr><tr><td>scalbnf</td></tr><tr><td>scalbnl</td></tr><tr><td>scalbln</td></tr><tr><td>scalblnf</td></tr><tr><td>scalblnl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   computes efficiently a number times <code>FLT_RADIX</code> raised to a power  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ilogb</td></tr><tr><td>ilogbf</td></tr><tr><td>ilogbl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   extracts exponent of the given number  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>logb</td></tr><tr><td>logbf</td></tr><tr><td>logbl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   extracts exponent of the given number  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>nextafter</td></tr><tr><td>nextafterf</td></tr><tr><td>nextafterl</td></tr><tr><td>nexttoward</td></tr><tr><td>nexttowardf</td></tr><tr><td>nexttowardl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   determines next representable floating-point value towards the given value  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>copysign</td></tr><tr><td>copysignf</td></tr><tr><td>copysignl</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   produces a value with the magnitude of a given value and the sign of another given value  <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Classification and comparison </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>fpclassify</td></tr></table></code><table><tr><td></td></tr></table></td><td>   classifies the given floating-point value  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isfinite</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the given number has finite value  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isinf</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the given number is infinite  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isnan</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the given number is NaN <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isnormal</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the given number is normal  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>signbit</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the given number is negative  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isgreater</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the first floating-point argument is greater than the second <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isgreaterequal</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the first floating-point argument is greater or equal than the second <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isless</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the first floating-point argument is less than the second <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>islessequal</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the first floating-point argument is less or equal than the second <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>islessgreater</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the first floating-point argument is less or greater than the second <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isunordered</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if two floating-point values are unordered <br> (function) <br></td></tr></table><h3><span class="prog__sub">Types</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdlib.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>div_t</td></tr></table></code></td><td>   structure type, return of the <code>div</code> function <br> (typedef) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ldiv_t</td></tr></table></code></td><td>   structure type, return of the <code>ldiv</code> function <br> (typedef) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>lldiv_t</td></tr></table></code><table><tr><td></td></tr></table></td><td>   structure type, return of the <code>lldiv</code> function  <br> (typedef) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><inttypes.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>imaxdiv_t</td></tr></table></code><table><tr><td></td></tr></table></td><td>   structure type, return of the <code>imaxdiv</code> function  <br> (typedef) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><math.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>float_t</td></tr></table></code><table><tr><td></td></tr></table></td><td>   most efficient floating-point type at least as wide as <code>float</code> <br> (typedef) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>double_t</td></tr></table></code><table><tr><td></td></tr></table></td><td>   most efficient floating-point type at least as wide as <code>double</code> <br> (typedef) <br></td></tr></table><h3><span class="prog__sub">Macro constants</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><math.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>HUGE_VALF</td></tr><tr><td>HUGE_VAL</td></tr><tr><td>HUGE_VALL</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   indicates value too big to be representable (infinity) by <code>float</code>, <code>double</code> and <code>long double</code> respectively   <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>INFINITY</td></tr></table></code><table><tr><td></td></tr></table></td><td>   evaluates to positive infinity or the value guaranteed to overflow a <code>float</code> <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>NAN</td></tr></table></code><table><tr><td></td></tr></table></td><td>   evaluates to a quiet NaN of type <code>float</code> <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>FP_FAST_FMAF</td></tr><tr><td>FP_FAST_FMA</td></tr><tr><td>FP_FAST_FMAL</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   indicates that the fma function generally executes about as fast as, or faster than, a multiply and an add of double operands   <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>FP_ILOGB0</td></tr><tr><td>FP_ILOGBNAN</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   evaluates to ilogb(x) if x is zero or NaN, respectively  <br> (macro constant) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>math_errhandling</td></tr><tr><td>MATH_ERRNO</td></tr><tr><td>MATH_ERREXCEPT</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   defines the error handling mechanism used by the common mathematical functions  <br> (macro constant) <br></td></tr><tr><td colspan="2"> <h5>   Classification </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>FP_NORMAL</td></tr><tr><td>FP_SUBNORMAL</td></tr><tr><td>FP_ZERO</td></tr><tr><td>FP_INFINITE</td></tr><tr><td>FP_NAN</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   indicates a floating-point category  <br> (macro constant) <br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math.html
random	A										<section class="prog__container"><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdlib.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>rand</td></tr></table></code></td><td>   generates a pseudo-random number  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>srand</td></tr></table></code></td><td>   seeds pseudo-random number generator <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>RAND_MAX</td></tr></table></code></td><td>   maximum possible value generated by <code>rand()</code> <br> (macro constant) <br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/random.html
tgmath	A										<section class="prog__container"><p>The header <code><tgmath.h></code> includes the headers <code><math.h></code> and <code><complex.h></code> and defines several type-generic macros that determine which real or, when applicable, complex function to call based on the types of the arguments.</p><p>For each macro, the parameters whose corresponding real type in the unsuffixed math.h function is <code>double</code> are known as <i>generic parameters</i> (for example, both parameters of <code>pow</code> are generic parameters, but only the first parameter of <code>scalbn</code> is a generic parameter)</p><p>When a <code><tgmath.h></code> macro is used the types of the arguments passed to the generic parameters determine which function is selected by the macro as described below. If the types of the arguments are not compatible with the parameter types of the selected function, the behavior is undefined (e.g. if a complex argument is passed into a real-only tgmath macro: <code>float complex fc; ceil(fc)</code> or <code>double complex dc; double d; fmax(dc, d)</code> are examples of undefined behavior)</p><p>Note: type-generic macros were implemented in implementation-defined manner in C99, but C11 keyword _Generic makes it possible to implement these macros in portable manner.</p><h3><span class="prog__sub">Complex/real type-generic macros</span></h3><p>For all functions that have both real and complex counterparts, a type-generic macro <code>XXX</code> exists, which calls either of:</p><ul><li> real function:</li></ul><dl><dd><ul><li> <code>float</code> variant <code>XXXf</code></li><li> <code>double</code> variant <code>XXX</code></li><li> <code>long double</code> variant <code>XXXl</code></li></ul></dd></dl><ul><li> complex function:</li></ul><dl><dd><ul><li> <code>float</code> variant <code>cXXXf</code></li><li> <code>double</code> variant <code>cXXX</code></li><li> <code>long double</code> variant <code>cXXXl</code></li></ul></dd></dl><p>An exception to the above rule is the <code>fabs</code> macro (see the table below).</p><p>The function to call is determined as follows:<br></p><ul><li> If any of the arguments for the generic parameters is imaginary, the behavior is specified on each function reference page individually (in particular, sin, cos, tag, cosh, sinh, tanh, asin, atan, asinh, and atanh call <i>real</i> functions, the return types of sin, tan, sinh, tanh, asin, atan, asinh, and atanh are imaginary, and the return types of cos and cosh are real)</li><li> If any of the arguments for the generic parameters is complex, then the complex function is called, otherwise the real function is called.</li><li> If any of the arguments for the generic parameters is <code>long double</code>, then the <code>long double</code> variant is called. Otherwise, if any of the parameters is <code>double</code> or integer, then the <code>double</code> variant is called. Otherwise, <code>float</code> variant is called.</li></ul><p>The type-generic macros are as follows:<br></p><table class="wikitable"><tr><th> Type-generic macro</th><th colspan="3"> Real function <br> variants<br></th><th colspan="3"> Complex function <br> variants<br></th></tr><tr><th style="height: 8em;">  </th><th> <code>float</code></th><th> <code>double</code></th><th> <code>long double</code></th><th> <code>float</code></th><th> <code>double</code></th><th> <code>long double</code></th></tr><tr><th> fabs</th><td> <tt>fabsf</tt></td><td> <tt>fabs</tt></td><td> <tt>fabsl</tt></td><td> <tt>cabsf</tt></td><td> <tt>cabs</tt></td><td> <tt>cabsl</tt></td></tr><tr><th> exp</th><td> <tt>expf</tt></td><td> <tt>exp</tt></td><td> <tt>expl</tt></td><td> <tt>cexpf</tt></td><td> <tt>cexp</tt></td><td> <tt>cexpl</tt></td></tr><tr><th> log</th><td> <tt>logf</tt></td><td> <tt>log</tt></td><td> <tt>logl</tt></td><td> <tt>clogf</tt></td><td> <tt>clog</tt></td><td> <tt>clogl</tt></td></tr><tr><th> pow</th><td> <tt>powf</tt></td><td> <tt>pow</tt></td><td> <tt>powl</tt></td><td> <tt>cpowf</tt></td><td> <tt>cpow</tt></td><td> <tt>cpowl</tt></td></tr><tr><th> sqrt</th><td> <tt>sqrtf</tt></td><td> <tt>sqrt</tt></td><td> <tt>sqrtl</tt></td><td> <tt>csqrtf</tt></td><td> <tt>csqrt</tt></td><td> <tt>csqrtl</tt></td></tr><tr><th> sin</th><td> <tt>sinf</tt></td><td> <tt>sin</tt></td><td> <tt>sinl</tt></td><td> <tt>csinf</tt></td><td> <tt>csin</tt></td><td> <tt>csinl</tt></td></tr><tr><th> cos</th><td> <tt>cosf</tt></td><td> <tt>cos</tt></td><td> <tt>cosl</tt></td><td> <tt>ccosf</tt></td><td> <tt>ccos</tt></td><td> <tt>ccosl</tt></td></tr><tr><th> tan</th><td> <tt>tanf</tt></td><td> <tt>tan</tt></td><td> <tt>tanl</tt></td><td> <tt>ctanf</tt></td><td> <tt>ctan</tt></td><td> <tt>ctanl</tt></td></tr><tr><th> asin</th><td> <tt>asinf</tt></td><td> <tt>asin</tt></td><td> <tt>asinl</tt></td><td> <tt>casinf</tt></td><td> <tt>casin</tt></td><td> <tt>casinl</tt></td></tr><tr><th> acos</th><td> <tt>acosf</tt></td><td> <tt>acos</tt></td><td> <tt>acosl</tt></td><td> <tt>cacosf</tt></td><td> <tt>cacos</tt></td><td> <tt>cacosl</tt></td></tr><tr><th> atan</th><td> <tt>atanf</tt></td><td> <tt>atan</tt></td><td> <tt>atanl</tt></td><td> <tt>catanf</tt></td><td> <tt>catan</tt></td><td> <tt>catanl</tt></td></tr><tr><th> sinh</th><td> <tt>sinhf</tt></td><td> <tt>sinh</tt></td><td> <tt>sinhl</tt></td><td> <tt>csinhf</tt></td><td> <tt>csinh</tt></td><td> <tt>csinhl</tt></td></tr><tr><th> cosh</th><td> <tt>coshf</tt></td><td> <tt>cosh</tt></td><td> <tt>coshl</tt></td><td> <tt>ccoshf</tt></td><td> <tt>ccosh</tt></td><td> <tt>ccoshl</tt></td></tr><tr><th> tanh</th><td> <tt>tanhf</tt></td><td> <tt>tanh</tt></td><td> <tt>tanhl</tt></td><td> <tt>ctanhf</tt></td><td> <tt>ctanh</tt></td><td> <tt>ctanhl</tt></td></tr><tr><th> asinh</th><td> <tt>asinhf</tt></td><td> <tt>asinh</tt></td><td> <tt>asinhl</tt></td><td> <tt>casinhf</tt></td><td> <tt>casinh</tt></td><td> <tt>casinhl</tt></td></tr><tr><th> acosh</th><td> <tt>acoshf</tt></td><td> <tt>acosh</tt></td><td> <tt>acoshl</tt></td><td> <tt>cacoshf</tt></td><td> <tt>cacosh</tt></td><td> <tt>cacoshl</tt></td></tr><tr><th> atanh</th><td> <tt>atanhf</tt></td><td> <tt>atanh</tt></td><td> <tt>atanhl</tt></td><td> <tt>catanhf</tt></td><td> <tt>catanh</tt></td><td> <tt>catanhl</tt></td></tr></table><h3><span class="prog__sub">Real-only functions</span></h3><p>For all functions that do not have complex counterparts, with the exception of <code>modf</code>, a type-generic macro <code>XXX</code> exists, which calls either of the variants of a real function:</p><ul><li> <code>float</code> variant <code>XXXf</code></li><li> <code>double</code> variant <code>XXX</code></li><li> <code>long double</code> variant <code>XXXl</code></li></ul><p>The function to call is determined as follows:<br></p><ul><li> If any of the arguments for the generic parameters is <code>long double</code>, then the <code>long double</code> variant is called. Otherwise, if any of the arguments for the generic parameters is <code>double</code>, then the <code>double</code> variant is called. Otherwise, <code>float</code> variant is called.</li></ul><table class="wikitable"><tr><th> Type-generic macro</th><th colspan="3"> Real function <br> variants<br></th></tr><tr><th style="height: 8em;">  </th><th> <code>float</code></th><th> <code>double</code></th><th> <code>long double</code></th></tr><tr><th> atan2</th><td> <tt>atan2f</tt></td><td> <tt>atan2</tt></td><td> <tt>atan2l</tt></td></tr><tr><th> cbrt</th><td> <tt>cbrtf</tt></td><td> <tt>cbrt</tt></td><td> <tt>cbrtl</tt></td></tr><tr><th> ceil</th><td> <tt>ceilf</tt></td><td> <tt>ceil</tt></td><td> <tt>ceill</tt></td></tr><tr><th> copysign</th><td> <tt>copysignf</tt></td><td> <tt>copysign</tt></td><td> <tt>copysignl</tt></td></tr><tr><th> erf</th><td> <tt>erff</tt></td><td> <tt>erf</tt></td><td> <tt>erfl</tt></td></tr><tr><th> erfc</th><td> <tt>erfcf</tt></td><td> <tt>erfc</tt></td><td> <tt>erfcl</tt></td></tr><tr><th> exp2</th><td> <tt>exp2f</tt></td><td> <tt>exp2</tt></td><td> <tt>exp2l</tt></td></tr><tr><th> expm1</th><td> <tt>expm1f</tt></td><td> <tt>expm1</tt></td><td> <tt>expm1l</tt></td></tr><tr><th> fdim</th><td> <tt>fdimf</tt></td><td> <tt>fdim</tt></td><td> <tt>fdiml</tt></td></tr><tr><th> floor</th><td> <tt>floorf</tt></td><td> <tt>floor</tt></td><td> <tt>floorl</tt></td></tr><tr><th> fma</th><td> <tt>fmaf</tt></td><td> <tt>fma</tt></td><td> <tt>fmal</tt></td></tr><tr><th> fmax</th><td> <tt>fmaxf</tt></td><td> <tt>fmax</tt></td><td> <tt>fmaxl</tt></td></tr><tr><th> fmin</th><td> <tt>fminf</tt></td><td> <tt>fmin</tt></td><td> <tt>fminl</tt></td></tr><tr><th> fmod</th><td> <tt>fmodf</tt></td><td> <tt>fmod</tt></td><td> <tt>fmodl</tt></td></tr><tr><th> frexp</th><td> <tt>frexpf</tt></td><td> <tt>frexp</tt></td><td> <tt>frexpl</tt></td></tr><tr><th> hypot</th><td> <tt>hypotf</tt></td><td> <tt>hypot</tt></td><td> <tt>hypotl</tt></td></tr><tr><th> ilogb</th><td> <tt>ilogbf</tt></td><td> <tt>ilogb</tt></td><td> <tt>ilogbl</tt></td></tr><tr><th> ldexp</th><td> <tt>ldexpf</tt></td><td> <tt>ldexp</tt></td><td> <tt>ldexpl</tt></td></tr><tr><th> lgamma</th><td> <tt>lgammaf</tt></td><td> <tt>lgamma</tt></td><td> <tt>lgammal</tt></td></tr><tr><th> llrint</th><td> <tt>llrintf</tt></td><td> <tt>llrint</tt></td><td> <tt>llrintl</tt></td></tr><tr><th> llround</th><td> <tt>llroundf</tt></td><td> <tt>llround</tt></td><td> <tt>llroundl</tt></td></tr><tr><th> log10</th><td> <tt>log10f</tt></td><td> <tt>log10</tt></td><td> <tt>log10l</tt></td></tr><tr><th> log1p</th><td> <tt>log1pf</tt></td><td> <tt>log1p</tt></td><td> <tt>log1pl</tt></td></tr><tr><th> log2</th><td> <tt>log2f</tt></td><td> <tt>log2</tt></td><td> <tt>log2l</tt></td></tr><tr><th> logb</th><td> <tt>logbf</tt></td><td> <tt>logb</tt></td><td> <tt>logbl</tt></td></tr><tr><th> lrint</th><td> <tt>lrintf</tt></td><td> <tt>lrint</tt></td><td> <tt>lrintl</tt></td></tr><tr><th> lround</th><td> <tt>lroundf</tt></td><td> <tt>lround</tt></td><td> <tt>lroundl</tt></td></tr><tr><th> nearbyint</th><td> <tt>nearbyintf</tt></td><td> <tt>nearbyint</tt></td><td> <tt>nearbyintl</tt></td></tr><tr><th> nextafter</th><td> <tt>nextafterf</tt></td><td> <tt>nextafter</tt></td><td> <tt>nextafterl</tt></td></tr><tr><th> nexttoward</th><td> <tt>nexttowardf</tt></td><td> <tt>nexttoward</tt></td><td> <tt>nexttowardl</tt></td></tr><tr><th> remainder</th><td> <tt>remainderf</tt></td><td> <tt>remainder</tt></td><td> <tt>remainderl</tt></td></tr><tr><th> remquo</th><td> <tt>remquof</tt></td><td> <tt>remquo</tt></td><td> <tt>remquol</tt></td></tr><tr><th> rint</th><td> <tt>rintf</tt></td><td> <tt>rint</tt></td><td> <tt>rintl</tt></td></tr><tr><th> round</th><td> <tt>roundf</tt></td><td> <tt>round</tt></td><td> <tt>roundl</tt></td></tr><tr><th> scalbln</th><td> <tt>scalblnf</tt></td><td> <tt>scalbln</tt></td><td> <tt>scalblnl</tt></td></tr><tr><th> scalbn</th><td> <tt>scalbnf</tt></td><td> <tt>scalbn</tt></td><td> <tt>scalbnl</tt></td></tr><tr><th> tgamma</th><td> <tt>tgammaf</tt></td><td> <tt>tgamma</tt></td><td> <tt>tgammal</tt></td></tr><tr><th> trunc</th><td> <tt>truncf</tt></td><td> <tt>trunc</tt></td><td> <tt>truncl</tt></td></tr></table><h3><span class="prog__sub">Complex-only functions</span></h3><p>For all complex number functions that do not have real counterparts, a type-generic macro <code>cXXX</code> exists, which calls either of the variants of a complex function:</p><ul><li> <code>float complex</code> variant <code>cXXXf</code></li><li> <code>double complex</code> variant <code>cXXX</code></li><li> <code>long double complex</code> variant <code>cXXXl</code></li></ul><p>The function to call is determined as follows:<br></p><ul><li> If any of the arguments for the generic parameters is real, complex, or imaginary, then the appropriate complex function is called.</li></ul><table class="wikitable"><tr><th> Type-generic macro</th><th colspan="3"> Complex function <br> variants<br></th></tr><tr><th style="height: 8em;">  </th><th> <code>float</code></th><th> <code>double</code></th><th> <code>long double</code></th></tr><tr><th> carg</th><td> <tt>cargf</tt></td><td> <tt>carg</tt></td><td> <tt>cargl</tt></td></tr><tr><th> conj</th><td> <tt>conjf</tt></td><td> <tt>conj</tt></td><td> <tt>conjl</tt></td></tr><tr><th> creal</th><td> <tt>crealf</tt></td><td> <tt>creal</tt></td><td> <tt>creall</tt></td></tr><tr><th> cimag</th><td> <tt>cimagf</tt></td><td> <tt>cimag</tt></td><td> <tt>cimagl</tt></td></tr><tr><th> cproj</th><td> <tt>cprojf</tt></td><td> <tt>cproj</tt></td><td> <tt>cprojl</tt></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/tgmath.html
cabs	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       cabsf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      cabs( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double cabsl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define fabs( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex absolute value (also known as norm, modulus, or magnitude) of <code>z</code>.</ul><ul>4) Type-generic macro: if <code>z</code> has type <code>long double complex</code> or <code>long double imaginary</code>, <code>cabsl</code> is called. If <code>z</code>  has type <code>float complex</code> or <code>float imaginary</code>, <code>cabsf</code> is called. If <code>z</code> has type <code>double complex</code> or <code>double imaginary</code>, <code>cabs</code> is called. For real and integer types, the corresponding version of <code>fabs</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, returns the absolute value (norm, magnitude) of <code>z</code>.</p><p>Errors and special cases are handled as if the function is implemented as <code>hypot(creal(z), cimag(z))</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/cabs.html
cacos	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       cacosf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      cacos( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex cacosl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define acos( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex arc cosine of <code>z</code> with branch cuts outside the interval [−1,+1] along the real axis.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>cacosl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>cacos</code> is called, if <code>z</code> has type <code>float complex</code>, <code>cacosf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>acosf</code>, <code>acos</code>, <code>acosl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding complex number version.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, complex arc cosine of <code>z</code> is returned, in the range [0 ; ∞) along the real axis and in the range [−<i>i</i>π ; <i>i</i>π] along the imaginary axis.</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>cacos(conj(z)) == conj(cacos(z))</code></li><li> If <code>z</code> is <code>±0+0i</code>, the result is <code>π/2-0i</code></li><li> If <code>z</code> is <code>±0+NaNi</code>, the result is <code>π/2+NaNi</code></li><li> If <code>z</code> is <code>x+∞i</code> (for any finite x), the result is <code>π/2-∞i</code></li><li> If <code>z</code> is <code>x+NaNi</code> (for any nonzero finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised.</li><li> If <code>z</code> is <code>-∞+yi</code> (for any positive finite y), the result is <code>π-∞i</code></li><li> If <code>z</code> is <code>-∞+yi</code> (for any positive finite y), the result is <code>+0-∞i</code></li><li> If <code>z</code> is <code>-∞+∞i</code>, the result is <code>3π/4-∞i</code></li><li> If <code>z</code> is <code>+∞+∞i</code>, the result is <code>π/4-∞i</code></li><li> If <code>z</code> is <code>±∞+NaNi</code>, the result is <code>NaN±∞i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+∞i</code>, the result is <code>NaN-∞i</code></li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/cacos.html
cacosh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       cacoshf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      cacosh( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex cacoshl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define acosh( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes complex arc hyperbolic cosine of a complex value <code>z</code> with branch cut at values less than 1 along the real axis.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>cacoshl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>cacosh</code> is called, if <code>z</code> has type <code>float complex</code>, <code>cacoshf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>acoshf</code>, <code>acosh</code>, <code>acoshl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding complex number version and the return type is complex.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The complex arc hyperbolic cosine of <code>z</code> in the interval [0; ∞) along the real axis and in the interval [−iπ; +iπ] along the imaginary axis.</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>cacosh(conj(z)) == conj(cacosh(z))</code></li><li> If <code>z</code> is <code>±0+0i</code>, the result is <code>+0+iπ/2</code></li><li> If <code>z</code> is <code>+x+∞i</code> (for any finite x), the result is <code>+∞+iπ/2</code></li><li> If <code>z</code> is <code>+x+NaNi</code> (for any<sup class="reference" id="cite_ref-1">[1]</sup> finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised.</li><li> If <code>z</code> is <code>-∞+yi</code> (for any positive finite y), the result is <code>+∞+iπ</code></li><li> If <code>z</code> is <code>+∞+yi</code> (for any positive finite y), the result is <code>+∞+0i</code></li><li> If <code>z</code> is <code>-∞+∞i</code>, the result is <code>+∞+3iπ/4</code></li><li> If <code>z</code> is <code>±∞+NaNi</code>, the result is <code>+∞+NaNi</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised.</li><li> If <code>z</code> is <code>NaN+∞i</code>, the result is <code>+∞+NaNi</code></li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><ol class="references"><li id="cite_note-1">↑ per DR471, this holds for non-zero x only. If <code>z</code> is <code>0+NaNi</code>, the result should be <code>NaN+iπ/2</code></li></ol><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/cacosh.html
carg	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       cargf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      carg( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double cargl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define carg( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the argument (also called phase angle) of <code>z</code>, with a branch cut along the negative real axis.</ul><ul>4) Type-generic macro: if <code>z</code> has type <code>long double complex</code>, <code>long double imaginary</code>, or <code>long double</code>, <code>cargl</code> is called. If <code>z</code>  has type <code>float complex</code>, <code>float imaginary</code>, or <code>float</code>, <code>cargf</code> is called. If <code>z</code> has type <code>double complex</code>, <code>double imaginary</code>, <code>double</code>, or any integer type, <code>carg</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, returns the phase angle of <code>z</code> in the interval (−π; π).</p><p>Errors and special cases are handled as if the function is implemented as <code>atan2(cimag(z), creal(z))</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/carg.html
casin	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       casinf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      casin( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex casinl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define asin( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex arc sine of <code>z</code> with branch cuts outside the interval [−1,+1] along the real axis.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>casinl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>casin</code> is called, if <code>z</code> has type <code>float complex</code>, <code>casinf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>asinf</code>, <code>asin</code>, <code>asinl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>asinh</code>, implementing the formula asin(iy) = i asinh(y), and the return type of the macro is imaginary.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, complex arc sine of <code>z</code> is returned, in the range of a strip unbounded along the imaginary axis and in the interval [−π/2; +π/2] along the real axis.</p><p>Errors and special cases are handled as if the operation is implemented by <code>-I * casinh(I*z)</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/casin.html
casinh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       casinhf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      casinh( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex casinhl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define asinh( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex arc hyperbolic sine of <code>z</code> with branch cuts outside the interval [−i; +i] along the imaginary axis.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>casinhl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>casinh</code> is called, if <code>z</code> has type <code>float complex</code>, <code>casinhf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>asinhf</code>, <code>asinh</code>, <code>asinhl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>asin</code>, implementing the formula asinh(iy) = i asin(y), and the return type is imaginary.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the complex arc hyperbolic sine of <code>z</code> is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [−iπ/2; +iπ/2] along the imaginary axis.</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>casinh(conj(z)) == conj(casinh(z))</code></li><li> <code>casinh(-z) == -casinh(z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>x+∞i</code> (for any positive finite x), the result is <code>+∞+π/2</code></li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>+∞+yi</code> (for any positive finite y), the result is <code>+∞+0i</code></li><li> If <code>z</code> is <code>+∞+∞i</code>, the result is <code>+∞+iπ/4</code></li><li> If <code>z</code> is <code>+∞+NaNi</code>, the result is <code>+∞+NaNi</code></li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN+0i</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite nonzero y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+∞i</code>, the result is <code>±∞+NaNi</code> (the sign of the real part is unspecified)</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/casinh.html
catan	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       catanf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      catan( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex catanl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define atan( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex arc tangent of <code>z</code> with branch cuts outside the interval [−i,+i] along the imaginary axis.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>catanl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>catan</code> is called, if <code>z</code> has type <code>float complex</code>, <code>catanf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>atanf</code>, <code>atan</code>, <code>atanl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>atanh</code>, implementing the formula atan(iy) = i atanh(y), and the return type of the macro is imaginary.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, complex arc tangent of <code>z</code> is returned, in the range of a strip unbounded along the imaginary axis and in the interval [−π/2; +π/2] along the real axis.</p><p>Errors and special cases are handled as if the operation is implemented by <code>-I * catanh(I*z)</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/catan.html
catanh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       catanhf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      catanh( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex catanhl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define atanh( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex arc hyperbolic tangent of <code>z</code> with branch cuts outside the interval [−1; +1] along the real axis.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>catanhl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>catanh</code> is called, if <code>z</code> has type <code>float complex</code>, <code>catanhf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>atanhf</code>, <code>atanh</code>, <code>atanhl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of <code>atan</code>, implementing the formula atanh(iy) = i atan(y), and the return type is imaginary.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the complex arc hyperbolic tangent of <code>z</code> is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [−iπ/2; +iπ/2] along the imaginary axis.</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>catanh(conj(z)) == conj(catanh(z))</code></li><li> <code>catanh(-z) == -catanh(z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>+0+NaNi</code>, the result is <code>+0+NaNi</code></li><li> If <code>z</code> is <code>+1+0i</code>, the result is <code>+∞+0i</code> and <code>FE_DIVBYZERO</code> is raised</li><li> If <code>z</code> is <code>x+∞i</code> (for any finite positive x), the result is <code>+0+iπ/2</code></li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite nonzero x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>+∞+yi</code> (for any finite positive y), the result is <code>+0+iπ/2</code></li><li> If <code>z</code> is <code>+∞+∞i</code>, the result is <code>+0+iπ/2</code></li><li> If <code>z</code> is <code>+∞+NaNi</code>, the result is <code>+0+NaNi</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+∞i</code>, the result is <code>±0+iπ/2</code> (the sign of the real part is unspecified)</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/catanh.html
ccos	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       ccosf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      ccos( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex ccosl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define cos( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex cosine of <code>z</code>.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>ccosl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>ccos</code> is called, if <code>z</code> has type <code>float complex</code>, <code>ccosf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>cosf</code>, <code>cos</code>, <code>cosl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>cosh</code>, implementing the formula cos(iy) = cosh(y), and the return type is real.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the complex cosine of <code>z</code> is returned.</p><p>Errors and special cases are handled as if the operation is implemented by <code>ccosh(I*z)</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/ccos.html
ccosh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       ccoshf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      ccosh( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex ccoshl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define cosh( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex hyperbolic cosine of <code>z</code>.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>ccoshl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>ccosh</code> is called, if <code>z</code> has type <code>float complex</code>, <code>ccoshf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>coshf</code>, <code>cosh</code>, <code>coshl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>cos</code>, implementing the formula cosh(iy) = cos(y), and the return type is real.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, complex hyperbolic cosine of <code>z</code> is returned</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>ccosh(conj(z)) == conj(ccosh(z))</code></li><li> <code>ccosh(z) == ccosh(-z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>1+0i</code></li><li> If <code>z</code> is <code>+0+∞i</code>, the result is <code>NaN±0i</code> (the sign of the imaginary part is unspecified) and <code>FE_INVALID</code> is raised</li><li> If <code>z</code> is <code>+0+NaNi</code>, the result is <code>NaN±0i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>x+∞i</code> (for any finite non-zero x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> is raised</li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite non-zero x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>+∞+0i</code>, the result is <code>+∞+0i</code></li><li> If <code>z</code> is <code>+∞+yi</code> (for any finite non-zero y), the result is <code>+∞+cis(y)</code></li><li> If <code>z</code> is <code>+∞+∞i</code>, the result is <code>±∞+NaNi</code> (the sign of the real part is unspecified) and <code>FE_INVALID</code> is raised</li><li> If <code>z</code> is <code>+∞+NaN</code>, the result is <code>+∞+NaN</code></li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN±0i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite non-zero y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><p>where cis(y) is cos(y) + i sin(y)</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/ccosh.html
cexp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       cexpf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      cexp( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex cexpl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define exp( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex base-<i>e</i> exponential of <code>z</code>.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>cexpl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>cexp</code> is called, if <code>z</code> has type <code>float complex</code>, <code>cexpf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>expf</code>, <code>exp</code>, <code>expl</code>). If <code>z</code> is imaginary, the corresponding complex argument version is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, <i>e</i> raised to the power of <code>z</code>, e<span class="t-su">z<br/></span> is returned.</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>cexp(conj(z)) == conj(cexp(z))</code></li><li> If <code>z</code> is <code>±0+0i</code>, the result is <code>1+0i</code></li><li> If <code>z</code> is <code>x+∞i</code> (for any finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> is raised.</li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised.</li><li> If <code>z</code> is <code>+∞+0i</code>, the result is <code>+∞+0i</code></li><li> If <code>z</code> is <code>-∞+yi</code> (for any finite y), the result is <code>+0+cis(y)</code></li><li> If <code>z</code> is <code>+∞+yi</code> (for any finite nonzero y), the result is <code>+∞+cis(y)</code></li><li> If <code>z</code> is <code>-∞+∞i</code>, the result is <code>±0±0i</code> (signs are unspecified)</li><li> If <code>z</code> is <code>+∞+∞i</code>, the result is <code>±∞+NaNi</code> and <code>FE_INVALID</code> is raised (the sign of the real part is unspecified)</li><li> If <code>z</code> is <code>-∞+NaNi</code>, the result is <code>±0±0i</code> (signs are unspecified)</li><li> If <code>z</code> is <code>+∞+NaNi</code>, the result is <code>±∞+NaNi</code> (the sign of the real part is unspecified)</li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN+0i</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any nonzero y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><p>where cis(y) is cos(y) + i sin(y)</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/cexp.html
cimag	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       cimagf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      cimag( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double cimagl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define cimag( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Returns the imaginary part of <code>z</code>.</ul><ul>4) Type-generic macro: if <code>z</code> has type <code>long double complex</code>, <code>long double imaginary</code>, or <code>long double</code>, <code>cimagl</code> is called. If <code>z</code>  has type <code>float complex</code>, <code>float imaginary</code>, or <code>float</code>, <code>cimagf</code> is called. If <code>z</code> has type <code>double complex</code>, <code>double imaginary</code>, <code>double</code>, or any integer type, <code>cimag</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The imaginary part of <code>z</code>.</p><p>This function is fully specified for all possible inputs and is not subject to any errors described in math_errhandling</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/cimag.html
clog	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       clogf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      clog( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex clogl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define log( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex natural (base-<i>e</i>) logarithm of <code>z</code> with branch cut along the negative real axis.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>clogl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>clog</code> is called, if <code>z</code> has type <code>float complex</code>, <code>clogf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>logf</code>, <code>log</code>, <code>logl</code>). If <code>z</code> is imaginary, the corresponding complex number version is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the complex natural logarithm of <code>z</code> is returned, in the range of a strip in the interval [−iπ, +iπ] along the imaginary axis and mathematically unbounded along the real axis.</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> The function is continuous onto the branch cut taking into account the sign of imaginary part</li><li> <code>clog(conj(z)) == conj(clog(z))</code></li><li> If <code>z</code> is <code>-0+0i</code>, the result is <code>-∞+πi</code> and <code>FE_DIVBYZERO</code> is raised</li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>-∞+0i</code> and <code>FE_DIVBYZERO</code> is raised</li><li> If <code>z</code> is <code>x+∞i</code> (for any finite x), the result is <code>+∞+πi/2</code></li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>-∞+yi</code> (for any finite positive y), the result is <code>-∞+πi</code></li><li> If <code>z</code> is <code>+∞+yi</code> (for any finite positive y), the result is <code>-∞+0i</code></li><li> If <code>z</code> is <code>-∞+∞i</code>, the result is <code>+∞+3πi/4</code></li><li> If <code>z</code> is <code>+∞+∞i</code>, the result is <code>+∞+πi/4</code></li><li> If <code>z</code> is <code>±∞+NaNi</code>, the result is <code>+∞+NaNi</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+∞i</code>, the result is <code>+∞+NaNi</code></li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/clog.html
CMPLX	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>float complex       CMPLXF( float real, float imag );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>double complex      CMPLX( double real, double imag );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>long double complex CMPLXL( long double real, long double imag );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of <code>real</code> (converted to the specified argument type) and the imaginary part having the value of <code>imag</code> (converted to the specified argument type)</p><p>The expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions <code>real</code> and <code>imag</code> are also suitable.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  real</td><td> -</td><td>  the real part of the complex number to return</td></tr><tr class="t-par"><td>  imag</td><td> -</td><td>  the imaginary part of the complex number to return</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>A complex number composed of <code>real</code> and <code>imag</code> as the real and imaginary parts.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/CMPLX.html
complex	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define complex _Complex</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>This macro expands to a type specifier used to identify complex types.</p><p>A program may undefine and perhaps then redefine the <code>complex</code> macro.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/complex.html
Complex_I	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define _Complex_I /* unspecified */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>_Complex_I</code> macro expands to a value of type <code>const float _Complex</code> with the value of the imaginary unit.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/Complex_I.html
conj	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       conjf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      conj( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex conjl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define conj( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex conjugate of <code>z</code> by reversing the sign of the imaginary part.</ul><ul>4) Type-generic macro: if <code>z</code> has type <code>long double complex</code>, <code>long double imaginary</code>, or <code>long double</code>, <code>conjl</code> is called. If <code>z</code>  has type <code>float complex</code>, <code>float imaginary</code>, or <code>float</code>, <code>conjf</code> is called. If <code>z</code> has type <code>double complex</code>, <code>double imaginary</code>, <code>double</code>, or any integer type, <code>conj</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The complex conjugate of <code>z</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/conj.html
cpow	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       cpowf( float complex x, float complex y );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      cpow( double complex x, double complex y );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex cpowl( long double complex x, long double complex y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define pow( x, y )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex power function x<span class="t-su">y<br/></span>, with branch cut for the first parameter along the negative real axis.</ul><ul>4) Type-generic macro: If any argument has type <code>long double complex</code>, <code>cpowl</code> is called. if any argument has type <code>double complex</code>, <code>cpow</code> is called, if any argument has type <code>float complex</code>, <code>cpowf</code> is called. If the arguments are real or integer, then the macro invokes the corresponding real function (<code>powf</code>, <code>pow</code>, <code>powl</code>). If any argument is imaginary, the corresponding complex number version is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the complex power x<span class="t-su">y<br/></span>, is returned.</p><p>Errors and special cases are handled as if the operation is implemented by <code>cexp(y*clog(x))</code>, except that the implementation is allowed to treat special cases more carefully.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/cpow.html
cproj	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       cprojf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      cproj( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double cprojl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define cproj( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the projection of <code>z</code> on the Riemann sphere.</ul><ul>4) Type-generic macro: if <code>z</code> has type <code>long double complex</code>, <code>long double imaginary</code>, or <code>long double</code>, <code>cprojl</code> is called. If <code>z</code>  has type <code>float complex</code>, <code>float imaginary</code>, or <code>float</code>, <code>cprojf</code> is called. If <code>z</code> has type <code>double complex</code>, <code>double imaginary</code>, <code>double</code>, or any integer type, <code>cproj</code> is called.</ul><p>For most <code>z</code>, <code>cproj(z)==z</code>, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, <code>INFINITY+0.0*I</code> or <code>INFINITY-0.0*I</code>. The sign of the imaginary (zero) component is the sign of <code>cimag(z)</code>. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The projection of <code>z</code> on the Riemann sphere.</p><p>This function is fully specified for all possible inputs and is not subject to any errors described in math_errhandling</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/cproj.html
creal	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       crealf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      creal( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double creall( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define creal( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Returns the real part of <code>z</code>.</ul><ul>4) Type-generic macro: if <code>z</code> has type <code>long double complex</code>, <code>long double imaginary</code>, or <code>long double</code>, <code>creall</code> is called. If <code>z</code>  has type <code>float complex</code>, <code>float imaginary</code>, or <code>float</code>, <code>crealf</code> is called. If <code>z</code> has type <code>double complex</code>, <code>double imaginary</code>, <code>double</code>, or any integer type, <code>creal</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The real part of <code>z</code>.</p><p>This function is fully specified for all possible inputs and is not subject to any errors described in math_errhandling</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/creal.html
csin	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       csinf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      csin( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex csinl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define sin( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex sine of <code>z</code>.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>csinl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>csin</code> is called, if <code>z</code> has type <code>float complex</code>, <code>csinf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>sinf</code>, <code>sin</code>, <code>sinl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>sinh</code>, implementing the formula sin(iy) = i sinh(y), and the return type of the macro is imaginary.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the complex sine of <code>z</code>.</p><p>Errors and special cases are handled as if the operation is implemented by <code>-I * csinh(I*z)</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/csin.html
csinh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       csinhf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      csinh( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex csinhl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define sinh( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex hyperbolic sine of <code>z</code>.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>csinhl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>csinh</code> is called, if <code>z</code> has type <code>float complex</code>, <code>csinhf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>sinhf</code>, <code>sinh</code>, <code>sinhl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>sin</code>, implementing the formula sinh(iy) = i sin(y), and the return type is imaginary.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, complex hyperbolic sine of <code>z</code> is returned</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>csinh(conj(z)) == conj(csinh(z))</code></li><li> <code>csinh(z) == -csinh(-z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>+0+∞i</code>, the result is <code>±0+NaNi</code> (the sign of the real part is unspecified) and <code>FE_INVALID</code> is raised</li><li> If <code>z</code> is <code>+0+NaNi</code>, the result is <code>±0+NaNi</code></li><li> If <code>z</code> is <code>x+∞i</code> (for any positive finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> is raised</li><li> If <code>z</code> is <code>x+NaNi</code> (for any positive finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>+∞+0i</code>, the result is <code>+∞+0i</code></li><li> If <code>z</code> is <code>+∞+yi</code> (for any positive finite y), the result is <code>+∞+cis(y)</code></li><li> If <code>z</code> is <code>+∞+∞i</code>, the result is <code>±∞+NaNi</code> (the sign of the real part is  unspecified) and <code>FE_INVALID</code> is raised</li><li> If <code>z</code> is <code>+∞+NaNi</code>, the result is <code>±∞+NaNi</code> (the sign of the real part is  unspecified)</li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN+0i</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite nonzero y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><p>where cis(y) is cos(y) + i sin(y)</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/csinh.html
csqrt	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       csqrtf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      csqrt( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex csqrtl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define sqrt( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex square root of <code>z</code> with branch cut along the negative real axis.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>csqrtl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>csqrt</code> is called, if <code>z</code> has type <code>float complex</code>, <code>csqrtf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>sqrtf</code>, <code>sqrt</code>, <code>sqrtl</code>). If <code>z</code> is imaginary, the corresponding complex number version is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, returns the square root of <code>z</code>, in the range of the right half-plane, including the imaginary axis ([0; +∞) along the real axis and (−∞; +∞) along the imaginary axis.)</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> The function is continuous onto the branch cut taking into account the sign of imaginary part</li><li> <code>csqrt(conj(z)) == conj(csqrt(z))</code></li><li> If <code>z</code> is <code>±0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>x+∞i</code>, the result is <code>+∞+∞i</code> even if x is NaN</li><li> If <code>z</code> is <code>x+NaNi</code>, the result is <code>NaN+NaNi</code> (unless x is ±∞) and  <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>-∞+yi</code>, the result is <code>+0+∞i</code> for finite positive y</li><li> If <code>z</code> is <code>+∞+yi</code>, the result is <code>+∞+0i)</code> for finite positive y</li><li> If <code>z</code> is <code>-∞+NaNi</code>, the result is <code>NaN±∞</code> (sign of imaginary part unspecified)</li><li> If <code>z</code> is <code>+∞+NaNi</code>, the result is <code>+∞+NaNi</code></li><li> If <code>z</code> is <code>NaN+yi</code>, the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/csqrt.html
ctan	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       ctanf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      ctan( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex ctanl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define tan( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex tangent of <code>z</code>.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>ctanl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>ctan</code> is called, if <code>z</code> has type <code>float complex</code>, <code>ctanf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>tanf</code>, <code>tan</code>, <code>tanl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>tanh</code>, implementing the formula tan(iy) = i tanh(y), and the return type is imaginary.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the complex tangent of <code>z</code> is returned.</p><p>Errors and special cases are handled as if the operation is implemented by <code>-i * ctanh(i*z)</code>, where <code>i</code> is the imaginary unit.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/ctan.html
ctanh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float complex       ctanhf( float complex z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double complex      ctanh( double complex z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double complex ctanhl( long double complex z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define tanh( z )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complex hyperbolic tangent of <code>z</code>.</ul><ul>4) Type-generic macro: If <code>z</code> has type <code>long double complex</code>, <code>ctanhl</code> is called. if <code>z</code> has type <code>double complex</code>, <code>ctanh</code> is called, if <code>z</code> has type <code>float complex</code>, <code>ctanhf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>tanhf</code>, <code>tanh</code>, <code>tanhl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <code>tan</code>, implementing the formula tanh(iy) = i tan(y), and the return type is imaginary.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  z</td><td> -</td><td>  complex argument</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, complex hyperbolic tangent of <code>z</code> is returned</p><h3><span class="prog__sub">Error handling and special values</span></h3><p>Errors are reported consistent with math_errhandling</p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>ctanh(conj(z)) == conj(ctanh(z))</code></li><li> <code>ctanh(-z) == -ctanh(z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>x+∞i</code> (for any<sup class="reference" id="cite_ref-1">[1]</sup> finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> is raised</li><li> If <code>z</code> is <code>x+NaN</code> (for any<sup class="reference" id="cite_ref-2">[2]</sup> finite x), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>+∞+yi</code> (for any finite positive y), the result is <code>1+0i</code></li><li> If <code>z</code> is <code>+∞+∞i</code>, the result is <code>1±0i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>+∞+NaNi</code>, the result is <code>1±0i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN+0i</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any non-zero y), the result is <code>NaN+NaNi</code> and <code>FE_INVALID</code> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><ol class="references"><li id="cite_note-1">↑ per DR471, this only holds for non-zero x. If <code>z</code> is <code>0+∞i</code>, the result should be <code>0+NaNi</code></li><li id="cite_note-2">↑ per DR471, this only holds for non-zero x. If <code>z</code> is <code>0+NaNi</code>, the result should be <code>0+NaNi</code></li></ol><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/ctanh.html
I	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define I /* unspecified */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>I</code> macro expands to either <code>_Complex_I</code> or <code>_Imaginary_I</code>. If the implementation does not support imaginary types, then the macro always expands to <code>_Complex_I</code>.</p><p>A program may undefine and perhaps then redefine the macro <code>I</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/I.html
imaginary	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define imaginary _Imaginary</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>This macro expands to the keyword _Imaginary.</p><p>This is a convenience macro that makes it possible to use <code>float imaginary</code>, <code>double imaginary</code>, and <code>long double imaginary</code> as an alternative way to write the three pure imaginary C types <code>float _Imaginary</code>, <code>double _Imaginary</code>, and <code>long double _Imaginary</code></p><p>As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.<br></p><table class="t-rev-begin"><tr class="t-rev t-since-c99 t-until-c11"><td><p>A compiler that defines <code>__STDC_IEC_559_COMPLEX__</code> is not required to support imaginary numbers. POSIX recommends checking if the macro <code>_Imaginary_I</code> is defined to identify imaginary number support.</p></td><td><br/></td></tr><tr class="t-rev t-since-c11"><td><p>Imaginary numbers are supported if <code>__STDC_IEC_559_COMPLEX__</code> is defined.</p></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/imaginary.html
Imaginary_I	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><complex.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define _Imaginary_I /* unspecified */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>_Imaginary_I</code> macro expands to a value of type <code>const float _Imaginary</code> with the value of the imaginary unit.</p><p>As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.<br></p><table class="t-rev-begin"><tr class="t-rev t-since-c99 t-until-c11"><td><p>A compiler that defines <code>__STDC_IEC_559_COMPLEX__</code> is not required to support imaginary numbers. POSIX recommends checking if the macro <code>_Imaginary_I</code> is defined to identify imaginary number support.</p></td><td><br/></td></tr><tr class="t-rev t-since-c11"><td><p>Imaginary numbers are supported if <code>__STDC_IEC_559_COMPLEX__</code> is defined.</p></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/complex/Imaginary_I.html
FE_DFL_ENV	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_DFL_ENV  /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The macro constant <code>FE_DFL_ENV</code> expands to an expression of type <code>const fenv_t*</code>, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</p><p>Additional macros that begin with <code>FE_</code> followed by uppercase letters, and have the type <code>const fenv_t*</code>, may be supported by an implementation.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/FE_DFL_ENV.html
FE_exceptions	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_DIVBYZERO    /*implementation defined power of 2*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_INEXACT      /*implementation defined power of 2*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_INVALID      /*implementation defined power of 2*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_OVERFLOW     /*implementation defined power of 2*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_UNDERFLOW    /*implementation defined power of 2*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_ALL_EXCEPT  FE_DIVBYZERO | FE_INEXACT | \<br>                       FE_INVALID | FE_OVERFLOW |  \<br>                       FE_UNDERFLOW<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>All these macro constants (except <code>FE_ALL_EXCEPT</code>) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported. </p><p>The macro constant <code>FE_ALL_EXCEPT</code>, which expands to the bitwise OR of all other <code>FE_*</code>, is always defined and is zero if floating-point exceptions are not supported by the implementation.</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>FE_DIVBYZERO</code></td><td>  pole error occurred in an earlier floating-point operation</td></tr><tr class="t-dsc"><td> <code>FE_INEXACT</code></td><td>  inexact result: rounding was necessary to store the result of an earlier floating-point operation</td></tr><tr class="t-dsc"><td> <code>FE_INVALID</code></td><td>  domain error occurred in an earlier floating-point operation</td></tr><tr class="t-dsc"><td> <code>FE_OVERFLOW</code></td><td>  the result of an earlier floating-point operation was too large to be representable</td></tr><tr class="t-dsc"><td> <code>FE_UNDERFLOW</code></td><td>  the result of an earlier floating-point operation was subnormal with a loss of precision</td></tr><tr class="t-dsc"><td> <code>FE_ALL_EXCEPT</code></td><td>  bitwise OR of all supported floating-point exceptions</td></tr></table><p>The implementation may define additional macro constants in <code><fenv.h></code> to identify additional floating-point exceptions. All such constants begin with <code>FE_</code> followed by at least one uppercase letter.</p><p>See math_errhandling for further details.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions.html
FE_round	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_DOWNWARD     /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_TONEAREST    /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_TOWARDZERO   /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FE_UPWARD       /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Each of these macro constants expands to a nonnegative integer constant expression, which can be used with <code>fesetround</code> and <code>fegetround</code> to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in <code><fenv.h></code>, which should all begin with <code>FE_</code> followed by at least one uppercase letter. Each macro is only defined if it is supported.</p><p>On most implementations, these macro constants expand to the values equal to the values of <code>FLT_ROUNDS</code> and <code>float_round_style</code></p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>FE_DOWNWARD</code></td><td>  rounding towards negative infinity</td></tr><tr class="t-dsc"><td> <code>FE_TONEAREST</code></td><td>  rounding towards nearest integer</td></tr><tr class="t-dsc"><td> <code>FE_TOWARDZERO</code></td><td>  rounding towards zero</td></tr><tr class="t-dsc"><td> <code>FE_UPWARD</code></td><td>  rounding towards positive infinity</td></tr></table><p>Additional rounding modes may be supported by an implementation.<br></p><p>The current rounding mode affects the following:<br></p><ul><li> results of floating-point arithmetic operators outside of constant expressions</li></ul><pre><code>double x = 1;x/10; // 0.09999999999999999167332731531132594682276248931884765625   // or 0.1000000000000000055511151231257827021181583404541015625</code></pre><ul><li> results of standard library mathematical functions</li></ul><pre><code>sqrt(2); // 1.41421356237309492343001693370752036571502685546875      // or 1.4142135623730951454746218587388284504413604736328125</code></pre><ul><li> floating-point to floating-point implicit conversion and casts</li></ul><pre><code>double d = 1 + DBL_EPSILON;float f = d; //  1.00000000000000000000000           // or 1.00000011920928955078125</code></pre><ul><li> string conversions such as <code>strtod</code> or <code>printf</code></li></ul><pre><code>strtof("0.1", NULL); // 0.0999999940395355224609375                  // or 0.100000001490116119384765625</code></pre><ul><li> the library rounding functions <code>nearbyint</code>, <code>rint</code>, <code>lrint</code></li></ul><pre><code>lrint(2.1); // 2 or 3</code></pre><p>The current rounding mode does NOT affect the following:<br></p><ul><li> floating-point to integer implicit conversion and casts (always towards zero)</li><li> results of floating-point arithmetic operators in constant expressions (always to nearest)</li><li> the library functions <code>round</code>, <code>lround</code>, <code>ceil</code>, <code>floor</code>, <code>trunc</code></li></ul><p>As with any floating-point environment functionality, rounding is only guaranteed if <code>#pragma STDC FENV_ACCESS ON</code> is set.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/FE_round.html
feclearexcept	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int feclearexcept( int excepts );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Attempts to clear the floating-point exceptions that are listed in the bitmask argument <code>excepts</code>, which is a bitwise OR of the floating point exception macros.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  excepts</td><td> -</td><td>  bitmask listing the exception flags to clear</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> if all indicated exceptions were successfully cleared or if <code>excepts</code> is zero. Returns a non-zero value on error.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/feclearexcept.html
feenv	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int fegetenv( fenv_t* envp );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int fesetenv( const fenv_t* envp );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>1) Attempts to store the status of the floating-point environment in the object pointed to by <code>envp</code>.</p><p>2) Attempts to establish the floating-point environment from the object pointed to by <code>envp</code>. The value of that object must be previously obtained by a call to <code>feholdexcept</code> or <code>fegetenv</code> or be a floating-point macro constant. If any of the floating-point status flags are set in <code>envp</code>, they become set in the environment (and are then testable with <code>fetestexcept</code>), but the corresponding floating-point exceptions are not raised (execution continues uninterrupted)</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  envp</td><td> -</td><td>  pointer to the object of type <code>fenv_t</code> which holds the status of the floating-point environment</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> on success, non-zero otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/feenv.html
feexceptflag	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int fegetexceptflag( fexcept_t* flagp, int excepts );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int fesetexceptflag( const fexcept_t* flagp, int excepts );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument <code>excepts</code>, which is a bitwise OR of the floating point exception macros. </p><p>2) Attempts to copy the full contents of the floating-point exception flags that are listed in <code>excepts</code> from <code>flagp</code> into the floating-point environment. Does not raise any exceptions, only modifies the flags.</p><p>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in <code>flagp</code> in implementation-defined format.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  flagp</td><td> -</td><td>  pointer to an <code>fexcept_t</code> object where the flags will be stored or read from</td></tr><tr class="t-par"><td>  excepts</td><td> -</td><td>  bitmask listing the exception flags to get/set</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> on success, non-zero otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/feexceptflag.html
feholdexcept	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int feholdexcept( fenv_t* envp );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>First, saves the current floating-point environment to the object pointed to by <code>envp</code> (similar to <code>fegetenv</code>), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by <code>feupdateenv</code> or <code>fesetenv</code>.</p><p>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to <code>feupdateenv</code> after clearing the unwanted exceptions.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  envp</td><td> -</td><td>  pointer to the object of type <code>fenv_t</code> where the floating-point environment will be stored</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> on success, non-zero otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/feholdexcept.html
feraiseexcept	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int feraiseexcept( int excepts );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Attempts to raise all floating point exceptions listed in <code>excepts</code> (a bitwise OR of the floating point exception macros). If one of the exceptions is <code>FE_OVERFLOW</code> or <code>FE_UNDERFLOW</code>, this function may additionally raise <code>FE_INEXACT</code>. The order in which the exceptions are raised is unspecified, except that <code>FE_OVERFLOW</code> and <code>FE_UNDERFLOW</code> are always raised before <code>FE_INEXACT</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  excepts</td><td> -</td><td>  bitmask listing the exception flags to raise</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> if all listed exceptions were raised, non-zero value otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/feraiseexcept.html
feround	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int fesetround( int round );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int fegetround();</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>1) Attempts to establish the floating-point rounding direction equal to the argument argument <code>round</code>, which is expected to be one of the floating point rounding macros. </p><p>2) Returns the value of the floating point rounding macro that corresponds to the current rounding direction. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  round</td><td> -</td><td>  rounding direction, one of floating point rounding macros</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>1) <code>​0​</code> on success, non-zero otherwise.</p><p>2) the floating point rounding macro describing the current rounding direction or a negative value if the direction cannot be determined.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/feround.html
fetestexcept	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int fetestexcept( int excepts );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines which of the specified subset of the floating point exceptions are currently set. The argument <code>excepts</code> is a bitwise OR of the floating point exception macros.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  excepts</td><td> -</td><td>  bitmask listing the exception flags to test</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Bitwise OR of the floating-point exception macros that are both included in <code>excepts</code> and correspond to floating-point exceptions currently set.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/fetestexcept.html
feupdateenv	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><fenv.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int feupdateenv( const fenv_t* envp );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by <code>envp</code> (similar to <code>fesetenv</code>), then raises the floating-point exceptions that were saved.</p><p>This function may be used to end the non-stop mode established by an earlier call to <code>feholdexcept</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  envp</td><td> -</td><td>  pointer to the object of type <code>fenv_t</code> set by an earlier call to <code>feholdexcept</code> or <code>fegetenv</code> or equal to <code>FE_DFL_ENV</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> on success, non-zero otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/fenv/feupdateenv.html
abs	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int        abs( int n );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>long       labs( long n );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long long llabs( long long n );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><inttypes.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>intmax_t imaxabs( intmax_t n );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Computes the absolute value of an integer number.  The behavior is undefined if the result cannot be represented by the return type.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  n</td><td> -</td><td>  integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The absolute value of <code>n</code> (i.e. <code>|n|</code>), if it is representable.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/abs.html
acos	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       acosf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      acos( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double acosl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define acos( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the principal value of the arc cosine of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>acosl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>acos</code> is called. Otherwise, <code>acosf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>cacosf</code>, <code>cacos</code>, <code>cacosl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the arc cosine of <code>arg</code> (arccos(arg)) in the range [0 ; π], is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error occurs if <code>arg</code> is outside the range <code>[-1.0; 1.0]</code>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is +1, the value <code>+0</code> is returned.</li><li> If |arg| > 1, a domain error occurs and NaN is returned.</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/acos.html
acosh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       acoshf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      acosh( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double acoshl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define acosh( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the inverse hyperbolic cosine of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>acoshl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>acosh</code> is called. Otherwise, <code>acoshf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>cacoshf</code>, <code>cacosh</code>, <code>cacoshl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing the area of a hyperbolic sector</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the inverse hyperbolic cosine of <code>arg</code> (cosh<span class="t-su">-1<br/></span>(arg), or arcosh(arg)) on the interval [0, +∞], is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the argument is less than 1, a domain error occurs.<br></p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is less than 1, <code>FE_INVALID</code> is raised an NaN is returned</li><li> if the argument is 1, +0 is returned</li><li> if the argument is +∞, +∞ is returned</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/acosh.html
asin	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       asinf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      asin( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double asinl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define asin( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the principal values of the arc sine of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>asinl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>asin</code> is called. Otherwise, <code>asinf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>casinf</code>, <code>casin</code>, <code>casinl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3>If no errors occur, the arc sine of <code>arg</code> (arcsin(arg)) in the range [-<span class="t-mfrac"><table><tr><td>π</td></tr><tr><td>2</td></tr></table></span> ; +<span class="t-mfrac"><table><tr><td>π</td></tr><tr><td>2</td></tr></table></span>], is returned.<p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error occurs if <code>arg</code> is outside the range <code>[-1.0; 1.0]</code>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, it is returned unmodified</li><li> If |arg| > 1, a domain error occurs and NaN is returned.</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/asin.html
asinh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       asinhf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      asinh( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double asinhl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define asinh( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the inverse hyperbolic sine of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>asinhl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>asinh</code> is called. Otherwise, <code>asinhf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>casinhf</code>, <code>casinh</code>, <code>casinhl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing the area of a hyperbolic sector</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the inverse hyperbolic sine of <code>arg</code> (sinh<span class="t-su">-1<br/></span>(arg), or arsinh(arg)), is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0 or ±∞, it is returned unmodified</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/asinh.html
atan	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       atanf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      atan( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double atanl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define atan( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the principal value of the arc tangent of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>atanl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>atan</code> is called. Otherwise, <code>atanf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>catanf</code>, <code>catan</code>, <code>catanl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3>If no errors occur, the arc tangent of <code>arg</code> (arctan(arg)) in the range [- <span class="t-mfrac"><table><tr><td>π</td></tr><tr><td>2</td></tr></table></span> ; +<span class="t-mfrac"><table><tr><td>π</td></tr><tr><td>2</td></tr></table></span>] radians, is returned.<p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, it is returned unmodified</li><li> If the argument is +∞, +π/2 is returned</li><li> If the argument is -∞, -π/2 is returned</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/atan.html
atan2	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       atan2f( float y, float x );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      atan2( double y, double x );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double atan2l( long double y, long double x );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define atan2( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the arc tangent of <code>y/x</code> using the signs of arguments to determine the correct quadrant.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>atan2l</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>atan2</code> is called. Otherwise, <code>atan2f</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3>If no errors occur, the arc tangent of <code>y/x</code> (arctan(<span class="t-mfrac"><table><tr><td>y</td></tr><tr><td>x</td></tr></table></span>)) in the range [-π ; +π] radians, is returned.<p>If a domain error occurs, an implementation-defined value is returned.<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error may occur if <code>x</code> and <code>y</code> are both zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>x</code> and <code>y</code> are both zero, domain error <i>does not</i> occur</li><li> If <code>x</code> and <code>y</code> are both zero, range error does not occur either</li><li> If <code>y</code> is zero, pole error does not occur</li><li> If <code>y</code> is <code>±0</code> and <code>x</code> is negative or <code>-0</code>, <code>±π</code> is returned</li><li> If <code>y</code> is <code>±0</code> and <code>x</code> is positive or <code>+0</code>, <code>±0</code> is returned</li><li> If <code>y</code> is <code>±∞</code> and <code>x</code> is finite, <code>±π/2</code> is returned</li><li> If <code>y</code> is <code>±∞</code> and <code>x</code> is <code>-∞</code>, <code>±3π/4</code> is returned</li><li> If <code>y</code> is <code>±∞</code> and <code>x</code> is <code>+∞</code>, <code>±π/4</code> is returned</li><li> If <code>x</code> is <code>±0</code> and <code>y</code> is negative, <code>-π/2</code> is returned</li><li> If <code>x</code> is <code>±0</code> and <code>y</code> is positive, <code>+π/2</code> is returned</li><li> If <code>x</code> is <code>-∞</code> and <code>y</code> is finite and positive, <code>+π</code> is returned</li><li> If <code>x</code> is <code>-∞</code> and <code>y</code> is finite and negative, <code>-π</code> is returned</li><li> If <code>x</code> is <code>+∞</code> and <code>y</code> is finite and positive, <code>+0</code> is returned</li><li> If <code>x</code> is <code>+∞</code> and <code>y</code> is finite and negative, <code>-0</code> is returned</li><li> If either <code>x</code> is NaN or <code>y</code> is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/atan2.html
atanh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       atanhf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      atanh( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double atanhl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define atanh( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the inverse hyperbolic tangent of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>atanhl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>atanh</code> is called. Otherwise, <code>atanhf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>catanhf</code>, <code>catanh</code>, <code>catanhl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing the area of a hyperbolic sector</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the inverse hyperbolic tangent of <code>arg</code> (tanh<span class="t-su">-1<br/></span>(arg), or artanh(arg)), is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned (with the correct sign).</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the argument is not on the interval [-1, +1], a range error occurs.</p><p>If the argument is ±1, a pole error occurs.<br></p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0, it is returned unmodified</li><li> if the argument is ±1, ±∞ is returned and <code>FE_DIVBYZERO</code> is raised.</li><li> if |arg|>1, NaN is returned and <code>FE_INVALID</code> is raised.</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/atanh.html
cbrt	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       cbrtf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      cbrt( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double cbrtl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define cbrt( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the cubic root of <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>cbrtl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>cbrt</code> is called. Otherwise, <code>cbrtf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the cubic root of <code>arg</code> (<span>3</span><span>√</span><span>arg</span>), is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0 or ±∞, it is returned, unchanged</li><li> if the argument is NaN, NaN is returned.</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/cbrt.html
ceil	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       ceilf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      ceil( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double ceill( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define ceil( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the smallest integer value not less than <code>arg</code>. </ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>ceill</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>ceil</code> is called. Otherwise, <code>ceilf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the smallest integer value not less than <code>arg</code>, that is ⌈arg⌉, is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current rounding mode has no effect.</li><li> If <code>arg</code> is ±∞, it is returned, unmodified</li><li> If <code>arg</code> is ±0, it is returned, unmodified</li><li> If arg is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/ceil.html
copysign	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       copysignf( float x, float y );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      copysign( double x, double y );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double copysignl( long double x, long double y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define copysign(from, to)</code></td><td> (7) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Composes a floating point value with the magnitude of <code>x</code> and the sign of <code>y</code>. </ul><ul>4) Type-generic macro: If any argument has type <code>long double</code>, <code>copysignl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>copysign</code> is called. Otherwise, <code>copysignf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the floating point value with the magnitude of <code>x</code> and the sign of <code>y</code> is returned.</p><p>If <code>x</code> is NaN, then NaN with the sign of <code>y</code> is returned.</p><p>If <code>y</code> is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</p><h3><span class="prog__sub">Error handling</span></h3><p>This function is not subject to any errors specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The returned value is exact (<code>FE_INEXACT</code> is never raised) and independent of the current rounding mode.</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/copysign.html
cos	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       cosf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      cos( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double cosl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define cos( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the cosine of <code>arg</code> (measured in radians).</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>cosl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>cos</code> is called. Otherwise, <code>cosf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>ccosf</code>, <code>ccos</code>, <code>ccosl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing angle in radians</td></tr></table><h3><span class="prog__sub">Return value</span></h3><h3><span class="prog__sub"></span></h3><p>If no errors occur, the cosine of <code>arg</code> (cos(arg)) in the range [-1 ; +1], is returned.</p><table class="t-rev-begin"><tr class="t-rev t-until-cxx11"><td><p>The result may have little or no significance if the magnitude of <code>arg</code> is large.</p></td><td></td></tr></table><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0, the result is 1.0</li><li> if the argument is ±∞, NaN is returned and <code>FE_INVALID</code> is raised</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/cos.html
cosh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       coshf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      cosh( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double coshl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define cosh( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the hyperbolic cosine of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>coshl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>cosh</code> is called. Otherwise, <code>coshf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>ccoshf</code>, <code>ccosh</code>, <code>ccoshl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing a hyperbolic angle</td></tr></table><h3><span class="prog__sub">Return value</span></h3>If no errors occur, the hyperbolic cosine of <code>arg</code> (cosh(arg), or <span class="t-mfrac"><table><tr><td>e<span class="t-su">arg<br/></span>+e<span class="t-su">-arg<br/></span></td></tr><tr><td>2</td></tr></table></span>) is returned.<p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0, 1 is returned</li><li> If the argument is ±∞, +∞ is returned</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/cosh.html
div	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>div_t     div( int x, int y );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td> <code>ldiv_t    ldiv( long x, long y );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>lldiv_t   lldiv( long long x, long long y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><inttypes.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>imaxdiv_t imaxdiv( intmax_t x, intmax_t y );</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Computes both the quotient and the remainder of the division of the numerator <code>x</code> by the denominator <code>y</code>.</p><table class="t-rev-begin"><tr class="t-rev t-until-c99"><td><p>Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that <code>quot * y + rem == x</code>.</p></td><td>(until C99)</td></tr><tr class="t-rev t-since-c99"><td><p>Computes the quotient (the result of the expression <code>x/y</code>) and remainder (the result of the expression <code>x%y</code>) simultaneously.</p></td><td></td></tr></table><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  integer values</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, imaxdiv_t, respectively), returns both as an object of type <code>div_t</code>, <code>ldiv_t</code>, <code>lldiv_t</code>, <code>imaxdiv_t</code> defined as follows:</p><h2>  div_t </h2><pre><code>struct div_t { int quot; int rem; };</code></pre><p>or<br></p><pre><code>struct div_t { int rem; int quot; };</code></pre><h2>  ldiv_t </h2><pre><code>struct ldiv_t { long quot; long rem; };</code></pre><p>or<br></p><pre><code>struct ldiv_t { long rem; long quot; };</code></pre><h2>  lldiv_t </h2><pre><code>struct lldiv_t { long long quot; long long rem; };</code></pre><p>or<br></p><pre><code>struct lldiv_t { long long rem; long long quot; };</code></pre><h2>  imaxdiv_t </h2><pre><code>struct imaxdiv_t { intmax_t quot; intmax_t rem; };</code></pre><p>or<br></p><pre><code>struct imaxdiv_t { intmax_t rem; intmax_t quot; };</code></pre><p><br>If either the remainder or the quotient cannot be represented, the behavior is undefined.<br></p><p><br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/div.html
erf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       erff( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      erf( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double erfl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define erf( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the error function of <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>erfl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>erf</code> is called. Otherwise, <code>erff</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3>If no errors occur, value of the error function of <code>arg</code>, that is <span class="t-mfrac"><table><tr><td>2</td></tr><tr><td><span>√</span><span>π</span></td></tr></table></span><span style="font-size: 1.3em; vertical-align:-0.08em; margin-right: 0.08em;">∫</span><span class="t-su t-su-b">arg<br>0<br></span><i>e</i><sup>-t<span class="t-su">2<br/></span></sup>d<i>t</i>, is returned.If a range error occurs due to underflow, the correct result (after rounding), that is <span class="t-mfrac"><table><tr><td>2*arg</td></tr><tr><td><span>√</span><span>π</span></td></tr></table></span>, is returned.<h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, ±0 is returned</li><li> If the argument is ±∞, ±1 is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/erf.html
erfc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       erfcf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      erfc( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double erfcl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define erfc( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the complementary error function of <code>arg</code>, that is <code>1.0-erf(arg)</code>, but without loss of precision for large <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>erfcl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>erfc</code> is called. Otherwise, <code>erfcf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3>If no errors occur, value of the complementary error function of <code>arg</code>, that is <span class="t-mfrac"><table><tr><td>2</td></tr><tr><td><span>√</span><span>π</span></td></tr></table></span><span style="font-size: 1.3em; vertical-align:-0.08em; margin-right: 0.08em;">∫</span><span class="t-su t-su-b">∞<br>arg<br></span><i>e</i><sup>-t<span class="t-su">2<br/></span></sup>d<i>t</i> or 1-erf(arg), is returned.<p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is +∞, +0 is returned</li><li> If the argument is -∞, 2 is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/erfc.html
exp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       expf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      exp( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double expl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define exp( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the <i>e</i> (Euler's number, <code>2.7182818</code>) raised to the given power <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>expl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>exp</code> is called. Otherwise, <code>expf</code> is called. If <code>arg</code> is complex or imaginary, then the macro invokes the corresponding complex function (<code>cexpf</code>, <code>cexp</code>, <code>cexpl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the base-<i>e</i> exponential of <code>arg</code> (e<span class="t-su">arg<br/></span>) is returned.</p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, 1 is returned</li><li> If the argument is -∞, +0 is returned</li><li> If the argument is +∞, +∞ is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/exp.html
exp2	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       exp2f( float n );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      exp2( double n );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double exp2l( long double n );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define exp2( n )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes 2 raised to the given power <code>n</code>.</ul><ul>4) Type-generic macro: If <code>n</code> has type <code>long double</code>, <code>exp2l</code> is called. Otherwise, if <code>n</code> has integer type or the type <code>double</code>, <code>exp2</code> is called. Otherwise, <code>exp2f</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  n</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the base-<i>2</i> exponential of <code>n</code> (2<span class="t-su">n<br/></span>) is returned.</p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, 1 is returned</li><li> If the argument is -∞, +0 is returned</li><li> If the argument is +∞, +∞ is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/exp2.html
expm1	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       expm1f( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      expm1( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double expm1l( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define expm1( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the <i>e</i> (Euler's number, <code>2.7182818</code>) raised to the given power <code>arg</code>, minus <code>1.0</code>. This function is more accurate than the expression <code>std::exp(arg)-1.0</code> if <code>arg</code> is close to zero.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>expm1l</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>expm1</code> is called. Otherwise, <code>expm1f</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur e<span class="t-su">arg<br/></span>-1 is returned.</p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, it is returned, unmodified</li><li> If the argument is -∞, -1 is returned</li><li> If the argument is +∞, +∞ is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/expm1.html
fabs	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       fabsf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      fabs( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double fabsl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define fabs( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the absolute value of a floating point value <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>fabsl</code> is called. Otherwise, if the argument has integer type or has type <code>double</code>, <code>fabs</code> is called. Otherwise, <code>fabsf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>cabsf</code>, <code>cabs</code>, <code>cabsl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If successful, returns the absolute value of <code>arg</code> (<code>|arg|</code>). The value returned is exact and does not depend on any rounding modes.</p><h3><span class="prog__sub">Error handling</span></h3><p>This function is not subject to any of the error conditions specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, +0 is returned</li><li> If the argument is ±∞, +∞ is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/fabs.html
fdim	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       fdimf( float x, float y );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      fdim( double x, double y );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double fdiml( long double x, long double y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define fdim( x, y )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Returns the positive difference between <code>x</code> and <code>y</code>, that is, if <code>x>y</code>, returns <code>x-y</code>, otherwise (if <code>x≤y</code>), returns +0.</ul><ul>4) Type-generic macro: If any argument has type <code>long double</code>, <code>fdiml</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fdim</code> is called. Otherwise, <code>fdimf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If successful, returns the positive difference between x and y.<br></p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct value (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If either argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/fdim.html
float_t	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>typedef /*implementation defined*/ float_t</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>typedef /*implementation defined*/ double_t</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The types <code>float_t</code> and <code>double_t</code> are floating types at least as wide as <code>float</code> and <code>double</code>, respectively, and such that <code>double_t</code> is at least as wide as <code>float_t</code>. The value of <code>FLT_EVAL_METHOD</code> determines the types of <code>float_t</code> and <code>double_t</code>.</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  FLT_EVAL_METHOD</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>0</code></td><td> <code>float_t</code> and <code>double_t</code> are equivalent to <code>float</code> and <code>double</code>, respectively</td></tr><tr class="t-dsc"><td> <code>1</code></td><td>  both <code>float_t</code> and <code>double_t</code> are equivalent to <code>double</code></td></tr><tr class="t-dsc"><td> <code>2</code></td><td>  both <code>float_t</code> and <code>double_t</code> are equivalent to <code>long double</code></td></tr><tr class="t-dsc"><td> <code>other</code></td><td>  both <code>float_t</code> and <code>double_t</code> are implementation defined</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/float_t.html
floor	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       floorf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      floor( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double floorl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define floor( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the largest integer value not greater than <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>floorl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>floor</code> is called. Otherwise, <code>floorf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the largest integer value not greater than <code>arg</code>, that is ⌊arg⌋, is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current rounding mode has no effect.</li><li> If <code>arg</code> is ±∞, it is returned, unmodified</li><li> If <code>arg</code> is ±0, it is returned, unmodified</li><li> If arg is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/floor.html
fma	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       fmaf( float x, float y, float z );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      fma( double x, double y, double z );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double fmal( long double x, long double y, long double z );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_FAST_FMA  /* implementation-defined */</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_FAST_FMAF /* implementation-defined */</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_FAST_FMAL /* implementation-defined */</code></td><td> (6) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define fma( x, y, z )</code></td><td> (7) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes <code>(x*y) + z</code> as if to infinite precision and rounded only once to fit the result type.</ul><ul>4-6) If the macro constants <code>FP_FAST_FMAF</code>, <code>FP_FAST_FMA</code>, or <code>FP_FAST_FMAL</code> are defined, the corresponding function <code>fmaf</code>, <code>fma</code>, or <code>fmal</code> evaluates faster (in addition to being more precise) than the expression <code>x*y+z</code> for <code>float</code>, <code>double</code>, and <code>long double</code> arguments, respectively. If defined, these macros evaluate to integer <code>1</code>.</ul><ul>7) Type-generic macro: If any argument has type <code>long double</code>, <code>fmal</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fma</code> is called. Otherwise, <code>fmaf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y, z</td><td> -</td><td>  floating point values</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If successful, returns the value of <code>(x*y) + z</code> as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</p><p>If a range error due to overflow occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct value (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and <code>FE_INVALID</code> is raised</li><li> If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and <code>FE_INVALID</code> may be raised</li><li> If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and <code>FE_INVALID</code> is raised</li><li> If x or y are NaN, NaN is returned</li><li> If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/fma.html
fmax	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       fmaxf( float x, float y );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      fmax( double x, double y );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double fmaxl( long double x, long double y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define fmax( x, y )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).</ul><ul>4) Type-generic macro: If any argument has type <code>long double</code>, <code>fmaxl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fmax</code> is called. Otherwise, <code>fmaxf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>This function is not subject to any of the error conditions specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If one of the two arguments is NaN, the value of the other argument is returned</li><li> Only if both arguments are NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/fmax.html
fmin	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       fminf( float x, float y );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      fmin( double x, double y );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double fminl( long double x, long double y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define fmin( x, y )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).</ul><ul>4) Type-generic macro: If any argument has type <code>long double</code>, <code>fminl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fmin</code> is called. Otherwise, <code>fminf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>This function is not subject to any of the error conditions specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If one of the two arguments is NaN, the value of the other argument is returned</li><li> Only if both arguments are NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/fmin.html
fmod	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       fmodf( float x, float y );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      fmod( double x, double y );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double fmodl( long double x, long double y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define fmod( x, y )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the floating-point remainder of the division operation <code>x/y</code>.</ul><ul>4) Type-generic macro: If any argument has type <code>long double</code>, <code>fmodl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fmod</code> is called. Otherwise, <code>fmodf</code> is called.</ul><p>The floating-point remainder of the division operation <code>x/y</code> calculated by this function is exactly the value <code>x - n*y</code>, where <code>n</code> is <code>x/y</code> with its fractional part truncated.</p><p>The returned value has the same sign as <code>x</code> and is less or equal to <code>y</code> in magnitude.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If successful, returns the floating-point remainder of the division <code>x/y</code> as defined above.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error may occur if <code>y</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>x</code> is ±0 and <code>y</code> is not zero, ±0 is returned</li><li> If <code>x</code> is ±∞ and <code>y</code> is not NaN, NaN is returned and <code>FE_INVALID</code> is raised</li><li> If <code>y</code> is ±0 and <code>x</code> is not NaN, NaN is returned  and <code>FE_INVALID</code> is raised</li><li> If <code>y</code> is ±∞ and <code>x</code> is finite, <code>x</code> is returned. </li><li> If either argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/fmod.html
FP_categories	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_NORMAL    /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_SUBNORMAL /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_ZERO      /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_INFINITE  /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_NAN       /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>FP_NORMAL</code>, <code>FP_SUBNORMAL</code>, <code>FP_ZERO</code>, <code>FP_INFINITE</code>, <code>FP_NAN</code> macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>FP_NORMAL</code></td><td>  indicates that the value is <i>normal</i>, i.e. not an infinity, subnormal, not-a-number or zero</td></tr><tr class="t-dsc"><td> <code>FP_SUBNORMAL</code></td><td>  indicates that the value is <i>subnormal</i></td></tr><tr class="t-dsc"><td> <code>FP_ZERO</code></td><td>  indicates that the value is positive or negative zero</td></tr><tr class="t-dsc"><td> <code>FP_INFINITE</code></td><td>  indicates that the value is not representable by the underlying type (positive or negative infinity)</td></tr><tr class="t-dsc"><td> <code>FP_NAN</code></td><td>  indicates that the value is not-a-number (NaN)</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/FP_categories.html
fpclassify	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define fpclassify(arg) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Categorizes floating point value <code>arg</code> into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category. The macro returns an integral value.</p><p><code>FLT_EVAL_METHOD</code> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that: a normal long double value might become subnormal when converted to double and zero when converted to float.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>One of <code>FP_INFINITE</code>, <code>FP_NAN</code>, <code>FP_NORMAL</code>, <code>FP_SUBNORMAL</code>, <code>FP_ZERO</code> or implementation-defined type, specifying the category of <code>arg</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/fpclassify.html
frexp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       frexpf( float arg, int* exp );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      frexp( double arg, int* exp );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double frexpl( long double arg, int* exp );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define frexp( arg, exp )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Decomposes given floating point value <code>x</code> into a normalized fraction and an integral power of two.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>frexpl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>frexp</code> is called. Otherwise, <code>frexpf</code> is called, respectively.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  exp</td><td> -</td><td>  pointer to integer value to store the exponent to</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If <code>arg</code> is zero, returns zero and stores zero in <code>*exp</code>.</p><p>Otherwise (if <code>arg</code> is not zero), if no errors occur, returns the value <code>x</code> in the range  <code>(-1;-0.5], [0.5; 1)</code> and stores an integer value in <code>*exp</code> such that x×2<span class="t-su">(*exp)<br/></span>=arg.</p><p>If the value to be stored in <code>*exp</code> is outside the range of <code>int</code>, the behavior is unspecified.</p><p>If <code>arg</code> is not a floating-point number, the behavior is unspecified.</p><h3><span class="prog__sub">Error handling</span></h3><p>This function is not subject to any errors specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>arg</code> is ±0, it is returned, unmodified, and <code>0</code> is stored in <code>*exp</code>.</li><li> If <code>arg</code> is ±∞, it is returned, and an unspecified value is stored in <code>*exp</code>.</li><li> If <code>arg</code> is NaN, NaN is returned, and an unspecified value is stored in <code>*exp</code>.</li><li> No floating-point exceptions are raised.</li><li> If <code>FLT_RADIX</code> is 2 (or a power of 2), the returned value is exact, the current rounding mode is ignored</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/frexp.html
HUGE_VAL	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define HUGE_VALF /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define HUGE_VAL  /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define HUGE_VALL /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>HUGE_VALF</code>, <code>HUGE_VAL</code> and <code>HUGE_VALL</code> macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see math_errhandling).</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>HUGE_VALF</code></td><td>  Expands to positive <code>float</code> expression that indicates overflow</td></tr><tr class="t-dsc"><td> <code>HUGE_VAL</code></td><td>  Expands to positive <code>double</code> expression that indicates overflow, not necessarily representable as a <code>float</code></td></tr><tr class="t-dsc"><td> <code>HUGE_VALL</code></td><td>  Expands to positive <code>long double</code> expression that indicates overflow, not necessarily representable as a <code>float</code> or <code>double</code></td></tr></table><p>On implementations that support floating-point infinities, these macros always expand to the positive infinities of <code>float</code>, <code>double</code>, and <code>long double</code>, respectively.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/HUGE_VAL.html
hypot	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       hypotf( float x, float y );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      hypot( double x, double y );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double hypotl( long double x, long double y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define hypot( x, y )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the square root of the sum of the squares of <code>x</code> and <code>y</code>, without undue overflow or underflow at intermediate stages of the computation.</ul><ul>4) Type-generic macro: If any argument has type <code>long double</code>, the long double version of the function is called. Otherwise, if any argument has integer type or has type <code>double</code>, the double version of the function is called. Otherwise, the <code>float</code> version of the function is called.</ul><p>The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length <code>x</code> and <code>y</code>, or the distance of the point <code>(x,y)</code> from the origin <code>(0,0)</code>, or the magnitude of a complex number <code>x+<i>i</i>y</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the hypotenuse of a right-angled triangle, <span>√</span><span>x<span class="t-su">2<br/></span>+y<span class="t-su">2<br/></span></span>, is returned.</p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> <code>hypot(x, y)</code>, <code>hypot(y, x)</code>, and <code>hypot(x, -y)</code> are equivalent</li><li> if one of the arguments is ±0, <code>hypot</code> is equivalent to <code>fabs</code> called with the non-zero argument</li><li> if one of the arguments is ±∞, <code>hypot</code> returns +∞ even if the other argument is NaN</li><li> otherwise, if any of the arguments is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/hypot.html
ilogb	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int ilogbf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int ilogb( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>int ilogbl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define ilogb( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_ILOGB0 /*implementation-defined*/</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FP_ILOGBNAN /*implementation-defined*/</code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Extracts the value of the unbiased exponent from the floating-point argument <code>arg</code>, and returns it as a signed integer value. </ul><ul>4) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>ilogbl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>ilogb</code> is called. Otherwise, <code>ilogbf</code> is called.</ul><ul>5) Expands to integer constant expression whose value is either <code>INT_MIN</code> or <code>-INT_MAX</code>.</ul><ul>6) Expands to integer constant expression whose value is either <code>INT_MIN</code> or <code>+INT_MAX</code>.</ul><p>Formally, the unbiased exponent is the integral part of log<span class="t-su t-su-b">r</span>|arg| as a signed integral value, for non-zero arg, where <code>r</code> is <code>FLT_RADIX</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the unbiased exponent of <code>arg</code> is returned as a signed int value.</p><p>If <code>arg</code> is zero, <code>FP_ILOGB0</code> is returned.</p><p>If <code>arg</code> is infinite, <code>INT_MAX</code> is returned.</p><p>If <code>arg</code> is a NaN, <code>FP_ILOGBNAN</code> is returned.</p><p>If the correct result is greater than <code>INT_MAX</code> or smaller than <code>INT_MIN</code>, the return value is unspecified and a domain error or range error may occur </p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>A domain error or range error may occur if <code>arg</code> is zero, infinite, or NaN.</p><p>If the correct result is greater than <code>INT_MAX</code> or smaller than <code>INT_MIN</code>, a domain error or a range error may occur </p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the correct result is greater than <code>INT_MAX</code> or smaller than <code>INT_MIN</code>, <code>FE_INVALID</code> is raised.</li><li> If <code>arg</code> is ±0, ±∞, or NaN, <code>FE_INVALID</code> is raised.</li><li> In all other cases, the result is exact (<code>FE_INEXACT</code> is never raised) and the current rounding mode is ignored</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/ilogb.html
INFINITY	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define INFINITY /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>If the implementation supports floating-point infinities, the macro <code>INFINITY</code> expands to constant expression of type <code>float</code> which evaluates to positive or unsigned infinity.</p><p>If the implementation does not support floating-point infinities, the macro <code>INFINITY</code> expands to a positive value that is guaranteed to overflow a <code>float</code> at compile time, and the use of this macro generates a compiler warning.</p><p>The style used to print an infinity is implementation defined.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/INFINITY.html
isfinite	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define isfinite(arg) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. The macro returns an integral value.</p><p><code>FLT_EVAL_METHOD</code> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>arg</code> has finite value, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/isfinite.html
isgreater	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define isgreater(x, y) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is greater than the floating-point number (<code>y</code>), without setting floating-point exceptions. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>x > y</code>, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/isgreater.html
isgreaterequal	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define isgreaterequal(x, y) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is greater than or equal to the floating-point number <code>y</code>, without setting floating-point exceptions.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>x >= y</code>, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/isgreaterequal.html
isinf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define isinf(arg) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> is positive or negative infinity. The macro returns an integral value.</p><p><code>FLT_EVAL_METHOD</code> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>arg</code> has an infinite value, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/isinf.html
isless	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define isless(x, y) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is less than the floating-point number <code>y</code>, without setting floating-point exceptions.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>x < y</code>, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/isless.html
islessequal	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define islessequal(x, y) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is less than or equal to the floating-point number <code>y</code>, without setting floating-point exceptions. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>x <= y</code>, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/islessequal.html
islessgreater	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define islessgreater(x, y) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is less than or greater than the floating-point number <code>y</code>, without setting floating-point exceptions. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>x < y || x > y</code>, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/islessgreater.html
isnan	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define isnan(arg) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> is a not-a-number (NaN) value. The macro returns an integral value.</p><p><code>FLT_EVAL_METHOD</code> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that (this matters if the evaluation type supports NaNs, while the semantic type does not).</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>arg</code> is a NaN, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/isnan.html
isnormal	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define isnormal(arg) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> is normal, i.e. is neither zero, subnormal, infinite, nor <code>NaN</code>. The macro returns an integral value.</p><p><code>FLT_EVAL_METHOD</code> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>arg</code> is normal, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/isnormal.html
isunordered	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define isunordered(x, y) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point numbers <code>x</code> and <code>y</code> are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  y</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if either <code>x</code> or <code>y</code> is NaN, <code>​0​</code> otherwise.</p><p><br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/isunordered.html
ldexp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       ldexpf( float arg, int exp );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      ldexp( double arg, int exp );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double ldexpl( long double arg, int exp );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define ldexp( arg, exp )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Multiplies a floating point value <code>arg</code> by the number 2 raised to the <code>exp</code> power.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>ldexpl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>ldexp</code> is called. Otherwise, <code>ldexpf</code> is called, respectively.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  exp</td><td> -</td><td>  integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, <code>arg</code> multiplied by 2 to the power of <code>exp</code> (arg×2<span class="t-su">exp<br/></span>) is returned.</p><p>If a range error due to overflow occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> Unless a range error occurs, <code>FE_INEXACT</code> is never raised (the result is exact)</li><li> Unless a range error occurs, the current rounding mode is ignored</li><li> If <code>arg</code> is ±0, it is returned, unmodified</li><li> If <code>arg</code> is ±∞, it is returned, unmodified</li><li> If <code>exp</code> is 0, then <code>arg</code> is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/ldexp.html
lgamma	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       lgammaf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      lgamma( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double lgammal( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define lgamma( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the natural logarithm of the absolute value of the gamma function of <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>lgammal</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>lgamma</code> is called. Otherwise, <code>lgammaf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the value of the logarithm of the gamma function of <code>arg</code>, that is log<span class="t-su t-su-b">e</span>|<span style="font-size: 1.3em; vertical-align:-0.08em; margin-right: 0.08em;">∫</span><span class="t-su t-su-b">∞<br>0<br></span><i>t</i><span class="t-su">arg-1<br/></span> <i>e</i><sup>-t</sup> d<i>t</i>|, is returned.</p><p>If a pole error occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error due to overflow occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If <code>arg</code> is zero or is an integer less than zero, a pole error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is 1, +0 is returned</li><li> If the argument is 2, +0 is returned</li><li> If the argument is ±0, +∞ is returned and <code>FE_DIVBYZERO</code> is raised</li><li> If the argument is a negative integer, +∞ is returned and <code>FE_DIVBYZERO</code> is raised</li><li> If the argument is ±∞, +∞ is returned.</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/lgamma.html
log	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       logf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      log( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double logl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define log( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the natural (base <i>e</i>) logarithm of <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>logl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>log</code> is called. Otherwise, <code>logf</code> is called. If <code>arg</code> is complex or imaginary, then the macro invokes the corresponding complex function (<code>clogf</code>, <code>clog</code>, <code>clogl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the natural (base-<i>e</i>) logarithm of <code>arg</code> (ln(arg) or log<span class="t-su t-su-b">e</span>(arg)) is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error occurs if <code>arg</code> is less than zero.</p><p>Pole error may occur if <code>arg</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, -∞ is returned and <code>FE_DIVBYZERO</code> is raised.</li><li> If the argument is 1, +0 is returned</li><li> If the argument is negative, NaN is returned and <code>FE_INVALID</code> is raised.</li><li> If the argument is +∞, +∞ is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/log.html
log10	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       log10f( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      log10( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double log10l( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define log10( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the common (base-<i>10</i>) logarithm of <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>log10l</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>log10</code> is called. Otherwise, <code>log10f</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the common (base-<i>10</i>) logarithm of <code>arg</code> (log<span class="t-su t-su-b">10</span>(arg) or lg(arg)) is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error occurs if <code>arg</code> is less than zero.</p><p>Pole error may occur if <code>arg</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, -∞ is returned and <code>FE_DIVBYZERO</code> is raised.</li><li> If the argument is 1, +0 is returned</li><li> If the argument is negative, NaN is returned and <code>FE_INVALID</code> is raised.</li><li> If the argument is +∞, +∞ is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/log10.html
log1p	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       log1pf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      log1p( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double log1pl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define log1p( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the natural (base <code>e</code>) logarithm of <code>1+arg</code>. This function is more precise than the expression <code>log(1+arg)</code> if <code>arg</code> is close to zero.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>log1pl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>log1p</code> is called. Otherwise, <code>log1pf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur ln(1+arg) is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error occurs if <code>arg</code> is less than -1.</p><p>Pole error may occur if <code>arg</code> is -1.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, it is returned unmodified</li><li> If the argument is -1, -∞ is returned and <code>FE_DIVBYZERO</code> is raised.</li><li> If the argument is less than -1, NaN is returned and <code>FE_INVALID</code> is raised.</li><li> If the argument is +∞, +∞ is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/log1p.html
log2	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       log2f( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      log2( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double log2l( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define log2( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the base <code>2</code> logarithm of <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>log2l</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>log2</code> is called. Otherwise, <code>log2f</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the base-<i>2</i> logarithm of <code>arg</code> (log<span class="t-su t-su-b">2</span>(arg) or lb(arg)) is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error occurs if <code>arg</code> is less than zero.</p><p>Pole error may occur if <code>arg</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, -∞ is returned and <code>FE_DIVBYZERO</code> is raised.</li><li> If the argument is 1, +0 is returned</li><li> If the argument is negative, NaN is returned and <code>FE_INVALID</code> is raised.</li><li> If the argument is +∞, +∞ is returned</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/log2.html
logb	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       logbf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      logb( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double logbl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define logb( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Extracts the value of the unbiased radix-independent exponent from the floating-point argument <code>arg</code>, and returns it as a floating-point value. </ul><ul>4) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>logbl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>logb</code> is called. Otherwise, <code>logbf</code> is called.</ul><p>Formally, the unbiased exponent is the signed integral part of log<span class="t-su t-su-b">r</span>|arg| (returned by this function as a floating-point value), for non-zero arg, where <code>r</code> is <code>FLT_RADIX</code>. If <code>arg</code> is subnormal, it is treated as though it was normalized.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the unbiased exponent of <code>arg</code> is returned as a signed floating-point value.</p><p>If a domain error occurs, an implementation-defined value is returned<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain or range error may occur if <code>arg</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>arg</code> is ±0, -∞ is returned and <code>FE_DIVBYZERO</code> is raised.</li><li> If <code>arg</code> is ±∞, +∞ is returned</li><li> If <code>arg</code> is NaN, NaN is returned.</li><li> In all other cases, the result is exact (<code>FE_INEXACT</code> is never raised) and the current rounding mode is ignored</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/logb.html
math_errhandling	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define MATH_ERRNO        1</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define MATH_ERREXCEPT    2</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define math_errhandling  /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The macro constant <code>math_errhandling</code> expands to an expression of type <code>int</code> that is either equal to <code>MATH_ERRNO</code>, or equal to <code>MATH_ERREXCEPT</code>, or equal to their bitwise OR (<code>MATH_ERRNO | MATH_ERREXCEPT</code>).</p><p>The value of <code>math_errhandling</code> indicates the type of error handling that is performed by the floating-point operators and functions:</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>MATH_ERREXCEPT</code></td><td>  indicates that floating-point exceptions are used: at least <code>FE_DIVBYZERO</code>, <code>FE_INVALID</code>, and <code>FE_OVERFLOW</code> are defined in <code><fenv.h></code>.</td></tr><tr class="t-dsc"><td> <code>MATH_ERRNO</code></td><td>  indicates that floating-point operations use the variable <code>errno</code> to report errors.</td></tr></table><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559), <code>math_errhandling &amp; MATH_ERREXCEPT</code> is required to be non-zero.</p><p>The following floating-point error conditions are recognized:<br></p><table class="wikitable"><tr><th>Condition</th><th>Explanation</th><th>errno</th><th>floating-point exception</th><th>Example</th></tr><tr><td>Domain error</td><td>the argument is outside the range in which the operation is mathematically defined (the description of each function lists the required domain errors)</td><td><code>EDOM</code></td><td><code>FE_INVALID</code></td><td><code>acos(2)</code></td></tr><tr><td>Pole error</td><td>the mathematical result of the function is exactly infinite or undefined</td><td><code>ERANGE</code></td><td><code>FE_DIVBYZERO</code></td><td><code>log(0.0)</code>, <code>1.0/0.0</code></td></tr><tr><td>Range error due to overflow</td><td>the mathematical result is finite, but becomes infinite after rounding, or becomes the largest representable finite value after rounding down</td><td><code>ERANGE</code></td><td><code>FE_OVERFLOW</code></td><td><code>pow(DBL_MAX,2)</code></td></tr><tr><td>Range error due to underflow</td><td>the result is non-zero, but becomes zero after rounding, or becomes subnormal with a loss of precision</td><td><code>ERANGE</code> or unchanged (implementation-defined)</td><td><code>FE_UNDERFLOW</code> or nothing (implementation-defined)</td><td><code>DBL_MIN/2</code></td></tr><tr><td>Inexact result</td><td>the result has to be rounded to fit in the destination type</td><td>unchanged</td><td><code>FE_INEXACT</code> or nothing (unspecified)</td><td><code>sqrt(2)</code>, <code>1.0/10.0</code></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/math_errhandling.html
modf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       modff( float arg, float* iptr );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      modf( double arg, double* iptr );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double modfl( long double arg, long double* iptr );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Decomposes given floating point value <code>arg</code> into integral and fractional parts, each having the same type and sign as <code>arg</code>. The integral part (in floating-point format) is stored in the object pointed to by <code>iptr</code>.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  iptr</td><td> -</td><td>  pointer to floating point value to store the integral part to</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, returns the fractional part of <code>x</code> with the same sign as <code>x</code>. The integral part is put into the value pointed to by <code>iptr</code>.</p><p>The sum of the returned value and the value stored in <code>*iptr</code> gives <code>arg</code> (allowing for rounding).</p><h3><span class="prog__sub">Error handling</span></h3><p>This function is not subject to any errors specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>arg</code> is ±0, ±0 is returned, and ±0 is stored in <code>*iptr</code>.</li><li> If <code>arg</code> is ±∞, ±0 is returned, and ±∞ is stored in <code>*iptr</code>.</li><li> If <code>arg</code> is NaN, NaN is returned, and NaN is stored in <code>*iptr</code>.</li><li> The returned value is exact, the current rounding mode is ignored</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/modf.html
NAN.2	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define NAN /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The macro <code>NAN</code> expands to constant expression of type <code>float</code> which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</p><p>The style used to print a NaN is implementation defined.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/NAN.2.html
nan	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       nanf( const char* arg );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      nan( const char* arg );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double nanl( const char* arg );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts the implementation-defined character string <code>arg</code> into the corresponding quiet NaN value, as if by calling <code>strtof</code>, <code>strtod</code>, or <code>strtold</code>, respectively, as follows:</p><p>The call <code>nan("string")</code> is equivalent to the call <code>strtod("NAN(string)", (char**)NULL);</code>.</p><p>The call <code>nan("")</code> is equivalent to the call <code>strtod("NAN()", (char**)NULL);</code>.</p><p>The call <code>nan(NULL)</code> is equivalent to the call <code>strtod("NAN", (char**)NULL);</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  narrow character string identifying the contents of a NaN</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The quiet NaN value that corresponds to the identifying string <code>arg</code> or zero if the implementation does not support quiet NaNs. </p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/nan.html
nearbyint	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       nearbyintf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      nearbyint( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double nearbyintl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define nearbyint( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Rounds the floating-point argument <code>arg</code> to an integer value in floating-point format, using the current rounding mode.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>nearbyintl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>nearbyint</code> is called. Otherwise, <code>nearbyintf</code> is called, respectively.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The nearest integer value to <code>arg</code>, according to the current rounding mode, is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>This function is not subject to any of the errors specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> <code>FE_INEXACT</code> is never raised</li><li> If <code>arg</code> is ±∞, it is returned, unmodified</li><li> If <code>arg</code> is ±0, it is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/nearbyint.html
nextafter	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       nextafterf( float from, float to );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      nextafter( double from, double to );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double nextafterl( long double from, long double to );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>float       nexttowardf( float from, long double to );</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      nexttoward( double from, long double to );</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double nexttowardl( long double from, long double to );</code></td><td> (6) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define nextafter(from, to)</code></td><td> (7) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>#define nexttoward(from, to)</code></td><td> (8) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) First, converts both arguments to the type of the function, then returns the next representable value of <code>from</code> in the direction of <code>to</code>. If <code>from</code> equals to <code>to</code>, <code>to</code> is returned.</ul><ul>4-6) First, converts the first argument to the type of the function, then returns the next representable value of <code>from</code> in the direction of <code>to</code>. If <code>from</code> equals to <code>to</code>, <code>to</code> is returned, converted from <code>long double</code> to the return type of the function without loss of range or precision.</ul><ul>7) Type-generic macro: If any argument has type <code>long double</code>, <code>nextafterl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>nextafter</code> is called. Otherwise, <code>nextafterf</code> is called.</ul><ul>8) Type-generic macro: If the argument <code>from</code> has type <code>long double</code>, <code>nexttowardl</code> is called. Otherwise, if <code>from</code> has integer type or the type <code>double</code>, <code>nexttoward</code> is called. Otherwise, <code>nexttowardf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  from, to</td><td> -</td><td>  floating point values</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the next representable value of <code>from</code> in the direction of <code>to</code>. is returned. If <code>from</code> equals <code>to</code>, then <code>to</code> is returned, converted to the type of the function.</p><p>If a range error due to overflow occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned (with the same sign as <code>from</code>).</p><p>If a range error occurs due to underflow, the correct result is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if <code>from</code> is finite, but the expected result is an infinity, raises <code>FE_INEXACT</code> and <code>FE_OVERFLOW</code></li><li> if <code>from</code> does not equal <code>to</code> and the result is subnormal or zero, raises <code>FE_INEXACT</code> and <code>FE_UNDERFLOW</code></li><li> in any case, the returned value is independent of the current rounding mode</li><li> if either <code>from</code> or <code>to</code> is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/nextafter.html
pow	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float powf( float base, float exponent );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double pow( double base, double exponent );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double powl( long double base, long double exponent );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define pow( base, exponent )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the value of <code>base</code> raised to the power <code>exponent</code>.</ul><ul>4) Type-generic macro: If any argument has type <code>long double</code>, <code>powl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>pow</code> is called. Otherwise, <code>powf</code> is called. If at least one argument is complex or imaginary, then the macro invokes the corresponding complex function (<code>cpowf</code>, <code>cpow</code>, <code>cpowl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  base</td><td> -</td><td>  base as floating point value</td></tr><tr class="t-par"><td>  exponent</td><td> -</td><td>  exponent as floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, <code>base</code> raised to the power of <code>exponent</code> (base<span class="t-su">exponent<br/></span>) is returned. </p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error or a range error due to overflow occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If <code>base</code> is finite and negative and <code>exponent</code> is finite and non-integer, a domain error occurs and a range error may occur.</p><p>If <code>base</code> is zero and <code>exponent</code> is zero, a domain error may occur.</p><p>If <code>base</code> is zero and <code>exponent</code> is negative, a domain error or a pole error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> <code>pow(+0, exponent)</code>, where <code>exponent</code> is a negative odd integer, returns <code>+∞</code> and raises <code>FE_DIVBYZERO</code></li><li> <code>pow(-0, exponent)</code>, where <code>exponent</code> is a negative odd integer, returns <code>-∞</code> and raises <code>FE_DIVBYZERO</code></li><li> <code>pow(±0, exponent)</code>, where <code>exponent</code> is negative, finite, and is an even integer or a non-integer, returns +∞ and raises <code>FE_DIVBYZERO</code></li><li> <code>pow(±0, -∞)</code> returns +∞ and may raise <code>FE_DIVBYZERO</code></li><li> <code>pow(+0, exponent)</code>, where <code>exponent</code> is a positive odd integer, returns +0</li><li> <code>pow(-0, exponent)</code>, where <code>exponent</code> is a positive odd integer, returns -0</li><li> <code>pow(±0, exponent)</code>, where <code>exponent</code> is positive non-integer or a positive even integer, returns +0</li><li> <code>pow(-1, ±∞)</code> returns <code>1</code></li><li> <code>pow(+1, exponent)</code> returns <code>1</code> for any <code>exponent</code>, even when <code>exponent</code> is <code>NaN</code></li><li> <code>pow(base, ±0)</code> returns <code>1</code> for any <code>base</code>, even when <code>base</code> is <code>NaN</code></li><li> <code>pow(base, exponent)</code> returns <code>NaN</code> and raises <code>FE_INVALID</code> if <code>base</code> is finite and negative and <code>exponent</code> is finite and non-integer.</li><li> <code>pow(base, -∞)</code> returns +∞ for any <code>|base|<1</code></li><li> <code>pow(base, -∞)</code> returns +0 for any <code>|base|>1</code></li><li> <code>pow(base, +∞)</code> returns +0 for any <code>|base|<1</code></li><li> <code>pow(base, +∞)</code> returns +∞ for any <code>|base|>1</code></li><li> <code>pow(-∞, exponent)</code> returns -0 if <code>exponent</code> is a negative odd integer</li><li> <code>pow(-∞, exponent)</code> returns +0 if <code>exponent</code> is a negative non-integer or even integer</li><li> <code>pow(-∞, exponent)</code> returns -∞ if <code>exponent</code> is a positive odd integer</li><li> <code>pow(-∞, exponent)</code> returns +∞ if <code>exponent</code> is a positive non-integer or even integer</li><li> <code>pow(+∞, exponent)</code> returns +0 for any negative <code>exponent</code></li><li> <code>pow(+∞, exponent)</code> returns +∞ for any positive <code>exponent</code></li><li> except where specified above, if any argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/pow.html
remainder	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       remainderf( float x, float y );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      remainder( double x, double y );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double remainderl( long double x, long double y );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define remainder( x, y )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the IEEE remainder of the floating point division operation <code>x/y</code>.</ul><ul>4) Type-generic macro: If any argument has type <code>long double</code>, <code>remainderl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>remainder</code> is called. Otherwise, <code>remainderf</code> is called.</ul><p>The IEEE floating-point remainder of the division operation <code>x/y</code> calculated by this function is exactly the value <code>x - n*y</code>, where the value <code>n</code> is the integral value nearest the exact value <code>x/y</code>. When |n-x/y| = ½, the value <code>n</code> is chosen to be even.</p><p>In contrast to <code>fmod()</code>, the returned value is not guaranteed to have the same sign as <code>x</code>.</p><p>If the returned value is <code>0</code>, it will have the same sign as <code>x</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If successful, returns the IEEE floating-point remainder of the division <code>x/y</code> as defined above.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result is returned.<br></p><p>If <code>y</code> is zero, but the domain error does not occur, zero is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error may occur if <code>y</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current rounding mode has no effect.</li><li> <code>FE_INEXACT</code> is never raised, the result is always exact.</li><li> If <code>x</code> is ±∞ and <code>y</code> is not NaN, NaN is returned and <code>FE_INVALID</code> is raised</li><li> If <code>y</code> is ±0 and <code>x</code> is not NaN, NaN is returned  and <code>FE_INVALID</code> is raised</li><li> If either argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/remainder.html
remquo	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       remquof( float x, float y, int *quo );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      remquo( double x, double y, int *quo );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double remquol( long double x, long double y, int *quo );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define remquo( x, y, quo )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the floating-point remainder of the division operation <code>x/y</code> as the <code>remainder()</code> function does.  Additionally, the sign and at least the three of the last bits of <code>x/y</code> will be stored in <code>quo</code>, sufficient to determine the octant of the result within a period.</ul><ul>4) Type-generic macro: If any non-pointer argument has type <code>long double</code>, <code>remquol</code> is called. Otherwise, if any non-pointer argument has integer type or has type <code>double</code>, <code>remquo</code> is called. Otherwise, <code>remquof</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  x, y</td><td> -</td><td>  floating point values</td></tr><tr class="t-par"><td>  quo</td><td> -</td><td>  pointer to an integer value to store the sign and some bits of <code>x/y</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If successful, returns the floating-point remainder of the division <code>x/y</code> as defined in <code>remainder</code>, and stores, in <code>*quo</code>, the sign and at least three of the least significant bits of <code>x/y</code> (formally, stores a value whose sign is the sign of <code>x/y</code> and whose magnitude is congruent modulo 2<span class="t-su">n<br/></span> to the magnitude of the integral quotient of <code>x/y</code>, where n is an implementation-defined integer greater than or equal to 3).</p><p>If <code>y</code> is zero, the value stored in <code>*quo</code> is unspecified.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.<br></p><p>If <code>y</code> is zero, but the domain error does not occur, zero is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error may occur if <code>y</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current rounding mode has no effect.</li><li> <code>FE_INEXACT</code> is never raised</li><li> If <code>x</code> is ±∞ and <code>y</code> is not NaN, NaN is returned and <code>FE_INVALID</code> is raised</li><li> If <code>y</code> is ±0 and <code>x</code> is not NaN, NaN is returned  and <code>FE_INVALID</code> is raised</li><li> If either <code>x</code> or <code>y</code> is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/remquo.html
rint	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float rintf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double rint( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double rintl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define rint( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>long lrintf( float arg );</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long lrint( double arg );</code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long lrintl( long double arg );</code></td><td> (7) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define lrint( arg )</code></td><td> (8) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>long long llrintf( float arg );</code></td><td> (9) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long long llrint( double arg );</code></td><td> (10) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long long llrintl( long double arg );</code></td><td> (11) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define llrint( arg )</code></td><td> (12) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Rounds the floating-point argument <code>arg</code> to an integer value in floating-point format, using the current rounding mode.</ul><ul>5-7, 9-11) Rounds the floating-point argument <code>arg</code> to an integer value in integer format, using the current rounding mode.</ul><ul>4,8,12) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>rintl</code>, <code>lrintl</code>, <code>llrintl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>rint</code>, <code>lrint</code>, <code>llrint</code> is called. Otherwise, <code>rintf</code>, <code>lrintf</code>, <code>llrintf</code> is called, respectively.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the nearest integer value to <code>arg</code>, according to the current rounding mode, is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the result of <code>lrint</code> or <code>llrint</code> is outside the range representable by the return type, a domain error or a range error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><dl><dd> For the <code>rint</code> function:</dd></dl><ul><li> If <code>arg</code> is ±∞, it is returned, unmodified</li><li> If <code>arg</code> is ±0, it is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul><dl><dd> For <code>lrint</code> and <code>llrint</code> functions:</dd></dl><ul><li> If <code>arg</code> is ±∞, <code>FE_INVALID</code> is raised and an implementation-defined value is returned</li><li> If the result of the rounding is outside the range of the return type, <code>FE_INVALID</code> is raised and an implementation-defined value is returned</li><li> If <code>arg</code> is NaN, <code>FE_INVALID</code> is raised and an implementation-defined value is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/rint.html
round	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       roundf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      round( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double roundl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define round( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>long      lroundf( float arg );</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long      lround( double arg );</code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long      lroundl( long double arg );</code></td><td> (7) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define lround( arg )</code></td><td> (8) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>long long llroundf( float arg );</code></td><td> (9) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long long llround( double arg );</code></td><td> (10) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long long llroundl( long double arg );</code></td><td> (11) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define llround( arg )</code></td><td> (12) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the nearest integer value to <code>arg</code> (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.</ul><ul>5-7, 9-11) Computes the nearest integer value to <code>arg</code> (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.</ul><ul>4,8,12) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>roundl</code>, <code>lroundl</code>, <code>llroundl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>round</code>, <code>lround</code>, <code>llround</code> is called. Otherwise, <code>roundf</code>, <code>lroundf</code>, <code>llroundf</code> is called, respectively.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the nearest integer value to <code>arg</code>, rounding halfway cases away from zero, is returned.</p><p>If a domain error occurs, an implementation-defined value is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the result of <code>lround</code> or <code>llround</code> is outside the range representable by the return type, a domain error or a range error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><dl><dd> For the <code>round</code>, <code>roundf</code>, and <code>roundl</code> function:</dd></dl><ul><li> The current rounding mode has no effect.</li><li> If <code>arg</code> is ±∞, it is returned, unmodified</li><li> If <code>arg</code> is ±0, it is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul><dl><dd> For <code>lround</code> and <code>llround</code> families of functions:</dd></dl><ul><li> <code>FE_INEXACT</code> is never raised</li><li> The current rounding mode has no effect.</li><li> If <code>arg</code> is ±∞, <code>FE_INVALID</code> is raised and an implementation-defined value is returned</li><li> If the result of the rounding is outside the range of the return type, <code>FE_INVALID</code> is raised and an implementation-defined value is returned</li><li> If <code>arg</code> is NaN, <code>FE_INVALID</code> is raised and an implementation-defined value is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/round.html
scalbn	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       scalbnf( float arg, int exp );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      scalbn( double arg, int exp );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double scalbnl( long double arg, int exp );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define scalbn( arg, exp )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       scalblnf( float arg, long exp );</code></td><td> (5) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      scalbln( double arg, long exp );</code></td><td> (6) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double scalblnl( long double arg, long exp );</code></td><td> (7) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define scalbln( arg, exp )</code></td><td> (8) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3,5-7) Multiplies a floating point value <code>arg</code> by <code>FLT_RADIX</code> raised to power <code>exp</code>.</ul><ul>4,8) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>scalbnl</code> or <code>scalblnl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>scalbn</code> or <code>scalbln</code> is called. Otherwise, <code>scalbnf</code> or <code>scalblnf</code> is called, respectively.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr><tr class="t-par"><td>  exp</td><td> -</td><td>  integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, <code>arg</code> multiplied by <code>FLT_RADIX</code> to the power of <code>exp</code> (arg×FLT_RADIX<span class="t-su">exp<br/></span>) is returned.</p><p>If a range error due to overflow occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> Unless a range error occurs, <code>FE_INEXACT</code> is never raised (the result is exact)</li><li> Unless a range error occurs, the current rounding mode is ignored</li><li> If <code>arg</code> is ±0, it is returned, unmodified</li><li> If <code>arg</code> is ±∞, it is returned, unmodified</li><li> If <code>exp</code> is 0, then <code>arg</code> is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/scalbn.html
signbit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define signbit(arg) /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> is negative. The macro returns an integral value.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Nonzero integral value if <code>arg</code> is negative, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/signbit.html
sin	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       sinf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      sin( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double sinl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define sin( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the sine of <code>arg</code> (measured in radians).</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>sinl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>sin</code> is called. Otherwise, <code>sinf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>csinf</code>, <code>csin</code>, <code>csinl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing an angle in radians</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the sine of <code>arg</code> (sin(arg)) in the range [-1 ; +1], is returned.</p><table class="t-rev-begin"><tr class="t-rev t-until-c99"><td><p>The result may have little or no significance if the magnitude of <code>arg</code> is large.</p></td><td>(until C99)</td></tr></table><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0, it is returned unmodified</li><li> if the argument is ±∞, NaN is returned and <code>FE_INVALID</code> is raised</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/sin.html
sinh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       sinhf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      sinh( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double sinhl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define sinh( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes hyperbolic sine of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>sinhl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>sinh</code> is called. Otherwise, <code>sinhf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>csinhf</code>, <code>csinh</code>, <code>csinhl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing a hyperbolic angle</td></tr></table><h3><span class="prog__sub">Return value</span></h3>If no errors occur, the hyperbolic sine of <code>arg</code> (sinh(arg), or <span class="t-mfrac"><table><tr><td>e<span class="t-su">arg<br/></span>-e<span class="t-su">-arg<br/></span></td></tr><tr><td>2</td></tr></table></span>) is returned.<p>If a range error due to overflow occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0 or ±∞, it is returned unmodified</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/sinh.html
sqrt	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       sqrtf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      sqrt( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double sqrtl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define sqrt( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes square root of <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>sqrtl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>sqrt</code> is called. Otherwise, <code>sqrtf</code> is called. If <code>arg</code> is complex or imaginary, then the macro invokes the corresponding complex function (<code>csqrtf</code>, <code>csqrt</code>, <code>csqrtl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, square root of <code>arg</code> (<span>√</span><span>arg</span>), is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>Domain error occurs if <code>arg</code> is less than zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is less than -0, <code>FE_INVALID</code> is raised and NaN is returned.</li><li> If the argument is +∞ or ±0, it is returned, unmodified.</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/sqrt.html
tan	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       tanf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      tan( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double tanl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define tan( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the tangent of <code>arg</code>  (measured in radians).</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>tanl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>tan</code> is called. Otherwise, <code>tanf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>ctanf</code>, <code>ctan</code>, <code>ctanl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing angle in radians</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the tangent of <code>arg</code> (tan(arg)) is returned.</p><table class="t-rev-begin"><tr class="t-rev t-until-c99"><td><p>The result may have little or no significance if the magnitude of <code>arg</code> is large.</p></td><td>(until C99)</td></tr></table><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0, it is returned unmodified</li><li> if the argument is ±∞, NaN is returned and <code>FE_INVALID</code> is raised</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/tan.html
tanh	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       tanhf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      tanh( double arg );</code></td><td> (2) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double tanhl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define tanh( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the hyperbolic tangent of <code>arg</code>.</ul><ul>4) Type-generic macro: If the argument has type <code>long double</code>, <code>tanhl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>tanh</code> is called. Otherwise, <code>tanhf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>ctanhf</code>, <code>ctanh</code>, <code>ctanhl</code>).</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value representing a hyperbolic angle</td></tr></table><h3><span class="prog__sub">Return value</span></h3>If no errors occur, the hyperbolic tangent of <code>arg</code> (tanh(arg), or <span class="t-mfrac"><table><tr><td>e<span class="t-su">arg<br/></span>-e<span class="t-su">-arg<br/></span></td></tr><tr><td>e<span class="t-su">arg<br/></span>+e<span class="t-su">-arg<br/></span></td></tr></table></span>) is returned.<p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is ±0, ±0 is returned</li><li> If the argument is ±∞, ±1 is returned</li><li> if the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/tanh.html
tgamma	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       tgammaf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      tgamma( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double tgammal( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define tgamma( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the gamma function of <code>arg</code>.</ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>tgammal</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>tgamma</code> is called. Otherwise, <code>tgammaf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the value of the gamma function of <code>arg</code>, that is <span style="font-size: 1.3em; vertical-align:-0.08em; margin-right: 0.08em;">∫</span><span class="t-su t-su-b">∞<br>0<br></span><i>t</i><span class="t-su">arg-1<br/></span> <i>e</i><sup>-t</sup> d<i>t</i>, is returned.</p><p>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.<br></p><p>If a pole error occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned.</p><p>If a range error due to overflow occurs, <code>±HUGE_VAL</code>, <code>±HUGE_VALF</code>, or <code>±HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct value (after rounding) is returned.<br></p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If <code>arg</code> is zero or is an integer less than zero, a pole error or a domain error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is ±0, ±∞ is returned and <code>FE_DIVBYZERO</code> is raised</li><li> If the argument is a negative integer, NaN is returned and <code>FE_INVALID</code> is raised</li><li> If the argument is -∞, NaN is returned and <code>FE_INVALID</code> is raised</li><li> If the argument is +∞, +∞ is returned.</li><li> If the argument is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/tgamma.html
trunc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><math.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       truncf( float arg );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      trunc( double arg );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double truncl( long double arg );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dsc-header"><td> Defined in header <code><tgmath.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define trunc( arg )</code></td><td> (4) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1-3) Computes the nearest integer not greater in magnitude than <code>arg</code>. </ul><ul>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>truncl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>trunc</code> is called. Otherwise, <code>truncf</code> is called.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>If no errors occur, the nearest integer value not greater in magnitude than <code>arg</code> (in other words, <code>arg</code> rounded towards zero), is returned.</p><h3><span class="prog__sub">Error handling</span></h3><p>Errors are reported as specified in math_errhandling.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current rounding mode has no effect.</li><li> If <code>arg</code> is ±∞, it is returned, unmodified</li><li> If <code>arg</code> is ±0, it is returned, unmodified</li><li> If arg is NaN, NaN is returned</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/math/trunc.html
rand	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int rand();</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns a pseudo-random integer value between <code>​0​</code> and <code>RAND_MAX</code> (0 and <code>RAND_MAX</code> included).</p><p><code>srand()</code> seeds the pseudo-random number generator used by <code>rand()</code>.If <code>rand()</code> is used before any calls to <code>srand()</code>, <code>rand()</code> behaves as if it was seeded with <code>srand(1)</code>.Each time <code>rand()</code> is seeded with <code>srand()</code>, it must produce the same sequence of values.</p><p><code>rand()</code> is not guaranteed to be thread-safe.</p><h3><span class="prog__sub">Parameters</span></h3><p>(none)<br></p><h3><span class="prog__sub">Return value</span></h3><p>Pseudo-random integer value between <code>​0​</code> and <code>RAND_MAX</code>, inclusive.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/random/rand.html
RAND_MAX	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define RAND_MAX /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Expands to an integer constant expression equal to the maximum value returned by the function <code>rand()</code>. This value is implementation dependent. It's guaranteed that this value is at least <code>32767</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/random/RAND_MAX.html
srand	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void srand( unsigned seed );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Seeds the pseudo-random number generator used by <code>rand()</code> with the value <code>seed</code>.</p><p>If <code>rand()</code> is used before any calls to <code>srand()</code>, <code>rand()</code> behaves as if it was seeded with <code>srand(1)</code>.</p><p>Each time <code>rand()</code> is seeded with the same <code>seed</code>, it must produce the same sequence of values.</p><p><code>srand()</code> is not guaranteed to be thread-safe.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  seed</td><td> -</td><td>  the seed value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/numeric/random/srand.html
conditional	A										<section class="prog__container"><p>The preprocessor supports conditional compilation of parts of a source file. This behavior is controlled by <code>#if</code>, <code>#else</code>, <code>#elif</code>, <code>#ifdef</code>, <code>#ifndef</code> and <code>#endif</code> directives.</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>#if</code> <i>expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>#ifdef</code> <i>expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>#ifndef</code> <i>expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>#elif</code> <i>expression</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>#else</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>#endif</code></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>The conditional preprocessing block starts with <code>#if</code>, <code>#ifdef</code> or <code>#ifndef</code> directive, then optionally includes any number of <code>#elif</code> directives, then optionally includes at most one <code>#else</code> directive and is terminated with the <code>#endif</code> directive. Any inner conditional preprocessing blocks are processed separately.</p><p>Each of <code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#ifdef</code> and <code>#ifndef</code> directives control a code block until the first <code>#elif</code>, <code>#else</code>, <code>#endif</code> directive not belonging to any inner conditional preprocessing blocks. </p><p><code>#if</code>, <code>#ifdef</code> and <code>#ifndef</code>  directives test the specified condition (see below), and if it evaluates to true, compiles the controlled code block. In that case subsequent <code>#else</code> and <code>#elif</code> directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent <code>#else</code> or <code>#elif</code> directive (if any) is processed. In the former case, the code block controlled by the <code>#else</code> directive is unconditionally compiled. In the latter case, the <code>#elif</code> directive acts as if it were a <code>#if</code> directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent <code>#elif</code> and <code>#else</code> directives. The conditional preprocessing block is terminated by the <code>#endif</code> directive.</p><h3><span class="prog__sub">Conditional evaluation</span></h3><h4><code>#if, #elif</code></h4><p>The <i>expression</i> is a constant expression, using only literals and identifiers, defined using <tt>#define</tt> directive. Any identifier, which is not literal, non defined using <tt>#define</tt> directive, evaluates to <i>0</i>. </p><p>The expression may contain unary operators in form <code>defined</code> <i>identifier</i> or  <code>defined (</code><i>identifier</i><code>)</code> which return <code>1</code> if the <i>identifier</i> was defined using <tt>#define</tt> directive and <i>0</i> otherwise. If the <i>expression</i> evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with <code>​0​</code>.</p><table class="t-rev-begin"><tr class="t-rev t-until-c11"><td>Note: <code>#if cond1</code> ... <code>#elif cond2</code> is different from <code>#if cond1</code> ... <code>#else</code> followed by <code>#if cond3</code> because if <code>cond1</code> is true, the second <code>#if</code> is skipped and <code>cond3</code> does not need to be well-formed, while #elif's <code>cond2</code> must be a valid expression.</td><td></td></tr></table><h4><code>#ifdef, #ifndef</code></h4><p>Checks if the identifier was defined using <tt>#define</tt> directive. </p><p><code>#ifdef</code> <i>identifier</i> is essentially equivalent to <code>#if defined(</code> <i>identifier</i><code>)</code>.</p><p><code>#ifndef</code> <i>identifier</i> is essentially equivalent to <code>#if !defined(</code> <i>identifier</i><code>)</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/preprocessor/conditional.html
error	A										<section class="prog__container"><p>Shows the given error message and renders the program ill-formed.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td class="t-sdsc-nopad"> <code>#error</code> <i>error_message</i></td><td class="t-sdsc-nopad"></td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>After encountering the <code>#error</code> directive, an implementation displays the diagnostic message <i>error_message</i> and renders the program ill-formed (the compilation stops). </p><p><i>error_message</i> can consist of several words not necessarily in quotes.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/preprocessor/error.html
impl	A										<section class="prog__container"><p>Implementation defined behavior is controlled by <code>#pragma</code> directive.</p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#pragma</code> <i>pragma_params</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>_Pragma</code> <code>(</code> <i>string-literal</i> <code>)</code></td><td> (2)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><ul>1) Behaves in an implementation-defined manner (unless <i>pragma_params</i> is one of the standard pragmas shown below.</ul><ul>2) Removes the encoding prefix (if any), the outer quotes, and leading/trailing whitespace from <i>string-literal</i>, replaces each <code>\"</code> with <code>"</code> and each <code>\\</code> with <code>\</code>, then tokenizes the result (as in translation stage 3), and then uses the result as if the input to <code>#pragma</code> in (1).</ul><h3><span class="prog__sub">Explanation</span></h3><p>The pragma directive controls implementation-specific behavior of the compiler, such as disabling compiler warnings or changing alignment requirements. Any pragma that is not recognized is ignored.<br></p><h3><span class="prog__sub">Standard pragmas</span></h3><p>The following three pragmas are defined by the language standard:<br></p><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#pragma STDC FENV_ACCESS </code><i>arg</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#pragma STDC FP_CONTRACT </code><i>arg</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#pragma STDC CX_LIMITED_RANGE </code><i>arg</i></td><td> (3)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><p>where <i>arg</i> is either <code>ON</code> or <code>OFF</code> or <code>DEFAULT</code>. </p><ul>1) If set to <code>ON</code>, informs the compiler that the program will access or modify floating-point environment, which means that optimizations that could subvert flag tests and mode changes (e.g., global common subexpression elimination, code motion, and constant folding) are prohibited. The default value is implementation-defined, usually <code>OFF</code>.</ul><ul>2) Allows <i>contracting</i> of floating-point expressions, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of <code>(x*y) + z</code> with a single fused multiply-add CPU instruction. The default value is implementation-defined, usually <code>ON</code>.</ul><ul>3) Informs the compiler that multiplication, division, and absolute value of complex numbers may use simplified mathematical formulas (x+iy)×(u+iv) = (xu-yv)+i(yu+xv), (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u<span class="t-su">2<br/></span>+v<span class="t-su">2<br/></span>), and |x+iy| = <span>√</span><span>x<span class="t-su">2<br/></span>+y<span class="t-su">2<br/></span></span>, despite the possibility of intermediate overflow. In other words, the programmer guarantees that the range of the values that will be passed to those function is limited. The default value is <code>OFF</code></ul><h3><span class="prog__sub">Non-standard pragmas</span></h3><h4>#pragma once</h4><p><code>#pragma once</code> is a non-standard pragma that is supported by the vast majority of modern compilers. If it appears in a header file, it indicates that it is only to be parsed once, even if it is (directly or indirectly) included multiple times in the same source file.</p><p>Standard approach to preventing multiple inclusion of the same header is by using include guards:</p><pre><code>#ifndef FILENAME_H#define FILENAME_H// contents of the header#endif /* FILENAME_H */</code></pre><p>So that all but the first inclusion of the header in any translation unit are excluded from compilation.<br></p><p>With <code>#pragma once</code>, the same header appears as</p><pre><code>#pragma once// contents of the header</code></pre><p>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with <code>#pragma once</code> files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</p><h4>#pragma pack</h4><table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete </td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/preprocessor/impl.html
include	A										<section class="prog__container"><p>Includes another source file into the current source file at the line immediately after the directive.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#include <</code><i>filename</i><code>></code></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#include "</code><i>filename</i><code>"</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><p>Includes source file, identified by <i>filename</i>, into the current source file at the line immediately after the directive.</p><p>The first version of the directive searches only standard include directories. The standard C++ library, as well as standard C library, is implicitly included in standard include directories. The standard include directories can be controlled by the user through compiler options. <br></p><p>Version (2) first searches the directory where the current file resides and, only if the file is not found, searches the standard include directories.<br></p><p>In the case the file is not found, the program is ill-formed.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/preprocessor/include.html
line	A										<section class="prog__container"><p>Changes the current line number and file name in the preprocessor.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#line</code> <i>lineno</i></td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#line</code> <i>lineno</i> <code>"</code><i>filename</i><code>"</code></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><ul>1) Changes the current preprocessor line number to <i>lineno</i>. Occurrences of the macro <code>__LINE__</code> beyond this point will expand to <i>lineno</i> plus the number of actual source code lines encountered since.</ul><ul>2) Also changes the current preprocessor file name to <i>filename</i>. Occurrences of the macro <code>__FILE__</code> beyond this point will produce <i>filename</i>.</ul><p>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to <code>#line</code> as long as they expand to a valid decimal integer optionally following a valid character string.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/preprocessor/line.html
replace	A										<section class="prog__container"><p>The preprocessor supports text macro replacement and function-like text macro replacement.<br></p><h3><span class="prog__sub">Syntax</span></h3><table class="t-sdsc-begin"><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#define</code> <i>identifier</i> <i>replacement-list</i>(optional)</td><td> (1)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#define</code> <i>identifier</i><code>(</code> <i>parameters</i> <code>)</code> <i>replacement-list</i></td><td> (2)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#define</code> <i>identifier</i><code>(</code> <i>parameters</i><code>, ... )</code> <i>replacement-list</i></td><td> (3)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#define</code> <i>identifier</i><code>( ... )</code> <i>replacement-list</i></td><td> (4)</td><td> </td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr><tr class="t-sdsc"><td> <code>#undef </code> <i>identifier</i></td><td> (5)</td><td class="t-sdsc-nopad"></td></tr><tr><td class="t-sdsc-sep" colspan="10"></td></tr></table><h3><span class="prog__sub">Explanation</span></h3><h4><code>#define</code> directives</h4><p>The <code>#define</code> directives define the <i>identifier</i> as a macro, that is they instruct the compiler to replace all successive occurrences of <i>identifier</i> with <i>replacement-list</i>, which can be optionally additionally processed. If the identifier is already defined as any type of macro, the program is ill-formed unless the definitions are identical. </p><h5>Object-like macros</h5><p>Object-like macros replace every occurrence of a defined <i>identifier</i> with <i>replacement-list</i>. Version (1) of the <code>#define</code> directive behaves exactly like that.</p><h5>Function-like macros</h5><p>Function-like macros replace each occurrence of a defined <i>identifier</i> with <i>replacement-list</i>, additionally taking a number of arguments, which then replace corresponding occurrences of any of the <i>parameters</i> in the <i>replacement-list</i>. </p><p>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a ( as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching ) token, skipping intervening matched pairs of left and right parentheses.<br></p><p>The number of arguments must be the same as the number of arguments in the macro definition (<i>parameters</i>) or the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</p><p>Version (2) of the <code>#define</code> directive defines a simple function-like macro.</p><p>Version (3) of the <code>#define</code> directive defines a function-like macro with variable number of arguments. The additional arguments can be accessed using <code>__VA_ARGS__</code> identifier, which is then replaced with arguments, supplied with the identifier to be replaced.</p><p>Version (4) of the <code>#define</code> directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments can be accessed only with <code>__VA_ARGS__</code> identifier, which is then replaced with arguments, supplied with identifier to be replaced.</p><p>Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (such as <code>macro(array[x = y, x + 1])</code>), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.</p><h4><code>#</code> and <code>##</code> operators</h4><p>In function-like macros, a <code>#</code> operator before an identifier in the <i>replacement-list</i> runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called "stringification". If the result of stringification is not a valid string literal, the behavior is undefined.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>When <code>#</code> appears before <code>__VA_ARGS__</code>, the entire expanded __VA_ARGS__ is enclosed in quotes:</p><pre><code>#define showlist(...) puts(#__VA_ARGS__)showlist();            // expands to puts("")showlist(1, "x", int); // expands to puts("1, \"x\", int")</code></pre></td><td></td></tr></table><p>A <code>##</code> operator between any two successive identifiers in the <i>replacement-list</i> runs parameter replacement on the two identifiers and then concatenates the result. This operation is called "concatenation" or "token pasting". Only tokens that form a valid token together may be pasted: identifiers that form a longer identifier, digits that form a number, or operators <code>+</code> and <code>=</code> that form a <code>+=</code>. A comment cannot be created by pasting <code>/</code> and <code>*</code> because comments are removed from text before macro substitution is considered. If the result of concatenation is not a valid token, the behavior is undefined.</p><p>Note: some compilers offer an extension that allows ## to appear after a comma and before __VA_ARGS__, in which case the ## does nothing when __VA_ARGS__ is non-empty, but removes the comma when __VA_ARGS__ is empty: this makes it possible to define macros such as <code>fprintf (stderr, format, ##__VA_ARGS__)</code></p><h4><code>#undef</code> directive</h4><p>The <code>#undef</code> directive undefines the <i>identifier</i>, that is it cancels the previous definition of the <i>identifier</i> by <code>#define</code> directive. If the identifier does not have an associated macro, the directive is ignored.</p><h3><span class="prog__sub">Predefined macros</span></h3><p>The following macro names are predefined in any translation unit:<br></p><table class="t-dsc-begin"><tr class="t-dsc"><td> <code>__STDC__</code></td><td>   expands to the integer constant <code>1</code>. This macro is intended to indicate a conforming implementation <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_VERSION__</code><table><tr><td></td></tr></table></td><td>   expands to an integer constant of type <code>long</code> whose value increases with each version of the C standard:<ul><li> <code>199409L</code> </li><li> <code>199901L</code> </li><li> <code>201112L</code>  <br> (macro constant)<br></li></ul></td></tr><tr class="t-dsc"><td> <code>__STDC_HOSTED__</code><table><tr><td></td></tr></table></td><td>   expands to the integer constant <code>1</code> if the implementation is hosted (runs under an OS), <code>​0​</code> if freestanding (runs without an OS)  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__FILE__</code></td><td>   expands to the name of the current file, as a character string literal, can be changed by the #line directive <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__LINE__</code></td><td>   expands to the source file line number, an integer constant, can be changed by the #line directive <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__DATE__</code></td><td>   expands to the date of translation, a character string literal of the form "Mmm dd yyyy". The name of the month is as if generated by <code>asctime()</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__TIME__</code></td><td>   expands to the time of translation, a character string literal of the form "hh:mm:ss", as in the time generated by <code>asctime()</code> <br> (macro constant)<br></td></tr></table><p>The following additional macro names may be predefined by an implementation:<br></p><table class="t-dsc-begin"><tr class="t-dsc"><td> <code>__STDC_ISO_10646__</code><table><tr><td></td></tr></table></td><td>   expands to an integer constant of the form <code>yyyymmL</code>, if <code>wchar_t</code> uses Unicode, the date indicates the latest revision of Unicode supported <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_IEC_559__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if IEC 60559 is supported  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_IEC_559_COMPLEX__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if IEC 60559 complex arithmetic is supported  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_UTF_16__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if <code>char16_t</code> use UTF-16 encoding  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_UTF_32__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if <code>char32_t</code> use UTF-32 encoding  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_MB_MIGHT_NEQ_WC__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if wide character encoding of the basic character set may not equal their narrow encoding, such as on EBCDIC-based systems that use Unicode for wchar_t  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_ANALYZABLE__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if analyzability is supported  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_LIB_EXT1__</code><table><tr><td></td></tr></table></td><td>   expands to an integer constant <code>201112L</code> if bounds-checking interfaces are supported  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_NO_ATOMICS__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if atomic types and atomic operations library are not supported  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_NO_COMPLEX__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if complex types and complex math library are not supported  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_NO_THREADS__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if  multithreading is not supported  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_NO_VLA__</code><table><tr><td></td></tr></table></td><td>   expands to <code>1</code> if variable-length arrays are not supported  <br> (macro constant)<br></td></tr></table><p>The values of these macros (except for <code>__FILE__</code> and <code>__LINE__</code>) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</p><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>The predefined variable <code>__func__</code> (see function definition for details) is not a preprocessor macro, even though it is sometimes used together with <code>__FILE__</code> and <code>__LINE__</code>, e.g. by <code>assert</code>.</p></td><td></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/preprocessor/replace.html
_Exit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dcl t-since-c99 t-until-c11"><td> <code>void _Exit( int exit_code );</code></td><td class="t-dcl-nopad"> </td><td>  <br> <br></td></tr><tr class="t-dcl t-since-c11"><td> <code>_Noreturn void _Exit( int exit_code );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Causes normal program termination to occur without completely cleaning the resources.<br></p><p>Destructors of variables with automatic, thread local and static storage durations are not called. Functions passed to <code>at_quick_exit()</code> or <code>atexit()</code> are not called. Whether open resources such as files are closed is implementation defined. If <code>exit_code</code> is <code>EXIT_FAILURE</code>, an implementation-defined status, indicating <i>unsuccessful</i> termination, is returned. In other cases implementation-defined status value is returned. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  exit_code</td><td> -</td><td>  exit status of the program</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/_Exit.html
abort	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-until-c11"><td> <code>void abort(void);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>_Noreturn void abort(void);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Causes abnormal program termination unless <code>SIGABRT</code> is being caught by a signal handler passed to signal and the handler does not return.</p><p>Functions passed to <code>atexit()</code> are not called. Whether open resources such as files are closed is implementation defined. Implementation defined status is returned to the host environment that indicates unsuccessful execution. </p><h3><span class="prog__sub">Parameters</span></h3><p>(none)<br></p><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/abort.html
at_quick_exit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int at_quick_exit( void (*func)(void) );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Registers the function pointed to by <code>func</code> to be called on quick program termination (via <code>quick_exit</code>).</p><p>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least <code>32</code> functions.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  func</td><td> -</td><td>  pointer to a function to be called on normal program termination</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> if the registration succeeds, nonzero value otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/at_quick_exit.html
atexit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int atexit( void (*func)(void) );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Registers the function pointed to by <code>func</code> to be called on normal program termination (via <code>exit()</code> or returning from <code>main()</code>). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.</p><p>The same function may be registered more than once.<br></p><p><code>atexit</code> is thread-safe: calling the function from several threads does not induce a data race. </p><p>The implementation is guaranteed to support the registration of at least <code>32</code> functions. The exact limit is implementation-defined.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  func</td><td> -</td><td>  pointer to a function to be called on normal program termination</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> if the registration succeeds, nonzero value otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/atexit.html
exit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-until-c11"><td> <code>void exit( int exit_code );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>_Noreturn void exit( int exit_code );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Causes normal program termination to occur.<br></p><p>Several cleanup steps are performed:<br></p><ul><li> functions passed to <code>atexit</code> are called, in reverse order of registration</li><li> all C streams are flushed and closed</li><li> files created by <code>tmpfile</code> are removed</li><li> control is returned to the host environment. If <code>exit_code</code> is zero or <code>EXIT_SUCCESS</code>, an implementation-defined status, indicating successful termination is returned. If <code>exit_code</code> is <code>EXIT_FAILURE</code>, an implementation-defined status, indicating unsuccessful termination is returned. In other cases implementation-defined status value is returned.</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/exit.html
EXIT_status	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define EXIT_SUCCESS /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define EXIT_FAILURE /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> macros expand into integral expressions that can be used as arguments to the <code>exit</code> function (and, therefore, as the values to return from the main function), and indicate program execution status.</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>EXIT_SUCCESS</code></td><td>  successful execution of a program</td></tr><tr class="t-dsc"><td> <code>EXIT_FAILURE</code></td><td>  unsuccessful execution of a program</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/EXIT_status.html
getenv	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>char *getenv( const char *name );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t getenv_s( size_t *restrict len, char *restrict value,<br>                  rsize_t valuesz, const char *restrict name );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Searches for an environmental variable with name <code>name</code> in the host-specified environment list and returns a pointer to the string that is associated with the matched environment variable. The set of environmental variables and methods of altering it are implementation-defined. </ul><ul> This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions setenv(), unsetenv(), and putenv() may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</ul><ul> Modifying the string returned by <code>getenv</code> invokes undefined behavior.</ul><ul>2) Same as (1), except that the values of the environment variable is written to the user-provided buffer <code>value</code> (unless null) and the number of bytes written is stored in the user-provided location <code>*len</code> (unless null). If the environment variable is not set in the environment, zero is written to <code>*len</code> (unless null) and <code>'\\0'</code> is written to <code>value[0]</code> (unless null). In addition, the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>name</code> is a null pointer</li><li> <code>valuesz</code> is greater than <code>RSIZE_MAX</code></li><li> <code>value</code> is a null pointer and <code>valuesz</code> is not zero</li></ul></dd><dd>As all bounds-checked functions, <code>getenv_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  name</td><td> -</td><td>  null-terminated character string identifying the name of the environmental variable to look for</td></tr><tr class="t-par"><td>  len</td><td> -</td><td>  pointer to a user-provided location where getenv_s will store the length of the environment variable</td></tr><tr class="t-par"><td>  value</td><td> -</td><td>  pointer to a user-provided character array where getenv_s will store the contents of the environment variable</td></tr><tr class="t-par"><td>  valuesz</td><td> -</td><td>  maximum number of characters that getenv_s is allowed to write to dest (size of the buffer)</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) character string identifying the value of the environmental variable or null pointer if such variable is not found.</ul><ul>2) zero if the environment variable was found, non-zero if it was not found of if a runtime constrant violation occurred. On any error, writes zero to <code>*len</code> (unless <code>len</code> is a null pointer).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/getenv.html
jmp_buf	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><setjmp.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>typedef /* unspecified */ jmp_buf;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>jmp_buf</code> type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type <code>jmp_buf</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/jmp_buf.html
longjmp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><setjmp.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c11"><td> <code>void longjmp( jmp_buf env, int status );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>_Noreturn void longjmp( jmp_buf env, int status );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Loads the execution context <code>env</code> saved by a previous call to <code>setjmp</code>. This function does not return. Control is transferred to the call site of the macro <code>setjmp</code> that set up <code>env</code>. That <code>setjmp</code> then returns the value, passed as the <code>status</code>.</p><p>If the function that called <code>setjmp</code> has exited (whether by return or by a different <code>longjmp</code> higher up the stack), the behavior is undefined. In other words, only long jumps up the call stack are allowed.</p><table class="t-rev-begin"><tr class="t-rev t-since-c11"><td><p>Jumping across threads (if the function that called <code>setjmp</code>  was executed by another thread) is also undefined behavior.</p></td><td></td></tr></table><table class="t-rev-begin"><tr class="t-rev t-since-c99"><td><p>If when <code>setjmp</code> was called, a VLA or another variably-modified type variable was in scope and control left that scope, <code>longjmp</code> to that <code>setjmp</code> invokes undefined behavior even if control remained within the function.</p><p>On the way up the stack, <code>longjmp</code> does not deallocate any VLAs, memory leaks may occur if their lifetimes are terminated in this way:</p><pre><code>void g(int n){    int a[n]; // a may remain allocated    h(n); // does not return}void h(int n){    int b[n]; // b may remain allocated    longjmp(buf, 2); // might cause a memory leak for h's b and g's a}</code></pre></td><td></td></tr></table><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  env</td><td> -</td><td>  variable referring to the execution state of the program saved by <code>setjmp</code></td></tr><tr class="t-par"><td>  status</td><td> -</td><td>  the value to return from <code>setjmp</code>. If it is equal to <code>​0​</code>, <code>1</code> is used instead</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/longjmp.html
quick_exit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>_Noreturn void quick_exit( int exit_code );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Causes normal program termination to occur without completely cleaning the resources.<br></p><p>Functions passed to <code>at_quick_exit</code> are called in reverse order of their registration. After calling the registered functions, calls <code>_Exit(exit_code)</code></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  exit_code</td><td> -</td><td>  exit status of the program</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/quick_exit.html
raise	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><signal.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int raise( int sig );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Sends signal sig to the program. The signal handler, specified using <code>signal()</code>, is invoked.</p><p>If the user-defined signal handling strategy is not set using <code>signal()</code> yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  sig</td><td> -</td><td>  the signal to be sent. It can be an implementation-defined value or one of the following values:<table class="t-dsc-begin"><tr class="t-dsc"><td> <code> <table><tr><td>SIGABRT</td></tr><tr><td>SIGFPE</td></tr><tr><td>SIGILL</td></tr><tr><td>SIGINT</td></tr><tr><td>SIGSEGV</td></tr><tr><td>SIGTERM</td></tr></table></code></td><td>   defines signal types <br> (macro constant) <br></td></tr></table><p><br></p></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> upon success, non-zero value on failure.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/raise.html
setjmp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><setjmp.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define setjmp(env) /* implementation-defined */</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Saves the current execution context into a variable <code>env</code> of type <code>jmp_buf</code>. This variable can later be used to restore the current execution context by <code>longjmp</code> function. That is, when a call to <code>longjmp</code> function is made, the execution continues at the particular call site that constructed the <code>jmp_buf</code> variable passed to <code>longjmp</code>. In that case <code>setjmp</code> returns the value passed to <code>longjmp</code>.</p><p>The invocation of <code>setjmp</code> must appear only in one of the following contexts:</p><ul><li> the entire controlling expression of a selection or iteration statement (if, switch, for, while, do-while)</li></ul><pre><code>switch(setjmp(env)) { ..</code></pre><ul><li> one operand of a relational or equality operator with the other operand an integer constant expression, with the resulting expression being the entire controlling expression of a selection or iteration statement</li></ul><pre><code>if(setjmp(env) > 10) { ...</code></pre><ul><li> the operand of a unary ! operator with the resulting expression being the entire controlling expression of a selection or iteration statement</li></ul><pre><code>while(!setjmp(env)) { ...</code></pre><ul><li> the entire expression of an expression statement (possibly cast to <code>void</code>).</li></ul><pre><code>setjmp(env);</code></pre><p>If <code>setjmp</code> appears in any other context, the behavior is undefined.</p><p>Upon return to the scope of setjmp, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when longjmp was executed, except for the non-volatile local variables in setjmp's scope, whose values are indeterminate if they have been changed since the setjmp invocation.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  env</td><td> -</td><td>  variable to save the execution state of the program to.</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> if the macro was called by the original code and the execution context was saved to <code>env</code>.</p><p>Non-zero value if a non-local jump was just performed. The return value in the same as passed to <code>longjmp</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/setjmp.html
sig_atomic_t	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><signal.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>typedef /* unspecified */ sig_atomic_t;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/sig_atomic_t.html
SIG_ERR	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><signal.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIG_ERR /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>A value of type <code>void (*)(int)</code>. When returned by <code>signal</code>, indicates that an error has occurred.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/SIG_ERR.html
SIG_strategies	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><signal.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIG_DFL /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIG_IGN /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>SIG_DFL</code> and <code>SIG_IGN</code> macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for <code>signal()</code> function.</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>SIG_DFL</code></td><td>  default signal handling</td></tr><tr class="t-dsc"><td> <code>SIG_IGN</code></td><td>  signal is ignored</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/SIG_strategies.html
SIG_types	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><signal.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIGTERM /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIGSEGV /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIGINT /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIGILL /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIGABRT /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define SIGFPE /*implementation defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.<br></p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>SIGTERM</code></td><td>  termination request, sent to the program</td></tr><tr class="t-dsc"><td> <code>SIGSEGV</code></td><td>  invalid memory access (segmentation fault)</td></tr><tr class="t-dsc"><td> <code>SIGINT</code></td><td>  external interrupt, usually initiated by the user</td></tr><tr class="t-dsc"><td> <code>SIGILL</code></td><td>  invalid program image, such as invalid instruction</td></tr><tr class="t-dsc"><td> <code>SIGABRT</code></td><td>  abnormal termination condition, as is e.g. initiated by <code>abort()</code></td></tr><tr class="t-dsc"><td> <code>SIGFPE</code></td><td>  erroneous arithmetic operation such as divide by zero</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/SIG_types.html
signal	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><signal.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void (*signal( int sig, void (*handler) (int))) (int);</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Sets the error handler for signal <code>sig</code>. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.</p><p>When signal handler is set to a function and a signal occurs, it is implementation defined whether <code>signal(sig, SIG_DFL)</code> will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  sig</td><td> -</td><td>  the signal to set the signal handler to. It can be an implementation-defined value or one of the following values:<table class="t-dsc-begin"><tr class="t-dsc"><td> <code> <table><tr><td>SIGABRT</td></tr><tr><td>SIGFPE</td></tr><tr><td>SIGILL</td></tr><tr><td>SIGINT</td></tr><tr><td>SIGSEGV</td></tr><tr><td>SIGTERM</td></tr></table></code></td><td>   defines signal types <br> (macro constant) <br></td></tr></table><p><br></p></td></tr><tr class="t-par"><td>  handler</td><td> -</td><td>  the signal handler. This must be one of the following:<ul><li><code>SIG_DFL</code> macro. The signal handler is set to default signal handler.</li><li><code>SIG_IGN</code> macro. The signal is ignored.</li><li>pointer to a function. The signature of the function must be equivalent to the following:</li></ul><table class="t-dcl-begin"><tbody><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void fun(int sig);</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Previous signal handler on success or <code>SIG_ERR</code> on failure (setting a signal handler can be disabled on some implementations).</p><h3><span class="prog__sub">Signal handler</span></h3><p>The following limitations are imposed on the user-defined function that is installed as a signal handler.<br></p><p>If the user defined function returns when handling <code>SIGFPE</code>, <code>SIGILL</code> or <code>SIGSEGV</code>, the behavior is undefined.</p><p>If the signal handler is called as a result of <code>abort</code> or <code>raise</code>, the behavior is undefined if the signal handler calls <code>raise</code>.</p><p>If the signal handler is called NOT as a result of <code>abort</code> or <code>raise</code> (in other words, the signal handler is <i>asynchronous</i>), the behavior is undefined if</p><ul><li> the signal handler calls any function within the standard library, except</li></ul><dl><dd><ul><li> <code>abort</code></li><li> <code>_Exit</code></li><li> <code>quick_exit</code></li><li> <code>signal</code> with the first argument being the number of the signal currently handled (async handler can re-register itself, but not other signals). </li><li> atomic functions from stdatomic.h if the atomic arguments are lock-free</li><li> <code>atomic_is_lock_free</code> (with any kind of atomic arguments)</li></ul></dd></dl><ul><li> the signal handler refers to any object with static <span>or thread-local</span> <span></span> storage duration <span>that is not a lock-free atomic</span> <span></span> other than by assigning to a static <code>volatile std::sig_atomic_t</code>.</li></ul><p>On entry to the signal handler, the state of the floating-point environment and the values of all objects is unspecified, except for<br></p><ul><li> objects of type <code>volatile sig_atomic_t</code></li><li> objects of lock-free atomic types </li><li> side effects made visible through <code>atomic_signal_fence</code> </li></ul><p>On return from a signal handler, the value of any object modified by the signal handler that is not <code>volatile sig_atomic_t</code> or lock-free atomic is undefined.</p><p>The behavior is undefined if <code>signal</code> is used in a multithreaded program. It is not required to be thread-safe.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/signal.html
system	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int system( const char *command );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Calls the host environment's command processor with command parameter. Returns implementation-defined value (usually the value that the invoked program returns).<br></p><p>If command is <code>NULL</code> pointer, checks if host environment has a command processor and returns nonzero value only if the command processor exists.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  command</td><td> -</td><td>  character string identifying the command to be run in the command processor. If NULL pointer is given, command processor is checked for existence</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Implementation-defined value. If <code>command</code> is <code>NULL</code>, returns nonzero value only if command processor exists.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/program/system.html
byte	A										<section class="prog__container"><p>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array <code>{'\\x63','\\x61','\\x74','\\0'</code>} is an NTBS holding the string <code>"cat"</code> in ASCII encoding.</p><h3><span class="prog__sub">Functions</span></h3><table class="t-dsc-begin"><tr><td colspan="2"> <h5>   Character classification </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><ctype.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isalnum</td></tr></table></code></td><td>   checks if a character is alphanumeric <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isalpha</td></tr></table></code></td><td>   checks if a character is alphabetic <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>islower</td></tr></table></code></td><td>   checks if a character is lowercase <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isupper</td></tr></table></code></td><td>   checks if a character is an uppercase character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isdigit</td></tr></table></code></td><td>   checks if a character is a digit <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isxdigit</td></tr></table></code></td><td>   checks if a character is a hexadecimal character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iscntrl</td></tr></table></code></td><td>   checks if a character is a control character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isgraph</td></tr></table></code></td><td>   checks if a character is a graphical character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isspace</td></tr></table></code></td><td>   checks if a character is a space character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isblank</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a character is a blank character  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>isprint</td></tr></table></code></td><td>   checks if a character is a printing character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>ispunct</td></tr></table></code></td><td>   checks if a character is a punctuation character <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Character manipulation </h5></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>tolower</td></tr></table></code></td><td>   converts a character to lowercase <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>toupper</td></tr></table></code></td><td>   converts a character to uppercase <br> (function) <br></td></tr></table><p>Note: additional functions whose names begin with either <code>to</code> or <code>is</code>, followed by a lowercase letter, may be added to the header <code>ctype.h</code> in future and should not be defined by programs that include that header.</p><table class="wikitable" style="font-size:85%; text-align:center;"><tr><th colspan="2"> ASCII values <br> (hex)<br></th><th> characters</th><th style="font-size:85%;"><p><tt>iscntrl</tt> <br><tt>iswcntrl</tt><br></p></th><th style="font-size:85%;"><p><tt>isprint</tt> <br><tt>iswprint</tt><br></p></th><th style="font-size:85%;"><p><tt>isspace</tt> <br><tt>iswspace</tt><br></p></th><th style="font-size:85%;"><p><tt>isblank</tt> <br><tt>iswblank</tt><br></p></th><th style="font-size:85%;"><p><tt>isgraph</tt> <br><tt>iswgraph</tt><br></p></th><th style="font-size:85%;"><p><tt>ispunct</tt> <br><tt>iswpunct</tt><br></p></th><th style="font-size:85%;"><p><tt>isalnum</tt> <br><tt>iswalnum</tt><br></p></th><th style="font-size:85%;"><p><tt>isalpha</tt> <br><tt>iswalpha</tt><br></p></th><th style="font-size:85%;"><p><tt>isupper</tt> <br><tt>iswupper</tt><br></p></th><th style="font-size:85%;"><p><tt>islower</tt> <br><tt>iswlower</tt><br></p></th><th style="font-size:85%;"><p><tt>isdigit</tt> <br><tt>iswdigit</tt><br></p></th><th style="font-size:85%;"><p><tt>isxdigit</tt> <br><tt>iswxdigit</tt><br></p></th></tr><tr><td> 0  - 8</td><td> <code>0x00-0x08</code></td><td> control codes (<code>NUL</code>, etc.)</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 9</td><td> <code>0x09</code></td><td> tab (<code>\\t</code>)</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 10  - 13</td><td> <code>0x0A-0x0D</code></td><td> whitespaces (<code>\\n</code>,<code>\v</code>,<code>\f</code>,<code>\r</code>)</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 14 - 31</td><td> <code>0x0E-0x1F</code></td><td> control codes</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 32</td><td> <code>0x20</code></td><td> space</td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 33 - 47</td><td> <code>0x21-0x2F</code></td><td> <code>!"#$%&amp;'()*+,-./</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 48 - 57</td><td> <code>0x30-0x39</code></td><td> <code>0123456789</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td></tr><tr><td> 58 - 64</td><td> <code>0x3a-0x40</code></td><td> <code>:;<=>?@</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 65 - 70</td><td> <code>0x41-0x46</code></td><td> <code>ABCDEF</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td></tr><tr><td> 71 - 90</td><td> <code>0x47-0x5A</code></td><td> <code>GHIJKLMNOPQRSTUVWXYZ</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 91 - 96</td><td> <code>0x5B-0x60</code></td><td> <code>[\]^_`</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 97 -102</td><td> <code>0x61-0x66</code></td><td> <code>abcdef</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td></tr><tr><td> 103-122</td><td> <code>0x67-0x7A</code></td><td> <code>ghijklmnopqrstuvwxyz</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 123-126</td><td> <code>0x7B-0x7E</code></td><td> <code>{|}~</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 127</td><td> <code>0x7F</code></td><td> backspace character (<code>DEL</code>)</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr></table><table class="t-dsc-begin"><tr><td colspan="2"> <h5>   Conversions to numeric formats </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdlib.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>atof</td></tr></table></code></td><td>   converts a byte string to a floating-point value  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>atoi</td></tr><tr><td>atol</td></tr><tr><td>atoll</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a byte string to an integer value <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strtol</td></tr><tr><td>strtoll</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a byte string to an integer value <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strtoul</td></tr><tr><td> strtoull</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a byte string to an unsigned integer value  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strtof</td></tr><tr><td>strtod</td></tr><tr><td>strtold</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a byte string to a floating point value <br> (function) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><inttypes.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strtoimax</td></tr><tr><td>strtoumax</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a byte string to <code>intmax_t</code> or <code>uintmax_t</code> <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   String manipulation </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><string.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strcpy</td></tr><tr><td>strcpy_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   copies one string to another <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strncpy</td></tr><tr><td>strncpy_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   copies a certain amount of characters from one string to another <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strcat</td></tr><tr><td>strcat_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   concatenates two strings <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strncat</td></tr><tr><td>strncat_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   concatenates a certain amount of characters of two strings <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strxfrm</td></tr></table></code></td><td>   transform a string so that strcmp would produce the same result as strcoll <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   String examination </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><string.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strlen</td></tr><tr><td>strnlen_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   returns the length of a given string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strcmp</td></tr></table></code></td><td>   compares two strings <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strncmp</td></tr></table></code></td><td>   compares a certain amount of characters of two strings <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strcoll</td></tr></table></code></td><td>   compares two strings in accordance to the current locale <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strchr</td></tr></table></code></td><td>   finds the first occurrence of a character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strrchr</td></tr></table></code></td><td>   finds the last occurrence of a character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strspn</td></tr></table></code></td><td>   returns the length of the maximum initial segment that consists <br> of only the characters found in another byte string  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strcspn</td></tr></table></code></td><td>   returns the length of the maximum initial segment that consists <br> of only the characters not found in another byte string  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strpbrk</td></tr></table></code></td><td>   finds the first location of any character in one string, in another string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strstr</td></tr></table></code></td><td>   finds the first occurrence of a substring of characters <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strtok</td></tr><tr><td>strtok_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   finds the next token in a byte string <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Character array manipulation </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><string.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>memchr</td></tr></table></code></td><td>   searches an array for the first occurrence of a character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>memcmp</td></tr></table></code></td><td>   compares two buffers <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>memset</td></tr><tr><td>memset_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   fills a buffer with a character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>memcpy</td></tr><tr><td>memcpy_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   copies one buffer to another <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>memmove</td></tr><tr><td>memmove_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   moves one buffer to another <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Miscellaneous </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><string.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>strerror</td></tr><tr><td>strerror_s</td></tr><tr><td>strerrorlen_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   returns a text version of a given error code <br> (function) <br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte.html
multibyte	A										<section class="prog__container"><p>A null-terminated multibyte string (NTMBS), or "multibyte string", is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).<br></p><p>Each character stored in the string may occupy more than one byte. The encoding used to represent characters in a multibyte character string is locale-specific: it may be UTF-8, GB18030, EUC-JP, Shift-JIS, etc. For example, the char array <code>{'\\xe4','\\xbd','\\xa0','\\xe5','\\xa5','\\xbd','\\0'</code>} is an NTMBS holding the string <code>"你好"</code> in UTF-8 multibyte encoding: the first three bytes encode the character 你, the next three bytes encode the character 好. The same string encoded in GB18030 is the char array <code>{'\\xc4', '\\xe3', '\\xba', '\\xc3', '\\0'</code>}, where each of the two characters is encoded as a two-byte sequence.</p><p>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as "shift sequences". Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are BOCU-1 and SCSU.</p><p>A multibyte character string is layout-compatible with null-terminated byte string (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the following locale-dependent conversion functions:</p><h3><span class="prog__sub">Multibyte/wide character conversions</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdlib.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mblen</td></tr></table></code></td><td>   returns the number of bytes in the next multibyte character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbtowc</td></tr></table></code></td><td>   converts the next multibyte character to wide character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wctomb</td></tr><tr><td>wctomb_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a wide character to its multibyte representation <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbstowcs</td></tr><tr><td>mbstowcs_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a narrow multibyte character string to wide string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcstombs</td></tr><tr><td>wcstombs_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a wide string to narrow multibyte character string <br> (function) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbsinit</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if the mbstate_t object represents initial shift state <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>btowc</td></tr></table></code><table><tr><td></td></tr></table></td><td>   widens a single-byte narrow character to wide character, if possible <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wctob</td></tr></table></code><table><tr><td></td></tr></table></td><td>   narrows a wide character to a single-byte narrow character, if possible <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbrlen</td></tr></table></code><table><tr><td></td></tr></table></td><td>   returns the number of bytes in the next multibyte character, given state <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbrtowc</td></tr></table></code><table><tr><td></td></tr></table></td><td>   converts the next multibyte character to wide character, given state <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcrtomb</td></tr><tr><td>wcrtomb_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a wide character to its multibyte representation, given state <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbsrtowcs</td></tr><tr><td>mbsrtowcs_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a narrow multibyte character string to wide string, given state <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcsrtombs</td></tr><tr><td>wcsrtombs_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a wide string to narrow multibyte character string, given state <br> (function) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><uchar.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbrtoc16</td></tr></table></code><table><tr><td></td></tr></table></td><td>   generate the next 16-bit wide character from a narrow multibyte string  <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>c16rtomb</td></tr></table></code><table><tr><td></td></tr></table></td><td>   convert a 16-bit wide character to narrow multibyte string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbrtoc32</td></tr></table></code><table><tr><td></td></tr></table></td><td>   generate the next 32-bit wide character from a narrow multibyte string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>c32rtomb</td></tr></table></code><table><tr><td></td></tr></table></td><td>   convert a 32-bit wide character to narrow multibyte string <br> (function) <br></td></tr></table><h3><span class="prog__sub">Types</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>mbstate_t</td></tr></table></code><table><tr><td></td></tr></table></td><td>   conversion state information necessary to iterate multibyte character strings <br> (class) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><uchar.h></code> </td></tr><tr class="t-dsc"><td> <code>char16_t</code><table><tr><td></td></tr></table></td><td>   16-bit character type  <br> (typedef)<br></td></tr><tr class="t-dsc"><td> <code>char32_t</code><table><tr><td></td></tr></table></td><td>   32-bit character type  <br> (typedef)<br></td></tr></table><h3><span class="prog__sub">Macros</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><limits.h></code> </td></tr><tr class="t-dsc"><td> <code>MB_LEN_MAX</code></td><td>   maximum number of bytes in a multibyte character  <br> (macro constant) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdlib.h></code> </td></tr><tr class="t-dsc"><td> <code>MB_CUR_MAX</code></td><td>  maximum number of bytes in a multibyte character in the current C locale<br>(macro variable) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><uchar.h></code> </td></tr><tr class="t-dsc"><td> <code>__STDC_UTF_16__</code><table><tr><td></td></tr></table></td><td>   indicates that UTF-16 encoding is used by <code>mbrtoc16</code> and <code>c16rtomb</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>__STDC_UTF_32__</code><table><tr><td></td></tr></table></td><td>   indicates that UTF-32 encoding is used by <code>mbrtoc32</code> and <code>c32rtomb</code> <br> (macro constant)<br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte.html
wide	A										<section class="prog__container"><p>A null-terminated wide string is a sequence of valid wide characters, ending with a null-character.<br></p><h3><span class="prog__sub">Functions</span></h3><table class="t-dsc-begin"><tr><td colspan="2"> <h5>   Character classification </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wctype.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswalnum</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is alphanumeric <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswalpha</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is alphabetic <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswlower</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is an lowercase character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswupper</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is an uppercase character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswdigit</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is a digit <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswxdigit</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a character is a hexadecimal character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswcntrl</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is a control character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswgraph</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is a graphical character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswspace</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is a space character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswblank</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is a blank character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswprint</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is a printing character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswpunct</td></tr></table></code><table><tr><td></td></tr></table></td><td>   checks if a wide character is a punctuation character <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>iswctype</td></tr></table></code><table><tr><td></td></tr></table></td><td>   classifies a wide character according to the specified LC_CTYPE category <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wctype</td></tr></table></code><table><tr><td></td></tr></table></td><td>   looks up a character classification category in the current C locale <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   Character manipulation </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wctype.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>towlower</td></tr></table></code><table><tr><td></td></tr></table></td><td>   converts a wide character to lowercase <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>towupper</td></tr></table></code><table><tr><td></td></tr></table></td><td>   converts a wide character to uppercase <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>towctrans</td></tr></table></code><table><tr><td></td></tr></table></td><td>   performs character mapping according to the specified LC_CTYPE mapping category <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wctrans</td></tr></table></code><table><tr><td></td></tr></table></td><td>   looks up a character mapping category in the current C locale <br> (function) <br></td></tr></table><table class="wikitable" style="font-size:85%; text-align:center;"><tr><th colspan="2"> ASCII values <br> (hex)<br></th><th> characters</th><th style="font-size:85%;"><p><tt>iscntrl</tt> <br><tt>iswcntrl</tt><br></p></th><th style="font-size:85%;"><p><tt>isprint</tt> <br><tt>iswprint</tt><br></p></th><th style="font-size:85%;"><p><tt>isspace</tt> <br><tt>iswspace</tt><br></p></th><th style="font-size:85%;"><p><tt>isblank</tt> <br><tt>iswblank</tt><br></p></th><th style="font-size:85%;"><p><tt>isgraph</tt> <br><tt>iswgraph</tt><br></p></th><th style="font-size:85%;"><p><tt>ispunct</tt> <br><tt>iswpunct</tt><br></p></th><th style="font-size:85%;"><p><tt>isalnum</tt> <br><tt>iswalnum</tt><br></p></th><th style="font-size:85%;"><p><tt>isalpha</tt> <br><tt>iswalpha</tt><br></p></th><th style="font-size:85%;"><p><tt>isupper</tt> <br><tt>iswupper</tt><br></p></th><th style="font-size:85%;"><p><tt>islower</tt> <br><tt>iswlower</tt><br></p></th><th style="font-size:85%;"><p><tt>isdigit</tt> <br><tt>iswdigit</tt><br></p></th><th style="font-size:85%;"><p><tt>isxdigit</tt> <br><tt>iswxdigit</tt><br></p></th></tr><tr><td> 0  - 8</td><td> <code>0x00-0x08</code></td><td> control codes (<code>NUL</code>, etc.)</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 9</td><td> <code>0x09</code></td><td> tab (<code>\\t</code>)</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 10  - 13</td><td> <code>0x0A-0x0D</code></td><td> whitespaces (<code>\\n</code>,<code>\v</code>,<code>\f</code>,<code>\r</code>)</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 14 - 31</td><td> <code>0x0E-0x1F</code></td><td> control codes</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 32</td><td> <code>0x20</code></td><td> space</td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 33 - 47</td><td> <code>0x21-0x2F</code></td><td> <code>!"#$%&amp;'()*+,-./</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 48 - 57</td><td> <code>0x30-0x39</code></td><td> <code>0123456789</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td></tr><tr><td> 58 - 64</td><td> <code>0x3a-0x40</code></td><td> <code>:;<=>?@</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 65 - 70</td><td> <code>0x41-0x46</code></td><td> <code>ABCDEF</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td></tr><tr><td> 71 - 90</td><td> <code>0x47-0x5A</code></td><td> <code>GHIJKLMNOPQRSTUVWXYZ</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 91 - 96</td><td> <code>0x5B-0x60</code></td><td> <code>[\]^_`</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 97 -102</td><td> <code>0x61-0x66</code></td><td> <code>abcdef</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td></tr><tr><td> 103-122</td><td> <code>0x67-0x7A</code></td><td> <code>ghijklmnopqrstuvwxyz</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 123-126</td><td> <code>0x7B-0x7E</code></td><td> <code>{|}~</code></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr><tr><td> 127</td><td> <code>0x7F</code></td><td> backspace character (<code>DEL</code>)</td><td class="table-yes" style="background: #90ff90; color: black; vertical-align: middle; text-align: center;"><b><code>≠0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td><td class="table-no" style="background:#ff9090; color:black; vertical-align: middle; text-align: center;"> <b><code>0</code></b></td></tr></table><table class="t-dsc-begin"><tr><td colspan="2"> <h5>   Conversions to numeric formats </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcstol</td></tr><tr><td>wcstoll</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a wide string to an integer value <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcstoul</td></tr><tr><td>wcstoull</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a wide string to an unsigned integer value <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcstof</td></tr><tr><td>wcstod</td></tr><tr><td>wcstold</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a wide string to a floating-point value <br> (function) <br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><inttypes.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcstoimax</td></tr><tr><td>wcstoumax</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   converts a wide string to <code>intmax_t</code> or <code>uintmax_t</code> <br> (function) <br></td></tr></table><table class="t-dsc-begin"><tr><td colspan="2"> <h5>   String manipulation </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcscpy</td></tr><tr><td>wcscpy_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   copies one wide string to another <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcsncpy</td></tr><tr><td>wcsncpy_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   copies a certain amount of wide characters from one string to another <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcscat</td></tr><tr><td>wcscat_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   appends a copy of one wide string to another <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcsncat</td></tr><tr><td>wcsncat_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   appends a certain amount of wide characters from one wide string to another <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcsxfrm</td></tr></table></code><table><tr><td></td></tr></table></td><td>   transform a wide string so that wcscmp would produce the same result as wcscoll <br> (function) <br></td></tr><tr><td colspan="2"> <h5>   String examination </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcslen</td></tr><tr><td>wcsnlen_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   returns the length of a wide string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcscmp</td></tr></table></code><table><tr><td></td></tr></table></td><td>   compares two wide strings <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcsncmp</td></tr></table></code><table><tr><td></td></tr></table></td><td>   compares a certain amount of characters from two wide strings <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcscoll</td></tr></table></code><table><tr><td></td></tr></table></td><td>   compares two wide strings in accordance to the current locale <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcschr</td></tr></table></code><table><tr><td></td></tr></table></td><td>   finds the first occurrence of a wide character in a wide string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcsrchr</td></tr></table></code><table><tr><td></td></tr></table></td><td>   finds the last occurrence of a wide character in a wide string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcsspn</td></tr></table></code><table><tr><td></td></tr></table></td><td>   returns the length of the maximum initial segment that consists <br> of only the wide characters found in another wide string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcscspn</td></tr></table></code><table><tr><td></td></tr></table></td><td>   returns the length of the maximum initial segment that consists <br> of only the wide chars <i>not</i> found in another wide string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcspbrk</td></tr></table></code><table><tr><td></td></tr></table></td><td>   finds the first location of any wide character in one wide string, in another wide string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcsstr</td></tr></table></code><table><tr><td></td></tr></table></td><td>   finds the first occurrence of a wide string within another wide string <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wcstok</td></tr><tr><td>wcstok_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   finds the next token in a wide string <br> (function) <br></td></tr></table><table class="t-dsc-begin"><tr><td colspan="2"> <h5>   Wide character array manipulation </h5></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wmemcpy</td></tr><tr><td>wmemcpy_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   copies a certain amount of wide characters between two non-overlapping arrays <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wmemmove</td></tr><tr><td>wmemmove_s</td></tr></table></code><table><tr><td></td></tr><tr><td></td></tr></table></td><td>   copies a certain amount of wide characters between two, possibly overlapping, arrays <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wmemcmp</td></tr></table></code><table><tr><td></td></tr></table></td><td>   compares a certain amount of wide characters from two arrays <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wmemchr</td></tr></table></code><table><tr><td></td></tr></table></td><td>   finds the first occurrence of a wide character in a wide character array <br> (function) <br></td></tr><tr class="t-dsc"><td> <code> <table><tr><td>wmemset</td></tr></table></code><table><tr><td></td></tr></table></td><td>   copies the given wide character to every position in a wide character array <br> (function) <br></td></tr></table><h3><span class="prog__sub">Types</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code>wchar_t</code></td><td>  integer type that can hold any valid wide character (C++ keyword)</td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wctype.h></code> </td></tr><tr class="t-dsc"><td> <code>wint_t</code></td><td>  integer type that can hold any valid wide character and at least one more value</td></tr><tr class="t-dsc"><td> <code>wctrans_t</code></td><td>  scalar type that holds locale-specific character mapping</td></tr><tr class="t-dsc"><td> <code>wctype_t</code></td><td>  scalar type that holds locale-specific character classification</td></tr></table><h3><span class="prog__sub">Macros</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code>WEOF</code><table><tr><td></td></tr></table></td><td>   a non-character value of type wint_t used to indicate errors <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>WCHAR_MIN</code><table><tr><td></td></tr></table></td><td>   the smallest valid value of wchar_t  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>WCHAR_MAX</code><table><tr><td></td></tr></table></td><td>   the largest valid value of wchar_t  <br> (macro constant)<br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide.html
atof	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>double atof( const char* str );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets a floating-point value in a byte string pointed to by <code>str</code>.</p><p>Function discards any whitespace characters (as determined by <code>std::isspace()</code>) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</p><ul><li>decimal floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C <code>locale</code>) (defines significand)</li><li> (optional) <code>e</code> or <code>E</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li>binary floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>0x</code> or <code>0X</code></li><li> nonempty sequence of hexadecimal digits optionally containing a decimal-point character (as determined by the current C <code>locale</code>) (defines significand)</li><li> (optional) <code>p</code> or <code>P</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li> infinity expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>INF</code> or <code>INFINITY</code> ignoring case</li></ul></dd></dl><ul><li> not-a-number expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>NAN</code> or <code>NAN(</code><i>char_sequence</i><code>)</code> ignoring case of the <code>NAN</code> part. <i>char_sequence</i> can only contain alphanumeric characters. The result is a quiet NaN floating-point value.</li></ul></dd></dl><ul><li> any other expression that may be accepted by the currently installed C <code>locale</code></li></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>double</code> value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of the return type, the return value is undefined. If no conversion can be performed, <code>0.0</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/atof.html
atoi	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int       atoi( const char *str );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>long      atol( const char *str );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c99"><td> <code>long long atoll( const char *str );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets an integer value in a byte string pointed to by <code>str</code>.</p><p>Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:<br></p><ul><li> (optional) plus or minus sign</li><li> numeric digits</li></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, <code>​0​</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/atoi.html
isalnum	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int isalnum( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:<br></p><ul><li> digits (<code>0123456789</code>)</li><li> uppercase letters (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>)</li><li> lowercase letters (<code>abcdefghijklmnopqrstuvwxyz</code>)</li></ul><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is an alphanumeric character, <code>0</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isalnum.html
isalpha	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int isalpha( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is an alphabetic character, i.e. either an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), or a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>).</p><p>In locales other than <code>"C"</code>, an alphabetic character is a character for which <code>isupper()</code> or <code>islower()</code> returns <code>true</code> or any other character considered alphabetic by the locale. In any case, <code>iscntrl()</code>, <code>isdigit()</code>, <code>ispunct()</code> and <code>isspace()</code> will return <code>false</code> for this character.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> or is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is an alphabetic character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isalpha.html
isblank	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int isblank( int ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a blank character in the current C locale. In the default C locale, only space (<code>0x20</code>) and horizontal tab (<code>0x09</code>) are classified as blank.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is a blank character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isblank.html
iscntrl	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int iscntrl( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a control character, i.e. codes <code>0x00-0x1F</code> and <code>0x7F</code>.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is a control character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/iscntrl.html
isdigit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int isdigit( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a numeric character (<code>0123456789</code>).</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is a numeric character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isdigit.html
isgraph	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int isgraph( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character has a graphical representation, i.e. it is either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>), or a punctuation character(<code>!"#$%&amp;'()*+,-./:;<=>?@[\]^_`{|}~</code>), or any graphical character specific to the current C locale.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character has a graphical representation character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isgraph.html
islower	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int islower( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is classified as a lowercase character according to the current C locale. In the default "C" locale, <code>islower</code> returns true only for the lowercase letters (<code>abcdefghijklmnopqrstuvwxyz</code>).</p><p>If <code>islower</code> returns <code>true</code>, it is guaranteed that <code>iscntrl</code>, <code>isdigit</code>, <code>ispunct</code>, and <code>isspace</code> return <code>false</code> for the same character in the same C locale.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is a lowercase letter, zero otherwise.<br></p><p><br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/islower.html
isprint	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><cctype></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int isprint( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character can be printed, i.e. it is either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>), a punctuation character(<code>!"#$%&amp;'()*+,-./:;<=>?@[\]^_`{|}~</code>), or space, or any character classified as printable by the current C locale.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character can be printed, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isprint.html
ispunct	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int ispunct( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a punctuation character in the current C locale. The default C locale classifies the characters <code>!"#$%&amp;'()*+,-./:;<=>?@[\]^_`{|}~</code> as punctuation.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is a punctuation character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/ispunct.html
isspace	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int isspace( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a whitespace character, i.e. either space (<code>0x20</code>), form feed (<code>0x0c</code>), line feed (<code>0x0a</code>), carriage return (<code>0x0d</code>), horizontal tab (<code>0x09</code>) or vertical tab (<code>0x0b</code>).</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is a whitespace character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isspace.html
isupper	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int isupper( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is an uppercase character according to the current C locale. In the default "C" locale, <code>isupper</code> returns true only for the uppercase letters (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>).</p><p>If <code>isupper</code> returns <code>true</code>, it is guaranteed that <code>iscntrl</code>, <code>isdigit</code>, <code>ispunct</code>, and <code>isspace</code> return <code>false</code> for the same character in the same C locale.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is an uppercase letter, zero otherwise.<br></p><p><br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isupper.html
isxdigit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int isxdigit( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a hexadecimal numeric character (<code>0123456789abcdefABCDEF</code>) or is classified as a hexadecimal character.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the character is an hexadecimal numeric character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/isxdigit.html
memchr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void* memchr( const void* ptr, int ch, size_t count );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of <code>ch</code> (after conversion to <code>unsigned char</code> as if by <code>(unsigned char)ch</code>) in the initial <code>count</code> characters (each interpreted as <code>unsigned char</code>) of the object pointed to by <code>ptr</code>.</p><p>The behavior is undefined if access occurs beyond the end of the array searched. The behavior is undefined if <code>ptr</code> is a null pointer.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to the object to be examined</td></tr><tr class="t-par"><td>  ch</td><td> -</td><td>  character to search for</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of characters to examine</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the location of the character, or <code>NULL</code> if no such character is found.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/memchr.html
memcmp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int memcmp( const void* lhs, const void* rhs, size_t count );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Compares the first <code>count</code> characters of the objects pointed to by <code>lhs</code> and <code>rhs</code>. The comparison is done lexicographically.</p><p>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as <code>unsigned char</code>) that differ in the objects being compared.</p><p>The behavior is undefined if access occurs beyond the end of either object pointed to by <code>lhs</code> and <code>rhs</code>. The behavior is undefined if either <code>lhs</code> or <code>rhs</code> is a null pointer.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  pointers to the objects to compare</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of bytes to examine</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Negative value if <code>lhs</code>  appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal, or if count is zero.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/memcmp.html
memcpy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>void* memcpy( void *dest, const void *src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>void* memcpy( void *restrict dest, const void *restrict src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t memcpy_s( void *restrict dest, rsize_t destsz,<br>                  const void *restrict src, rsize_t count );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies <code>count</code> characters from the object pointed to by <code>src</code> to the object pointed to by <code>dest</code>. Both objects are interpreted as arrays of <code>unsigned char</code>.</ul><ul> The behavior is undefined if access occurs beyond the end of the dest array. If the objects overlap<span> (which is a violation of the <tt>restrict</tt> contract)</span> <span></span>, the behavior is undefined. The behavior is undefined if either <code>dest</code> or <code>src</code> is a null pointer.</ul><ul>2) Same as (1), except that the following errors are detected at runtime and cause the entire destination range <code>[dest, dest+destsz)</code> to be zeroed out (if both <code>dest</code> and <code>destsz</code> are valid), as well as call the currently installed constraint handler function:<dl><dd><ul><li> <code>dest</code> or <code>src</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than <code>RSIZE_MAX</code></li><li> <code>count</code> is greater than <code>destsz</code> (buffer overflow would occur)</li><li> the source and the destination objects overlap</li></ul></dd></dl></ul><ul> The behavior is undefined if the size of the character array pointed to by <code>dest</code> < <code>count</code> <= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>memcpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the object to copy to</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  max number of bytes to modify in the destination (typically the size of the destination object)</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the object to copy from</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of bytes to copy</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) Returns a copy of <code>dest</code></ul><ul>2) Returns zero on success and non-zero value on error. Also on error, if <code>dest</code> is not a null pointer and <code>destsz</code> is valid, writes <code>destsz</code> zero bytes in to the destination array.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/memcpy.html
memmove	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>void* memmove( void* dest, const void* src, size_t count );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t memmove_s(void *dest, rsize_t destsz, const void *src, rsize_t count);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies <code>count</code> characters from the object pointed to by <code>src</code> to the object pointed to by <code>dest</code>. Both objects are interpreted as arrays of <code>unsigned char</code>. The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to <code>dest</code>.</ul><ul> The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if either <code>dest</code> or <code>src</code> is a null pointer.</ul><ul>2) Same as (1), except when detecting the following errors at runtime, it zeroes out the entire destination range <code>[dest, dest+destsz)</code> (if both <code>dest</code> and <code>destsz</code> are valid) and calls the currently installed constraint handler function:<dl><dd><ul><li> <code>dest</code> or <code>src</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than <code>RSIZE_MAX</code></li><li> <code>count</code> is greater than <code>destsz</code> (buffer overflow would occur)</li></ul></dd></dl></ul><ul> The behavior is undefined if the size of the character array pointed to by <code>dest</code> < <code>count</code> <= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>memmove_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the object to copy to</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  max number of bytes to modify in the destination (typically the size of the destination object)</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the object to copy from</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of bytes to copy</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) Returns a copy of <code>dest</code></ul><ul>2) Returns zero on success and non-zero value on error. Also on error, if <code>dest</code> is not a null pointer and <code>destsz</code> is valid, writes <code>destsz</code> zero bytes in to the destination array.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/memmove.html
memset	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>void *memset( void *dest, int ch, size_t count );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t memset_s( void *dest, rsize_t destsz, int ch, rsize_t count )</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies the value <code>ch</code> (after conversion to <code>unsigned char</code> as if by <code>(unsigned char)ch</code>) into each of the first <code>count</code> characters of the object pointed to by <code>dest</code>.</ul><ul> The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if <code>dest</code> is a null pointer.</ul><ul>2) Same as (1), except that the following errors are detected at runtime and call the currently installed constraint handler function after storing <code>ch</code> in every location of the destination range <code>[dest, dest+destsz)</code> if <code>dest</code> and <code>destsz</code> are themselves valid:<dl><dd><ul><li> <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than <code>RSIZE_MAX</code></li><li> <code>count</code> is greater than <code>destsz</code> (buffer overflow would occur)</li></ul></dd></dl></ul><ul> The behavior is undefined if the size of the character array pointed to by <code>dest</code> < <code>count</code> <= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>memset_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the object to fill</td></tr><tr class="t-par"><td>  ch</td><td> -</td><td>  fill byte</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of bytes to fill</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  size of the destination array</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) A copy of <code>dest</code></ul><ul>2) zero on success, non-zero on error. Also on error, if <code>dest</code> is not a null pointer and <code>destsz</code> is valid, writes <code>destsz</code> fill bytes <code>ch</code> to the destination array.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/memset.html
strcat	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>char *strcat( char *dest, const char *src );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>char *strcat( char *restrict dest, const char *restrict src );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t strcat_s(char *restrict dest, rsize_t destsz, const char *restrict src);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Appends a copy of the null-terminated byte string pointed to by <code>src</code> to the end of the null-terminated byte string pointed to by <code>dest</code>. The character <code>src[0]</code> replaces the null terminator at the end of <code>dest</code>. The resulting byte string is null-terminated.</ul><ul> The behavior is undefined if the destination array is not large enough for the contents of both <code>src</code> and <code>dest</code> and the terminating null character. The behavior is undefined if the strings overlap. The behavior is undefined if either <code>dest</code> or <code>src</code> is not a pointer to a null-terminated byte string.</ul><ul>2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to <code>destsz</code>) with unspecified values and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> is zero or greater than <code>RSIZE_MAX</code></li><li> there is no null terminator in the first <code>destsz</code> bytes of <code>dest</code></li><li> truncation would occur (the available space at the end of <code>dest</code> would not fit every character, including the null terminator, of <code>src</code>)</li><li> overlap would occur between the source and the destination strings</li></ul></dd></dl></ul><ul> The behavior is undefined if the size of the character array pointed to by <code>dest</code> < <code>strlen(dest)+strlen(src)+1</code> <= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>strcat_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to append to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated byte string to copy from</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  maximum number of characters to write, typically the size of the destination buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RMAX_SIZE</code>).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strcat.html
strchr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>char *strchr( const char *str, int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of <code>ch</code> (after conversion to <code>char</code> as if by <code>(char)ch</code>) in the null-terminated byte string pointed to by <code>str</code> (each character interpreted as <code>unsigned char</code>). The terminating null character is considered to be a part of the string and can be found when searching for <code>'\\0'</code>.</p><p>The behavior is undefined if <code>str</code> is not a pointer to a null-terminated byte string.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr class="t-par"><td>  ch</td><td> -</td><td>  character to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the found character in <code>str</code>, or null pointer if no such character is found.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strchr.html
strcmp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int strcmp( const char *lhs, const char *rhs );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Compares two null-terminated byte strings lexicographically.<br></p><p>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as <code>unsigned char</code>) that differ in the strings being compared.</p><p>The behavior is undefined if <code>lhs</code> or <code>rhs</code> are not pointers to null-terminated byte strings.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated byte strings to compare</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strcmp.html
strcoll	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int strcoll( const char *lhs, const char *rhs );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Compares two null-terminated byte strings according to the current locale as defined by the <code>LC_COLLATE</code> category.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated byte strings to compare</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Negative value if <code>lhs</code> is <i>less than</i> (precedes) <code>rhs</code>.</p><p><code>​0​</code> if <code>lhs</code> is <i>equal to</i> <code>rhs</code>.</p><p>Positive value if <code>lhs</code> is <i>greater than</i> (follows) <code>rhs</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strcoll.html
strcpy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>char *strcpy( char *dest, const char *src );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>char *strcpy( char *restrict dest, const char *restrict src );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t strcpy_s(char *restrict dest, rsize_t destsz, const char *restrict src);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies the null-terminated byte string pointed to by <code>src</code>, including the null terminator, to the character array whose first element is pointed to by <code>dest</code>.</ul><ul> The behavior is undefined if the <code>dest</code> array is not large enough. The behavior is undefined if the strings overlap. The behavior is undefined if either <code>dest</code> is not a pointer to a character array or <code>src</code> is not a pointer to a null-terminated byte string.</ul><ul>2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> is zero or greater than <code>RSIZE_MAX</code></li><li> <code>destsz</code> is less or equal <code>strnlen_s(src, destsz)</code>; in other words, truncation would occur</li><li> overlap would occur between the source and the destination strings</li></ul></dd></dl></ul><ul> The behavior is undefined if the size of the character array pointed to by <code>dest</code> <= <code>strnlen_s(src, destsz)</code> < <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>strcpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the character array to write to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated byte string to copy from</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  maximum number of characters to write, typically the size of the destination buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RSIZE_MAX</code>).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strcpy.html
strcspn	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>size_t strcspn( const char *dest, const char *src );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the length of the maximum initial segment of the null-terminated byte string pointed to by <code>dest</code>, that consists of only the characters <i>not</i> found in the null-terminated byte string pointed to by <code>src</code>.</p><p>The behavior is undefined if either <code>dest</code> or <code>src</code> is not a pointer to a null-terminated byte string.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated byte string that contains the characters to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The length of the maximum initial segment that contains only characters not found in the null-terminated byte string pointed to by <code>src</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strcspn.html
strerror	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>char* strerror( int errnum );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t strerror_s( char *buf, rsize_t bufsz, errno_t errnum );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>size_t strerrorlen_s( errno_t errnum );</code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Returns a pointer to the textual description of the system error code <code>errnum</code>, identical to the description that would be printed by <code>perror()</code>.</ul><ul> <code>errnum</code> is usually acquired from the <code>errno</code> variable, however the function accepts any value of type <code>int</code>. The contents of the string are locale-specific.</ul><ul> The returned string must not be modified by the program, but may be overwritten by a subsequent call to the <code>strerror</code> function. <code>strerror</code> is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</ul><ul>2) Same as (1), except that the message is copied into user-provided storage <code>buf</code>. No more than <code>bufsz-1</code> bytes are written, the buffer is always null-terminated. If the message had to be truncated to fit the buffer and <code>bufsz</code> is greater than 3, then only <code>bufsz-4</code> bytes are written, and the characters <code>"..."</code> are appended before the null terminator. In addition, the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>buf</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than <code>RSIZE_MAX</code></li></ul></dd></dl></ul><ul> The behavior is undefined if writing to <code>buf</code> occurs past the end of the array, which can happen when the size of the buffer pointed to by <code>buf</code> is less than the number of characters in the error message which in turn is less than <code>bufsz</code>.</ul><ul>3) Computes the length of the untruncated locale-specific error message that <code>strerror_s</code> would write if it were called with <code>errnum</code>. The length does not include the null terminator.<dl><dd>As with all bounds-checked functions, <code>strerror_s</code> and <code>strerrorlen_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  errnum</td><td> -</td><td>  integral value referring to an error code</td></tr><tr class="t-par"><td>  buf</td><td> -</td><td>  pointer to a user-provided buffer</td></tr><tr class="t-par"><td>  bufsz</td><td> -</td><td>  size of the user-provided buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) Pointer to a null-terminated byte string corresponding to the <code>errno</code> error code <code>errnum</code>.</ul><ul>2) Zero if the entire message was successfully stored in <code>buf</code>, non-zero otherwise.</ul><ul>3) Length (not including the null terminator) of the message that <code>strerror_s</code> would return</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strerror.html
strlen	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>size_t strlen( const char *str );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>size_t strnlen_s( const char *str, size_t strsz );</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Returns the length of the given null-terminated byte string, that is, the number of characters in a character array whose first element is pointed to by <code>str</code> up to and not including the first null character.</ul><ul> The behavior is undefined if <code>str</code> is not a pointer to a null-terminated byte string.</ul><ul>2) Same as (1), except that the function returns zero if <code>str</code> is a null pointer and returns <code>strsz</code> if the null character was not found in the first <code>strsz</code> bytes of <code>str</code>.</ul><ul> The behavior is undefined if both <code>str</code> points to a character array which lacks the null character and the size of that character array < <code>strsz</code>; in other words, an erroneous value of <code>strsz</code> does not expose the impending buffer overflow.<dl><dd>As with all bounds-checked functions, <code>strnlen_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td> str</td><td> -</td><td>  pointer to the null-terminated byte string to be examined</td></tr><tr class="t-par"><td> strsz</td><td> -</td><td>  maximum number of characters to examine</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) The length of the null-terminated byte string <code>str</code>.</ul><ul>2) The length of the null-terminated byte string <code>str</code> on success, zero if <code>str</code> is a null pointer, <code>strsz</code> if the null character was not found.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strlen.html
strncat	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>char *strncat( char *dest, const char *src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>char *strncat( char *restrict dest, const char *restrict src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t strncat_s(char *restrict dest, rsize_t destsz,<br>                  const char *restrict src, rsize_t count);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Appends at most <code>count</code> characters from the character array pointed to by <code>src</code>, stopping if the null character is found, to the end of the null-terminated byte string pointed to by <code>dest</code>. The character <code>src[0]</code> replaces the null terminator at the end of <code>dest</code>. The terminating null character is always appended in the end (so the maximum number of bytes the function may write is <code>count+1</code>).</ul><ul> The behavior is undefined if the destination array does not have enough space for the contents of both <code>dest</code> and the first <code>count</code> characters of <code>src</code>, plus the terminating null character. The behavior is undefined if the source and destination objects overlap. The behavior is undefined if either <code>dest</code> is not a pointer to a null-terminated byte string or <code>src</code> is not a pointer to a character array,</ul><ul>2) Same as (1), except that this function may clobber the remainder of the destination array (from the last byte written to <code>destsz</code>) and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is zero or greater than <code>RSIZE_MAX</code></li><li> there is no null character in the first <code>destsz</code> bytes of <code>dest</code></li><li> truncation would occur: <code>count</code> or the length of <code>src</code>, whichever is less, exceeds the space available between the null terminator of <code>dest</code> and <code>destsz</code>.</li><li> overlap would occur between the source and the destination strings</li></ul></dd></dl></ul><ul> The behavior is undefined if the size of the character array pointed to by <code>dest</code> < <code>strnlen(dest,destsz)+strnlen(src,count)+1</code> < <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by <code>src</code> < <code>strnlen(src,count)</code> < <code>destsz</code>; in other words, an erroneous value of <code>count</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>strncat_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to append to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the character array to copy from</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of characters to copy</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  the size of the destination buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RMAX_SIZE</code>).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strncat.html
strncmp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int strncmp( const char *lhs, const char *rhs, size_t count );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Compares at most <code>count</code> characters of two possibly null-terminated arrays. The comparison is done lexicographically.</p><p>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as <code>unsigned char</code>) that differ in the arrays being compared.</p><p>The behavior is undefined when access occurs past the end of either array <code>lhs</code> or <code>rhs</code>. The behavior is undefined when either <code>lhs</code> or <code>rhs</code> is the null pointer.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  pointers to the possibly null-terminated arrays to compare</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of characters to compare</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal, or if count is zero.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strncmp.html
strncpy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>char *strncpy( char *dest, const char *src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>char *strncpy( char *restrict dest, const char *restrict src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t strncpy_s(char *restrict dest, rsize_t destsz,<br>                  const char *restrict src, rsize_t count);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies at most <code>count</code> characters of the character array pointed to by <code>src</code> (including the terminating null character, but not any of the characters that follow the null character) to character array pointed to by <code>dest</code>. </ul><ul> If <code>count</code> is reached before the entire array <code>src</code> was copied, the resulting character array is not null-terminated.</ul><ul> If, after copying the terminating null character from <code>src</code>, <code>count</code> is not reached, additional null characters are written to <code>dest</code> until the total of <code>count</code> characters have been written.</ul><ul> The behavior is undefined if the character arrays overlap, if either <code>dest</code> or <code>src</code> is not a pointer to a character array (including if <code>dest</code> or <code>src</code> is a null pointer), if the size of the array pointed to by <code>dest</code> is less than <code>count</code>, or if the size of the array pointed to by <code>src</code> is less than <code>count</code> and it does not contain a null character.</ul><ul>2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to <code>count</code>, it stops after writing the terminating null character (if there was no null in the source, it writes one at <code>dest[count]</code> and then stops). Also, the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is zero or greater than <code>RSIZE_MAX</code></li><li> <code>count</code> is greater or equal <code>destsz</code>, but <code>destsz</code> is less or equal <code>strnlen_s(src, count)</code>, in other words, truncation would occur</li><li> overlap would occur between the source and the destination strings</li></ul></dd></dl></ul><ul> The behavior is undefined if the size of the character array pointed to by <code>dest</code> < <code>strnlen_s(src, destsz)</code> <= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by <code>src</code> < <code>strnlen_s(src, count)</code> < <code>destsz</code>; in other words, an erroneous value of <code>count</code> does not expose the impending buffer overflow.</ul><dl><dd>As all bounds-checked functions, <code>strncpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the character array to copy to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the character array to copy from</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of characters to copy</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  the size of the destination buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RSIZE_MAX</code>) and may clobber the rest of the destination array with unspecified values.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strncpy.html
strpbrk	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>char* strpbrk( const char* dest, const char* breakset );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Scans the null-terminated byte string pointed to by <code>dest</code> for any character from the null-terminated byte string pointed to by <code>breakset</code>, and returns a pointer to that character.</p><p>The behavior is undefined if either <code>dest</code> or <code>breakset</code> is not a pointer to a null-terminated byte string.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr class="t-par"><td>  breakset</td><td> -</td><td>  pointer to the null-terminated byte string that contains the characters to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the first character in <code>dest</code>, that is also in <code>breakset</code>, or null pointer if no such character exists.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strpbrk.html
strrchr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>char *strrchr( const char *str, int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Finds the last occurrence of <code>ch</code> (after conversion to <code>char</code> as if by <code>(char)ch</code>) in the null-terminated byte string pointed to by <code>str</code> (each character interpreted as <code>unsigned char</code>). The terminating null character is considered to be a part of the string and can be found if searching for <code>'\\0'</code>.</p><p>The behavior is undefined if <code>str</code> is not a pointer to a null-terminated byte string.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr class="t-par"><td>  ch</td><td> -</td><td>  character to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the found character in <code>str</code>, or null pointer if no such character is found.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strrchr.html
strspn	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>size_t strspn( const char *dest, const char *src );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the length of the maximum initial segment (span) of the null-terminated byte string pointed to by <code>dest</code>, that consists of only the characters found in the null-terminated byte string pointed to by <code>src</code>.</p><p>The behavior is undefined if either <code>dest</code> or <code>src</code> is not a pointer to a null-terminated byte string.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated byte string that contains the characters to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The length of the maximum initial segment that contains only characters from the null-terminated byte string pointed to by <code>src</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strspn.html
strstr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>char *strstr( const char* str, const char* substr );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of the null-terminated byte string pointed to by <code>substr</code> in the null-terminated byte string pointed to by <code>str</code>. The terminating null characters  are not compared.</p><p>The behavior is undefined if either <code>str</code> or <code>substr</code> is not a pointer to a null-terminated byte string.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to examine</td></tr><tr class="t-par"><td>  substr</td><td> -</td><td>  pointer to the null-terminated byte string to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the first character of the found substring in <code>str</code>, or <code>NULL</code> if no such substring is found. If <code>substr</code> points to an empty string, <code>str</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strstr.html
strtof	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       strtof( const char *restrict str, char **restrict str_end );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>double      strtod( const char          *str, char          **str_end );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>double      strtod( const char *restrict str, char **restrict str_end );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c99"><td> <code>long double strtold( const char *restrict str, char **restrict str_end );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets a floating-point value in a byte string pointed to by <code>str</code>.</p><p>Function discards any whitespace characters (as determined by <code>std::isspace()</code>) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</p><ul><li>decimal floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C <code>locale</code>) (defines significand)</li><li> (optional) <code>e</code> or <code>E</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li>binary floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>0x</code> or <code>0X</code></li><li> nonempty sequence of hexadecimal digits optionally containing a decimal-point character (as determined by the current C <code>locale</code>) (defines significand)</li><li> (optional) <code>p</code> or <code>P</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li> infinity expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>INF</code> or <code>INFINITY</code> ignoring case</li></ul></dd></dl><ul><li> not-a-number expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>NAN</code> or <code>NAN(</code><i>char_sequence</i><code>)</code> ignoring case of the <code>NAN</code> part. <i>char_sequence</i> can only contain alphanumeric characters. The result is a quiet NaN floating-point value.</li></ul></dd></dl><ul><li> any other expression that may be accepted by the currently installed C <code>locale</code></li></ul><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the character past the last character interpreted. If <code>str_end</code> is <code>NULL</code>, it is ignored.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr><tr class="t-par"><td>  str_end</td><td> -</td><td>  pointer to a pointer to character.</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Floating-point value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <code>HUGE_VAL</code>, <code>HUGE_VALF</code> or <code>HUGE_VALL</code> is returned. If no conversion can be performed, <code>​0​</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strtof.html
strtoimax	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><inttypes.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>intmax_t strtoimax( const char *restrict nptr, <br>                    char **restrict endptr, int base );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>uintmax_t strtoumax( const char *restrict nptr, <br>                     char **restrict endptr, int base );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets an integer value in a byte string pointed to by <code>nptr</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base)  integer number representation and converts them to an  integer value. The valid   integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>​0​</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>​0​</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <code>locale</code>.</p><p>If the value of base is <code>​0​</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.</p><p>The functions sets the pointer pointed to by <code>endptr</code> to point to the character past the last character interpreted. If <code>endptr</code> is <code>NULL</code>, it is ignored.</p><p>If the <code>nptr</code> is empty or does not have the expected form, no conversion is performed, and (if <code>enptr</code> is not <code>NULL</code>) the value of <code>nptr</code> is stored in the object pointed to by <code>endptr</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  nptr</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr><tr class="t-par"><td>  endptr</td><td> -</td><td>  pointer to a pointer to character.</td></tr><tr class="t-par"><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul><li> If successful, an integer value corresponding to the contents of <code>str</code> is returned.</li><li> If the converted value falls out of range of corresponding return type, a range error occurs (setting [[cpp/error/errno|<code>errno</code>]] to <code>ERANGE</code>) and <code>INTMAX_MAX</code>, <code>INTMAX_MIN</code>, <code>UINTMAX_MAX</code> or <code>​0​</code> is returned, as appropriate.</li><li> If no conversion can be performed, <code>​0​</code> is returned.</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strtoimax.html
strtok	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>char *strtok( char *str, const char *delim );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>char *strtok( char *restrict str, const char *restrict delim );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>char *strtok_s(char *restrict str, rsize_t *restrict strmax,<br>     const char *restrict delim, char **restrict ptr);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Finds the next token in a null-terminated byte string pointed to by <code>str</code>. The separator characters are identified by null-terminated byte string pointed to by <code>delim</code>.</ul><ul> This function is designed to be called multiples times to obtain successive tokens from the same string.</ul><dl><dd><ul><li> If <code>str != NULL</code>, the call is treated as the first call to <code>strtok</code> for this particular string. The function searches for the first character which is <i>not</i> contained in <code>delim</code>.</li></ul><dl><dd><ul><li> If no such character was found, there are no tokens in <code>str</code> at all, and the function returns a null pointer. </li><li> If such character was found, it is the <i>beginning of the token</i>. The function then searches from that point on for the first character that <i>is</i> contained in <code>delim</code>. </li></ul><dl><dd><ul><li> If no such character was found, <code>str</code> has only one token, and future calls to <code>strtok</code> will return a null pointer</li><li> If such character was found, it is <i>replaced</i> by the null character <code>'\\0'</code> and the pointer to the following character is stored in a static location for subsequent invocations.</li></ul></dd></dl><ul><li> The function then returns the pointer to the beginning of the token</li></ul></dd></dl><ul><li> If <code>str == NULL</code>, the call is treated as a subsequent calls to <code>strtok</code>: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as <code>str</code>.</li></ul></dd></dl><ul> The behavior is undefined if either <code>str</code> or <code>delim</code> is not a pointer to a null-terminated byte string.</ul><ul>2) Same as (1), except that on every step, writes the number of characters left to see in <code>str</code> into <code>*strmax</code> and writes the tokenizer's internal state to <code>*ptr</code>. Repeat calls (with null <code>str</code>) must pass <code>strmax</code> and <code>ptr</code> with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed constraint handler function, without storing anything in the object pointed to by <code>ptr</code><dl><dd><ul><li> <code>strmax</code>, <code>delim</code>, or <code>ptr</code> is a null pointer</li><li> on a non-initial call (with null <code>str</code>), <code>*ptr</code> is a null pointer</li><li> on the first call, <code>*strmax</code> is zero or greater than <code>RSIZE_MAX</code></li><li> search for the end of a token reaches the end of the source string (as measured by the initial value of <code>*strmax</code>)) without encountering the null terminator</li></ul></dd></dl></ul><ul> The behavior is undefined if both <code>str</code> points to a character array which lacks the null character and <code>strmax</code> points to a value which is greater than the size of that character array.<dl><dd>As all bounds-checked functions, <code>strtok_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to tokenize</td></tr><tr class="t-par"><td>  delim</td><td> -</td><td>  pointer to the null-terminated byte string identifying delimiters</td></tr><tr class="t-par"><td>  strmax</td><td> -</td><td>  pointer to an object which initially holds the size of <code>str</code>: strtok_s stores the number of characters that remain to be examined</td></tr><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to an object of type <code>char*</code>, which is used by strtok_s to store its internal state</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Returns pointer to the beginning of the next token or <code>NULL</code> if there are no more tokens.</p><h3><span class="prog__sub">Note</span></h3><p>This function is destructive: it writes the <code>'\\0'</code> characters in the elements of the string <code>str</code>. In particular, a string literal cannot be used as the first argument of <code>strtok</code>.</p><p>Each call to <code>strtok</code> modifies a static variable: is not thread safe.</p><p>Unlike most other tokenizers, the delimiters in <code>strtok</code> can be different for each subsequent token, and can even depend on the contents of the previous tokens.</p><p>The <code>strtok_s</code> function differs from the POSIX strtok_r function by guarding against storing outside of the string being tokenized, and by checking runtime constraints.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strtok.html
strtol	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>long      strtol( const char          *str, char          **str_end, int base );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>long      strtol( const char *restrict str, char **restrict str_end, int base );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c99"><td> <code>long long strtoll( const char *restrict str, char **restrict str_end, int base );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets an integer value in a byte string pointed to by <code>str</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base)  integer number representation and converts them to an  integer value. The valid   integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>​0​</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>​0​</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <code>locale</code>.</p><p>If the value of base is <code>​0​</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.</p><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the character past the last character interpreted. If <code>str_end</code> is <code>NULL</code>, it is ignored.</p><p>If the <code>str</code> is empty or does not have the expected form, no conversion is performed, and (if <code>str_end</code> is not <code>NULL</code>) the value of <code>str</code> is stored in the object pointed to by <code>str_end</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr><tr class="t-par"><td>  str_end</td><td> -</td><td>  pointer to a pointer to character.</td></tr><tr class="t-par"><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul><li> If successful, an integer value corresponding to the contents of <code>str</code> is returned.</li><li> If the converted value falls out of range of corresponding return type, a range error occurs (setting <code>errno</code> to <code>ERANGE</code>) and <code>LONG_MAX</code>, <code>LONG_MIN</code>, <code>LLONG_MAX</code> or <code>LLONG_MIN</code> is returned. </li><li> If no conversion can be performed, <code>​0​</code> is returned.</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strtol.html
strtoul	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>unsigned long      strtoul( const char          *str, char          **str_end, <br>                            int base );<br></code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>unsigned long      strtoul( const char *restrict str, char **restrict str_end, <br>                            int base );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c99"><td> <code>unsigned long long strtoull( const char *restrict str, char **restrict str_end,<br>                             int base );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets an unsigned integer value in a byte string pointed to by <code>str</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base) unsigned integer number representation and converts them to an  integer value. The valid unsigned  integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>​0​</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>​0​</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <code>locale</code>.</p><p>If the value of base is <code>​0​</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.</p><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the character past the last character interpreted. If <code>str_end</code> is <code>NULL</code>, it is ignored.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr><tr class="t-par"><td>  str_end</td><td> -</td><td>  pointer to a pointer to character.</td></tr><tr class="t-par"><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs (<code>errno</code> is set to <code>ERANGE</code>) and <code>ULONG_MAX</code> or <code>ULLONG_MAX</code> is returned. If no conversion can be performed, <code>​0​</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strtoul.html
strxfrm	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>size_t strxfrm( char          *dest, const char          *src, <br>                size_t count );<br></code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>size_t strxfrm( char *restrict dest, const char *restrict src, <br>                size_t count );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Transforms the null-terminated byte string pointed to by <code>src</code> into the implementation-defined form such that comparing two transformed strings with <code>strcmp</code> gives the same result as comparing the original strings with <code>strcoll</code>, in the current C locale.</p><p>The first <code>count</code> characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.</p><p>The behavior is undefined if the <code>dest</code> array is not large enough. The behavior is undefined if <code>dest</code> and <code>src</code> overlap.</p><p>If <code>count</code> is <code>​0​</code>, then <code>dest</code> is allowed to be a null pointer.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/strxfrm.html
tolower	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int tolower( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.<br></p><p>In the default "C" locale, the following uppercase letters <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> are replaced with respective lowercase letters <code>abcdefghijklmnopqrstuvwxyz</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to be converted. If the value of <code>ch</code> is not representable as <code>unsigned char</code> and does not equal <code>EOF</code>, the behavior is undefined.</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Lowercase version of <code>ch</code> or unmodified <code>ch</code> if no lowercase version is listed in the current C locale.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/tolower.html
toupper	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><ctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int toupper( int ch );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.<br></p><p>In the default "C" locale, the following lowercase letters <code>abcdefghijklmnopqrstuvwxyz</code> are replaced with respective uppercase letters <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  character to be converted. If the value of <code>ch</code> is not representable as <code>unsigned char</code> and does not equal <code>EOF</code>, the behavior is undefined.</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Uppercase version of <code>ch</code> or unmodified <code>ch</code> if no uppercase version is listed in the current C locale.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/byte/toupper.html
btowc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wint_t btowc( int c );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Widens a single-byte character <code>c</code> (reinterpreted as <code>unsigned char</code>) to its wide character equivalent. </p><p>Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to <code>wchar_t</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  c</td><td> -</td><td>  single-byte character to widen</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>WEOF</code> if <code>c</code> is <code>EOF</code></p><p>wide character representation of <code>c</code> if <code>(unsigned char)c</code> is a valid single-byte character in the initial shift state, <code>WEOF</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/btowc.html
c16rtomb	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><uchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>size_t c16rtomb( char* s, char16_t c16, mbstate_t* ps );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts a single code point from its variable-length 16-bit wide character representation (typically, UTF-16) to its narrow multibyte character representation.<br></p><p>If <code>s</code> is not a null pointer and <code>c16</code> is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences), and stores the multibyte character representation in the character array whose first element is pointed to by <code>s</code>. At most <code>MB_CUR_MAX</code> bytes can be written by this function.</p><p>If <code>s</code> is a null pointer, the call is equivalent to <code>c16rtomb(buf, u'\\0', ps)</code> for some internal buffer <code>buf</code>.</p><p>If <code>c16</code> is the null wide character <code>u'\\0'</code>, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter <code>*ps</code> is updated to represent the initial shift state.</p><p>If <code>c16</code> is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by <code>s</code>, only <code>*ps</code> is updated.</p><p>If the macro <code>__STDC_UTF_16__</code> is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  s</td><td> -</td><td>  pointer to narrow character array where the multibyte character will be stored</td></tr><tr class="t-par"><td>  c16</td><td> -</td><td>  the 16-bit wide character to convert</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by <code>s</code>. This value may be <code>​0​</code>, e.g. when processing the first <code>char16_t</code> in a multi-<code>char16_t</code>-character sequence (occurs as the leading surrogate in a surrogate pair of UTF-16).</p><p>On failure (if <code>c16</code> is not a valid 16-bit code unit), returns <code>-1</code>, stores <code>EILSEQ</code> in <code>errno</code>, and leaves <code>*ps</code> in unspecified state.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/c16rtomb.html
c32rtomb	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><uchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>size_t c32rtomb( char* s, char32_t c32, mbstate_t* ps );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation.<br></p><p>If <code>s</code> is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of <code>c32</code> (including any shift sequences), and stores the multibyte character representation in the character array whose first element is pointed to by <code>s</code>. At most <code>MB_CUR_MAX</code> bytes can be written by this function.</p><p>If <code>s</code> is a null pointer, the call is equivalent to <code>c32rtomb(buf, U'\\0', ps)</code> for some internal buffer <code>buf</code>.</p><p>If <code>c32</code> is the null wide character <code>U'\\0'</code>, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter <code>*ps</code> is updated to represent the initial shift state.</p><p>If the macro <code>__STDC_UTF_32__</code> is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  s</td><td> -</td><td>  pointer to narrow character array where the multibyte character will be stored</td></tr><tr class="t-par"><td>  c32</td><td> -</td><td>  the 32-bit wide character to convert</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by <code>s</code>. This value may be <code>​0​</code>, e.g. when processing the leading <code>char32_t</code> units in a multi-<code>char32_t</code>-unit sequence and then the number of bytes written when processing the final <code>char32_t</code> unit in the sequence (does not occur in UTF-32).</p><p>On failure (if <code>c32</code> is not a valid 32-bit wide character), returns <code>-1</code>, stores <code>EILSEQ</code> in <code>errno</code>, and leaves <code>*ps</code> in unspecified state.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/c32rtomb.html
mblen	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>int mblen( const char* s, size_t n );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines the size, in bytes, of the multibyte character whose first byte is pointed to by <code>s</code>. </p><p>If <code>s</code> is a null pointer, resets the global conversion state and determined whether shift sequences are used.</p><p>This function is equivalent to the call <code>mbtowc((wchar_t*)0, s, n)</code>, except that conversion state of <code>mbtowc</code> is unaffected.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mblen.html
mbrlen	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>size_t mbrlen( const char* s, size_t n, mbstate_t* ps );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Determines the size, in bytes, of the remainder of the multibyte character whose first byte is pointed to by <code>s</code>, given the current conversion state <code>ps</code>.</p><p>This function is equivalent to the call <code>mbrtowc(nullptr, s, n, ps?ps:&amp;internal)</code> for some hidden object <code>internal</code> of type <code>mbstate_t</code>, except that the expression <code>ps</code> is evaluated only once.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  s</td><td> -</td><td>  pointer to an element of a multibyte character string</td></tr><tr class="t-par"><td>  n</td><td> -</td><td>  limit on the number of bytes in s that can be examined</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the variable holding the conversion state</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> if the next <code>n</code> or fewer bytes complete the null character.</p><p>The number of bytes (between <code>1</code> and <code>n</code>) that complete a valid multibyte character</p><p><code>(size_t)-1</code> if encoding error occurs</p><p><code>(size_t)-2</code> if the next <code>n</code> bytes are part of a possibly valid multibyte character, which is still incomplete after examining all <code>n</code> bytes</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbrlen.html
mbrtoc16	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><uchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>size_t mbrtoc16( char16_t* pc16, const char* s, size_t n, mbstate_t* ps );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts a single code point from its narrow multibyte character representation to its variable-length 16-bit wide character representation (typically, UTF-16). <br></p><p>If <code>s</code> is not a null pointer, inspects at most <code>n</code> bytes of the multibyte character string, beginning with the byte pointed to by <code>s</code> to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in <code>s</code> is complete and valid, converts it to the corresponding 16-bit wide character and stores it in <code>*pc16</code> (if <code>pc16</code> is not null).</p><p>If the multibyte character in <code>*s</code> corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, <code>*ps</code> is updated in such a way that the next call to <code>mbrtoc16</code> will write out the additional char16_t, without considering <code>*s</code>.</p><p>If <code>s</code> is a null pointer, the values of <code>n</code> and <code>pc16</code> are ignored and the call is equivalent to <code>mbrtoc16(NULL, "", 1, ps)</code>.</p><p>If the wide character produced is the null character, the conversion state <code>*ps</code> represents the initial shift state.</p><p>If the macro <code>__STDC_UTF_16__</code> is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  pc16</td><td> -</td><td>  pointer to the location where the resulting 16-bit wide character will be written</td></tr><tr class="t-par"><td>  s</td><td> -</td><td>  pointer to the multibyte character string used as input</td></tr><tr class="t-par"><td>  n</td><td> -</td><td>  limit on the number of bytes in s that can be examined</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The first of the following that applies:<br></p><ul><li> <code>​0​</code> if the character converted from <code>s</code> (and stored in <code>*pc16</code> if non-null) was the null character</li><li> the number of bytes <code>[1...n]</code> of the multibyte character successfully converted from <code>s</code></li><li> <code>-3</code> if the next <code>char16_t</code> from a multi-<code>char16_t</code> character (e.g. a surrogate pair) has now been written to <code>*pc16</code>. No bytes are processed from the input in this case.</li><li> <code>-2</code> if the next <code>n</code> bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to <code>*pc16</code>.</li><li> <code>-1</code> if encoding error occurs. Nothing is written to <code>*pc16</code>, the value <code>EILSEQ</code> is stored in <code>errno</code> and the value if <code>*ps</code> is unspecified.</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbrtoc16.html
mbrtoc32	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><uchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>size_t mbrtoc32( char32_t* pc32, const char* s, size_t n, mbstate_t* ps );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts a single code point from its narrow multibyte character representation to its variable-length 32-bit wide character representation (but typically, UTF-32).<br></p><p>If <code>s</code> is not a null pointer, inspects at most <code>n</code> bytes of the multibyte character string, beginning with the byte pointed to by <code>s</code> to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in <code>s</code> is complete and valid, converts it to the corresponding 32-bit wide character and stores it in <code>*pc32</code> (if <code>pc32</code> is not null).</p><p>If the multibyte character in <code>*s</code> corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, <code>*ps</code> is updated in such a way that the next calls to <code>mbrtoc32</code> will write out the additional char32_t, without considering <code>*s</code>.</p><p>If <code>s</code> is a null pointer, the values of <code>n</code> and <code>pc32</code> are ignored and the call is equivalent to <code>mbrtoc32(NULL, "", 1, ps)</code>.</p><p>If the wide character produced is the null character, the conversion state <code>*ps</code> represents the initial shift state.</p><p>If the macro <code>__STDC_UTF_32__</code> is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  pc32</td><td> -</td><td>  pointer to the location where the resulting 32-bit wide character will be written</td></tr><tr class="t-par"><td>  s</td><td> -</td><td>  pointer to the multibyte character string used as input</td></tr><tr class="t-par"><td>  n</td><td> -</td><td>  limit on the number of bytes in s that can be examined</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The first of the following that applies:<br></p><ul><li> <code>​0​</code> if the character converted from <code>s</code> (and stored in <code>*pc32</code> if non-null) was the null character</li><li> the number of bytes <code>[1...n]</code> of the multibyte character successfully converted from <code>s</code></li><li> <code>-3</code> if the next <code>char32_t</code> from a multi-<code>char32_t</code> character has now been written to <code>*pc32</code>. No bytes are processed from the input in this case.</li><li> <code>-2</code> if the next <code>n</code> bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to <code>*pc32</code>.</li><li> <code>-1</code> if encoding error occurs. Nothing is written to <code>*pc32</code>, the value <code>EILSEQ</code> is stored in <code>errno</code> and the value if <code>*ps</code> is unspecified.</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbrtoc32.html
mbrtowc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>size_t mbrtowc( wchar_t* pwc, const char* s, size_t n, mbstate_t* ps );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts a narrow multibyte character to a wide character.<br></p><p>If <code>s</code> is not a null pointer, inspects at most <code>n</code> bytes of the multibyte character string, beginning with the byte pointed to by <code>s</code> to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in <code>s</code> is complete and valid, converts it to the corresponding wide character and stores it in <code>*pwc</code> (if <code>pwc</code> is not null).</p><p>If <code>s</code> is a null pointer, the values of <code>n</code> and <code>pwc</code> are ignored and call is equivalent to <code>mbrtowc(NULL, "", 1, ps)</code>.</p><p>If the wide character produced is the null character, the conversion state stored in <code>*ps</code> is the initial shift state.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  pwc</td><td> -</td><td>  pointer to the location where the resulting wide character will be written</td></tr><tr class="t-par"><td>  s</td><td> -</td><td>  pointer to the multibyte character string used as input</td></tr><tr class="t-par"><td>  n</td><td> -</td><td>  limit on the number of bytes in s that can be examined</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the conversion state used when interpreting the multibyte string</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The first of the following that applies:<br></p><ul><li> <code>​0​</code> if the character converted from <code>s</code> (and stored in <code>pwc</code> if non-null) was the null character</li><li> the number of bytes <code>[1...n]</code> of the multibyte character successfully converted from <code>s</code></li><li> <code>(size_t)-2</code> if the next <code>n</code> bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to <code>*pwc</code>.</li><li> <code>(size_t)-1</code> if encoding error occurs. Nothing is written to <code>*pwc</code>, the value <code>EILSEQ</code> is stored in <code>errno</code> and the value of <code>*ps</code> is left unspecified.</li></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbrtowc.html
mbsinit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int mbsinit( const mbstate_t* ps);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>If <code>ps</code> is not a null pointer, the <code>mbsinit</code> function determines whether the pointed-to <code>mbstate_t</code> object describes the initial conversion state. </p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbsinit.html
mbsrtowcs	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c95"><td> <code>size_t mbsrtowcs( wchar_t* dst, const char** src, size_t len, mbstate_t* ps )</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t mbsrtowcs_s( size_t *restrict retval, wchar_t *restrict dst, rsize_t dstsz,<br>                     const char **restrict src, rsize_t len, mbstate_t *restrict ps);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts a null-terminated multibyte character sequence, which begins in the conversion state described by <code>*ps</code>, from the array whose first element is pointed to by <code>*src</code> to its wide character representation. If <code>dst</code> is not null, converted characters are stored in the successive elements of the wchar_t array pointed to by <code>dst</code>. No more than <code>len</code> wide characters are written to the destination array. Each multibyte character is converted as if by a call to <code>mbrtowc</code>. The conversion stops if:</ul><ul> * The multibyte null character was converted and stored. <code>*src</code> is set to <code>NULL</code> and <code>*ps</code> represents the initial shift state.</ul><ul> * An invalid multibyte character (according to the current C locale) was encountered. <code>*src</code> is set to point at the beginning  of the first unconverted multibyte character.</ul><ul> * the next wide character to be stored would exceed <code>len</code>. <code>*src</code> is set to point at the beginning of the first unconverted multibyte character. This condition is not checked if <code>dst==NULL</code>.</ul><ul>2) Same as (1), except that</ul><ul> * the function returns its result as an out-parameter <code>retval</code></ul><ul> * if no null character was written to <code>dst</code> after <code>len</code> wide characters were written, then <code>L'\\0'</code> is stored in <code>dst[len]</code>, which means len+1 total wide characters are written</ul><ul> * the function clobbers the destination array from the terminating null and until <code>dstsz</code></ul><ul> * If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</ul><ul> * the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>retval</code>, <code>ps</code>, <code>src</code>, or <code>*src</code> is a null pointer</li><li> <code>dstsz</code> or <code>len</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code> (unless <code>dst</code> is null)</li><li> <code>dstsz</code> is not zero (unless <code>dst</code> is null)</li><li> There is no null character in the first <code>dstsz</code> multibyte characters in the <code>*src</code> array and <code>len</code> is greater than <code>dstsz</code> (unless <code>dst</code> is null)</li></ul></dd><dd>As all bounds-checked functions, <code>mbsrtowcs_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dst</td><td> -</td><td>  pointer to wide character array where the results will be stored</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to pointer to the first element of a null-terminated multibyte string</td></tr><tr class="t-par"><td>  len</td><td> -</td><td>  number of wide characters available in the array pointed to by dst</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the conversion state object</td></tr><tr class="t-par"><td>  dstsz</td><td> -</td><td>  max number of wide characters that will be written (size of the <code>dst</code> array)</td></tr><tr class="t-par"><td>  retval</td><td> -</td><td>  pointer to a size_t object where the result will be stored</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) On success, returns the number of wide characters, excluding the terminating <code>L'\\0'</code>, written to the character array. If <code>dst==NULL</code>, returns the number of wide characters that would have been written given unlimited length. On conversion error (if invalid multibyte character was encountered), returns <code>(size_t)-1</code>, stores <code>EILSEQ</code> in <code>errno</code>, and leaves <code>*ps</code> in unspecified state.</ul><ul>2) zero on success (in which case the number of wide characters excluding terminating zero that were, or would be written to <code>dst</code>, is stored in <code>*retval</code>), non-sero on error. In case of a runtime constraint violation, stores <code>(size_t)-1</code> in <code>*retval</code> (unless <code>retval</code> is null) and sets <code>dst[0]</code> to <code>L'\\0'</code> (unless <code>dst</code> is null or <code>dstmax</code> is zero or greater than <code>RSIZE_MAX</code>)</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbsrtowcs.html
mbstate_t	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><uchar.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c95"><td> <code>struct mbstate_t;</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The type <code>mbstate_t</code> is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of <code>mbstate_t</code> represents the initial conversion state, although other values of <code>mbstate_t</code> may exist that also represent the initial conversion state.</p><p>Possible implementation of <code>mbstate_t</code> is a struct type holding an array representing the incomplete multibyte character, an integer counter indicating the number of bytes in the array that have been processed, and a representation of the current shift state.</p><p>The following functions should not be called from multiple threads without synchronization with the <code>mbstate_t*</code> argument of <code>NULL</code> due to possible data races: <code>mbrlen</code>, <code>mbrtowc</code>, <code>mbsrtowcs</code>, <code>mbtowc</code>, <code>wcrtomb</code>, <code>wcsrtombs</code>, <code>wctomb</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbstate_t.html
mbstowcs	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>size_t mbstowcs( wchar_t          *dst, const char          *src, size_t len)</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>size_t mbstowcs( wchar_t *restrict dst, const char *restrict src, size_t len)</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t mbstowcs_s(size_t *restrict retval, wchar_t *restrict dst,<br>                  rsize_t dstsz, const char *restrict src, rsize_t len);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts a multibyte character string from the array whose first element is pointed to by <code>src</code> to its wide character representation. Converted characters are stored in the successive elements of the array pointed to by <code>dst</code>. No more than <code>len</code> wide characters are written to the destination array.</ul><ul> Each character is converted as if by a call to <code>mbtowc</code>, except that the mbtowc conversion state is unaffected. The conversion stops if:</ul><ul> * The multibyte null character was converted and stored.</ul><ul> * An invalid (in the current C locale) multibyte character was encountered.</ul><ul> * The next wide character to be stored would exceed <code>len</code>.</ul><ul> If <code>src</code> and <code>dst</code> overlap, the behavior is undefined</ul><ul>2) Same as (1), except that</ul><ul> * conversion is as-if by <code>mbrtowc</code>, not <code>mbtowc</code></ul><ul> * the function returns its result as an out-parameter <code>retval</code></ul><ul> * if no null character was written to <code>dst</code> after <code>len</code> wide characters were written, then <code>L'\\0'</code> is stored in <code>dst[len]</code>, which means len+1 total wide characters are written</ul><ul> * if <code>dst</code> is a null pointer, the number of wide characters that would be produced is stored in <code>*retval</code></ul><ul> * the function clobbers the destination array from the terminating null and until <code>dstsz</code></ul><ul> * If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</ul><ul> * the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>retval</code> or <code>src</code> is a null pointer</li><li> <code>dstsz</code> or <code>len</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code> (unless <code>dst</code> is null)</li><li> <code>dstsz</code> is not zero (unless <code>dst</code> is null)</li><li> There is no null character in the first <code>dstsz</code> multibyte characters in the <code>src</code> array and <code>len</code> is greater than <code>dstsz</code> (unless <code>dst</code> is null)</li></ul></dd><dd>As all bounds-checked functions, <code>mbstowcs_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbstowcs.html
mbtowc	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>int mbtowc( wchar_t          *pwc, const char          *s, size_t n )</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>int mbtowc( wchar_t *restrict pwc, const char *restrict s, size_t n )</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts a multibyte character whose first byte is pointed to by <code>s</code> to a wide character, written to <code>*pwc</code> if <code>pwc</code> is not null.</p><p>If <code>s</code> is a null pointer, resets the global conversion state and determines whether shift sequences are used.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/mbtowc.html
wcrtomb	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c95"><td> <code>size_t wcrtomb( char *s, wchar_t wc, mbstate_t *ps);</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t wcrtomb_s(size_t *restrict retval, char *restrict s, rsize_t ssz,<br>                  wchar_t wc, mbstate_t *restrict ps);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts a wide character to its narrow multibyte representation.<br></p><ul>1) If <code>s</code> is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of <code>wc</code> (including any shift sequences), and stores the multibyte character representation in the character array whose first element is pointed to by <code>s</code>. At most <code>MB_CUR_MAX</code> bytes can be written by this function.</ul><ul> If <code>s</code> is a null pointer, the call is equivalent to <code>wcrtomb(buf, L'\\0', ps)</code> for some internal buffer <code>buf</code>.</ul><ul> If wc is the null wide character <code>L'\\0'</code>, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter <code>*ps</code> is updated to represent the initial shift state.</ul><ul>2) Same as (1), except that</ul><ul> if <code>s</code> is a null pointer, the call is equivalent to <code>wcrtomb_s(&amp;retval, buf, sizeof buf, L'\\0', ps)</code> with internal variables <code>retval</code> and <code>buf</code> (whose size is greater than <code>MB_CUR_MAX</code>)</ul><ul> the result is returned in the out-parameter <code>retval</code></ul><ul> the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>retval</code> or <code>ps</code> is a null pointer.</li><li> <code>ssz</code> is zero or greater than <code>RSIZE_MAX</code> (unless <code>s</code> is null)</li><li> <code>ssz</code> is less than the number of bytes that would be written (unless <code>s</code> is null)</li><li> <code>s</code> is a null pointer but <code>ssz</code> is not zero </li></ul></dd><dd>As all bounds-checked functions, <code>wcrtomb_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  s</td><td> -</td><td>  pointer to narrow character array where the multibyte character will be stored</td></tr><tr class="t-par"><td>  wc</td><td> -</td><td>  the wide character to convert</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr><tr class="t-par"><td>  ssz</td><td> -</td><td>  max number of bytes to write (the size of the buffer <code>s</code>)</td></tr><tr class="t-par"><td>  retval</td><td> -</td><td>  pointer to an out-parameter where the result (number of bytes in the multibyte string including any shift sequences) will be stored</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by <code>s</code>. </ul><ul> On failure (if <code>wc</code> is not a valid wide character), returns <code>(size_t)-1</code>, stores <code>EILSEQ</code> in <code>errno</code>, and leaves <code>*ps</code> in unspecified state.</ul><ul>2) Returns zero on success and non-zero on failure, in which case, <code>s[0]</code> is set to <code>'\\0'</code> (unless <code>s</code> is null or <code>ssz</code> is zero or greater than <code>RSIZE_MAX</code>) and <code>*retval</code> is set to <code>(size_t)-1</code> (unless <code>retval</code> is null)</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/wcrtomb.html
wcsrtombs	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c95"><td> <code>size_t wcsrtombs( char *dst, const wchar_t **src, size_t len, mbstate_t* ps )</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t wcsrtombs_s( size_t *restrict retval, char *restrict dst, rsize_t dstsz,<br>                     const wchar_t **restrict src, rsize_t len, mbstate_t *restrict ps);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts a sequence of wide characters from the array whose first element is pointed to by <code>*src</code> to its narrow multibyte representation that begins in the conversion state described by <code>*ps</code>. If <code>dst</code> is not null, converted characters are stored in the successive elements of the char array pointed to by <code>dst</code>. No more than <code>len</code> bytes are written to the destination array.</ul><ul> Each character is converted as if by a call to <code>wcrtomb</code>. The conversion stops if:</ul><ul> * The null character <code>L'\\0'</code> was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by <code>'\\0'</code>, <code>*src</code> is set to <code>NULL</code> and <code>*ps</code> represents the initial shift state.</ul><ul> * A <code>wchar_t</code> was found that does not correspond to a valid character in the current C locale. <code>*src</code> is set to point at the first unconverted wide character.</ul><ul> * the next multibyte character to be stored would exceed <code>len</code>. <code>*src</code> is set to point at the first unconverted wide character. This condition is not checked if <code>dst==NULL</code>.</ul><ul>2) Same as (1), except that</ul><ul> * the function returns its result as an out-parameter <code>retval</code></ul><ul> * if the conversion stops without writing a null character, the function will store <code>'\\0'</code> in the next byte in <code>dst</code>, which may be <code>dst[len]</code> or <code>dst[dstsz]]</code>, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.</ul><ul> * the function clobbers the destination array from the terminating null and until <code>dstsz</code></ul><ul> * If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</ul><ul> * the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>retval</code>, <code>ps</code>, <code>src</code>, or <code>*src</code> is a null pointer</li><li> <code>dstsz</code> or <code>len</code> is greater than <code>RSIZE_MAX</code> (unless <code>dst</code> is null)</li><li> <code>dstsz</code> is not zero (unless <code>dst</code> is null)</li><li> <code>len</code> is greater than <code>dstsz</code> and the conversion does not encounter null or encoding error in the <code>src</code> array by the time <code>dstsz</code> is reached (unless <code>dst</code> is null)</li></ul></dd><dd>As with all bounds-checked functions, <code>wcsrtombs_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dst</td><td> -</td><td>  pointer to narrow character array where the multibyte characters will be stored</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to pointer to the first element of a null-terminated wide string</td></tr><tr class="t-par"><td>  len</td><td> -</td><td>  number of bytes available in the array pointed to by dst</td></tr><tr class="t-par"><td>  ps</td><td> -</td><td>  pointer to the conversion state object</td></tr><tr class="t-par"><td>  dstsz</td><td> -</td><td>  max number of bytes that will be written (size of the <code>dst</code> array)</td></tr><tr class="t-par"><td>  retval</td><td> -</td><td>  pointer to a size_t object where the result will be stored</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) On success, returns the number of bytes (including any shift sequences, but excluding the terminating <code>'\\0'</code>) written to the character array whose first element is pointed to by <code>dst</code>. If <code>dst==NULL</code>, returns the number of bytes that would have been written. On conversion error (if invalid wide character was encountered), returns <code>(size_t)-1</code>, stores <code>EILSEQ</code> in <code>errno</code>, and leaves <code>*ps</code> in unspecified state.</ul><ul>2) Returns zero on success (in which case the number of bytes excluding terminating zero that were, or would be written to <code>dst</code>, is stored in <code>*retval</code>), non-zero on error. In case of a runtime constraint violation, stores <code>(size_t)-1</code> in <code>*retval</code> (unless <code>retval</code> is null) and sets <code>dst[0]</code> to <code>'\\0'</code> (unless <code>dst</code> is null or <code>dstmax</code> is zero or greater than <code>RSIZE_MAX</code>)</ul><p><br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/wcsrtombs.html
wcstombs	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-until-c99"><td> <code>size_t wcstombs( char          *dst, const wchar_t          *src, size_t len );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) </td></tr><tr class="t-dcl t-since-c99"><td> <code>size_t wcstombs( char *restrict dst, const wchar_t *restrict src, size_t len );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t wcstombs_s( size_t *restrict retval, char *restrict dst, rsize_t dstsz,<br>                    const wchar_t *restrict src, rsize_t len );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts a sequence of wide characters from the array whose first element is pointed to by <code>src</code> to its narrow multibyte representation that begins in the initial shift state. Converted characters are stored in the successive elements of the char array pointed to by <code>dst</code>. No more than <code>len</code> bytes are written to the destination array.</ul><ul> Each character is converted as if by a call to <code>wctomb</code>, except that the wctomb's conversion state is unaffected. The conversion stops if:</ul><ul> * The null character <code>L'\\0'</code> was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by <code>'\\0'</code>,</ul><ul> * A <code>wchar_t</code> was found that does not correspond to a valid character in the current C locale.</ul><ul> * The next multibyte character to be stored would exceed <code>len</code>.</ul><ul> If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</ul><ul>2) Same as (1), except that</ul><ul> * conversion is as-if by <code>wcrtomb</code>, not <code>wctomb</code></ul><ul> * the function returns its result as an out-parameter <code>retval</code></ul><ul> * if the conversion stops without writing a null character, the function will store <code>'\\0'</code> in the next byte in <code>dst</code>, which may be <code>dst[len]</code> or <code>dst[dstsz]]</code>, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.</ul><ul> * if <code>dst</code> is a null pointer, the number of wide characters that would be produced is stored in <code>*retval</code></ul><ul> * the function clobbers the destination array from the terminating null and until <code>dstsz</code></ul><ul> * If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</ul><ul> * the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>retval</code> or <code>src</code> is a null pointer</li><li> <code>dstsz</code> or <code>len</code> is greater than <code>RSIZE_MAX</code> (unless <code>dst</code> is null)</li><li> <code>dstsz</code> is not zero (unless <code>dst</code> is null)</li><li> <code>len</code> is greater than <code>dstsz</code> and the conversion does not encounter null or encoding error in the <code>src</code> array by the time <code>dstsz</code> is reached (unless <code>dst</code> is null)</li></ul></dd><dd>As all bounds-checked functions, <code>wcstombs_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/wcstombs.html
wctob	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int wctob( wint_t c );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Narrows a wide character <code>c</code> if its multibyte character equivalent in the initial shift state is a single byte.</p><p>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  c</td><td> -</td><td>  wide character to narrow</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>EOF</code> if <code>c</code> does not represent a multibyte character with length <code>1</code> in initial shift state.</p><p>otherwise, the single-byte representation of <code>c</code> as <code>unsigned char</code> converted to <code>int</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/wctob.html
wctomb	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int wctomb( char *s, wchar_t wc );</code></td><td> (1) </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t wctomb_s(int *restrict status, char *restrict s, rsize_t ssz, wchar_t wc);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Converts a wide character <code>wc</code> to multibyte encoding and stores it (including any shift sequences) in the char array whose first element is pointed to by <code>s</code>. No more than <code>MB_CUR_MAX</code> characters are stored.</ul><ul> If <code>wc</code> is the null character, the null byte is written to <code>s</code>, preceded by any shift sequences necessary to restore the initial shift state.</ul><ul> If <code>s</code> is a null pointer, this function resets the global conversion state and determines whether shift sequences are used.</ul><ul>2) Same as (1), except that the result is returned in the out-parameter <code>status</code> and the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>ssz</code> is less than the number of bytes that would be written (unless <code>s</code> is null)</li><li> <code>ssz</code> is greater than <code>RSIZE_MAX</code> (unless <code>s</code> is null)</li><li> <code>s</code> is a null pointer but <code>ssz</code> is not zero </li></ul></dd><dd>As all bounds-checked functions, <code>wctomb_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/multibyte/wctomb.html
iswalnum	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswalnum( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is an alphanumeric character, i.e. either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>) or any alphanumeric character specific to the current locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is a alphanumeric character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswalnum.html
iswalpha	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswalpha( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>) or any alphabetic character specific to the current locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is a alphabetic character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswalpha.html
iswblank	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>int iswblank( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (<code>0x20</code>) and horizontal tab (<code>0x09</code>) are blank characters.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is a blank character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswblank.html
iswcntrl	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswcntrl( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is a control character, i.e. codes <code>0x00-0x1F</code> and <code>0x7F</code> and any control characters specific to the current locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is a control character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswcntrl.html
iswctype	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswctype( wint_t wc, wctype_t desc );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Classifies the wide character <code>wc</code> using the current C locale's LC_CTYPE category identified by <code>desc</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  wc</td><td> -</td><td>  the wide character to classify</td></tr><tr class="t-par"><td>  desc</td><td> -</td><td>  the LC_CTYPE category, obtained from a call to <code>wctype</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero if the character <code>wc</code> has the property identified by <code>desc</code> in LC_CTYPE facet of the current C locale, zero otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswctype.html
iswdigit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswdigit( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is an numeric character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswdigit.html
iswgraph	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswgraph( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character has a graphical representation, i.e. it is either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>), a punctuation character(<code>!"#$%&amp;'()*+,-./:;<=>?@[\]^_`{|}~</code>) or any graphical character specific to the current C locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character has a graphical representation character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswgraph.html
iswlower	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswlower( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is a lowercase letter, i.e. one of <code>abcdefghijklmnopqrstuvwxyz</code> or any lowercase letter specific to the current locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is an lowercase letter, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswlower.html
iswprint	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswprint( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character can be printed, i.e. it is either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>), a punctuation character(<code>!"#$%&amp;'()*+,-./:;<=>?@[\]^_`{|}~</code>), space or any printable character specific to the current C locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character can be printed, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswprint.html
iswpunct	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswpunct( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is a punctuation character, i.e. it is one of <code>!"#$%&amp;'()*+,-./:;<=>?@[\]^_`{|}~</code> or any punctuation character specific to the current locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is a punctuation character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswpunct.html
iswspace	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswspace( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is a whitespace character, i.e. either space (<code>0x20</code>), form feed (<code>0x0c</code>), line feed (<code>0x0a</code>), carriage return (<code>0x0d</code>), horizontal tab (<code>0x09</code>), vertical tab (<code>0x0b</code>) or any whitespace character specific to the current locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is a whitespace character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswspace.html
iswupper	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswupper( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is an uppercase letter, i.e. one of <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> or any uppercase letter specific to the current locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is an uppercase letter, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswupper.html
iswxdigit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int iswxdigit( wint_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of <code>0123456789abcdefABCDEF</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if the wide character is a hexadecimal numeric character, zero otherwise.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/iswxdigit.html
towctrans	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wint_t towctrans( wint_t wc, wctrans_t desc );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Maps the wide character <code>wc</code> using the current C locale's LC_CTYPE mapping category identified by <code>desc</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  wc</td><td> -</td><td>  the wide character to map</td></tr><tr class="t-par"><td>  desc</td><td> -</td><td>  the LC_CTYPE mapping, obtained from a call to <code>wctrans</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The mapped value of <code>wc</code> using the mapping identified by <code>desc</code> in LC_CTYPE facet of the current C locale.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/towctrans.html
towlower	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wint_t towlower( wint_t wc );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts the given wide character to lowercase, if possible.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  wc</td><td> -</td><td>  wide character to be converted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Lowercase version of <code>wc</code> or unmodified <code>wc</code> if no lowercase version is listed in the current C locale.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/towlower.html
towupper	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wint_t towupper( wint_t wc );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Converts the given wide character to uppercase, if possible.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  wc</td><td> -</td><td>  wide character to be converted</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Uppercase version of <code>wc</code> or unmodified <code>wc</code> if no uppercase version is listed in the current C locale.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/towupper.html
wcscat	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>wchar_t *wcscat( wchar_t *dest, const wchar_t *src );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>wchar_t *wcscat(wchar_t *restrict dest, const wchar_t *restrict src);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t wcscat_s(wchar_t *restrict dest, rsize_t destsz,<br>                 const wchar_t *restrict src);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Appends a copy of the wide string pointed to by <code>src</code> to the end of the wide string pointed to by <code>dest</code>. The wide character <code>src[0]</code> replaces the null terminator at the end of <code>dest</code>. The resulting wide string is null-terminated. The behavior is undefined if the destination array is not large enough for the contents of both <code>str</code> and <code>dest</code> and the terminating null wide character. The behavior is undefined if the strings overlap. </ul><ul>2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to <code>destsz</code>) with unspecified values and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> there is no null terminator in the first <code>destsz</code> bytes of <code>dest</code></li><li> truncation would occur (the available space at the end of <code>dest</code> would not fit every wide character, including the null terminator, of <code>src</code>)</li><li> overlap would occur between the source and the destination strings</li></ul></dd><dd>As all bounds-checked functions, <code>wcscat_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to append to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string to copy from</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  maximum number of characters to write, typically the size of the destination buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, writes <code>L'\\0'</code> to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RMAX_SIZE/sizeof(wchar_t)</code>).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcscat.html
wcschr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wchar_t* wcschr( const wchar_t* str, wchar_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of the wide character <code>ch</code> in the wide string pointed to by <code>str</code>. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the found character in <code>str</code>, or <code>NULL</code> if no such character is found.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcschr.html
wcscmp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int wcscmp( const wchar_t *lhs, const wchar_t *rhs );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Compares two null-terminated wide strings lexicographically.<br></p><p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.<br></p><p>The behavior is undefined if <code>lhs</code> or <code>rhs</code> are not pointers to null-terminated wide strings.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated wide strings to compare</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcscmp.html
wcscoll	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int wcscoll( const wchar_t *lhs, const wchar_t *rhs );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Compares two null-terminated wide strings according to the collation order defined by the <code>LC_COLLATE</code> category of the currently installed locale.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated wide strings to compare</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Negative value if <code>lhs</code> is <i>less than</i> (precedes) <code>rhs</code>.</p><p><code>​0​</code> if <code>lhs</code> is <i>equal to</i> <code>rhs</code>.</p><p>Positive value if <code>lhs</code> is <i>greater than</i> (follows) <code>rhs</code>.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcscoll.html
wcscpy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>wchar_t *wcscpy( wchar_t *dest, const wchar_t *src );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>wchar_t *wcscpy( wchar_t *restrict dest, const wchar_t *restrict src );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t wcscpy_s( wchar_t *restrict dest, rsize_t destsz,<br>                  const wchar_t *restrict src );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies the wide string pointed to by <code>src</code> (including the terminating null wide character) to wide character array pointed to by <code>dest</code>. The behavior is undefined if the <code>dest</code> array is not large enough. The behavior is undefined if the strings overlap.</ul><ul>2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> is zero or greater than <code>RSIZE_MAX / sizeof(wchar_t)</code></li><li> <code>destsz</code> is less or equal <code>wcsnlen_s(src, destsz)</code>, in other words, truncation would occur</li><li> overlap would occur between the source and the destination strings</li></ul></dd><dd>As with all bounds-checked functions, <code>wcscpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the wide character array to copy to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string to copy from</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  maximum number of characters to write, typically the size of the destination buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, writes <code>L'\\0'</code> to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RMAX_SIZE / sizeof(wchar_t)</code>).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcscpy.html
wcscspn	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>size_t wcscspn( const wchar_t* dest, const wchar_t* src );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the length of the maximum initial segment of the wide string pointed to by <code>dest</code>, that consists of only the characters <i>not</i> found in wide string pointed to by <code>src</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string that contains the characters to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The length of the maximum initial segment that contains only characters not found in the character string pointed to by <code>src</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcscspn.html
wcslen	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c95"><td> <code>size_t wcslen( const wchar_t *str );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>size_t wcsnlen_s(const wchar_t *str, size_t strsz);</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.</ul><ul>2) Same as (1), except that the function returns zero if <code>str</code> is a null pointer and returns <code>strsz</code> if the null wide character was not found in the first <code>strsz</code> wide characters of <code>src</code><dl><dd>As all bounds-checked functions, <code>wcsnlen_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td> str</td><td> -</td><td>  pointer to the null-terminated wide string to be examined</td></tr><tr class="t-par"><td> strsz</td><td> -</td><td>  maximum number of wide characters to examine</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) The length of the null-terminated wide string <code>str</code>.</ul><ul>2) The length of the null-terminated wide string <code>str</code> on success, zero if <code>str</code> is a null  pointer, <code>strsz</code> if the null wide character was not found.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcslen.html
wcsncat	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>wchar_t *wcsncat( wchar_t *dest, const wchar_t *src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>wchar_t *wcsncat( wchar_t *restrict dest,<br>                  const wchar_t *restrict src, size_t count );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t wcsncat_s( wchar_t *restrict dest, rsize_t destsz,<br>                   const wchar_t *restrict src, rsize_t count );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Appends at most <code>count</code> wide characters from the wide string pointed to by <code>src</code>, stopping if the null terminator is copied, to the end of the character string pointed to by <code>dest</code>. The wide character <code>src[0]</code> replaces the null terminator at the end of <code>dest</code>. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is <code>count+1</code>).</ul><ul> The behavior is undefined if the destination array is not large enough for the contents of both <code>str</code> and <code>dest</code> and the terminating null wide character.</ul><ul> The behavior is undefined if the strings overlap. </ul><ul>2) Same as (1), except that this function may clobber the remainder of the destination array (from the last byte written to <code>destsz</code>) and that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> there is no null wide character in the first <code>destsz</code> bytes of <code>dest</code></li><li> truncation would occur: <code>count</code> or the length of <code>src</code>, whichever is less, exceeds the space available between the null terminator of <code>dest</code> and <code>destsz</code>.</li><li> overlap would occur between the source and the destination strings</li></ul></dd><dd>As all bounds-checked functions, <code>wcsncat_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to append to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string to copy from</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of wide characters to copy</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  the size of the destination buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, writes <code>L'\\0'</code> to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RMAX_SIZE/sizeof(wchar_t)</code>).</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcsncat.html
wcsncmp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int wcsncmp( const wchar_t* lhs, const wchar_t* rhs, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Compares at most <code>count</code> wide characters of two null-terminated wide strings. The comparison is done lexicographically.</p><p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.<br></p><p>The behavior is undefined if <code>lhs</code> or <code>rhs</code> are not pointers to null-terminated strings.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated wide strings to compare</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of characters to compare</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcsncmp.html
wcsncpy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>wchar_t* wcsncpy( wchar_t* dest, const wchar_t* src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>wchar_t *wcsncpy(wchar_t *restrict dest, const wchar_t *restrict src, size_t n);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t wcsncpy_s( wchar_t *restrict dest, rsize_t destsz,<br>                   const wchar_t *restrict src, rsize_t n);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies at most <code>count</code> characters of the wide string pointed to by <code>src</code> (including the terminating null wide character) to wide character array pointed to by <code>dest</code>. </ul><ul> If <code>count</code> is reached before the entire string <code>src</code> was copied, the resulting wide character array is not null-terminated.</ul><ul> If, after copying the terminating null wide character from <code>src</code>, <code>count</code> is not reached, additional null wide characters are written to <code>dest</code> until the total of <code>count</code> characters have been written.</ul><ul> If the strings overlap, the behavior is undefined.</ul><ul>2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to <code>count</code>, it stops after writing the terminating null character (if there was no null in the source, it writes one at <code>dest[count]</code> and then stops). Also, the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> <code>count</code> is greater or equal <code>destsz</code>, but <code>destsz</code> is less or equal <code>wcsnlen_s(src, count)</code>, in other words, truncation would occur</li><li> overlap would occur between the source and the destination strings</li></ul></dd><dd>As all bounds-checked functions, <code>wcsncpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the wide character array to copy to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the wide string to copy from</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  maximum number of wide characters to copy</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  the size of the destination buffer</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, writes <code>L'\\0'</code> to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>) and may clobber the rest of the destination array with unspecified values.</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcsncpy.html
wcspbrk	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wchar_t* wcspbrk( const wchar_t* dest, const wchar_t* str );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Finds the first character in wide string pointed to by <code>dest</code>, that is also in wide string pointed to by <code>str</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string that contains the characters to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the first character in <code>dest</code>, that is also in <code>str</code>, or <code>NULL</code> if no such character exists.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcspbrk.html
wcsrchr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wchar_t* wcsrchr( const wchar_t* str, wchar_t ch );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Finds the last occurrence of the wide character <code>ch</code> in the wide string pointed to by <code>str</code>. </p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the found character in <code>str</code>, or <code>NULL</code> if no such character is found.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcsrchr.html
wcsspn	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>size_t wcsspn( const wchar_t* dest, const wchar_t* src );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the length of the maximum initial segment of the wide string pointed to by <code>dest</code>, that consists of only the characters found in wide string pointed to by <code>src</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string that contains the characters to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The length of the maximum initial segment that contains only characters from wide string pointed to by <code>src</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcsspn.html
wcsstr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wchar_t* wcsstr( const wchar_t* dest, const wchar_t* src );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of the wide string <code>src</code> in the wide string pointed to by <code>dest</code>. The terminating null characters are not compared.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to examine</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string to search for</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the first character of the found substring in <code>dest</code>, or <code>NULL</code> if no such substring is found. If <code>src</code> points to an empty string, <code>dest</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcsstr.html
wcstof	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>float       wcstof( const wchar_t* str, wchar_t** str_end );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl"><td> <code>double      wcstod( const wchar_t* str, wchar_t** str_end );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long double wcstold( const wchar_t* str, wchar_t** str_end );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets a floating point value in a wide string pointed to by <code>str</code>.</p><p>Function discards any whitespace characters (as determined by <code>std::isspace()</code>) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</p><ul><li>decimal floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C <code>locale</code>) (defines significand)</li><li> (optional) <code>e</code> or <code>E</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li>binary floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>0x</code> or <code>0X</code></li><li> nonempty sequence of hexadecimal digits optionally containing a decimal-point character (as determined by the current C <code>locale</code>) (defines significand)</li><li> (optional) <code>p</code> or <code>P</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li> infinity expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>INF</code> or <code>INFINITY</code> ignoring case</li></ul></dd></dl><ul><li> not-a-number expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>NAN</code> or <code>NAN(</code><i>char_sequence</i><code>)</code> ignoring case of the <code>NAN</code> part. <i>char_sequence</i> can only contain alphanumeric characters. The result is a quiet NaN floating-point value.</li></ul></dd></dl><ul><li> any other expression that may be accepted by the currently installed C <code>locale</code></li></ul><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the wide character past the last character interpreted. If <code>str_end</code> is <code>NULL</code>, it is ignored.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be interpreted</td></tr><tr class="t-par"><td>  str_end</td><td> -</td><td>  pointer to a pointer to a wide character.</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Floating point value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <code>HUGE_VAL</code>, <code>HUGE_VALF</code> or <code>HUGE_VALL</code> is returned. If no conversion can be performed, <code>​0​</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcstof.html
wcstoimax	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><inttypes.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>intmax_t wcstoimax( const wchar_t *restrict nptr, <br>                    wchar_t **restrict endptr, int base );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>uintmax_t wcstoumax( const wchar_t *restrict nptr,<br>                     wchar_t **restrict endptr, int base );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets an unsigned integer value in a wide string pointed to by <code>nptr</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base) unsigned integer number representation and converts them to an  integer value. The valid unsigned  integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>​0​</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>​0​</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <code>locale</code>.</p><p>If the value of base is <code>​0​</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.</p><p>The functions sets the pointer pointed to by <code>endptr</code> to point to the wide character past the last character interpreted. If <code>endptr</code> is <code>NULL</code>, it is ignored.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  nptr</td><td> -</td><td>  pointer to the null-terminated wide string to be interpreted</td></tr><tr class="t-par"><td>  endptr</td><td> -</td><td>  pointer to a pointer to a wide character.</td></tr><tr class="t-par"><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <code>INTMAX_MAX</code>, <code>INTMAX_MIN</code>, <code>UINTMAX_MAX</code>, or <code>​0​</code> is returned, as appropriate. If no conversion can be performed, <code>​0​</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcstoimax.html
wcstok	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>wchar_t* wcstok( wchar_t* str, const wchar_t* delim, wchar_t **ptr );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>wchar_t *wcstok(wchar_t * restrict str, const wchar_t * restrict delim,<br>                wchar_t **restrict ptr);<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>wchar_t *wcstok_s( wchar_t *restrict str, rsize_t *restrict strmax,<br>                   const wchar_t *restrict delim, wchar_t **restrict ptr);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Finds the next token in a null-terminated wide string pointed to by <code>str</code>. The separator characters are identified by null-terminated wide string pointed to by <code>delim</code>.</ul><ul> This function is designed to be called multiples times to obtain successive tokens from the same string.</ul><dl><dd><ul><li> If <code>str != NULL</code>, the call is treated as the first call to <code>wcstok</code> for this particular wide string. The function searches for the first wide character which is <i>not</i> contained in <code>delim</code>.</li></ul><dl><dd><ul><li> If no such wide character was found, there are no tokens in <code>str</code> at all, and the function returns a null pointer. </li><li> If such wide character was found, it is the <i>beginning of the token</i>. The function then searches from that point on for the first wide character that <i>is</i> contained in <code>delim</code>. </li></ul><dl><dd><ul><li> If no such wide character was found, <code>str</code> has only one token, and future calls to <code>wcstok</code> will return a null pointer</li><li> If such wide character was found, it is <i>replaced</i> by the null wide character <code>L'\\0'</code> and the parser state (typically a pointer to the following wide character) is stored in the user-provided location <code>*ptr</code>.</li></ul></dd></dl><ul><li> The function then returns the pointer to the beginning of the token</li></ul></dd></dl><ul><li> If <code>str == NULL</code>, the call is treated as a subsequent call to <code>wcstok</code>: the function continues from where it left in the previous invocation with the same <code>*ptr</code>. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as <code>str</code>.</li></ul></dd></dl><ul>2) Same as (1), except that on every step, writes the number of characters left to see in <code>str</code> into <code>*strmax</code>. Repeat calls (with null <code>str</code>) must pass both <code>strmax</code> and <code>ptr</code> with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed constraint handler function, without storing anything in the object pointed to by <code>ptr</code><dl><dd><ul><li> <code>strmax</code>, <code>delim</code>, or <code>ptr</code> is a null pointer</li><li> on a non-initial call (with null <code>str</code>), <code>*ptr</code> is a null pointer</li><li> on the first call, <code>*strmax</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> search for the end of a token reaches the end of the source string (as measured by the initial value of <code>*strmax</code>)) without encountering the null terminator</li></ul></dd><dd>As all bounds-checked functions, <code>wcstok_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to tokenize</td></tr><tr class="t-par"><td>  delim</td><td> -</td><td>  pointer to the null-terminated wide string identifying delimiters</td></tr><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to an object of type <code>wchar_t*</code>, which is used by both <code>wcstok</code> and <code>wcstok_s</code> to store the internal state of the parser</td></tr><tr class="t-par"><td>  strmax</td><td> -</td><td>  pointer to an object which initially holds the size of <code>str</code>: wcstok_s stores the number of characters that remain to be examined</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Returns pointer to the beginning of the next token or null pointer if there are no more tokens.<br></p><h3><span class="prog__sub">Note</span></h3><p>This function is destructive: it writes the <code>L'\\0'</code> characters in the elements of the string <code>str</code>. In particular, a wide string literal cannot be used as the first argument of <code>wcstok</code>.</p><p>Unlike <code>strtok</code>, <code>wcstok</code> does not update static storage: it stores the parser state in the user-provided location.</p><p>Unlike most other tokenizers, the delimiters in <code>wcstok</code> can be different for each subsequent token, and can even depend on the contents of the previous tokens.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcstok.html
wcstol	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><cwchar></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>long      wcstol( const wchar_t* str, wchar_t** str_end, int base );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>long long wcstoll( const wchar_t* str, wchar_t** str_end, int base );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets an integer value in a wide string pointed to by <code>str</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base)  integer number representation and converts them to an  integer value. The valid   integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>​0​</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>​0​</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <code>locale</code>.</p><p>If the value of base is <code>​0​</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.</p><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the wide character past the last character interpreted. If <code>str_end</code> is <code>NULL</code>, it is ignored.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be interpreted</td></tr><tr class="t-par"><td>  str_end</td><td> -</td><td>  pointer to a pointer to wide character</td></tr><tr class="t-par"><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <code>LONG_MAX</code>, <code>LONG_MIN</code>, <code>LLONG_MAX</code> or <code>LLONG_MIN</code> is returned. If no conversion can be performed, <code>​0​</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcstol.html
wcstoul	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>unsigned long      wcstoul( const wchar_t* str, wchar_t** str_end, int base );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl t-since-c99"><td> <code>unsigned long long wcstoull( const wchar_t* str, wchar_t** str_end, int base );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Interprets an unsigned integer value in a wide string pointed to by <code>str</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base) unsigned integer number representation and converts them to an  integer value. The valid unsigned  integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>​0​</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>​0​</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <code>locale</code>.</p><p>If the value of base is <code>​0​</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.</p><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the wide character past the last character interpreted. If <code>str_end</code> is <code>NULL</code>, it is ignored.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be interpreted</td></tr><tr class="t-par"><td>  str_end</td><td> -</td><td>  pointer to a pointer to a wide character.</td></tr><tr class="t-par"><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <code>ULONG_MAX</code> or <code>ULLONG_MAX</code> is returned. If no conversion can be performed, <code>​0​</code> is returned.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcstoul.html
wcsxfrm	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr class="t-dcl t-until-c99"><td> <code>size_t wcsxfrm( wchar_t* dest, const wchar_t* src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td> (until C99) <br> <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>size_t wcsxfrm( wchar_t* restrict dest, const wchar_t* restrict src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Transforms the null-terminated wide string pointed to by <code>src</code> into the implementation-defined form such that comparing two transformed strings with <code>wcscmp</code> gives the same result as comparing the original strings with <code>wcscoll</code>, in the current C locale.</p><p>The first <code>count</code> characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.</p><p>If <code>count</code> is <code>​0​</code>, then <code>dest</code> is allowed to be a null pointer.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wcsxfrm.html
wctrans	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wctrans_t wctrans( const char* str );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Constructs a value of type <code>wctrans_t</code> that describes a LC_CTYPE category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as <code>"tojhira"</code> or <code>"tojkana"</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  C string holding the name of the desired mapping.<p>The following values of <code>str</code> are supported in all C locales:</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Value of <code>str</code></td><td>  Effect</td></tr><tr class="t-dsc"><td> <code>"toupper"</code></td><td>  identifies the mapping used by <code>towupper</code></td></tr><tr class="t-dsc"><td> <code>"tolower"</code></td><td>  identifies the mapping used by <code>towlower</code></td></tr></table><p><br></p></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>wctrans_t</code> object suitable for use with <code>towctrans</code> to map wide characters according to the named mapping of the current C locale or zero if <code>str</code> does not name a mapping supported by the current C locale.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wctrans.html
wctype	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wctype.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wctype_t wctype( const char* str );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Constructs a value of type <code>wctype_t</code> that describes a LC_CTYPE category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as <code>"jkanji"</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  str</td><td> -</td><td>  C string holding the name of the desired category</td></tr></table><p>The following values of <code>str</code> are supported in all C locales:</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  value of <code>str</code></td><td>  effect</td></tr><tr class="t-dsc"><td> <code>"alnum"</code></td><td>  identifies the category used by <code>iswalnum</code></td></tr><tr class="t-dsc"><td> <code>"alpha"</code></td><td>  identifies the category used by <code>iswalpha</code></td></tr><tr class="t-dsc"><td> <code>"blank"</code></td><td>  identifies the category used by <code>iswblank</code> </td></tr><tr class="t-dsc"><td> <code>"cntrl"</code></td><td>  identifies the category used by <code>iswcntrl</code></td></tr><tr class="t-dsc"><td> <code>"digit"</code></td><td>  identifies the category used by <code>iswdigit</code></td></tr><tr class="t-dsc"><td> <code>"graph"</code></td><td>  identifies the category used by <code>iswgraph</code></td></tr><tr class="t-dsc"><td> <code>"lower"</code></td><td>  identifies the category used by <code>iswlower</code></td></tr><tr class="t-dsc"><td> <code>"print"</code></td><td>  identifies the category used by <code>iswprint</code></td></tr><tr class="t-dsc"><td> <code>"space"</code></td><td>  identifies the category used by <code>iswspace</code></td></tr><tr class="t-dsc"><td> <code>"upper"</code></td><td>  identifies the category used by <code>iswupper</code></td></tr><tr class="t-dsc"><td> <code>"xdigit"</code></td><td>  identifies the category used by <code>iswxdigit</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>wctype_t</code> object suitable for use with <code>iswctype</code> to classify wide characters according to the named category of the current C locale or zero if <code>str</code> does not name a category supported by the current C locale.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wctype.html
wmemchr	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wchar_t *wmemchr( const wchar_t *ptr, wchar_t ch, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Locates the first occurrence of wide character <code>ch</code> in the initial <code>count</code> wide characters of the wide character array or integer array of compatible type, pointed to by <code>ptr</code>. </p><p>If <code>count</code> is zero, the function returns a null pointer.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ptr</td><td> -</td><td>  pointer to the wide character array to be examined</td></tr><tr class="t-par"><td>  ch</td><td> -</td><td>  wide character to search for</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of wide characters to examine</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Pointer to the location of the wide character, or a null pointer if no such character is found.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wmemchr.html
wmemcmp	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>int wmemcmp( const wchar_t *lhs, const wchar_t *rhs, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Compares the first <code>count</code> wide characters of the wide character (or compatible integer type) arrays pointed to by <code>lhs</code> and <code>rhs</code>. The comparison is done lexicographically.</p><p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.<br></p><p>If <code>count</code> is zero, the function does nothing.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  pointers to the wide character arrays to compare</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of wide characters to examine</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Negative value if the value of the first differing wide character in <code>lhs</code> is less than the value of the corresponding wide character in <code>rhs</code>: <code>lhs</code> precedes <code>rhs</code> in lexicographical order.</p><p><code>​0​</code> if all <code>count</code> wide characters of <code>lhs</code> and <code>rhs</code> are equal.</p><p>Positive value if the value of the first differing wide character in <code>lhs</code> is greater than the value of the corresponding wide character in <code>rhs</code>: <code>rhs</code> precedes <code>lhs</code> in lexicographical order.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wmemcmp.html
wmemcpy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux"><td></td><td rowspan="142">(1)</td><td></td></tr><tr class="t-dcl t-since-c95 t-until-c99"><td> <code>wchar_t* wmemcpy( wchar_t* dest, const wchar_t* src, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  <br>(until C99) <br></td></tr><tr class="t-dcl t-since-c99"><td> <code>wchar_t *wmemcpy(wchar_t *restrict dest, const wchar_t *restrict src,<br>                 size_t count );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr></tbody><tbody><tr class="t-dcl t-since-c11"><td> <code>errno_t wmemcpy_s( wchar_t *restrict dest, rsize_t destsz,<br>                   const wchar_t *restrict src, rsize_t count );<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies exactly <code>count</code> successive wide characters from the wide character array pointed to by <code>src</code> to the wide character array pointed to by <code>dest</code>. If the objects overlap, the behavior is undefined. If <code>count</code> is zero, the function does nothing.</ul><ul>2) Same as (1), except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> <code>count</code> is greater than <code>destsz</code> (overflow would occur)</li><li> overlap would occur between the source and the destination arrays</li></ul></dd><dd>As all bounds-checked functions, <code>wmemcpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the wide character array to copy to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the wide character array to copy from</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of wide characters to copy</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  max number of wide characters to write (the size of the destination buffer)</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) returns a copy of <code>dest</code></ul><ul>2) returns zero on success, returns non-zero on error. Also, on error, fills the entire <code>dst</code> up to and not including <code>dst+dstsz</code> with null wide characters, <code>L'\\0'</code> (unless <code>dest</code> is null or <code>destsz</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>)</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wmemcpy.html
wmemmove	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c95"><td> <code>wchar_t* wmemmove( wchar_t* dest, const wchar_t* src, size_t count );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>errno_t wmemmove_s( wchar_t *dest, rsize_t destsz,<br>                    const wchar_t *src, rsize_t count);<br></code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Copies exactly <code>count</code> successive wide characters from the wide character array pointed to by <code>src</code> to the wide character array pointed to by <code>dest</code>. If <code>count</code> is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to <code>dest</code>.</ul><ul>2) Same as (1), except that the following errors are detected at runtime and call the currently installed constraint handler function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> <code>count</code> is greater than <code>destsz</code> (overflow would occur)</li></ul></dd><dd>As all bounds-checked functions, <code>wmemmove_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the wide character array to copy to</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  pointer to the wide character array to copy from</td></tr><tr class="t-par"><td>  destsz</td><td> -</td><td>  max number of wide characters to write (the size of the destination buffer)</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of wide characters to copy</td></tr></table><h3><span class="prog__sub">Return value</span></h3><ul>1) Returns a copy of <code>dest</code></ul><ul>2) Returns zero on success, returns non-zero on error. Also, on error, fills the entire <code>dst</code> up to and not including <code>dst+dstsz</code> with null wide characters, <code>L'\\0'</code> (unless <code>dest</code> is null or <code>destsz</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>)</ul><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wmemmove.html
wmemset	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td> <code>wchar_t *wmemset( wchar_t *dest, wchar_t ch, size_t count );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Copies the wide character <code>ch</code> into each of the first <code>count</code> wide characters of the wide character array (or integer array of compatible type) pointed to by <code>dest</code>.</p><p>If overflow occurs, the behavior is undefined.<br></p><p>If <code>count</code> is zero, the function does nothing.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  pointer to the wide character array to fill</td></tr><tr class="t-par"><td>  ch</td><td> -</td><td>  fill wide character</td></tr><tr class="t-par"><td>  count</td><td> -</td><td>  number of wide characters to fill</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Returns a copy of <code>dest</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/string/wide/wmemset.html
call_once	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void call_once( once_flag* flag, void (*func)(void) );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>typedef /* unspecified */ once_flag</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>#define ONCE_FLAG_INIT /* unspecified */</code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Calls function <code>func</code> exactly once, even if invoked from several threads. The completion of the function <code>func</code> synchronizes with all previous or subsequent calls to <code>call_once</code> with the same <code>flag</code> variable.</ul><ul>2) Complete object type capable of holding a flag used by <code>call_once</code></ul><ul>3) Expands to a value that can be used to initialize an object of type <code>once_flag</code>.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  flag</td><td> -</td><td>  pointer to an object of type <code>call_once</code> that is used to ensure <code>func</code> is called only once</td></tr><tr class="t-par"><td>  func</td><td> -</td><td>  the function to execute only once</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/call_once.html
cnd_broadcast	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int cnd_broadcast( cnd_t *cond );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Unblocks all thread that currently wait on condition variable pointed to by <code>cond</code>. If no threads are blocked, does nothing and returns <code>thrd_success</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  cond</td><td> -</td><td>  pointer to a condition variable</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/cnd_broadcast.html
cnd_destroy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void cnd_destroy( cnd_t* cond );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Destroys the condition variable pointed to by <code>cond</code>.</p><p>If there are threads waiting on <code>cond</code>, the behavior is undefined.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  cond</td><td> -</td><td>  pointer to the condition variable to destroy</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/cnd_destroy.html
cnd_init	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int cnd_init( cnd_t* cond );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Initializes new condition variable. The object pointed to by <code>cond</code> will be set to value that identifies the condition variable.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  cond</td><td> -</td><td>  pointer to a variable to store identifier of the condition variable to</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if the condition variable was successfully created. Otherwise returns <code>thrd_nomem</code> if there was insufficient amount of memory or <code>thrd_error</code> if another error occurred.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/cnd_init.html
cnd_signal	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int cnd_signal( cnd_t *cond );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Unblocks one thread that currently waits on condition variable pointed to by <code>cond</code>. If no threads are blocked, does nothing and returns <code>thrd_success</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  cond</td><td> -</td><td>  pointer to a condition variable</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/cnd_signal.html
cnd_timedwait	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int cnd_timedwait( cnd_t* restrict cond, mtx_t* restrict mutex,<br>                   const struct timespec* restrict time_point );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically unlocks the mutex pointed to by <code>mutex</code> and blocks on the condition variable pointed to by <code>cond</code> until the thread is signalled by <code>cnd_signal</code> or <code>cnd_broadcast</code>, or until the <code>TIME_UTC</code> based time point pointed to by <code>time_point</code> has been reached. The mutex is locked again before the function returns.</p><p>The behavior is undefined if the mutex is not already locked by the calling thread.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  cond</td><td> -</td><td>  pointer to the condition variable to block on</td></tr><tr class="t-par"><td>  mutex</td><td> -</td><td>  pointer to the mutex to unlock for the duration of the block</td></tr><tr class="t-par"><td>  duration</td><td> -</td><td>  pointer to a object specifying timeout time to wait until</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_timedout</code> if the timeout time has been reached before the mutex is locked, or  <code>thrd_error</code> if an error occurred.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/cnd_timedwait.html
cnd_wait	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int cnd_wait( cnd_t* cond, mtx_t* mutex );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Atomically unlocks the mutex pointed to by <code>mutex</code> and blocks on the condition variable pointed to by <code>cond</code> until the thread is signalled by <code>cnd_signal</code> or <code>cnd_broadcast</code>. The mutex is locked again before the function returns.</p><p>The behavior is undefined if the mutex is not already locked by the calling thread.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  cond</td><td> -</td><td>  pointer to the condition variable to block on</td></tr><tr class="t-par"><td>  mutex</td><td> -</td><td>  pointer to the mutex to unlock for the duration of the block</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/cnd_wait.html
mtx_destroy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void mtx_destroy( mtx_t *mutex );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Destroys the mutex pointed to by <code>mutex</code>.</p><p>If there are threads waiting on <code>mutex</code>, the behavior is undefined.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  mutex</td><td> -</td><td>  pointer to the mutex to destroy</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/mtx_destroy.html
mtx_init	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int mtx_init( mtx_t* mutex, int type );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Creates a new mutex object with <code>type</code>. The object pointed to by <code>mutex</code> is set to an identifier of the newly created mutex.</p><p><code>type</code> must have one of the following values:</p><ul><li><code>mtx_plain</code> - a simple, non-recursive mutex is created.</li><li><code>mtx_timed</code> - a non-recursive mutex, that supports timeout, is created.</li><li><code>mtx_plain | mtx_recursive</code> - a recursive mutex is created.</li><li><code>mtx_timed | mtx_recursive</code> - a recursive mutex, that supports timeout, is created.</li></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  mutex</td><td> -</td><td>  pointer to the mutex to initialize</td></tr><tr class="t-par"><td>  type</td><td> -</td><td>  the type of the mutex</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/mtx_init.html
mtx_lock	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int mtx_lock( mtx_t* mutex );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Blocks the current thread until the mutex pointed to by <code>mutex</code> is locked.</p><p>The behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.<br></p><p>Prior calls to <code>mtx_unlock</code> on the same mutex <i>synchronize-with</i> this operation, and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  mutex</td><td> -</td><td>  pointer to the mutex to lock</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/mtx_lock.html
mtx_timedlock	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int mtx_timedlock( mtx_t *restrict mutex,<br>                   const struct timespec *restrict time_point );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Blocks the current thread until the mutex pointed to by <code>mutex</code> is locked or until the <code>TIME_UTC</code> based time point pointed to by <code>time_point</code> has been reached.</p><p>The behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.<br></p><p>The behavior is undefined if the mutex does not support timeout.<br></p><p>Prior calls to <code>mtx_unlock</code> on the same mutex <i>synchronize-with</i> this operation (if this operation succeeds), and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  mutex</td><td> -</td><td>  pointer to the mutex to lock</td></tr><tr class="t-par"><td>  time_point</td><td> -</td><td>  pointer to the timeout time to wait until</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_timedout</code> if the timeout time has been reached before the mutex is locked, <code>thrd_error</code> if an error occurs.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/mtx_timedlock.html
mtx_trylock	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int mtx_trylock( mtx_t *mutex );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Tries to lock the mutex pointed to by <code>mutex</code> without blocking. Returns immediately if the mutex is already locked.</p><p>Prior calls to <code>mtx_unlock</code> on the same mutex <i>synchronize-with</i> this operation (if this operation succeeds), and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  mutex</td><td> -</td><td>  pointer to the mutex to lock</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_busy</code> if the mutex has already been locked, <code>thrd_error</code> if an error occurs.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/mtx_trylock.html
mtx_types	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>enum {<br>    mtx_plain = /* unspecified */,<br>    mtx_recursive = /* unspecified */,<br>    mtx_timed = /* unspecified */<br>};<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>When passed to <code>mtx_init</code>, identifies the type of a mutex to create.</p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>mtx_plain</code></td><td>  plain mutex</td></tr><tr class="t-dsc"><td> <code>mtx_recursive</code></td><td>  recursive mutex</td></tr><tr class="t-dsc"><td> <code>mtx_timed</code></td><td>  timed mutex</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/mtx_types.html
mtx_unlock	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int mtx_unlock( mtx_t *mutex );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Unlocks the mutex pointed to by <code>mutex</code>. </p><p>The behavior is undefined if the mutex is not locked by the calling thread.<br></p><p>This function <i>synchronizes-with</i> subsequent <code>mtx_lock</code>, <code>mtx_trylock</code>, or <code>mtx_timedlock</code> on the same mutex. All lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic).</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  mutex</td><td> -</td><td>  pointer to the mutex to unlock</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/mtx_unlock.html
ONCE_FLAG_INIT	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void call_once( once_flag* flag, void (*func)(void) );</code></td><td> (1) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>typedef /* unspecified */ once_flag</code></td><td> (2) </td><td>  </td></tr><tr class="t-dcl t-since-c11"><td> <code>#define ONCE_FLAG_INIT /* unspecified */</code></td><td> (3) </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><ul>1) Calls function <code>func</code> exactly once, even if invoked from several threads. The completion of the function <code>func</code> synchronizes with all previous or subsequent calls to <code>call_once</code> with the same <code>flag</code> variable.</ul><ul>2) Complete object type capable of holding a flag used by <code>call_once</code></ul><ul>3) Expands to a value that can be used to initialize an object of type <code>once_flag</code>.</ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  flag</td><td> -</td><td>  pointer to an object of type <code>call_once</code> that is used to ensure <code>func</code> is called only once</td></tr><tr class="t-par"><td>  func</td><td> -</td><td>  the function to execute only once</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/ONCE_FLAG_INIT.html
thrd_create	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int thrd_create( thrd_t *thr, thrd_start_t func, void *arg );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Creates a new thread executing the function <code>func</code>. The function is invoked as <code>func(arg)</code>.</p><p>If successful, the object pointed to by <code>thr</code> is set to the identifier of the new thread.</p><p>The completion of this function <i>synchronizes-with</i> the beginning of the thread.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  thr</td><td> -</td><td>  pointer to memory location to put the identifier of the new thread</td></tr><tr class="t-par"><td>  func</td><td> -</td><td>  function to execute</td></tr><tr class="t-par"><td>  arg</td><td> -</td><td>  argument to pass to the function</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if the creation of the new thread was successful. Otherwise returns <code>thrd_nomem</code> if there was insufficient amount of memory or <code>thrd_error</code> if another error occurred.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_create.html
thrd_current	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>thrd_t thrd_current(void);</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the identifier of the calling thread.<br></p><h3><span class="prog__sub">Parameters</span></h3><p>(none)<br></p><h3><span class="prog__sub">Return value</span></h3><p>The identifier of the calling thread.<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_current.html
thrd_detach	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int thrd_detach( thrd_t thr );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Detaches the thread identified by <code>thr</code> from the current environment. The resources held by the thread will be freed automatically once the thread exits.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  thr</td><td> -</td><td>  identifier of the thread to detach</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_detach.html
thrd_equal	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int thrd_equal( thrd_t lhs, thrd_t rhs );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Checks whether <code>lhs</code> and <code>rhs</code> refer to the same thread.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  lhs, rhs</td><td> -</td><td>  threads to compare</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>Non-zero value if <code>lhs</code> and <code>rhs</code> refer to the same value, <code>​0​</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_equal.html
thrd_errors	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>enum {<br>    thrd_success = /* unspecified */,<br>    thrd_nomem = /* unspecified */,<br>    thrd_timedout = /* unspecified */,<br>    thrd_busy = /* unspecified */,<br>    thrd_error = /* unspecified */<br>};<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Identifiers a thread error state.<br></p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Constant</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>thrd_success</code></td><td>  indicates successful return value</td></tr><tr class="t-dsc"><td> <code>thrd_timedout</code></td><td>  indicates timed out return value</td></tr><tr class="t-dsc"><td> <code>thrd_busy</code></td><td>  indicates unsuccessful return value due to resource temporary unavailable</td></tr><tr class="t-dsc"><td> <code>thrd_nomem</code></td><td>  indicates unsuccessful return value due to out of memory condition</td></tr><tr class="t-dsc"><td> <code>thrd_error</code></td><td>  indicates unsuccessful return value</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_errors.html
thrd_exit	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>_Noreturn void thrd_exit( int res );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>First, for every thread-specific storage key which was created with a non-null destructor and for which the associated value is non-null (see <code>tss_create</code>), <code>thrd_exit</code> sets the value associated with the key to <code>NULL</code> and then invokes the destructor with the previous value of the key. The order in which the destructors are invoked is unspecified.</p><p>If, after this, there remain keys with both non-null destructors and values (e.g. if a destructor executed <code>tss_set</code>), the process is repeated up to <code>TSS_DTOR_ITERATIONS</code> times.</p><p>FInally, the <code>thrd_exit</code> function terminates execution of the calling thread and sets its result code to <code>res</code>.</p><p>If the last thread in the program is terminated with <code>thrd_exit</code>, the entire program terminates as if by calling <code>exit</code> with <code>EXIT_SUCCESS</code> as the argument (so the functions registered by <code>atexit</code> are executed in the context of that last thread)</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  res</td><td> -</td><td>  the result value to return</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_exit.html
thrd_join	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int thrd_join( thrd_t thr, int *res );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Blocks the current thread until the thread identified by <code>thr</code> finishes execution.</p><p>If <code>res</code> is not a null pointer, the result code of the thread is put to the location pointed to by <code>res</code>.</p><p>The termination of the thread <i>synchronizes-with</i> the completion of this function.</p><p>The behavior is undefined if the thread was previously detached or joined by another thread.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  thr</td><td> -</td><td>  identifier of the thread to join</td></tr><tr class="t-par"><td>  res</td><td> -</td><td>  location to put the result code to</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_join.html
thrd_sleep	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int thrd_sleep( const struct timespec* time_point,<br>                struct timespec* remaining );<br></code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Blocks the execution of the current thread for <i>at least</i> until the <code>TIME_UTC</code> based time point pointed to by <code>time_point</code> has been reached.</p><p>The sleep may resume earlier if a <code>signal</code> that is not ignored is received. In such case, if <code>remaining</code> is not <code>NULL</code>, the remaining time duration is stored into the object pointed to by <code>remaining</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  time_point</td><td> -</td><td>  pointer to the time point to sleep until</td></tr><tr class="t-par"><td>  remaining</td><td> -</td><td>  pointer to the object to put the remaining time on interruption. May be <code>NULL</code>, in which case it is ignored</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>​0​</code> on successful sleep, <code>-1</code> if a signal occurred, other negative value if an error occurred.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_sleep.html
thrd_yield	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void thrd_yield();</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Provides a hint to the implementation to reschedule the execution of threads, allowing other threads to run. <br></p><h3><span class="prog__sub">Parameters</span></h3><p>(none)<br></p><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thrd_yield.html
thread_local	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>#define thread_local _Thread_local</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Convenience macro which can be used to specify that an object has thread-local storage duration.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/thread_local.html
tss_create	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int tss_create( tss_t* tss_key, tss_dtor_t destructor );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Creates new thread-specific storage key and stores it in the object pointed to by <code>tss_key</code>. Although the same key value may be used by different threads, the values bound to the key by <code>tss_set</code> are maintained on a per-thread basis and persist for the life of the calling thread.</p><p>The value <code>NULL</code> is associated with the newly created key in all existing threads, and upon thread creation, the values associated with all TSS keys is initialized to <code>NULL</code>.</p><p>If <code>destructor</code> is not a null pointer, then also associates the destructor which is called when the storage is released by <code>thrd_exit</code> (but not by <code>tss_delete</code> and not at program termination by <code>exit</code>).</p><p>A call to <code>tss_create</code> from within a thread-specific storage destructor results in undefined behavior.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  tss_key</td><td> -</td><td>  pointer to memory location to store the new thread-specific storage key</td></tr><tr class="t-par"><td>  destructor</td><td> -</td><td>  pointer to a function to call at thread exit</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/tss_create.html
tss_delete	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void tss_delete( tss_t tss_id );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Destroys the thread-specific storage identified by <code>tss_id</code>. </p><p>The destructor, if one was registered by <code>tss_create</code>, is not called (they are only called at thread exit, either by <code>thrd_exit</code> or by returning from the thread function), it is the responsibility of the programmer to ensure that every thread that is aware of <code>tss_id</code> performed all necessary cleanup, before the call to <code>tss_delete</code> is made.</p><p>If <code>tss_delete</code> is called while another thread is executing destructors for <code>tss_id</code>, it's unspecified whether this changes the number of invocations to the associated destructor.</p><p>If <code>tss_delete</code> is called while the calling thread is executing destructors, then the destructor associated with <code>tss_id</code> will not be executed again on this thread.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  tss_id</td><td> -</td><td>  thread-specific storage key previously returned by <code>tss_create</code> and not yet deleted by <code>tss_delete</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/tss_delete.html
TSS_DTOR_ITERATIONS	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>#define TSS_DTOR_ITERATIONS /* unspecified */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Expands to a positive integral constant expression defining the maximum number of times a destructor for thread-local storage pointer will be called by  <code>thrd_exit</code>.</p><p>This constant is equivalent to the POSIX <code>PTHREAD_DESTRUCTOR_ITERATIONS</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/TSS_DTOR_ITERATIONS.html
tss_get	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>void *tss_get( tss_t tss_key );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the value held in thread-specific storage for the current thread identified by <code>tss_key</code>. Different threads may get different values identified by the same key.</p><p>On thread startup (see <code>thrd_create</code>), the values associated with all TSS keys are NULL. Different value may be placed in the thread-specific storage with <code>tss_set</code>.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  tss_key</td><td> -</td><td>  thread-specific storage key, obtained from <code>tss_create</code> and not deleted by <code>tss_delete</code></td></tr></table><h3><span class="prog__sub">Return value</span></h3><p>The value on success, <code>NULL</code> on failure.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/tss_get.html
tss_set	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><threads.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>int tss_set( tss_t tss_id, void *val );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Sets the value of the thread-specific storage identified by <code>tss_id</code> for the current thread to <code>val</code>. Different threads may set different values to the same key.</p><p>The destructor, if available, is not invoked.<br></p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  tss_id</td><td> -</td><td>  thread-specific storage key, obtained from <code>tss_create</code> and not deleted by <code>tss_delete</code></td></tr><tr class="t-par"><td>  val</td><td> -</td><td>  value to set thread-specific storage to</td></tr></table><h3><span class="prog__sub">Return value</span></h3><p><code>thrd_success</code> if successful, <code>thrd_error</code> otherwise.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/thread/tss_set.html
boolean	A										<section class="prog__container"><p>The C programming language, as of C99, supports Boolean arithmetic with the built-in type <code>_Bool</code> (see _Bool). When the header <code><stdbool.h></code> is included, the Boolean type is also accessible as <code>bool</code>.</p><p>Standard logical operators <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> can be used with the Boolean type in any combination. </p><p>A program may undefine and perhaps then redefine the macros <code>bool</code>, <code>true</code> and <code>false</code>.</p><h3><span class="prog__sub">Macros</span></h3><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Macro name</td><td>  Expands to</td></tr><tr class="t-dsc"><td> <code>bool</code></td><td> <code>_Bool</code></td></tr><tr class="t-dsc"><td> <code>true</code></td><td>  integer constant <code>1</code></td></tr><tr class="t-dsc"><td> <code>false</code></td><td>  integer constant <code>0</code></td></tr><tr class="t-dsc"><td> <code>__bool_true_false_are_defined</code></td><td>  integer constant <code>1</code></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/boolean.html
integer	A										<section class="prog__container"><h3><span class="prog__sub">Types</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdint.h></code> </td></tr><tr class="t-dsc"><td> <code>int8_t</code><br><code>int16_t</code><br><code>int32_t</code><br><code>int64_t</code><br></td><td>  signed integer type with width of<br> exactly 8, 16, 32 and 64 bits respectively<br>with no padding bits and using 2's complement for negative values<br>(provided only if the implementation directly supports the type)<br></td></tr><tr class="t-dsc"><td> <code>int_fast8_t</code><br><code>int_fast16_t</code><br><code>int_fast32_t</code><br><code>int_fast64_t</code><br></td><td>  fastest signed integer type with width of<br> at least 8, 16, 32 and 64 bits respectively<br></td></tr><tr class="t-dsc"><td> <code>int_least8_t</code><br><code>int_least16_t</code><br><code>int_least32_t</code><br><code>int_least64_t</code><br></td><td>  smallest signed integer type with width of<br> at least 8, 16, 32 and 64 bits respectively<br></td></tr><tr class="t-dsc"><td> <code>intmax_t</code></td><td>  maximum width integer type</td></tr><tr class="t-dsc"><td> <code>intptr_t</code></td><td>  integer type capable of holding a pointer</td></tr><tr class="t-dsc"><td> <code>uint8_t</code><br><code>uint16_t</code><br><code>uint32_t</code><br><code>uint64_t</code><br></td><td>  unsigned integer type with width of<br> exactly 8, 16, 32 and 64 bits respectively <br>(provided only if the implementation directly supports the type)<br></td></tr><tr class="t-dsc"><td> <code>uint_fast8_t</code><br><code>uint_fast16_t</code><br><code>uint_fast32_t</code><br><code>uint_fast64_t</code><br></td><td>  fastest unsigned integer type with width of<br> at least 8, 16, 32 and 64 bits respectively<br></td></tr><tr class="t-dsc"><td> <code>uint_least8_t</code><br><code>uint_least16_t</code><br><code>uint_least32_t</code><br><code>uint_least64_t</code><br></td><td>  smallest unsigned integer type with width of<br> at least 8, 16, 32 and 64 bits respectively<br></td></tr><tr class="t-dsc"><td> <code>uintmax_t</code></td><td>  maximum width unsigned integer type</td></tr><tr class="t-dsc"><td> <code>uintptr_t</code></td><td>  unsigned integer type capable of holding a pointer</td></tr></table><h3><span class="prog__sub">Macro constants</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdint.h></code> </td></tr><tr><td colspan="2"> <h5>   Signed integers : minimum value </h5></td></tr><tr class="t-dsc"><td> <code><table><tr><td>INT8_MIN</td></tr><tr><td>INT16_MIN</td></tr><tr><td>INT32_MIN</td></tr><tr><td>INT64_MIN</td></tr></table></code></td><td>    minimum value of an object of type <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>INT_FAST8_MIN</td></tr><tr><td>INT_FAST16_MIN</td></tr><tr><td>INT_FAST32_MIN</td></tr><tr><td>INT_FAST64_MIN</td></tr></table></code></td><td>    minimum value of an object of type <code>int_fast8_t</code>, <code>int_fast16_t</code>, <code>int_fast32_t</code>, <code>int_fast64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>INT_LEAST8_MIN</td></tr><tr><td>INT_LEAST16_MIN</td></tr><tr><td>INT_LEAST32_MIN</td></tr><tr><td>INT_LEAST64_MIN</td></tr></table></code></td><td>    minimum value of an object of type <code>int_least8_t</code>, <code>int_least16_t</code>, <code>int_least32_t</code>, <code>int_least64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>INTPTR_MIN</code></td><td>   minimum value of an object of type <code>intptr_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>INTMAX_MIN</code></td><td>   minimum value of an object of type <code>intmax_t</code> <br> (macro constant)<br></td></tr><tr><td colspan="2"> <h5>   Signed integers : maximum value </h5></td></tr><tr class="t-dsc"><td> <code><table><tr><td>INT8_MAX</td></tr><tr><td>INT16_MAX</td></tr><tr><td>INT32_MAX</td></tr><tr><td>INT64_MAX</td></tr></table></code></td><td>    maximum value of an object of type <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>INT_FAST8_MAX</td></tr><tr><td>INT_FAST16_MAX</td></tr><tr><td>INT_FAST32_MAX</td></tr><tr><td>INT_FAST64_MAX</td></tr></table></code></td><td>    maximum value of an object of type <code>int_fast8_t</code>, <code>int_fast16_t</code>, <code>int_fast32_t</code>, <code>int_fast64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>INT_LEAST8_MAX</td></tr><tr><td>INT_LEAST16_MAX</td></tr><tr><td>INT_LEAST32_MAX</td></tr><tr><td>INT_LEAST64_MAX</td></tr></table></code></td><td>    maximum value of an object of type <code>int_least8_t</code>, <code>int_least16_t</code>, <code>int_least32_t</code>, <code>int_least64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>INTPTR_MAX</code></td><td>   maximum value of an object of type <code>intptr_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>INTMAX_MAX</code></td><td>   maximum value of an object of type <code>intmax_t</code> <br> (macro constant)<br></td></tr><tr><td colspan="2"> <h5>   Unsigned integers : maximum value </h5></td></tr><tr class="t-dsc"><td> <code><table><tr><td>UINT8_MAX</td></tr><tr><td>UINT16_MAX</td></tr><tr><td>UINT32_MAX</td></tr><tr><td>UINT64_MAX</td></tr></table></code></td><td>    maximum value of an object of type <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, <code>uint64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>UINT_FAST8_MAX</td></tr><tr><td>UINT_FAST16_MAX</td></tr><tr><td>UINT_FAST32_MAX</td></tr><tr><td>UINT_FAST64_MAX</td></tr></table></code></td><td>    maximum value of an object of type <code>uint_fast8_t</code>, <code>uint_fast16_t</code>, <code>uint_fast32_t</code>, <code>uint_fast64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>UINT_LEAST8_MAX</td></tr><tr><td>UINT_LEAST16_MAX</td></tr><tr><td>UINT_LEAST32_MAX</td></tr><tr><td>UINT_LEAST64_MAX</td></tr></table></code></td><td>    maximum value of an object of type <code>uint_least8_t</code>, <code>uint_least16_t</code>, <code>uint_least32_t</code>, <code>uint_least64_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>UINTPTR_MAX</code></td><td>   maximum value of an object of type <code>uintptr_t</code> <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>UINTMAX_MAX</code></td><td>   maximum value of an object of type <code>uintmax_t</code> <br> (macro constant)<br></td></tr></table><h3><span class="prog__sub">Function macros for minimum-width integer constants</span></h3><table class="t-dsc-begin"><tr class="t-dsc"><td> <code><table><tr><td>INT8_C</td></tr><tr><td>INT16_C</td></tr><tr><td>INT32_C</td></tr><tr><td>INT64_C</td></tr></table></code></td><td>   expands to an integer constant expression having the value specified by its argument and the type <code>int_least8_t</code>, <code>int_least16_t</code>, <code>int_least32_t</code>, <code>int_least64_t</code> respectively  <br> (function macro)<br></td></tr><tr class="t-dsc"><td> <code>INTMAX_C</code></td><td>   expands to an integer constant expression having the value specified by its argument and the type <code>intmax_t</code> <br> (function macro)<br></td></tr><tr class="t-dsc"><td> <code><table><tr><td>UINT8_C</td></tr><tr><td>UINT16_C</td></tr><tr><td>UINT32_C</td></tr><tr><td>UINT64_C</td></tr></table></code></td><td>   expands to an integer constant expression having the value specified by its argument and the type <code>uint_least8_t</code>, <code>uint_least16_t</code>, <code>uint_least32_t</code>, <code>uint_least64_t</code> respectively  <br> (function macro)<br></td></tr><tr class="t-dsc"><td> <code>UINTMAX_C</code></td><td>   expands to an integer constant expression having the value specified by its argument and the type <code>uintmax_t</code> <br> (function macro)<br></td></tr></table><pre><code>#include <stdint.h>UINT64_C(0x123) // might expand to 0x123ULL or 0x123UL</code></pre><p><br></p><h3><span class="prog__sub">Format macro constants</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><inttypes.h></code> </td></tr></table><h4>Format constants for the <code>fprintf</code> family of functions</h4><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="3"> Equivalent<br>for <code>int</code> or<br><code>unsigned int</code><br></th><th rowspan="3"> Description</th><th colspan="5"> Macros for data types</th></tr><tr><td> <br><code>[u]int<b>x</b>_t</code><br></td><td> <code>[u]int_least<b>x</b>_t</code></td><td> <code>[u]int_fast<b>x</b>_t</code></td><td rowspan="2"> <code>[u]intmax_t</code></td><td rowspan="2"> <code>[u]intptr_t</code></td></tr><tr><td colspan="3"> <b>x</b> = 8, 16, 32 or 64</td></tr><tr><th> <code>d</code></th><td rowspan="2" style="text-align:left;"> output of a signed decimal integer value</td><td> PRId<b>x</b></td><td> PRIdLEAST<b>x</b></td><td> PRIdFAST<b>x</b></td><td> PRIdMAX</td><td> PRIdPTR</td></tr><tr><th> <code>i</code></th><td> PRIi<b>x</b></td><td> PRIiLEAST<b>x</b></td><td> PRIiFAST<b>x</b></td><td> PRIiMAX</td><td> PRIiPTR</td></tr><tr><th> <code>u</code></th><td style="text-align:left;"> output of an unsigned decimal integer value</td><td> PRIu<b>x</b></td><td> PRIuLEAST<b>x</b></td><td> PRIuFAST<b>x</b></td><td> PRIuMAX</td><td> PRIuPTR</td></tr><tr><th> <code>o</code></th><td style="text-align:left;"> output of an unsigned octal integer value</td><td> PRIo<b>x</b></td><td> PRIoLEAST<b>x</b></td><td> PRIoFAST<b>x</b></td><td> PRIoMAX</td><td> PRIoPTR</td></tr><tr><th> <code>x</code></th><td style="text-align:left;"> output of an unsigned lowercase hexadecimal integer value</td><td> PRIx<b>x</b></td><td> PRIxLEAST<b>x</b></td><td> PRIxFAST<b>x</b></td><td> PRIxMAX</td><td> PRIxPTR</td></tr><tr><th> <code>X</code></th><td style="text-align:left;"> output of an unsigned uppercase hexadecimal integer value</td><td> PRIX<b>x</b></td><td> PRIXLEAST<b>x</b></td><td> PRIXFAST<b>x</b></td><td> PRIXMAX</td><td> PRIXPTR</td></tr></table><h4>Format constants for the <code>fscanf</code> family of functions</h4><table class="wikitable" style="text-align:center; font-size:85%; max-width:90em;"><tr><th rowspan="3"> Equivalent<br>for <code>int</code> or<br><code>unsigned int</code><br></th><th rowspan="3"> Description</th><th colspan="5"> Macros for data types</th></tr><tr><td> <br><code>[u]int<b>x</b>_t</code><br></td><td> <code>[u]int_least<b>x</b>_t</code></td><td> <code>[u]int_fast<b>x</b>_t</code></td><td rowspan="2"> <code>[u]intmax_t</code></td><td rowspan="2"> <code>[u]intptr_t</code></td></tr><tr><td colspan="3"> <b>x</b> = 8, 16, 32 or 64</td></tr><tr><th> <code>d</code></th><td style="text-align:left;"> input of a signed decimal integer value</td><td> SCNd<b>x</b></td><td> SCNdLEAST<b>x</b></td><td> SCNdFAST<b>x</b></td><td> SCNdMAX</td><td> SCNdPTR</td></tr><tr><th> <code>i</code></th><td style="text-align:left;"> input of a signed integer value (base is determined by the first characters parsed)</td><td> SCNi<b>x</b></td><td> SCNiLEAST<b>x</b></td><td> SCNiFAST<b>x</b></td><td> SCNiMAX</td><td> SCNiPTR</td></tr><tr><th> <code>u</code></th><td style="text-align:left;"> input of an unsigned decimal integer value</td><td> SCNu<b>x</b></td><td> SCNuLEAST<b>x</b></td><td> SCNuFAST<b>x</b></td><td> SCNuMAX</td><td> SCNuPTR</td></tr><tr><th> <code>o</code></th><td style="text-align:left;"> input of an unsigned octal integer value</td><td> SCNo<b>x</b></td><td> SCNoLEAST<b>x</b></td><td> SCNoFAST<b>x</b></td><td> SCNoMAX</td><td> SCNoPTR</td></tr><tr><th> <code>x</code></th><td style="text-align:left;"> input of an unsigned hexadecimal integer value</td><td> SCNx<b>x</b></td><td> SCNxLEAST<b>x</b></td><td> SCNxFAST<b>x</b></td><td> SCNxMAX</td><td> SCNxPTR</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/integer.html
limits	A										<section class="prog__container"><h3><span class="prog__sub">Limits of library types</span></h3><table class="t-dsc-begin"><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><stdint.h></code> </td></tr><tr class="t-dsc"><td> <code>PTRDIFF_MIN</code><table><tr><td></td></tr></table></td><td>   minimum value of object of <code>ptrdiff_t</code> type  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>PTRDIFF_MAX</code><table><tr><td></td></tr></table></td><td>   maximum value of object of <code>ptrdiff_t</code> type  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>SIZE_MAX</code><table><tr><td></td></tr></table></td><td>   maximum value of object of <code>size_t</code> type  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>SIG_ATOMIC_MIN</code><table><tr><td></td></tr></table></td><td>   minimum value of object of <code>sig_atomic_t</code> type  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>SIG_ATOMIC_MAX</code><table><tr><td></td></tr></table></td><td>   maximum value of object of <code>sig_atomic_t</code> type  <br> (macro constant)<br></td></tr><tr class="t-dsc-header"><td colspan="2"> Defined in header <code><wchar.h></code> </td></tr><tr class="t-dsc"><td> <code>WCHAR_MIN</code><table><tr><td></td></tr></table></td><td>   minimum value of object of <code>wchar_t</code> type  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>WCHAR_MAX</code><table><tr><td></td></tr></table></td><td>   maximum value of object of <code>wchar_t</code> type  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>WINT_MIN</code><table><tr><td></td></tr></table></td><td>   minimum value of object of <code>wint_t</code> type  <br> (macro constant)<br></td></tr><tr class="t-dsc"><td> <code>WINT_MAX</code><table><tr><td></td></tr></table></td><td>   maximum value of object of <code>wint_t</code> type  <br> (macro constant)<br></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/limits.html
max_align_t	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stddef.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c11"><td> <code>typedef /*implementation-defined*/ max_align_t;</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><code>max_align_t</code> is a type whose alignment requirement is at least as strict (as large) as that of every scalar type.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/max_align_t.html
NULL	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stddef.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><locale.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define NULL /*implementation-defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The macro <code>NULL</code> is an implementation-defined null pointer constant, which may be</p><ul><li> an integer constant expression with the value <code>​0​</code></li><li> an integer constant expression with the value 0 cast to the type <code>void*</code></li></ul><p>A null pointer constant may be converted to any pointer type; such conversion results in the null pointer value of that type.</p><h3><span class="prog__sub">Possible implementation</span></h3><table class="eq-fun-cpp-table"><tr><td><pre><code>// C++ compatible:#define NULL 0// C++ incompatible:#define NULL (10*2 - 20)#define NULL ((void*)0)</code></pre></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/NULL.html
offsetof	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stddef.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>#define offsetof(type, member) /*implementation-defined*/</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The macro <code>offsetof</code> expands to a constant of type <code>size_t</code>, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/offsetof.html
ptrdiff_t	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stddef.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>typedef /*implementation-defined*/ ptrdiff_t;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><code>ptrdiff_t</code> is the signed integer type of the result of subtracting two pointers.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/ptrdiff_t.html
size_t	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stddef.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><stdio.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><stdlib.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><string.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><time.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><uchar.h></code></td><td></td><td></td></tr><tr class="t-dsc-header"><td> Defined in header <code><wchar.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>typedef /*implementation-defined*/ size_t;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><code>size_t</code> is the unsigned integer type of the result of <tt>sizeof</tt> <span>, alignof</span> <span></span> and <code>offsetof</code>. </p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/size_t.html
FLT_EVAL_METHOD	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><float.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FLT_EVAL_METHOD /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Specifies the precision in which all floating-point arithmetic operations other than assignment and cast are done. <br></p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Value</td><td>  Explanation</td></tr><tr class="t-dsc"><td>  negative values except <code>-1</code></td><td>  implementation-defined behavior</td></tr><tr class="t-dsc"><td> <code>-1</code></td><td>  the default precision is not known</td></tr><tr class="t-dsc"><td> <code>0</code></td><td>  all operations and constants evaluate in the range and precision of the type used. Additionally, <code>float_t</code> and <code>double_t</code> are equivalent to <code>float</code> and <code>double</code> respectively</td></tr><tr class="t-dsc"><td> <code>1</code></td><td>  all operations and constants evaluate in the range and precision of <code>double</code>. Additionally, both <code>float_t</code> and <code>double_t</code> are equivalent to <code>double</code></td></tr><tr class="t-dsc"><td> <code>2</code></td><td>  all operations and constants evaluate in the range and precision of <code>long double</code>. Additionally, both <code>float_t</code> and <code>double_t</code> are equivalent to <code>long double</code></td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD.html
FLT_ROUNDS	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><float.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>#define FLT_ROUNDS /* implementation defined */</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>Returns the current rounding direction of floating-point arithmetic operations.<br></p><table class="t-dsc-begin"><tr class="t-dsc-hitem"><td>  Value</td><td>  Explanation</td></tr><tr class="t-dsc"><td> <code>-1</code></td><td>  the default rounding direction is not known</td></tr><tr class="t-dsc"><td> <code>0</code></td><td>  toward zero, <code>FE_TOWARDZERO</code></td></tr><tr class="t-dsc"><td> <code>1</code></td><td>  to nearest, <code>FE_TONEAREST</code></td></tr><tr class="t-dsc"><td> <code>2</code></td><td>  towards positive infinity, <code>FE_UPWARD</code></td></tr><tr class="t-dsc"><td> <code>3</code></td><td>  towards negative infinity, <code>FE_DOWNWARD</code></td></tr><tr class="t-dsc"><td>  other values</td><td>  implementation-defined behavior</td></tr></table><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/types/limits/FLT_ROUNDS.html
va_arg	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdarg.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>T va_arg( va_list ap, T );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>va_arg</code> macro expands to an expression of type <code>T</code> that corresponds to the next parameter from the <code>va_list</code> <code>ap</code>.</p><p>Prior to calling <code>va_arg</code>, <code>ap</code> must be initialized by a call to either <code>va_start</code> or <code>va_copy</code>, with no intervening call to <code>va_end</code>.  Each invocation of the <code>va_arg</code> macro modifies <code>ap</code> to point to the next variable argument.</p><p>If <code>va_arg</code> is called when there are no more arguments in <code>ap</code>, or if the type of the next argument in <code>ap</code> (after promotions) is not compatible with <code>T</code>, the behavior is undefined, unless:</p><ul><li> one type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in both types; or</li><li> one type is pointer to <code>void</code> and the other is a pointer to a character type.</li></ul><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ap</td><td> -</td><td>  an instance of the <code>va_list</code> type</td></tr><tr class="t-par"><td>  T</td><td> -</td><td>  the type of the next parameter in <code>ap</code></td></tr></table><h3><span class="prog__sub">Expanded value</span></h3><p>the next variable parameter in <code>ap</code></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/variadic/va_arg.html
va_copy	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdarg.h></code></td><td></td><td></td></tr><tr class="t-dcl t-since-c99"><td> <code>void va_copy( va_list dest, va_list src );</code></td><td class="t-dcl-nopad"> </td><td>  </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>va_copy</code> macro copies <code>src</code> to <code>dest</code>.</p><p><code>va_end</code> should be called on <code>dest</code> before the function returns or any subsequent re-initialization of <code>dest</code> (via calls to <code>va_start</code> or <code>va_copy</code>).</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  dest</td><td> -</td><td>  an instance of the <code>va_list</code> type to initialize</td></tr><tr class="t-par"><td>  src</td><td> -</td><td>  the source <code>va_list</code> that will be used to initialize <code>dest</code></td></tr></table><h3><span class="prog__sub">Expanded value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/variadic/va_copy.html
va_end	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdarg.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void va_end( va_list ap );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>va_end</code> macro performs cleanup for an <code>ap</code> object initialized by a call to <code>va_start</code> or <code>va_copy</code>.  <code>va_end</code> may modify <code>ap</code> so that it is no longer usable.</p><p>If there is no corresponding call to <code>va_start</code> or <code>va_copy</code>, or if <code>va_end</code> is not called before a function that calls <code>va_start</code> or <code>va_copy</code> returns, the behavior is undefined.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ap</td><td> -</td><td>  an instance of the <code>va_list</code> type to clean up</td></tr></table><h3><span class="prog__sub">Expanded value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/variadic/va_end.html
va_list	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dcl"><td class="t-dcl-nopad"> <code>/* unspecified */ va_list;</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p><code>va_list</code> is a complete object type suitable for holding the information needed by the macros <code>va_start</code>, <code>va_copy</code>, <code>va_arg</code>, and <code>va_end</code>.</p><p>If a <code>va_list</code> instance is created, passed to another function, and used via <code>va_arg</code> in that function, then any subsequent use in the calling function should be preceded by a call to <code>va_end</code>.</p><p>It is legal to pass a pointer to a <code>va_list</code> object to another function and then use that object after the function returns.</p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/variadic/va_list.html
va_start	A										<section class="prog__container"><table class="t-dcl-begin"><tbody><tr class="t-dsc-header"><td> Defined in header <code><stdarg.h></code></td><td></td><td></td></tr><tr class="t-dcl"><td class="t-dcl-nopad"> <code>void va_start( va_list ap, parmN );</code></td><td class="t-dcl-nopad"> </td><td class="t-dcl-nopad"> </td></tr><tr class="t-dcl-sep"><td></td><td></td><td></td></tr></tbody></table><p>The <code>va_start</code> macro enables access to the variable arguments following the named argument <code>parmN</code>.  </p><p><code>va_start</code> should be invoked with an instance to a valid <code>va_list</code> object <code>ap</code> before any calls to <code>va_arg</code>.</p><p>If <code>parmN</code> is declared with <code>register</code> storage class specifier, with an array type, with a function type, or with a type not compatible with the type that results from default argument promotions, the behavior is undefined.</p><h3><span class="prog__sub">Parameters</span></h3><table class="t-par-begin"><tr class="t-par"><td>  ap</td><td> -</td><td>  an instance of the <code>va_list</code> type</td></tr><tr class="t-par"><td>  parmN</td><td> -</td><td>  the named parameter preceding the first variable parameter</td></tr></table><h3><span class="prog__sub">Expanded value</span></h3><p>(none)<br></p><style type="text/css">.t-su {display: inline-block;margin-bottom: -0.3em;vertical-align: 0.8em;line-height: 1.2em;font-size: 85%;text-align: left}.t-su-b {vertical-align: -0.4em}.t-mfrac > table {display: inline-block;vertical-align: middle;border-spacing: 0;}.t-mfrac > table > tbody > tr:first-child > td {border-bottom: 0.1em solid}</style></section>	http://en.cppreference.com/w/c/variadic/va_start.html
