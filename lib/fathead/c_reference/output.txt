Comments	A										<section class="prog__container"><p>Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>/*</code> comment <code>*/</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>//</code> comment\n</td><td> (2)</td><td> (since C99)</td></tr><tr><td></td></tr></table><div>1) Often known as "C-style" or "multi-line" comments.</div><div>2) Often known as "C++-style" or "single-line" comments.</div><p>All comments are removed from the program at <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">translation phase 3</a> by replacing each comment with a single whitespace character.</p><span class="prog__sub"> C-style</span><p>C-style comments are usually used to comment large blocks of text or small fragments of code; however, they can be used to comment single lines. To insert text as a C-style comment, simply surround the text with <code>/*</code> and <code>*/</code>. C-style comments tell the compiler to ignore all content between <code>/*</code> and <code>*/</code>. Although it is not part of the C standard, <code>/**</code> and <code>*/</code> are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment.</p><p>Except within a <a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant">character constant</a>, a <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literal</a>, or a comment, the characters <code>/*</code> introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters <code>*/</code> that terminate the comment. C-style comments cannot be nested.</p><table><tr><td><span class="prog__sub"> C++-style</span><p>C++-style comments are usually used to comment single lines of text or code; however, they can be placed together to form multi-line comments. To insert text as a C++-style comment, simply precede the text with <code>//</code> and follow the text with the new line character. C++-style comments tell the compiler to ignore all content between <code>//</code> and a new line.</p><p>Except within a <a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant">character constant</a>, a <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literal</a>, or a comment, the characters <code>//</code>introduce a comment that includes all multibyte characters up to, but not including, the next new-line character. The contents of such a comment are examined only to identifymultibyte characters and to find the new-line character that terminates the comment. C++-style comments can be nested:</p><div><div><pre><code>//  y = f(x);   // invoke algorithm</code></pre></div></div><p>A C-style comment may appear within a C++-style comment:<br></p><div><div><pre><code>//  y = f(x);   /* invoke algorithm */</code></pre></div></div><p>A C++-style comment may appear within a C-style comment; this is a mechanism for excluding a small block of source code:<br></p><div><div><pre><code>/*<br>    y = f(x);   // invoke algorithms<br>    z = g(x);<br>*/</code></pre></div></div></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/comment
C Standard Library header files	A										<section class="prog__container"><table><tr><td> <code>&lt;assert.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/error" title="c/error">Conditionally compiled macro that compares its argument to zero</a></td></tr><tr><td> <code>&lt;complex.h&gt;</code> (since C99)</td><td> <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">Complex number arithmetic</a></td></tr><tr><td> <code>&lt;ctype.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/string/byte" title="c/string/byte">Functions to determine the type contained in character data</a></td></tr><tr><td> <code>&lt;errno.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/error" title="c/error">Macros reporting error conditions</a></td></tr><tr><td> <code>&lt;fenv.h&gt;</code> (since C99)</td><td> <a href="http://en.cppreference.com/w/c/numeric/fenv" title="c/numeric/fenv">Floating-point environment</a></td></tr><tr><td> <code>&lt;float.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/types/limits#Limits_of_floating_point_types" title="c/types/limits">Limits of float types</a></td></tr><tr><td> <code>&lt;inttypes.h&gt;</code> (since C99)</td><td> <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">Format conversion of integer types</a></td></tr><tr><td> <code>&lt;iso646.h&gt;</code> (since C95)</td><td> <a href="http://en.cppreference.com/w/c/language/operator_alternative" title="c/language/operator alternative"> Alternative operator spellings</a></td></tr><tr><td> <code>&lt;limits.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">Sizes of basic types</a></td></tr><tr><td> <code>&lt;locale.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/locale" title="c/locale">Localization utilities</a></td></tr><tr><td> <code>&lt;math.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/numeric/math" title="c/numeric/math">Common mathematics functions</a></td></tr><tr><td> <code>&lt;setjmp.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/program" title="c/program">Nonlocal jumps</a></td></tr><tr><td> <code>&lt;signal.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/program" title="c/program">Signal handling</a></td></tr><tr><td> <code>&lt;stdalign.h&gt;</code> (since C11)</td><td> <a href="http://en.cppreference.com/w/c/types" title="c/types">alignas and alignof</a> convenience macros</td></tr><tr><td> <code>&lt;stdarg.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/variadic" title="c/variadic">Variable arguments</a></td></tr><tr><td> <code>&lt;stdatomic.h&gt;</code> (since C11)</td><td> <a href="http://en.cppreference.com/w/c/atomic" title="c/atomic">Atomic types</a></td></tr><tr><td> <code>&lt;stdbool.h&gt;</code> (since C99)</td><td> <a href="http://en.cppreference.com/w/c/types/boolean" title="c/types/boolean">Boolean type</a></td></tr><tr><td> <code>&lt;stddef.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/types" title="c/types">Common macro definitions</a></td></tr><tr><td> <code>&lt;stdint.h&gt;</code> (since C99)</td><td> <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">Fixed-width integer types</a></td></tr><tr><td> <code>&lt;stdio.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/io" title="c/io">Input/output</a></td></tr><tr><td> <code>&lt;stdlib.h&gt;</code></td><td> General utilities: <a href="http://en.cppreference.com/w/c/memory" title="c/memory">memory management</a>, <a href="http://en.cppreference.com/w/c/program" title="c/program">program utilities</a>, <a href="http://en.cppreference.com/w/c/string" title="c/string">string conversions</a>, <a href="http://en.cppreference.com/w/c/numeric/random" title="c/numeric/random">random numbers</a></td></tr><tr><td> <code>&lt;stdnoreturn.h&gt;</code> (since C11)</td><td> <a href="http://en.cppreference.com/w/c/types" title="c/types">noreturn</a> convenience macros</td></tr><tr><td> <code>&lt;string.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/string/byte" title="c/string/byte">String handling</a></td></tr><tr><td> <code>&lt;tgmath.h&gt;</code> (since C99)</td><td> <a href="http://en.cppreference.com/w/c/numeric/tgmath" title="c/numeric/tgmath">Type-generic math</a> (macros wrapping math.h and complex.h)</td></tr><tr><td> <code>&lt;threads.h&gt;</code> (since C11)</td><td> <a href="http://en.cppreference.com/w/c/thread" title="c/thread">Thread library</a></td></tr><tr><td> <code>&lt;time.h&gt;</code></td><td> <a href="http://en.cppreference.com/w/c/chrono" title="c/chrono">Time/date utilities</a></td></tr><tr><td> <code>&lt;uchar.h&gt;</code> (since C11)</td><td> <a href="http://en.cppreference.com/w/c/string/multibyte" title="c/string/multibyte">UTF-16 and UTF-32 character utilities</a></td></tr><tr><td> <code>&lt;wchar.h&gt;</code> (since C95)</td><td> <a href="http://en.cppreference.com/w/c/string/wide" title="c/string/wide">Extended multibyte and wide character utilities</a></td></tr><tr><td> <code>&lt;wctype.h&gt;</code> (since C95)</td><td> <a href="http://en.cppreference.com/w/c/string/wide" title="c/string/wide">Wide character classification and mapping utilities</a></td></tr></table><p><br/></p></section>	http://en.cppreference.com/w/c/header
C language	A										<section class="prog__container"><p>This is a reference of the core C language constructs.<br></p><table><tr><td><p><b><a href="http://en.cppreference.com/w/c/language/basic_concepts" title="c/language/basic concepts"> Basic concepts</a></b></p><div><p><a href="http://en.cppreference.com/w/c/comment" title="c/comment"> Comments</a><br/><a href="http://en.cppreference.com/w/c/language/ascii" title="c/language/ascii"> ASCII chart</a><br/><a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases"> Translation phases</a><br/><a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier"> identifier </a> -<a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope"> scope</a> -<a href="http://en.cppreference.com/w/c/language/lifetime" title="c/language/lifetime"> lifetime</a><br/><a href="http://en.cppreference.com/w/c/language/name_space" title="c/language/name space"> lookup and name spaces</a><br/><a href="http://en.cppreference.com/w/c/language/type" title="c/language/type"> type</a> - <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types"> arithmetic types</a><br/><a href="http://en.cppreference.com/w/c/language/object" title="c/language/object"> objects and alignment</a> <br/><a href="http://en.cppreference.com/w/c/language/main_function" title="c/language/main function"> The <code>main</code> function</a><br/><a href="http://en.cppreference.com/w/c/language/memory_model" title="c/language/memory model"> Memory model and data races</a><br/></p></div><p><b><a href="http://en.cppreference.com/w/c/keyword" title="c/keyword"> Keywords</a></b></p><div></div><p><b><a href="http://en.cppreference.com/w/c/preprocessor" title="c/preprocessor"> Preprocessor</a></b></p><div><p><a href="http://en.cppreference.com/w/c/preprocessor/conditional" title="c/preprocessor/conditional"> #if - #ifdef - #ifndef</a><br/><a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace"> #define - # - ##</a><br/><a href="http://en.cppreference.com/w/c/preprocessor/include" title="c/preprocessor/include"> #include</a> -<a href="http://en.cppreference.com/w/c/preprocessor/impl" title="c/preprocessor/impl"> #pragma</a><br/><a href="http://en.cppreference.com/w/c/preprocessor/line" title="c/preprocessor/line"> #line</a> -<a href="http://en.cppreference.com/w/c/preprocessor/error" title="c/preprocessor/error"> #error</a><br/></p></div><p><b><a href="http://en.cppreference.com/w/c/language/statements" title="c/language/statements"> Statements</a></b></p><div><p><a href="http://en.cppreference.com/w/c/language/if" title="c/language/if"> <code>if</code></a> -<a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch"> <code>switch</code></a><br/><a href="http://en.cppreference.com/w/c/language/for" title="c/language/for"> <code>for</code></a><br/><a href="http://en.cppreference.com/w/c/language/while" title="c/language/while"> <code>while</code></a> - <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do"> <code>do</code>-<code>while</code></a><br/><a href="http://en.cppreference.com/w/c/language/continue" title="c/language/continue"> <code>continue</code></a> -<a href="http://en.cppreference.com/w/c/language/break" title="c/language/break"> <code>break</code></a><br/><a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto"> <code>goto</code></a> -<a href="http://en.cppreference.com/w/c/language/return" title="c/language/return"> <code>return</code></a><br/></p></div></td><td><p><b><a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions"> Expressions</a></b></p><div><p><a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category"> Value categories</a><br/><a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order"> Evaluation order and sequencing</a><br/><a href="http://en.cppreference.com/w/c/language/expressions#Constants_and_literals" title="c/language/expressions"> Constants and literals</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/integer_constant" title="c/language/integer constant"> integer constants</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/floating_constant" title="c/language/floating constant"> floating constants</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant"> character constants</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal"> string literals</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/compound_literal" title="c/language/compound literal"> compound literals</a>(C99)<br/><a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression"> Constant expressions</a><br/><a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion"> Implicit conversions</a> <br/><a href="http://en.cppreference.com/w/c/language/expressions#Operators" title="c/language/expressions">Operators</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access"> member access and indirection</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/operator_logical" title="c/language/operator logical"> logical</a> -<a href="http://en.cppreference.com/w/c/language/operator_comparison" title="c/language/operator comparison"> comparison</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic"> arithmetic</a> -<a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment"> assignment</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec"> increment and decrement</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/operator_other" title="c/language/operator other"> call, comma, ternary</a><br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof"> <code>sizeof</code></a> -<a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof"> <code>alignof</code></a>(C11)<br/>\xc2\xa0<a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast"> cast operators</a><br/><a href="http://en.cppreference.com/w/c/language/operator_precedence" title="c/language/operator precedence"> Operator precedence</a><br/><a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic"> Generic selection</a>(C11)<br/></p></div><p><b><a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization"> Initialization</a></b></p><div><p><a href="http://en.cppreference.com/w/c/language/scalar_initialization" title="c/language/scalar initialization"> scalar</a><br/><a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization"> array</a><br/><a href="http://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization"> structure/union </a><br/></p></div></td><td><p><b><a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations"> Declarations</a></b></p><div><p><a href="http://en.cppreference.com/w/c/language/pointer" title="c/language/pointer"> Pointers</a> -<a href="http://en.cppreference.com/w/c/language/array" title="c/language/array"> Arrays</a><br/><a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum"> Enumerations</a><br/><a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration"> Storage duration and linkage </a><br/><a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a> - <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> - <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a>(C99)<br/><a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct"> struct </a> - <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union"> union</a> -<a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field"> bit fields</a><br/><a href="http://en.cppreference.com/w/c/language/_Alignas" title="c/language/ Alignas"> <code>alignas</code></a>(C11) -<a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef"> <code>typedef</code></a><br/><a href="http://en.cppreference.com/w/c/language/_Static_assert" title="c/language/ Static assert"> static_assert</a>(C11)<br/><a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic"> Atomic types</a>(C11)<br/><a href="http://en.cppreference.com/w/c/language/extern" title="c/language/extern"> External and tentative definitions</a><br/></p></div><p><b><a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions"> Functions</a></b></p><div><p><a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration"> Function declaration</a><br/><a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition"> Function definition</a><br/><a href="http://en.cppreference.com/w/c/language/inline" title="c/language/inline">inline</a>(C99) - <a href="http://en.cppreference.com/w/c/language/_Noreturn" title="c/language/ Noreturn">noreturn</a>(C11)<br/><a href="http://en.cppreference.com/w/c/language/variadic" title="c/language/variadic"> Variadic arguments</a><br/></p></div><p><b>Miscellaneous</b></p><div><p><a href="http://en.cppreference.com/w/c/language/history" title="c/language/history"> History of C</a><br/><a href="http://en.cppreference.com/w/c/language/conformance" title="c/language/conformance"> Conformance</a><br/><a href="http://en.cppreference.com/w/c/language/behavior" title="c/language/behavior"> Undefined behavior</a><br/><a class="new" href="/mwiki/index.php?title=c/language/asm&amp;action=edit&amp;redlink=1" title="c/language/asm (page does not exist)"> Inline assembly</a><br/><a class="new" href="/mwiki/index.php?title=c/language/as_if&amp;action=edit&amp;redlink=1" title="c/language/as if (page does not exist)"> As-if rule</a><br/><a class="new" href="/mwiki/index.php?title=c/language/signal&amp;action=edit&amp;redlink=1" title="c/language/signal (page does not exist)"> signal handling</a> <br/><a href="http://en.cppreference.com/w/c/language/analyzability" title="c/language/analyzability"> Analyzability</a>(C11)<br/></p><br/></div><p><br/></p></td></tr></table></section>	http://en.cppreference.com/w/c/language.1
bsearch, bsearch_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void* bsearch( const void *key, const void *ptr, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0int (*comp)(const void*, const void*) );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>void* bsearch_s( const void *key, const void *ptr, rsize_t count, rsize_t size,<br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0int (*comp)(const void *, const void *, void *),<br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0void *context );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Finds an element equal to element pointed to by <code>key</code> in an array pointed to by <code>ptr</code>. The array contains <code>count</code> elements of <code>size</code> bytes and must be partitioned with respect to <code>key</code>, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by <code>comp</code>. The behavior is undefined if the array is not already partitioned with respect to <code>*key</code> in ascending order according to the same criterion that <code>comp</code> uses.</div><div>2) Same as (1), except that the additional context argument <code>context</code> is passed to <code>comp</code> and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>count</code> or <code>size</code> is greater than RSIZE_MAX</li><li> <code>key</code>, <code>ptr</code> or <code>comp</code> is a null pointer (unless <code>count</code> is zero)</li></ul></dd><dd>As with all bounds-checked functions, <code>bsearch_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></div><p>If the array contains several elements that <code>comp</code> would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</p><span class="prog__sub"> Parameters</span><table><tr><td>  key</td><td> -</td><td>  pointer to the element to search for</td></tr><tr><td>  ptr</td><td> -</td><td>  pointer to the array to examine</td></tr><tr><td>  count</td><td> -</td><td>  number of element in the array</td></tr><tr><td>  size</td><td> -</td><td>  size of each element in the array in bytes</td></tr><tr><td>   comp</td><td> -</td><td>  comparison function which returns \xe2\x80\x8ba negative integer value if the first argument is <i>less</i> than the second, <br/><p>a positive integer value if the first argument is <i>greater</i> than the second and zero if the arguments are equal. <code>key</code> is passed as the first argument, an element from the array as the second.<br/>The signature of the comparison function should be equivalent to the following:</p><p><code>\xc2\xa0int cmp(const void *a, const void *b);</code></p><p>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.<br></p><p>\xe2\x80\x8b<br></p></td></tr><tr><td>  context</td><td> -</td><td>  additional information (e.g., collating sequence), passed to <code>comp</code> as the third argument</td></tr></table><span class="prog__sub"> Return value</span><div>1) Pointer to an element in the array that compares equal to <code>*key</code>, or null pointer if such element has not been found.</div><div>2) Same as (1), except that the null pointer is also returned on runtime constraints violations.</div></section>	http://en.cppreference.com/w/c/algorithm/bsearch
qsort, qsort_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void qsort( void *ptr, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 int (*comp)(const void *, const void *) );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t qsort_s( void *ptr, rsize_t count, rsize_t size,<br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0int (*comp)(const void *, const void *, void *),<br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0void *context );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Sorts the given array pointed to by <code>ptr</code> in ascending order. The array contains <code>count</code> elements of <code>size</code> bytes. Function pointed to by <code>comp</code> is used for object comparison. </div><div>2) Same as (1), except that the additional context parameter <code>context</code> is passed to <code>comp</code> and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>count</code> or <code>size</code> is greater than RSIZE_MAX</li><li> <code>ptr</code> or <code>comp</code> is a null pointer (unless <code>count</code> is zero)</li></ul></dd><dd>As with all bounds-checked functions, <code>qsort_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></div><p>If <code>comp</code> indicates two elements as equivalent, their order in the resulting sorted array is undefined.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ptr</td><td> -</td><td>  pointer to the array to sort</td></tr><tr><td>  count</td><td> -</td><td>  number of element in the array</td></tr><tr><td>  size</td><td> -</td><td>  size of each element in the array in bytes</td></tr><tr><td>   comp</td><td> -</td><td>  comparison function which returns \xe2\x80\x8ba negative integer value if the first argument is <i>less</i> than the second, <br/><p>a positive integer value if the first argument is <i>greater</i> than the second and zero if the arguments are equal.<br/>The signature of the comparison function should be equivalent to the following:</p><p><code>\xc2\xa0int cmp(const void *a, const void *b);</code></p><p>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.<br></p><p>\xe2\x80\x8b<br></p></td></tr><tr><td>  context</td><td> -</td><td>  additional information (e.g., collating sequence), passed to <code>comp</code> as the third argument</td></tr></table><span class="prog__sub"> Return value</span><div>1) (none)</div><div>2) zero on success, non-zero if a runtime constraints violation was detected</div></section>	http://en.cppreference.com/w/c/algorithm/qsort
atomic_compare_exchange_weak, atomic_compare_exchange_strong, atomic_compare_exchange_weak_explicit, atomic_compare_exchange_strong_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>_Bool atomic_compare_exchange_strong( volatile A* obj,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 C* expected, C desired );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>_Bool atomic_compare_exchange_weak( volatile A *obj, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 C* expected, C desired );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td> <div><code>_Bool atomic_compare_exchange_strong_explicit( volatile A* obj, <br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0C* expected, C desired,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> succ, <br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> fail );</code></div></td><td> (3) </td><td> (since C11) </td></tr><tr><td> <div><code>_Bool atomic_compare_exchange_weak_explicit( volatile A *obj, <br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0C* expected, C desired,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> succ, <br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> fail );</code></div></td><td> (4) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically compares the value pointed to by <code>obj</code> with the value pointed to by <code>expected</code>, and if those are equal, replaces the former with <code>desired</code> (performs read-modify-write operation). Otherwise, loads the actual value pointed to by <code>obj</code> into <code>*expected</code> (performs load operation).</p><p>The memory models for the read-modify-write and load operations are <code>succ</code> and <code>fail</code> respectively. The (1-2) versions use <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a> by default.</p><p>The weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if <code>*obj != *expected</code> even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to test and modify</td></tr><tr><td>  expected</td><td> -</td><td>  pointer to the value expected to be found in the atomic object</td></tr><tr><td>  desired</td><td> -</td><td>  the value to store in the atomic object if it is as expected</td></tr><tr><td>  succ</td><td> -</td><td>  the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted.</td></tr><tr><td>  fail</td><td> -</td><td>  the memory synchronization ordering for the load operation if the comparison fails. Cannot be <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_release</a> or <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_acq_rel</a> and cannot specify stronger ordering than <code>succ</code></td></tr></table><span class="prog__sub"> Return value</span><p>The result of the comparison: <code>true</code> if <code>*obj</code> was equal to <code>*exp</code>, <code>false</code> otherwise.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_compare_exchange
atomic_exchange, atomic_exchange_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>C atomic_exchange( volatile A* obj, C desired );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>C atomic_exchange_explicit( volatile A* obj, C desired, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with <code>desired</code> and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>. </p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>..</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr><td>  desired</td><td> -</td><td>  the value to replace the atomic object with</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><span class="prog__sub"> Return value</span><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_exchange
atomic_fetch_add, atomic_fetch_add_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>C atomic_fetch_add( volatile A* obj, M arg );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>C atomic_fetch_add_explicit( volatile A* obj, M arg, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of addition of <code>arg</code> to the old value of <code>obj</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <a href="http://en.cppreference.com/w/c/types/ptrdiff_t" title="c/types/ptrdiff t">ptrdiff_t</a> if <code>A</code> is atomic pointer type.</p><p>For signed integer types, arithmetic is defined to use two\xe2\x80\x99s complement representation. There<br>are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr><td>  arg</td><td> -</td><td>  the value to add to the value stored in the atomic object</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><span class="prog__sub"> Return value</span><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;threads.h&gt;#include &lt;stdatomic.h&gt;\xc2\xa0<a href="http://en.cppreference.com/w/c/atomic">atomic_int</a> acnt;int cnt;\xc2\xa0int f(void* thr_data){    for(int n = 0; n &lt; 1000; ++n) {        atomic_fetch_add_explicit(&amp;acnt, 1, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order_relaxed</a>); // atomic        ++cnt; // undefined behavior, in practice some updates missed    }    return 0;}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/thread">thrd_t</a> thr[10];    for(int n = 0; n &lt; 10; ++n)        <a href="http://en.cppreference.com/w/c/thread/thrd_create">thrd_create</a>(&amp;thr[n], f, <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>);    for(int n = 0; n &lt; 10; ++n)        <a href="http://en.cppreference.com/w/c/thread/thrd_join">thrd_join</a>(thr[n], <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>);\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The atomic counter is\xc2\xa0%u\n", acnt);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The non-atomic counter is\xc2\xa0%u\n", cnt);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>The atomic counter is 10000<br>The non-atomic counter is 9511</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_add
atomic_fetch_and, atomic_fetch_and_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>C atomic_fetch_and( volatile A* obj, M arg );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>C atomic_fetch_and_explicit( volatile A* obj, M arg, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of bitwise AND between the old value of <code>obj</code> and <code>arg</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <a href="http://en.cppreference.com/w/c/types/ptrdiff_t" title="c/types/ptrdiff t">ptrdiff_t</a> if <code>A</code> is atomic pointer type.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr><td>  arg</td><td> -</td><td>  the value to bitwise AND to the value stored in the atomic object</td></tr><tr><td>  order</td><td> -</td><td>  the memory sycnhronization ordering for this operation: all values are permitted</td></tr></table><span class="prog__sub"> Return value</span><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_and
atomic_fetch_or, atomic_fetch_or_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>C atomic_fetch_or( volatile A* obj, M arg );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>C atomic_fetch_or_explicit( volatile A* obj, M arg, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of bitwise OR between the old value of <code>obj</code> and <code>arg</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <a href="http://en.cppreference.com/w/c/types/ptrdiff_t" title="c/types/ptrdiff t">ptrdiff_t</a> if <code>A</code> is atomic pointer type.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr><td>  arg</td><td> -</td><td>  the value to bitwise OR to the value stored in the atomic object</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><span class="prog__sub"> Return value</span><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_or
atomic_fetch_sub, atomic_fetch_sub_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>C atomic_fetch_sub( volatile A* obj, M arg );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>C atomic_fetch_sub_explicit( volatile A* obj, M arg, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of subtraction of <code>arg</code> from the old value of <code>obj</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <a href="http://en.cppreference.com/w/c/types/ptrdiff_t" title="c/types/ptrdiff t">ptrdiff_t</a> if <code>A</code> is atomic pointer type.</p><p>For signed integer types, arithmetic is defined to use two\xe2\x80\x99s complement representation. There<br>are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr><td>  arg</td><td> -</td><td>  the value to subtract from the value stored in the atomic object</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><span class="prog__sub"> Return value</span><p>The value held previously by the atomic object pointed to by <code>obj</code>.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_sub
atomic_fetch_xor, atomic_fetch_xor_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>C atomic_fetch_xor( volatile A* obj, M arg );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>C atomic_fetch_xor_explicit( volatile A* obj, M arg, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value pointed by <code>obj</code> with the result of bitwise XOR between the old value of <code>obj</code> and <code>arg</code>, and returns the value <code>obj</code> held previously. The operation is read-modify-write operation. The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>M</code> is either the non-atomic type corresponding to <code>A</code> if <code>A</code> is atomic integer type, or <a href="http://en.cppreference.com/w/c/types/ptrdiff_t" title="c/types/ptrdiff t">ptrdiff_t</a> if <code>A</code> is atomic pointer type.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr><td>  arg</td><td> -</td><td>  the value to bitwise XOR to the value stored in the atomic object</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><span class="prog__sub"> Return value</span><p>The value held previously be the atomic object pointed to by <code>obj</code>.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_fetch_xor
atomic_flag	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>struct atomic_flag;</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong class="selflink">atomic_flag</strong> is an atomic boolean type. Unlike other atomic types, it is guaranteed to be lock-free. Unlike <a href="http://en.cppreference.com/w/c/atomic" title="c/atomic">atomic_bool</a>, <code>atomic_flag</code> does not provide load or store operations.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_flag
atomic_flag_clear, atomic_flag_clear_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void atomic_flag_clear( volatile <a href="http://en.cppreference.com/w/c/atomic/atomic_flag">atomic_flag</a>* obj );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>void atomic_flag_clear_explicit( volatile <a href="http://en.cppreference.com/w/c/atomic/atomic_flag">atomic_flag</a>* obj, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically changes the state of a <code>atomic_flag</code> pointed to by <code>obj</code> to clear (<code>false</code>). The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>.</p><p>The argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic flags.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic flag object to modify</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/atomic/atomic_flag_clear
ATOMIC_FLAG_INIT	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define ATOMIC_FLAG_INIT /* unspecified */</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Expands to an expression that can be used to initialize <a href="http://en.cppreference.com/w/c/atomic/atomic_flag" title="c/atomic/atomic flag">atomic_flag</a> type. The value <code>atomic_flag</code> that is not initialized using this macro is undefined.</p></section>	http://en.cppreference.com/w/c/atomic/ATOMIC_FLAG_INIT
atomic_flag_test_and_set, atomic_flag_test_and_set_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>_Bool atomic_flag_test_and_set( volatile <a href="http://en.cppreference.com/w/c/atomic/atomic_flag">atomic_flag</a>* obj );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>_Bool atomic_flag_test_and_set_explicit( volatile <a href="http://en.cppreference.com/w/c/atomic/atomic_flag">atomic_flag</a>* obj, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically changes the state of a <code>atomic_flag</code> pointed to by <code>obj</code> to set (<code>true</code>) and returns the previous value. The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>.</p><p>The argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic flags.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic flag object to modify</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation: all values are permitted</td></tr></table><span class="prog__sub"> Return value</span><p>The previous value held by the atomic flag pointed to by <code>obj</code>.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set
atomic_init	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void atomic_init( volatile A* obj, C desired );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Initializes the default-constructed atomic object <code>obj</code> with the value <code>desired</code>. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race. </p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to an atomic object to initialize</td></tr><tr><td>  desired</td><td> -</td><td>  the value to initialize atomic object with</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/atomic/atomic_init
atomic_is_lock_free	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>_Bool atomic_is_lock_free( const volatile A* obj );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the atomic operations on all objects of the type <code>A</code> (the type of the object pointed to by <code>obj</code>) are lock-free. In any given program execution, the result of calling <code>atomic_is_lock_free</code> is the same for all pointers of the same type.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to inspect</td></tr></table><span class="prog__sub"> Return value</span><p><code>true</code> if the the operations on all objects of the type <code>A</code> are lock-free, <code>false</code> otherwise.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_is_lock_free
atomic_load, atomic_load_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>C atomic_load( const volatile A* obj );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>C atomic_load_explicit( const volatile A* obj, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically loads and returns the current value of the atomic variable pointed to by <code>obj</code>. The operation is atomic read operation. </p><p>The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>. <code>order</code> must be one of <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_relaxed</a>, <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_consume</a>, <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_acquire</a> or <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>. Otherwise the behavior is undefined.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to access</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation</td></tr></table><span class="prog__sub"> Return value</span><p>The current value of the atomic variable pointed to by <code>obj</code>.</p></section>	http://en.cppreference.com/w/c/atomic/atomic_load
ATOMIC_*_LOCK_FREE	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define ATOMIC_BOOL_LOCK_FREE \xc2\xa0 \xc2\xa0 /* implementation-defined */<br/><p>#define ATOMIC_CHAR_LOCK_FREE \xc2\xa0 \xc2\xa0 /* implementation-defined */<br/>#define ATOMIC_CHAR16_T_LOCK_FREE /* implementation-defined */<br/>#define ATOMIC_CHAR32_T_LOCK_FREE /* implementation-defined */<br/>#define ATOMIC_WCHAR_T_LOCK_FREE \xc2\xa0/* implementation-defined */<br/>#define ATOMIC_SHORT_LOCK_FREE \xc2\xa0 \xc2\xa0/* implementation-defined */<br/>#define ATOMIC_INT_LOCK_FREE \xc2\xa0 \xc2\xa0 \xc2\xa0/* implementation-defined */<br/>#define ATOMIC_LONG_LOCK_FREE \xc2\xa0 \xc2\xa0 /* implementation-defined */<br/>#define ATOMIC_LLONG_LOCK_FREE \xc2\xa0 \xc2\xa0/* implementation-defined */<br/></p>#define ATOMIC_POINTER_LOCK_FREE \xc2\xa0/* implementation-defined */</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Expands to <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">preprocessor constant expressions</a> that evaluate to either <code>0</code>, <code>1</code>, or <code>2</code> which indicate the lock-free property of the corresponding <a href="http://en.cppreference.com/w/c/atomic" title="c/atomic">atomic types</a> (both signed and unsigned).</p><table><tr><td>  Value</td><td>  Explanation</td></tr><tr><td> <code>0</code></td><td>  The atomic type is never lock-free</td></tr><tr><td> <code>1</code></td><td>  The atomic type is sometimes lock-free</td></tr><tr><td> <code>2</code></td><td>  The atomic type is always lock-free</td></tr></table></section>	http://en.cppreference.com/w/c/atomic/ATOMIC_LOCK_FREE_consts
atomic_signal_fence	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void atomic_signal_fence( <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by <code>order</code>, between a thread and a signal handler executed on the same thread. This is equivalent to <a href="http://en.cppreference.com/w/c/atomic/atomic_thread_fence" title="c/atomic/atomic thread fence">atomic_thread_fence</a>, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as <code>order</code> instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</p><span class="prog__sub"> Parameters</span><table><tr><td>  order</td><td> -</td><td>  the memory ordering executed by this fence</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/atomic/atomic_signal_fence
atomic_store, atomic_store_explicit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void atomic_store( volatile A* obj , C desired);</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>void atomic_store_explicit( volatile A* obj, C desired, <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically replaces the value of the atomic variable pointed to by <code>obj</code> with <code>desired</code>. The operation is atomic write operation. </p><p>The first version orders memory accesses according to <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>, the second version orders memory accesses according to <code>order</code>. <code>order</code> must be one of <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_relaxed</a>, <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_release</a> or <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>. Otherwise the behavior is undefined.</p><p>This is a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic function</a> defined for all <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic object types</a> <code>A</code>. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> (e.g. memory-mapped I/O) atomic variables.<code>C</code> is the non-atomic type corresponding to <code>A</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  obj</td><td> -</td><td>  pointer to the atomic object to modify</td></tr><tr><td>  order</td><td> -</td><td>  the memory synchronization ordering for this operation</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/atomic/atomic_store
atomic_thread_fence	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void atomic_thread_fence( <a href="http://en.cppreference.com/w/c/atomic/memory_order">memory_order</a> order );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by <code>order</code>, without an associated atomic operation. For example, all non-atomic and relaxed atomic stores that happen before a <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_release</a> fence in thread A will be synchronized with non-atomic and relaxed atomic loads from the same locations made in thread B after an <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_acquire</a> fence.</p><span class="prog__sub"> Parameters</span><table><tr><td>  order</td><td> -</td><td>  the memory ordering executed by this fence</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/atomic/atomic_thread_fence
ATOMIC_VAR_INIT	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define ATOMIC_VAR_INIT(value) /* unspecified */</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Expands to an expression that can be used to initialize an atomic variable of the same type as <code>value</code>. The initial value of atomic object of automatic storage duration that is not initialized using this macro is undefined. The default (zero) initialization of static and thread-local variables produces valid value however.</p><p>If this macro is not used for initialization of an atomic variable, any accesses during initialization from another thread, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_relaxed</a> operation).</p></section>	http://en.cppreference.com/w/c/atomic/ATOMIC_VAR_INIT
kill_dependency	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>A kill_dependency(A y);</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Informs the compiler that the dependency tree started by an <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_consume</a> atomic load operation does not extend past the return value of <code>kill_dependency</code>; that is, the argument does not carry a dependency into the return value.</p><p>The function is implemented as a macro. <code>A</code> is the type of <code>y</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  y</td><td> -</td><td>  the expression whose return value is to be removed from a dependency tree</td></tr></table><span class="prog__sub"> Return value</span><p>Returns <code>y</code>, no longer a part of a dependency tree.</p></section>	http://en.cppreference.com/w/c/atomic/kill_dependency
memory_order	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>enum memory_order {<br/><p>\xc2\xa0 \xc2\xa0 memory_order_relaxed,<br/>\xc2\xa0 \xc2\xa0 memory_order_consume,<br/>\xc2\xa0 \xc2\xa0 memory_order_acquire,<br/>\xc2\xa0 \xc2\xa0 memory_order_release,<br/>\xc2\xa0 \xc2\xa0 memory_order_acq_rel,<br/>\xc2\xa0 \xc2\xa0 memory_order_seq_cst<br/></p>};</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><code>memory_order</code> specifies how regular, non-atomic memory accesses are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.</p><p>The default behavior of all atomic operations in the <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">language</a> and the library provides for <i>sequentially consistent ordering</i> (see discussion below). That default can hurt performance, but the library's atomic operations can be given an additional <code>memory_order</code> argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.</p><span class="prog__sub"> Constants</span><table><tr><td> <div>Defined in header <code>&lt;stdatomic.h&gt;</code> </div></td></tr><tr><td>  Value</td><td>  Explanation</td></tr><tr><td> <code>memory_order_relaxed</code></td><td>  Relaxed operation: there are no synchronization or ordering constraints, only atomicity is required of this operation (see <a href="#Relaxed_ordering">Relaxed ordering</a> below)</td></tr><tr><td> <code>memory_order_consume</code></td><td>  A load operation with this memory order performs a <i>consume operation</i> on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see <a href="#Release-Consume_ordering">Release-Consume ordering</a> below)</td></tr><tr><td> <code>memory_order_acquire</code></td><td>  A load operation with this memory order performs the <i>acquire operation</i> on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see <a href="#Release-Acquire_ordering">Release-Acquire ordering</a> below)</td></tr><tr><td> <code>memory_order_release</code></td><td>  A store operation with this memory order performs the <i>release operation</i>: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see <a href="#Release-Acquire_ordering">Release-Acquire ordering</a> below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see <a href="#Release-Consume_ordering">Release-Consume ordering</a> below).</td></tr><tr><td> <code>memory_order_acq_rel</code></td><td>  A read-modify-write operation with this memory order is both an <i>acquire operation</i> and a <i>release operation</i>. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</td></tr><tr><td> <code>memory_order_seq_cst</code></td><td>  Any operation with this memory order is both an <i>acquire operation</i> and a <i>release operation</i>, plus a single total order exists in which all threads observe all modifications in the same order (see <a href="#Sequentially-consistent_ordering">Sequentially-consistent ordering</a> below)</td></tr></table><table><tr><td></td><td>This section is incomplete<br/>Reason: happens-before and other concepts, as in C++, but keep modification orders and the four consistencies in <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">c/language/atomic</a> </td></tr></table><table><tr><td></td><td>This section is incomplete<br/>Reason: when doing above, don't forget that although happens-before wasn't acyclic in C11 as published, this was updated to match C++11 via DR 401 </td></tr></table><h4> Relaxed ordering</h4><p>Atomic operations tagged <code>memory_order_relaxed</code> are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</p><p>For example, with <code>x</code> and <code>y</code> initially zero,</p><p><code>// Thread 1:<br/>r1 = <a href="http://en.cppreference.com/w/c/atomic/atomic_load">atomic_load_explicit</a>(y, memory_order_relaxed); // A<br/><a href="http://en.cppreference.com/w/c/atomic/atomic_store">atomic_store_explicit</a>(x, r1, memory_order_relaxed); // B<br/>// Thread 2:<br/>r2 = <a href="http://en.cppreference.com/w/c/atomic/atomic_load">atomic_load_explicit</a>(x, memory_order_relaxed); // C<br/><a href="http://en.cppreference.com/w/c/atomic/atomic_store">atomic_store_explicit</a>(y, 42, memory_order_relaxed); // D</code></p><p>is allowed to produce <code>r1 == r2 == 42</code> because, although A is <i>sequenced-before</i> B within thread 1 and C is <i>sequenced before</i> D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in Thread 1  while the side effect of B on x could be visible to the load C in Thread 2.</p><p><br/></p><p>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters , since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor)<br></p><h4> Release-Consume ordering</h4><p>If an atomic store in thread A is tagged <code>memory_order_release</code> and an atomic load in thread B from the same variable is tagged <code>memory_order_consume</code>, all memory writes (non-atomic and relaxed atomic) that are <i>dependency-ordered-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> within those operations in thread B into which the load operation <i>carries dependency</i>, that is, once the atomic load is completed, those operators and functions in thread B that use the value obtained from the load are guaranteed to see what thread A wrote to memory.</p><p>The synchronization is established only between the threads <i>releasing</i> and <i>consuming</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.</p><p>On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain). <br></p><p>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is <a class="extiw" href="http://en.wikipedia.com/wiki/Read-copy-update" title="enwiki:Read-copy-update">rcu_dereference</a>.</p><p><br/></p><p>Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.<br></p><h4> Release sequence</h4><p>If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a "release sequence" is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no <code>memory_order_release</code> semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.</p><h4> Release-Acquire ordering</h4><p>If an atomic store in thread A is tagged <code>memory_order_release</code> and an atomic load in thread B from the same variable is tagged <code>memory_order_acquire</code>, all memory writes (non-atomic and relaxed atomic) that <i>happened-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> in thread B, that is, once the atomic load is completed, thread B is guaranteed to see everything thread A wrote to memory.</p><p>The synchronization is established only between the threads <i>releasing</i> and <i>acquiring</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.</p><p>On strongly-ordered systems (x86, SPARC TSO, IBM mainframe), release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from moving non-atomic stores past the atomic store-release or perform non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions have to be used.<br></p><p>Mutual exclusion locks (such as <a href="http://en.cppreference.com/w/c/thread#Mutual_exclusion" title="c/thread">mutexes</a> or <a href="http://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set" title="c/atomic/atomic flag test and set">atomic spinlock</a>) are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.</p><h4> Sequentially-consistent ordering</h4><p>Atomic operations tagged <code>memory_order_seq_cst</code> not only order memory the same way as release/acquire ordering (everything that <i>happened-before</i> a store in one thread becomes a <i>visible side effect</i> in the thread that did a load), but also establish a <i>single total modification order</i> of all atomic operations that are so tagged.</p><p>Formally,<br></p><p>Each <code>memory_order_seq_cst</code> operation B that loads from atomic variable M, observes one of the following:</p><ul><li> the result of the last operation A that modified M, which appears before B in the single total order</li><li> OR, if there was such an A, B may observe the result of some modification on M that is not <code>memory_order_seq_cst</code> and does not <i>happen-before</i> A</li><li> OR, if there wasn't such an A, B may observe the result of some unrelated modification of M that is not <code>memory_order_seq_cst</code></li></ul><p>If there was a <code>memory_order_seq_cst</code> std::atomic_thread_fence operation X <i>sequenced-before</i> B, then B observes one of the following:</p><ul><li> the last <code>memory_order_seq_cst</code> modification of M that appears before X in the single total order</li><li> some unrelated modification of M that appears later in M's modification order</li></ul><p>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two <code>memory_order_seq_cst</code> std::atomic_thread_fences X and Y, and if A is <i>sequenced-before</i> X, Y is <i>sequenced-before</i> B, and X appears before Y in the Single Total Order, then B observes either:</p><ul><li> the effect of A</li><li> some unrelated modification of M that appears after A in M's modification order</li></ul><p>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if <br></p><ul><li> there is a <code>memory_order_seq_cst</code> std::atomic_thread_fence X such that A is <i>sequenced-before</i> X and X appears before B in the Single Total Order</li><li> or, there is a <code>memory_order_seq_cst</code> std::atomic_thread_fence Y such that Y is <i>sequenced-before</i> B and A appears before Y in the Single Total Order</li><li> or, there are <code>memory_order_seq_cst</code> std::atomic_thread_fences X and Y such that A is <i>sequenced-before</i> X, Y is <i>sequenced-before</i> B, and X appears before Y in the Single Total Order.</li></ul><p>Note that this means that:<br></p><div>1) as soon as atomic operations that are not tagged <code>memory_order_seq_cst</code> enter the picture, the sequential consistency is lost</div><div>2) the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (<i>sequenced-before</i> is not a cross-thread relationship, unlike <i>happens-before</i>)</div><p>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.<br></p><p>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.<br></p><span class="prog__sub"> Relationship with volatile</span><p>Within a thread of execution, accesses (reads and writes) to <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile objects</a> cannot be reordered past observable side-effects (including other volatile accesses) that are separated by a sequence point within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.</p><p>In addition, volatile accesses are not atomic (concurrent read and write is a <a href="http://en.cppreference.com/w/c/language/memory_model" title="c/language/memory model">data race</a>) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</p><p>One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (<a class="external text" href="http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.100).aspx" rel="nofollow">MSDN</a>), and thus volatiles may be used for inter-thread synchronization. Standard <code>volatile</code> semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a <a href="http://en.cppreference.com/w/c/program/signal" title="c/program/signal">signal</a> handler that runs in the same thread when applied to <code>sig_atomic_t</code> variables.</p><span class="prog__sub"> Examples</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/atomic/memory_order
asctime, asctime_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char* asctime( const struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a>* time_ptr );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t asctime_s(char *buf, rsize_t bufsz, const struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *time_ptr);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts given calendar time <a href="http://en.cppreference.com/w/c/chrono/tm" title="c/chrono/tm">tm</a> to a textual representation of the following fixed 25-character form: <code>Www Mmm dd hh:mm:ss yyyy\n</code><ul><li><code>Www</code> - three-letter English abbreviated day of the week from <code>time_ptr-&gt;tm_wday</code>, one of <code>Mon</code>, <code>Tue</code>, <code>Wed</code>, <code>Thu</code>, <code>Fri</code>, <code>Sat</code>, <code>Sun</code>.</li><li><code>Mmm</code> - three-letter English abbreviated month name from <code>time_ptr-&gt;tm_mon</code>, one of <code>Jan</code>, <code>Feb</code>, <code>Mar</code>, <code>Apr</code>, <code>May</code>, <code>Jun</code>, <code>Jul</code>, <code>Aug</code>, <code>Sep</code>, <code>Oct</code>, <code>Nov</code>, <code>Dec</code>.</li><li><code>dd</code> - 2-digit day of the month from <code>timeptr-&gt;tm_mday</code> as if printed by <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">sprintf</a> using <code>%2d</code></li><li><code>hh</code> - 2-digit hour from <code>timeptr-&gt;tm_hour</code> as if printed by <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">sprintf</a> using <code>%.2d</code></li><li><code>mm</code> - 2-digit minute from <code>timeptr-&gt;tm_min</code> as if printed by <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">sprintf</a> using <code>%.2d</code></li><li><code>ss</code> - 2-digit second from <code>timeptr-&gt;tm_sec</code> as if printed by <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">sprintf</a> using <code>%.2d</code></li><li><code>yyyy</code> - 4-digit year from <code>timeptr-&gt;tm_year + 1900</code> as if printed by <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">sprintf</a> using <code>%4d</code></li></ul></div><div> The behavior is undefined if any member of <code>*time_ptr</code> is outside its normal range</div><div> The behavior is undefined if the calendar year indicated by <code>time_ptr-&gt;tm_year</code> has more than 4 digits or is less than the year 1000.</div><div> The function does not support localization, and the newline character cannot be removed.</div><div> The function modifies static storage and is not thread-safe.</div><div>2) Same as (1), except that the message is copied into user-provided storage <code>buf</code>, which is guaranteed to be null-terminated, and the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>buf</code> or <code>time_ptr</code> is a null pointer</li><li> <code>bufsz</code> is less than 26 or greater than RSIZE_MAX</li><li> not all members of <code>*time_ptr</code> are within their normal ranges</li><li> the year indicated by <code>time_ptr-&gt;tm_year</code> is less than 0 or greater than 9999</li></ul></dd><dd>As all bounds-checked functions, <code>asctime_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>time.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  time_ptr</td><td> -</td><td>  pointer to a <a href="http://en.cppreference.com/w/c/chrono/tm" title="c/chrono/tm">tm</a> object specifying the time to print</td></tr><tr><td>  buf</td><td> -</td><td>  pointer to a user-supplied buffer at least 26 bytes in length</td></tr><tr><td>  bufsz</td><td> -</td><td>  size of the user-supplied buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) pointer to a static null-terminated character string holding the textual representation of date and time as described above. The string may be shared between <code>asctime</code> and <a href="http://en.cppreference.com/w/c/chrono/ctime" title="c/chrono/ctime">ctime</a>, and may be overwritten on each invocation of any of those functions.</div><div>2) zero on success, non-zero on failure, in which case <code>buf[0]</code> is set to zero (unless <code>buf</code> is a null pointer or <code>bufsz</code> is zero or greater than RSIZE_MAX).</div></section>	http://en.cppreference.com/w/c/chrono/asctime
clock	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/chrono/clock_t">clock_t</a> clock(void);</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds, divide it by <a href="http://en.cppreference.com/w/c/chrono/CLOCKS_PER_SEC" title="c/chrono/CLOCKS PER SEC">CLOCKS_PER_SEC</a>. </p><p>Only the difference between two values returned by different calls to <strong class="selflink">clock</strong> is meaningful, as the beginning of the <strong class="selflink">clock</strong> era does not have to coincide with the start of the program. <strong class="selflink">clock</strong> time may advance faster or slower than the wall clock, depending on the execution resources given to the program by the operating system. For example, if the CPU is shared by other processes, <strong class="selflink">clock</strong> time may advance slower than wall clock. On the other hand, if the current process is multithreaded and more than one execution core is available, <strong class="selflink">clock</strong> time may advance faster than wall clock.</p><span class="prog__sub"> Parameters</span><p>(none)<br></p><span class="prog__sub"> Return value</span><p>Processor time used by the program so far or <code>(<a href="http://en.cppreference.com/w/c/chrono/clock_t">clock_t</a>)(-1)</code> if that information is unavailable or its value cannot be represented.</p></section>	http://en.cppreference.com/w/c/chrono/clock
clock_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>typedef /* unspecified */ clock_t;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Arithmetic (until C11)Real (since C11) type capable of representing the processor time used by a process. It has implementation-defined range and precision.</p></section>	http://en.cppreference.com/w/c/chrono/clock_t
CLOCKS_PER_SEC	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define CLOCKS_PER_SEC /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Expands to an expression (not necessarily a compile-time constant) of type <a href="http://en.cppreference.com/w/c/chrono/clock_t" title="c/chrono/clock t">clock_t</a> equal to the number of clock ticks per second, as returned by <a href="http://en.cppreference.com/w/c/chrono/clock" title="c/chrono/clock">clock()</a>. </p></section>	http://en.cppreference.com/w/c/chrono/CLOCKS_PER_SEC
ctime, ctime_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char* ctime( const <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a>* <a href="http://en.cppreference.com/w/c/chrono/time">time</a> );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t ctime_s(char *buffer, rsize_t bufsz, const <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> *<a href="http://en.cppreference.com/w/c/chrono/time">time</a>);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts given time since epoch to a calendar local time and then to a textual representation, as if by calling <code><a href="http://en.cppreference.com/w/c/chrono/asctime">asctime</a>(<a href="http://en.cppreference.com/w/c/chrono/localtime">localtime</a>(<a href="http://en.cppreference.com/w/c/chrono/time">time</a>))</code>.</div><div>2) Same as (1), except that the function is equivalent to <code>asctime_s(buffer, bufsz, localtime_s(<a href="http://en.cppreference.com/w/c/chrono/time">time</a>, &amp;(struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a>){0}))</code>, and the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>buffer</code> or <code>time</code> is a null pointer</li><li> <code>bufsz</code> is less than <code>26</code> or greater than RSIZE_MAX</li></ul></dd><dd>As with all bounds-checked functions, <code>ctime_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>time.h</code>.</dd></dl></div><p>The resulting string has the following format:<br></p><div><div><pre><code>Www Mmm dd hh:mm:ss yyyy\n</code></pre></div></div><ul><li><code>Www</code> - the day of the week (one of <code>Mon</code>, <code>Tue</code>, <code>Wed</code>, <code>Thu</code>, <code>Fri</code>, <code>Sat</code>, <code>Sun</code>).</li><li><code>Mmm</code> - the month (one of <code>Jan</code>, <code>Feb</code>, <code>Mar</code>, <code>Apr</code>, <code>May</code>, <code>Jun</code>, <code>Jul</code>, <code>Aug</code>, <code>Sep</code>, <code>Oct</code>, <code>Nov</code>, <code>Dec</code>).</li><li><code>dd</code> - the day of the month</li><li><code>hh</code> - hours</li><li><code>mm</code> - minutes</li><li><code>ss</code> - seconds </li><li><code>yyyy</code> - years</li></ul><p>The function does not support localization.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  time</td><td> -</td><td>  pointer to a <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> object specifying the time to print</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to an element of a char array of size at least <code>bufsz</code></td></tr><tr><td>  bufsz</td><td> -</td><td>  max number of bytes to output, typically the size of the buffer pointed to by <code>buffer</code></td></tr></table><span class="prog__sub"> Return value</span><div>1) pointer to a static null-terminated character string holding the textual representation of date and time. The string may be shared between <code>asctime</code> and <strong class="selflink">ctime</strong>, and may be overwritten on each invocation of any of those functions.</div><div>2) zero on success (in which case the string representatino of time has been written out to the array pointed to by <code>buffer</code>), or non-zero on failure (in which case, the terminating null character is always written to <code>buffer[0]</code> unless <code>buffer</code> is a null pointer or <code>bufsz</code> is zero or greater than RSIZE_MAX.</div></section>	http://en.cppreference.com/w/c/chrono/ctime
difftime	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>double difftime( <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> time_end, <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> time_beg );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Computes difference between two calendar times as <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> objects (<code>time_end - time_beg</code>) in seconds. If <code>time_end</code> refers to time point before <code>time_beg</code> then the result is negative.</p><span class="prog__sub"> Parameters</span><table><tr><td>  time_beg, time_end</td><td> -</td><td>  times to compare</td></tr></table><span class="prog__sub"> Return value</span><p>Difference between two times in seconds.<br></p></section>	http://en.cppreference.com/w/c/chrono/difftime
gmtime, gmtime_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *gmtime( const <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> *<a href="http://en.cppreference.com/w/c/chrono/time">time</a> );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *gmtime_s(const <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> *restrict <a href="http://en.cppreference.com/w/c/chrono/time">time</a>, struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *restrict result);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts given time since epoch (a <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> value pointed to by <code>time</code>) into calendar time, expressed in Coordinated Universal Time (UTC) in the <a href="http://en.cppreference.com/w/c/chrono/tm" title="c/chrono/tm">struct tm</a> format. The result is stored in static storage and a pointer to that static storage is returned.</div><div>2) Same as (1), except that the function uses user-provided storage <code>result</code> for the result and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>time</code> or <code>result</code> is a null pointer</li></ul></dd><dd>As with all bounds-checked functions, <code>gmtime_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>time.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  time</td><td> -</td><td>  pointer to a time_t object to convert</td></tr><tr><td>  result</td><td> -</td><td>  pointer to a struct tm object to store the result</td></tr></table><span class="prog__sub"> Return value</span><div>1) pointer to a static internal <a href="http://en.cppreference.com/w/c/chrono/tm" title="c/chrono/tm">tm</a> object on success, or null pointer otherwise. The structure may be shared between <strong class="selflink">gmtime</strong>, <a href="http://en.cppreference.com/w/c/chrono/localtime" title="c/chrono/localtime">localtime</a>, and <a href="http://en.cppreference.com/w/c/chrono/ctime" title="c/chrono/ctime">ctime</a> and may be overwritten on each invocation.</div><div>2) copy of the <code>result</code> pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to UTC)</div></section>	http://en.cppreference.com/w/c/chrono/gmtime
localtime, localtime_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *localtime( const <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> *<a href="http://en.cppreference.com/w/c/chrono/time">time</a> );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *localtime_s(const <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> *restrict <a href="http://en.cppreference.com/w/c/chrono/time">time</a>, struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *restrict result);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts given time since epoch (a <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> value pointed to by <code>time</code>) into calendar time, expressed in local time, in the <a href="http://en.cppreference.com/w/c/chrono/tm" title="c/chrono/tm">struct tm</a> format. The result is stored in static storage and a pointer to that static storage is returned.</div><div>2) Same as (1), except that the function uses user-provided storage <code>result</code> for the result and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>time</code> or <code>result</code> is a null pointer</li></ul></dd><dd>As with all bounds-checked functions, <code>localtime_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>time.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  time</td><td> -</td><td>  pointer to a <code>time_t</code> object to convert</td></tr><tr><td>  result</td><td> -</td><td>  pointer to a struct tm object to store the result</td></tr></table><span class="prog__sub"> Return value</span><div>1) pointer to a static internal <a href="http://en.cppreference.com/w/c/chrono/tm" title="c/chrono/tm">tm</a> object on success, or null pointer otherwise. The structure may be shared between <a href="http://en.cppreference.com/w/c/chrono/gmtime" title="c/chrono/gmtime">gmtime</a>, <strong class="selflink">localtime</strong>, and <a href="http://en.cppreference.com/w/c/chrono/ctime" title="c/chrono/ctime">ctime</a> and may be overwritten on each invocation.</div><div>2) copy of the <code>result</code> pointer, or null pointer on error (which may be a runtime constraint violation or a failure to convert the specified time to local calendar time)</div></section>	http://en.cppreference.com/w/c/chrono/localtime
mktime	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> mktime( struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *<a href="http://en.cppreference.com/w/c/chrono/time">time</a> );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Renormalizes local calendar time expressed as a <a href="http://en.cppreference.com/w/c/chrono/tm" title="c/chrono/tm">struct tm</a> object and also converts it to time since epoch as a <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> object. <code>time-&gt;tm_wday</code> and <code>time-&gt;tm_yday</code> are ignored. The values in <code>time</code> are not checked for being out of range.</p><p>A negative value of <code>time-&gt;tm_isdst</code> causes <code>mktime</code> to attempt to determine if Daylight Saving Time was in effect in the specified time.</p><p>If the conversion to <code>time_t</code> is successful, the <code>time</code> object is modified. All fields of <code>time</code> are updated to fit their proper ranges. <code>time-&gt;tm_wday</code> and <code>time-&gt;tm_yday</code> are recalculated using information available in other fields.</p><span class="prog__sub"> Parameters</span><table><tr><td>  time</td><td> -</td><td>  pointer to a <a href="http://en.cppreference.com/w/c/chrono/tm" title="c/chrono/tm">tm</a> object specifying local calendar time to convert</td></tr></table><span class="prog__sub"> Return value</span><p>time since epoch as a <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> object on success or <code>-1</code> if <code>time</code> cannot be represented as a <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> object (POSIX also requires <code>EOVERFLOW</code> to be stored in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> in this case).</p></section>	http://en.cppreference.com/w/c/chrono/mktime
strftime	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strftime( char * \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 str, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const char * \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 format, const struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> * \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 <a href="http://en.cppreference.com/w/c/chrono/time">time</a> );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strftime( char *restrict str, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const char *restrict format, const struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> *restrict <a href="http://en.cppreference.com/w/c/chrono/time">time</a> );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts the date and time information from a given calendar time <code>time</code> to a null-terminated multibyte character string <code>str</code> according to format string <code>format</code>. Up to <code>count</code> bytes are written.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the first element of the char array for output</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of bytes to write</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated multibyte character string specifying the format of conversion.<p>The format string consists of zero or more conversion specifiers and ordinary characters (except <code>%</code>). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with <code>%</code> character, optionally followed by <code>E</code> or <code>O</code> modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</p><table><tr><th> Conversion<br/> specifier</th><th> Explanation</th><th> Used fields</th></tr><tr><th> <code>%</code></th><td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td></td></tr><tr><th> <code>n</code><br/>(C99)</th><td> writes newline character</td><td></td></tr><tr><th> <code>t</code><br/>(C99)</th><td> writes horizontal tab character</td><td></td></tr><tr><th colspan="3"> Year</th></tr><tr><th> <code>Y</code></th><td> writes <b>year</b> as a decimal number, e.g. 2017</td><td> <code>tm_year</code></td></tr><tr><th> <code>EY</code><br/>(C99)</th><td> writes <b>year</b> in the alternative representation, e.g.\xe5\xb9\xb3\xe6\x88\x9023\xe5\xb9\xb4 (year Heisei 23) instead of 2011\xe5\xb9\xb4 (year 2011) in ja_JP locale</td><td> <code>tm_year</code></td></tr><tr><th> <code>y</code></th><td> writes last 2 digits of <b>year</b> as a decimal number (range <code>[00,99]</code>)</td><td> <code>tm_year</code></td></tr><tr><th> <code>Oy</code><br/>(C99)</th><td> writes last 2 digits of <b>year</b> using the alternative numeric system, e.g. \xe5\x8d\x81\xe4\xb8\x80 instead of 11 in ja_JP locale</td><td> <code>tm_year</code></td></tr><tr><th> <code>Ey</code><br/>(C99)</th><td> writes <b>year</b> as offset from locale's alternative calendar period <code>%EC</code> (locale-dependent)</td><td> <code>tm_year</code></td></tr><tr><th> <code>C</code><br/>(C99)</th><td> writes first 2 digits of <b>year</b> as a decimal number (range <code>[00,99]</code>)</td><td> <code>tm_year</code></td></tr><tr><th> <code>EC</code><br/>(C99)</th><td> writes name of the <b>base year (period)</b> in the locale's alternative representation, e.g. \xe5\xb9\xb3\xe6\x88\x90 (Heisei era) in ja_JP</td><td> <code>tm_year</code></td></tr><tr><th> <code>G</code><br/>(C99)</th><td> writes <b>ISO 8601 week-based year</b>, i.e. the year that contains the specified week.<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year</li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>g</code><br/>(C99)</th><td> writes last 2 digits of <b>ISO 8601 week-based year</b>, i.e. the year that contains the specified week (range <code>[00,99]</code>).<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year </li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th colspan="3"> Month</th></tr><tr><th> <code>b</code></th><td> writes <b>abbreviated month</b> name, e.g. <code>Oct</code> (locale dependent)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>h</code><br/>(C99)</th><td> synonym of <code>b</code></td><td> <code>tm_mon</code></td></tr><tr><th> <code>B</code></th><td> writes <b>full month</b> name, e.g. <code>October</code> (locale dependent)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>m</code></th><td> writes <b>month</b> as a decimal number (range <code>[01,12]</code>)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>Om</code><br/>(C99)</th><td> writes <b>month</b> using the alternative numeric system, e.g. \xe5\x8d\x81\xe4\xba\x8c instead of 12 in ja_JP locale</td><td> <code>tm_mon</code></td></tr><tr><th colspan="3"> Week</th></tr><tr><th> <code>U</code></th><td> writes <b>week of the year</b> as a decimal number (Sunday is the first day of the week) (range <code>[00,53]</code>)</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OU</code><br/>(C99)</th><td> writes <b>week of the year</b>, as by <code>%U</code>, using the alternative numeric system, e.g. \xe4\xba\x94\xe5\x8d\x81\xe4\xba\x8c instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>W</code></th><td> writes <b>week of the year</b> as a decimal number (Monday is the first day of the week) (range <code>[00,53]</code>)</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OW</code><br/>(C99)</th><td> writes <b>week of the year</b>, as by <code>%W</code>, using the alternative numeric system, e.g. \xe4\xba\x94\xe5\x8d\x81\xe4\xba\x8c instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>V</code><br/>(C99)</th><td> writes <b>ISO 8601 week of the year</b> (range <code>[01,53]</code>).<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year </li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OV</code><br/>(C99)</th><td> writes <b>week of the year</b>, as by <code>%V</code>, using the alternative numeric system, e.g. \xe4\xba\x94\xe5\x8d\x81\xe4\xba\x8c instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th colspan="3"> Day of the year/month</th></tr><tr><th> <code>j</code></th><td> writes <b>day of the year</b> as a decimal number (range <code>[001,366]</code>)</td><td> <code>tm_yday</code></td></tr><tr><th> <code>d</code></th><td> writes <b>day of the month</b> as a decimal number (range <code>[01,31]</code>)</td><td> <code>tm_mday</code></td></tr><tr><th> <code>Od</code><br/>(C99)</th><td> writes zero-based <b>day of the month</b> using the alternative numeric system, e.g \xe4\xba\x8c\xe5\x8d\x81\xe4\xb8\x83 instead of 23 in ja_JP locale<p>Single character is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th> <code>e</code><br/>(C99)</th><td> writes <b>day of the month</b> as a decimal number (range <code>[1,31]</code>).<p>Single digit is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th> <code>Oe</code><br/>(C99)</th><td> writes one-based <b>day of the month</b> using the alternative numeric system, e.g. \xe4\xba\x8c\xe5\x8d\x81\xe4\xb8\x83 instead of 27 in ja_JP locale<p>Single character is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th colspan="3"> Day of the week</th></tr><tr><th> <code>a</code></th><td> writes <b>abbreviated weekday</b> name, e.g. <code>Fri</code> (locale dependent)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>A</code></th><td> writes <b>full weekday</b> name, e.g. <code>Friday</code> (locale dependent)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>w</code></th><td> writes <b>weekday</b> as a decimal number, where Sunday is <code>0</code> (range <code>[0-6]</code>)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>Ow</code><br/>(C99)</th><td> writes <b>weekday</b>, where Sunday is <code>0</code>, using the alternative numeric system, e.g. \xe4\xba\x8c instead of 2 in ja_JP locale</td><td> <code>tm_wday</code></td></tr><tr><th> <code>u</code><br/>(C99)</th><td> writes <b>weekday</b> as a decimal number, where Monday is <code>1</code> (ISO 8601 format) (range <code>[1-7]</code>)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>Ou</code><br/>(C99)</th><td> writes <b>weekday</b>, where Monday is <code>1</code>, using the alternative numeric system, e.g. \xe4\xba\x8c instead of 2 in ja_JP locale</td><td> <code>tm_wday</code></td></tr><tr><th colspan="3"> Hour, minute, second</th></tr><tr><th> <code>H</code></th><td> writes <b>hour</b> as a decimal number, 24 hour clock (range <code>[00-23]</code>)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>OH</code><br/>(C99)</th><td> writes <b>hour</b> from 24-hour clock using the alternative numeric system, e.g. \xe5\x8d\x81\xe5\x85\xab instead of 18 in ja_JP locale</td><td> <code>tm_hour</code></td></tr><tr><th> <code>I</code></th><td> writes <b>hour</b> as a decimal number, 12 hour clock (range <code>[01,12]</code>)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>OI</code><br/>(C99)</th><td> writes <b>hour</b> from 12-hour clock using the alternative numeric system, e.g. \xe5\x85\xad instead of 06 in ja_JP locale</td><td> <code>tm_hour</code></td></tr><tr><th> <code>M</code></th><td> writes <b>minute</b> as a decimal number (range <code>[00,59]</code>)</td><td> <code>tm_min</code></td></tr><tr><th> <code>OM</code><br/>(C99)</th><td> writes <b>minute</b> using the alternative numeric system, e.g. \xe4\xba\x8c\xe5\x8d\x81\xe4\xba\x94 instead of 25 in ja_JP locale</td><td> <code>tm_min</code></td></tr><tr><th> <code>S</code></th><td> writes <b>second</b> as a decimal number (range <code>[00,60]</code>)</td><td> <code>tm_sec</code></td></tr><tr><th> <code>OS</code><br/>(C99)</th><td> writes <b>second</b> using the alternative numeric system, e.g. \xe4\xba\x8c\xe5\x8d\x81\xe5\x9b\x9b instead of 24 in ja_JP locale</td><td> <code>tm_sec</code></td></tr><tr><th colspan="3"> Other</th></tr><tr><th> <code>c</code></th><td> writes <b>standard date and time string</b>, e.g. <code>Sun Oct 17 04:41:13 2010</code> (locale dependent)</td><td> all</td></tr><tr><th> <code>Ec</code><br/>(C99)</th><td> writes <b>alternative date and time string</b>, e.g. using \xe5\xb9\xb3\xe6\x88\x9023\xe5\xb9\xb4 (year Heisei 23) instead of 2011\xe5\xb9\xb4 (year 2011) in ja_JP locale</td><td> all</td></tr><tr><th> <code>x</code></th><td> writes localized <b>date representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>Ex</code><br/>(C99)</th><td> writes <b>alternative date representation</b>, e.g. using \xe5\xb9\xb3\xe6\x88\x9023\xe5\xb9\xb4 (year Heisei 23) instead of 2011\xe5\xb9\xb4 (year 2011) in ja_JP locale</td><td> all</td></tr><tr><th> <code>X</code></th><td> writes localized <b>time representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>EX</code><br/>(C99)</th><td> writes <b>alternative time representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>D</code><br/>(C99)</th><td> equivalent to <b>"%m/%d/%y"</b></td><td> <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_year</code></td></tr><tr><th> <code>F</code><br/>(C99)</th><td> equivalent to <b>"%Y-%m-%d"</b> (the ISO 8601 date format)</td><td> <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_year</code></td></tr><tr><th> <code>r</code><br/>(C99)</th><td> writes localized <b>12-hour clock</b> time (locale dependent)</td><td> <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code></td></tr><tr><th> <code>R</code><br/>(C99)</th><td> equivalent to <b>"%H:%M"</b></td><td> <code>tm_hour</code>, <code>tm_min</code></td></tr><tr><th> <code>T</code><br/>(C99)</th><td> equivalent to <b>"%H:%M:%S"</b> (the ISO 8601 time format)</td><td> <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code></td></tr><tr><th> <code>p</code></th><td> writes localized <b>a.m. or p.m.</b> (locale dependent)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>z</code><br/>(C99)</th><td> writes <b>offset from UTC</b> in the ISO 8601 format (e.g. <code>-0430</code>), or no characters if the time zone information is not available</td><td> <code>tm_isdst</code></td></tr><tr><th> <code>Z</code></th><td> writes <b>time zone name or abbreviation</b>, or no characters if the time zone information is not available (locale dependent)</td><td> <code>tm_isdst</code></td></tr></table><p><br/></p></td></tr><tr><td>  time</td><td> -</td><td>  pointer to a struct tm object specifying the time to format</td></tr></table><span class="prog__sub"> Return value</span><p>The number of bytes written into the character array pointed to by <code>str</code> not including the terminating <code>'\x00'</code> on success. If <code>count</code> was reached before the entire string could be stored, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned and the contents are undefined.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    char buff[70];    struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> my_time = { .tm_year=112, // = year 2012                          .tm_mon=9,    // = 10th month                          .tm_mday=9,   // = 9th day                          .tm_hour=8,   // = 8 hours                          .tm_min=10,   // = 10 minutes                          .tm_sec=20    // = 20 secs    };\xc2\xa0    if (strftime(buff, sizeof buff, "%A\xc2\xa0%c", &amp;my_time)) {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>(buff);    } else {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("strftime failed");    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_TIME</a>, "el_GR.utf8");\xc2\xa0    if (strftime(buff, sizeof buff, "%A\xc2\xa0%c", &amp;my_time)) {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>(buff);    } else {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("strftime failed");    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Sunday Sun Oct  9 08:10:20 2012<br>\xce\x9a\xcf\x85\xcf\x81\xce\xb9\xce\xb1\xce\xba\xce\xae \xce\x9a\xcf\x85\xcf\x81 09 \xce\x9f\xce\xba\xcf\x84 2012 08:10:20 \xcf\x80\xce\xbc EST</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/chrono/strftime
time	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> time( <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> *arg );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the current calendar time encoded as a <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> object, and also stores it in the <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> object pointed to by <code>arg</code> (unless <code>arg</code> is a null pointer)</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  pointer to a <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> object where the time will be stored, or a null pointer</td></tr></table><span class="prog__sub"> Return value</span><p>Current calendar time encoded as <a href="http://en.cppreference.com/w/c/chrono/time_t" title="c/chrono/time t">time_t</a> object on success, <code>(<a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a>)(-1)</code> on error. If <code>arg</code> is not a null pointer, the return value is also stored in the object pointed to by  <code>arg</code>.</p></section>	http://en.cppreference.com/w/c/chrono/time
time_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>typedef /* unspecified */ time_t;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Arithmetic (until C11) Real (since C11) type capable of representing times.</p><p>Although not defined by the C standard, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to <a class="extiw" href="http://en.wikipedia.com/wiki/Unix_time" title="enwiki:Unix time"> POSIX time</a>.</p></section>	http://en.cppreference.com/w/c/chrono/time_t
timespec	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>struct timespec;</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Structure holding an interval broken down into seconds and nanoseconds.<br></p><span class="prog__sub"> Member objects</span><table><tr><td> time_t tv_sec</td><td> whole seconds (valid values are &gt;= 0)</td></tr><tr><td> long tv_nsec</td><td>  nanoseconds (valid values are [0, 999999999])</td></tr></table></section>	http://en.cppreference.com/w/c/chrono/timespec
timespec_get	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int timespec_get( struct timespec *ts, int base)</code></div></td><td> </td><td> (since C11) </td></tr><tr><td> <div><code>#define TIME_UTC /* implementation-defined */</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Modifies the timespec object pointed to by <code>ts</code> to hold the current calendar time in the time base <code>base</code>.</div><div>2) Expands to a value suitable for use as the <code>base</code> argument of <code>timespec_get</code></div><p>Other macro constants beginning with <code>TIME_</code> may be provided by the implementation to indicate additional time bases</p><p>If <code>base</code> is <code>TIME_UTC</code>, then</p><ul><li> ts-&gt;tv_sec is set to the number of seconds since an implementation defined epoch, truncated to a whole value</li><li> ts-&gt;tv_nsec member is set to the integral number of nanoseconds, rounded to the resolution of the system clock</li></ul><span class="prog__sub"> Parameters</span><table><tr><td>  ts</td><td> -</td><td>  pointer to an object of type <code>struct timespec</code></td></tr><tr><td>  base</td><td> -</td><td> <code>TIME_UTC</code> or another nonzero integer value indicating the time base</td></tr></table><span class="prog__sub"> Return value</span><p>The value of <code>base</code> if successful, zero otherwise.</p></section>	http://en.cppreference.com/w/c/chrono/timespec_get
tm	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>struct tm;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Structure holding a calendar date and time broken down into its components.<br></p><span class="prog__sub"> Member objects</span><table><tr><td> int tm_sec</td><td>  seconds after the minute \xe2\x80\x93 [0, 61](until C99) / [0, 60] (since C99)<sup class="reference" id="cite_ref-leapsecond_1-0">[note 1]</sup></td></tr><tr><td> int tm_min</td><td>  minutes after the hour \xe2\x80\x93 [0, 59]</td></tr><tr><td> int tm_hour</td><td>  hours since midnight \xe2\x80\x93 [0, 23]</td></tr><tr><td> int tm_mday</td><td>  day of the month \xe2\x80\x93 [1, 31]</td></tr><tr><td> int tm_mon</td><td>  months since January \xe2\x80\x93 [0, 11]</td></tr><tr><td> int tm_year</td><td>  years since 1900</td></tr><tr><td> int tm_wday</td><td>  days since Sunday \xe2\x80\x93 [0, 6]</td></tr><tr><td> int tm_yday</td><td>  days since January 1 \xe2\x80\x93 [0, 365]</td></tr><tr><td> int tm_isdst</td><td>  Daylight Saving Time flag. The value is positive if DST is in effect, zero if not and negative if no information is available</td></tr></table></section>	http://en.cppreference.com/w/c/chrono/tm
wcsftime	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcsftime( wchar_t* str, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count, const wchar_t* format, <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a>* <a href="http://en.cppreference.com/w/c/chrono/time">time</a> );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts the date and time information from a given calendar time <code>time</code> to a null-terminated wide character string <code>str</code> according to format string <code>format</code>. Up to <code>count</code> bytes are written.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the first element of the wchar_t array for output</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of wide characters to write</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated wide character string specifying the format of conversion.<p>The format string consists of zero or more conversion specifiers and ordinary characters (except <code>%</code>). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with <code>%</code> character, optionally followed by <code>E</code> or <code>O</code> modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</p><table><tr><th> Conversion<br/> specifier</th><th> Explanation</th><th> Used fields</th></tr><tr><th> <code>%</code></th><td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td></td></tr><tr><th> <code>n</code><br/>(C99)</th><td> writes newline character</td><td></td></tr><tr><th> <code>t</code><br/>(C99)</th><td> writes horizontal tab character</td><td></td></tr><tr><th colspan="3"> Year</th></tr><tr><th> <code>Y</code></th><td> writes <b>year</b> as a decimal number, e.g. 2017</td><td> <code>tm_year</code></td></tr><tr><th> <code>EY</code><br/>(C99)</th><td> writes <b>year</b> in the alternative representation, e.g.\xe5\xb9\xb3\xe6\x88\x9023\xe5\xb9\xb4 (year Heisei 23) instead of 2011\xe5\xb9\xb4 (year 2011) in ja_JP locale</td><td> <code>tm_year</code></td></tr><tr><th> <code>y</code></th><td> writes last 2 digits of <b>year</b> as a decimal number (range <code>[00,99]</code>)</td><td> <code>tm_year</code></td></tr><tr><th> <code>Oy</code><br/>(C99)</th><td> writes last 2 digits of <b>year</b> using the alternative numeric system, e.g. \xe5\x8d\x81\xe4\xb8\x80 instead of 11 in ja_JP locale</td><td> <code>tm_year</code></td></tr><tr><th> <code>Ey</code><br/>(C99)</th><td> writes <b>year</b> as offset from locale's alternative calendar period <code>%EC</code> (locale-dependent)</td><td> <code>tm_year</code></td></tr><tr><th> <code>C</code><br/>(C99)</th><td> writes first 2 digits of <b>year</b> as a decimal number (range <code>[00,99]</code>)</td><td> <code>tm_year</code></td></tr><tr><th> <code>EC</code><br/>(C99)</th><td> writes name of the <b>base year (period)</b> in the locale's alternative representation, e.g. \xe5\xb9\xb3\xe6\x88\x90 (Heisei era) in ja_JP</td><td> <code>tm_year</code></td></tr><tr><th> <code>G</code><br/>(C99)</th><td> writes <b>ISO 8601 week-based year</b>, i.e. the year that contains the specified week.<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year</li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>g</code><br/>(C99)</th><td> writes last 2 digits of <b>ISO 8601 week-based year</b>, i.e. the year that contains the specified week (range <code>[00,99]</code>).<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year </li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th colspan="3"> Month</th></tr><tr><th> <code>b</code></th><td> writes <b>abbreviated month</b> name, e.g. <code>Oct</code> (locale dependent)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>h</code><br/>(C99)</th><td> synonym of <code>b</code></td><td> <code>tm_mon</code></td></tr><tr><th> <code>B</code></th><td> writes <b>full month</b> name, e.g. <code>October</code> (locale dependent)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>m</code></th><td> writes <b>month</b> as a decimal number (range <code>[01,12]</code>)</td><td> <code>tm_mon</code></td></tr><tr><th> <code>Om</code><br/>(C99)</th><td> writes <b>month</b> using the alternative numeric system, e.g. \xe5\x8d\x81\xe4\xba\x8c instead of 12 in ja_JP locale</td><td> <code>tm_mon</code></td></tr><tr><th colspan="3"> Week</th></tr><tr><th> <code>U</code></th><td> writes <b>week of the year</b> as a decimal number (Sunday is the first day of the week) (range <code>[00,53]</code>)</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OU</code><br/>(C99)</th><td> writes <b>week of the year</b>, as by <code>%U</code>, using the alternative numeric system, e.g. \xe4\xba\x94\xe5\x8d\x81\xe4\xba\x8c instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>W</code></th><td> writes <b>week of the year</b> as a decimal number (Monday is the first day of the week) (range <code>[00,53]</code>)</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OW</code><br/>(C99)</th><td> writes <b>week of the year</b>, as by <code>%W</code>, using the alternative numeric system, e.g. \xe4\xba\x94\xe5\x8d\x81\xe4\xba\x8c instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>V</code><br/>(C99)</th><td> writes <b>ISO 8601 week of the year</b> (range <code>[01,53]</code>).<p>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:<br></p><ul><li> Includes January 4</li><li> Includes first Thursday of the year </li></ul></td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th> <code>OV</code><br/>(C99)</th><td> writes <b>week of the year</b>, as by <code>%V</code>, using the alternative numeric system, e.g. \xe4\xba\x94\xe5\x8d\x81\xe4\xba\x8c instead of 52 in ja_JP locale</td><td> <code>tm_year</code>, <code>tm_wday</code>, <code>tm_yday</code></td></tr><tr><th colspan="3"> Day of the year/month</th></tr><tr><th> <code>j</code></th><td> writes <b>day of the year</b> as a decimal number (range <code>[001,366]</code>)</td><td> <code>tm_yday</code></td></tr><tr><th> <code>d</code></th><td> writes <b>day of the month</b> as a decimal number (range <code>[01,31]</code>)</td><td> <code>tm_mday</code></td></tr><tr><th> <code>Od</code><br/>(C99)</th><td> writes zero-based <b>day of the month</b> using the alternative numeric system, e.g \xe4\xba\x8c\xe5\x8d\x81\xe4\xb8\x83 instead of 23 in ja_JP locale<p>Single character is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th> <code>e</code><br/>(C99)</th><td> writes <b>day of the month</b> as a decimal number (range <code>[1,31]</code>).<p>Single digit is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th> <code>Oe</code><br/>(C99)</th><td> writes one-based <b>day of the month</b> using the alternative numeric system, e.g. \xe4\xba\x8c\xe5\x8d\x81\xe4\xb8\x83 instead of 27 in ja_JP locale<p>Single character is preceded by a space.<br></p></td><td> <code>tm_mday</code></td></tr><tr><th colspan="3"> Day of the week</th></tr><tr><th> <code>a</code></th><td> writes <b>abbreviated weekday</b> name, e.g. <code>Fri</code> (locale dependent)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>A</code></th><td> writes <b>full weekday</b> name, e.g. <code>Friday</code> (locale dependent)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>w</code></th><td> writes <b>weekday</b> as a decimal number, where Sunday is <code>0</code> (range <code>[0-6]</code>)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>Ow</code><br/>(C99)</th><td> writes <b>weekday</b>, where Sunday is <code>0</code>, using the alternative numeric system, e.g. \xe4\xba\x8c instead of 2 in ja_JP locale</td><td> <code>tm_wday</code></td></tr><tr><th> <code>u</code><br/>(C99)</th><td> writes <b>weekday</b> as a decimal number, where Monday is <code>1</code> (ISO 8601 format) (range <code>[1-7]</code>)</td><td> <code>tm_wday</code></td></tr><tr><th> <code>Ou</code><br/>(C99)</th><td> writes <b>weekday</b>, where Monday is <code>1</code>, using the alternative numeric system, e.g. \xe4\xba\x8c instead of 2 in ja_JP locale</td><td> <code>tm_wday</code></td></tr><tr><th colspan="3"> Hour, minute, second</th></tr><tr><th> <code>H</code></th><td> writes <b>hour</b> as a decimal number, 24 hour clock (range <code>[00-23]</code>)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>OH</code><br/>(C99)</th><td> writes <b>hour</b> from 24-hour clock using the alternative numeric system, e.g. \xe5\x8d\x81\xe5\x85\xab instead of 18 in ja_JP locale</td><td> <code>tm_hour</code></td></tr><tr><th> <code>I</code></th><td> writes <b>hour</b> as a decimal number, 12 hour clock (range <code>[01,12]</code>)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>OI</code><br/>(C99)</th><td> writes <b>hour</b> from 12-hour clock using the alternative numeric system, e.g. \xe5\x85\xad instead of 06 in ja_JP locale</td><td> <code>tm_hour</code></td></tr><tr><th> <code>M</code></th><td> writes <b>minute</b> as a decimal number (range <code>[00,59]</code>)</td><td> <code>tm_min</code></td></tr><tr><th> <code>OM</code><br/>(C99)</th><td> writes <b>minute</b> using the alternative numeric system, e.g. \xe4\xba\x8c\xe5\x8d\x81\xe4\xba\x94 instead of 25 in ja_JP locale</td><td> <code>tm_min</code></td></tr><tr><th> <code>S</code></th><td> writes <b>second</b> as a decimal number (range <code>[00,60]</code>)</td><td> <code>tm_sec</code></td></tr><tr><th> <code>OS</code><br/>(C99)</th><td> writes <b>second</b> using the alternative numeric system, e.g. \xe4\xba\x8c\xe5\x8d\x81\xe5\x9b\x9b instead of 24 in ja_JP locale</td><td> <code>tm_sec</code></td></tr><tr><th colspan="3"> Other</th></tr><tr><th> <code>c</code></th><td> writes <b>standard date and time string</b>, e.g. <code>Sun Oct 17 04:41:13 2010</code> (locale dependent)</td><td> all</td></tr><tr><th> <code>Ec</code><br/>(C99)</th><td> writes <b>alternative date and time string</b>, e.g. using \xe5\xb9\xb3\xe6\x88\x9023\xe5\xb9\xb4 (year Heisei 23) instead of 2011\xe5\xb9\xb4 (year 2011) in ja_JP locale</td><td> all</td></tr><tr><th> <code>x</code></th><td> writes localized <b>date representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>Ex</code><br/>(C99)</th><td> writes <b>alternative date representation</b>, e.g. using \xe5\xb9\xb3\xe6\x88\x9023\xe5\xb9\xb4 (year Heisei 23) instead of 2011\xe5\xb9\xb4 (year 2011) in ja_JP locale</td><td> all</td></tr><tr><th> <code>X</code></th><td> writes localized <b>time representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>EX</code><br/>(C99)</th><td> writes <b>alternative time representation</b> (locale dependent)</td><td> all</td></tr><tr><th> <code>D</code><br/>(C99)</th><td> equivalent to <b>"%m/%d/%y"</b></td><td> <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_year</code></td></tr><tr><th> <code>F</code><br/>(C99)</th><td> equivalent to <b>"%Y-%m-%d"</b> (the ISO 8601 date format)</td><td> <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_year</code></td></tr><tr><th> <code>r</code><br/>(C99)</th><td> writes localized <b>12-hour clock</b> time (locale dependent)</td><td> <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code></td></tr><tr><th> <code>R</code><br/>(C99)</th><td> equivalent to <b>"%H:%M"</b></td><td> <code>tm_hour</code>, <code>tm_min</code></td></tr><tr><th> <code>T</code><br/>(C99)</th><td> equivalent to <b>"%H:%M:%S"</b> (the ISO 8601 time format)</td><td> <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code></td></tr><tr><th> <code>p</code></th><td> writes localized <b>a.m. or p.m.</b> (locale dependent)</td><td> <code>tm_hour</code></td></tr><tr><th> <code>z</code><br/>(C99)</th><td> writes <b>offset from UTC</b> in the ISO 8601 format (e.g. <code>-0430</code>), or no characters if the time zone information is not available</td><td> <code>tm_isdst</code></td></tr><tr><th> <code>Z</code></th><td> writes <b>time zone name or abbreviation</b>, or no characters if the time zone information is not available (locale dependent)</td><td> <code>tm_isdst</code></td></tr></table><p><br/></p></td></tr></table><span class="prog__sub"> Return value</span><p>number of wide characters written into the wide character array pointed to by <code>str</code> not including the terminating <code>L'\x00'</code> on success. If <code>count</code> was reached before the entire string could be stored, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned and the contents are undefined.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;wchar.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t buff[40];    struct <a href="http://en.cppreference.com/w/c/chrono/tm">tm</a> my_time = { .tm_year=112, // = year 2012                          .tm_mon=9,    // = 10th month                          .tm_mday=9,   // = 9th day                          .tm_hour=8,   // = 8 hours                          .tm_min=10,   // = 10 minutes                          .tm_sec=20    // = 20 secs    };\xc2\xa0    if (wcsftime(buff, sizeof buff, L"%A\xc2\xa0%c", &amp;my_time)) {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ls\n", buff);    } else {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("wcsftime failed");    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "ja_JP.utf8");\xc2\xa0    if (wcsftime(buff, sizeof buff, L"%A\xc2\xa0%c", &amp;my_time)) {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ls\n", buff);    } else {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("wcsftime failed");    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Sunday Sun Oct  9 08:10:20 2012<br>\xe6\x97\xa5\xe6\x9b\x9c\xe6\x97\xa5 2012\xe5\xb9\xb410\xe6\x9c\x8809\xe6\x97\xa5 08\xe6\x99\x8210\xe5\x88\x8620\xe7\xa7\x92</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/chrono/wcsftime
abort_handler_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void abort_handler_s( const char * restrict msg,<br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 void * restrict ptr,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 errno_t error<br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes an implementation-defined message to <a href="http://en.cppreference.com/w/c/io" title="c/io">stderr</a> which must include the string pointed to by <code>msg</code> and calls <a href="http://en.cppreference.com/w/c/program/abort" title="c/program/abort">abort()</a>.</p><p>A pointer to this function can be passed to <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">set_constraint_handler_s</a> to establish a runtime constraints violation handler.</p><dl><dd>As with all bounds-checked functions, <code>abort_handler_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdlib.h&gt;</code>.</dd></dl><span class="prog__sub"> Parameters</span><table><tr><td>  msg</td><td> -</td><td>  pointer to the message written to the standard error stream</td></tr><tr><td>  ptr</td><td> -</td><td>  pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected</td></tr><tr><td>  error</td><td> -</td><td>  a positive value of type errno_t</td></tr></table><span class="prog__sub"> Return value</span><p>none; this function does not return to its caller<br></p></section>	http://en.cppreference.com/w/c/error/abort_handler_s
assert	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;assert.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#ifdef NDEBUG<br/><p>#define assert(condition) ((void)0)<br/>#else<br/>#define assert(condition) /*implementation defined*/<br/></p>#endif</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The definition of the macro <code>assert</code> depends on another macro, <code>NDEBUG</code>, which is not defined by the standard library.</p><p>If <code>NDEBUG</code> is defined as a macro name at the point in the source code where <code>&lt;assert.h&gt;</code> is included, then <code>assert</code> does nothing.</p><p>If <code>NDEBUG</code> is not defined, then <code>assert</code> checks if its argument (which must have scalar type) compares equal to zero. If it does, <code>assert</code> outputs implementation-specific diagnostic information on the standard error output and calls <code><a href="http://en.cppreference.com/w/c/program/abort">abort</a>()</code>. The diagnostic information is required to include the text of <code>expression</code>, as well as the values of the <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace">standard macros</a> <code>__FILE__</code>,  <code>__LINE__</code>, and the <a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition">predefined variable</a> <code>__func__</code>. (since C99)</p><span class="prog__sub"> Parameters</span><table><tr><td>  condition</td><td> -</td><td>  expression of scalar type</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;// uncomment to disable assert()// #define NDEBUG#include &lt;assert.h&gt;#include &lt;math.h&gt;\xc2\xa0int main(void){    double x = -1.0;    assert(x &gt;= 0.0);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("sqrt(x) =\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(x));   \xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>output with NDEBUG not defined:<br>a.out: main.cpp:10: main: Assertion `x &gt;= 0.0' failed.<br>\xc2\xa0<br>output with NDEBUG defined:<br>sqrt(x) = -nan</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/error/assert
errno	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;errno.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define errno /*implementation-defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><code>errno</code> is a preprocessor macro that expands to a thread-local (since C11) modifiable lvalue of type <code>int</code>. Several standard library functions indicate errors by writing positive integers to <code>errno</code>. Typically, the value of <code>errno</code> is set to one of the error codes listed in <code>&lt;errno.h&gt;</code> as macro constants beginning with the letter <code>E</code> followed by uppercase letters or digits.</p><p>The value of <code>errno</code> is <code>\xe2\x80\x8b0\xe2\x80\x8b</code> at program startup, and although library functions are allowed to write positive integers to <code>errno</code> whether or not an error occurred, library functions never store <code>\xe2\x80\x8b0\xe2\x80\x8b</code> in <code>errno</code>.</p><p>Library functions <a href="http://en.cppreference.com/w/c/io/perror" title="c/io/perror">perror</a> and <a href="http://en.cppreference.com/w/c/string/byte/strerror" title="c/string/byte/strerror">strerror</a> can be used to obtain textual descriptions of the error conditions that correspond to the current <code>errno</code> value.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;errno.h&gt;\xc2\xa0void show_errno(void){    if(errno==<a href="http://en.cppreference.com/w/c/error/errno_macros">EDOM</a>)   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("domain error");    if(errno==<a href="http://en.cppreference.com/w/c/error/errno_macros">EILSEQ</a>) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("illegal sequence");        if(errno==<a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("pole or range error");    if(errno==0)      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("no error");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" occurred\n");}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("MATH_ERRNO is\xc2\xa0%s\n", math_errhandling &amp; MATH_ERRNO ? "set" : "not set");\xc2\xa0    errno = 0;    1.0/0.0;    show_errno();\xc2\xa0    errno = 0;    <a href="http://en.cppreference.com/w/c/numeric/math/acos">acos</a>(+1.1);    show_errno();\xc2\xa0    errno = 0;    <a href="http://en.cppreference.com/w/c/numeric/math/log">log</a>(0.0);    show_errno();\xc2\xa0    errno = 0;    <a href="http://en.cppreference.com/w/c/numeric/math/sin">sin</a>(0.0);    show_errno();}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>MATH_ERRNO is set<br>pole or range error occurred<br>domain error occurred<br>pole or range error occurred<br>no error occurred</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/error/errno
Error numbers	A										<section class="prog__container"><p>Each of the macros defined in <code>&lt;errno.h&gt;</code> expands to an integer constant expression with type <code>int</code> and with a unique positive value. The following constants are defined (the implementation may define more, as long as they begin with <code>'E'</code> followed by digits or uppercase letters)</p><table><tr><td> <div>Defined in header <code>&lt;errno.h&gt;</code> </div></td></tr><tr><td> <div><div>EDOM</div></div></td><td>                       Mathematics argument out of domain of function <br/> (macro constant)</td></tr><tr><td> <div><div>EILSEQ</div><div>(C95)</div></div></td><td>   Illegal byte sequence <br/> (macro constant)</td></tr><tr><td> <div><div>ERANGE</div></div></td><td>                       Result too large <br/> (macro constant)</td></tr></table></section>	http://en.cppreference.com/w/c/error/errno_macros
ignore_handler_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void ignore_handler_s( const char * restrict msg,<br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0void * restrict ptr,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0errno_t error<br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0);</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The function simply returns to the caller without performing any other action.<br></p><p>A pointer to this function can be passed to <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">set_constraint_handler_s</a> to establish a runtime constraints violation handler that does nothing.</p><dl><dd>As with all bounds-checked functions, <code>ignore_handler_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdlib.h&gt;</code>.</dd></dl><span class="prog__sub"> Parameters</span><table><tr><td>  msg</td><td> -</td><td>  pointer to character string that describes the error</td></tr><tr><td>  ptr</td><td> -</td><td>  pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected</td></tr><tr><td>  error</td><td> -</td><td>  the error about to be returned by the calling function, if it happens to be one of the functions that return errno_t</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/error/ignore_handler_s
set_constraint_handler_s, constraint_handler_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>constraint_handler_t set_constraint_handler_s( constraint_handler_t handler );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Configures the handler to be called by all <a href="http://en.cppreference.com/w/c/error#Bounds_checking" title="c/error">bounds-checked functions</a> on a runtime constraint violation or restores the default handler (if <code>handler</code> is a null pointer)</p><p>The handler must be a pointer to function of type <code>constraint_handler_t</code>, which is defined as</p><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>typedef void (*constraint_handler_t)( const char *restrict msg,<br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 void *restrict ptr,<br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 errno_t error);</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>On a runtime constraint violation, it is called with the following arguments:<br></p><div>1) pointer to character string that describes the error</div><div>2) pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected</div><div>3) the error about to be returned by the calling function, if it happens to be one of the functions that return <code>errno_t</code></div><p>If <code>set_constraint_handler_s</code> is never called, the default handler is implementation-defined: it may be abort_handler_s, ignore_handler_s, or some other implementation-defined handler.</p><dl><dd>As with all bounds-checked functions, <code>set_constraint_handler_s</code> and <code>constraint_handler_t</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdlib.h&gt;</code>.</dd></dl><span class="prog__sub"> Parameters</span><table><tr><td>  handler</td><td> -</td><td>  pointer to function of type <code>constraint_handler_t</code> or a null pointer</td></tr></table><span class="prog__sub"> Return value</span><p>A pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling <code>set_constraint_handler_s(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>)</code> sets up the system default handler)</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#define __STDC_WANT_LIB_EXT1__ 1#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){#ifdef __STDC_LIB_EXT1__    char dst[2];    set_constraint_handler_s(ignore_handler_s);    int r = strcpy_s(dst, sizeof dst, "Too long!");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("dst = "%s", r =\xc2\xa0%d\n", dst, r);    set_constraint_handler_s(abort_handler_s);    r = strcpy_s(dst, sizeof dst, "Too long!");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("dst = "%s", r =\xc2\xa0%d\n", dst, r);#endif}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>dst = "", r = 22<br>abort_handler_s was called in response to a runtime-constraint violation.<br>\xc2\xa0<br>The runtime-constraint violation was caused by the following expression in strcpy_s:<br>(s1max &lt;= (s2_len=strnlen_s(s2, s1max)) ) (in string_s.c:62)<br>\xc2\xa0<br>Note to end users: This program was terminated as a result<br>of a bug present in the software. Please reach out to your<br>software's vendor to get more help.<br>Aborted</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/error/set_constraint_handler_s
static_assert	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;assert.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define static_assert _Static_assert</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>This convenience macro expands to the keyword <a href="http://en.cppreference.com/w/c/keyword/_Static_assert" title="c/keyword/ Static assert">_Static_assert</a></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;assert.h&gt;int main(void){    static_assert(2 + 2 == 4, "2+2 isn't 4");      // well-formed    static_assert(sizeof(int) &lt; sizeof(char),                 "this program requires that int is less than char"); // compile-time error}</code></pre></div></div><p><br/></p></div></section>	http://en.cppreference.com/w/c/error/static_assert
Floating-point extensions part 4: supplementary functions	A										<section class="prog__container"><p>Floating-point extensions for C - Part 4: Supplementary functions, ISO/IEC TS 18661-4:2015, defines the following new components for the C standard library, as recommended by ISO/IEC/IEEE 60559:2011 (the current revision of IEEE-754)<br></p><table><tr><td> <div><div>__STDC_IEC_60559_FUNCS__</div></div></td><td>   integer constant of type <code>long</code> and value <code>201506L</code> <br/> (macro constant)</td></tr><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code> </div></td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/exp2m1&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/exp2m1 (page does not exist)"> exp2m1 exp2m1f exp2m1lexp2m1fN exp2m1fNxexp2m1dN exp2m1dNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute 2x<br/>-1 <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/exp10&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/exp10 (page does not exist)"> exp10 exp10f exp10lexp10fN exp10fNxexp10dN exp10dNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute 10x<br/> <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/exp10m1&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/exp10m1 (page does not exist)"> exp10m1 exp10m1f exp10m1lexp10m1fN exp10m1fNxexp10m1dN exp10m1dNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute 10x<br/>-1 <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/logp1&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/logp1 (page does not exist)"> logp1 logp1f logp1llogp1fN logp1fNxlogp1dN logp1dNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute ln(1+x) (same as <a href="http://en.cppreference.com/w/c/numeric/math/log1p" title="c/numeric/math/log1p">log1p</a>) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/log2p1&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/log2p1 (page does not exist)"> log2p1 log2p1f log2p1llog2p1fN log2p1fNxlog2p1dN log2p1dNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute log<br/>2(1+x) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/log10p1&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/log10p1 (page does not exist)"> log10p1 log10p1f log10p1llog10p1fN log10p1fNxlog10p1dN log10p1dNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute log<br/>10(1+x) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/rsqrt&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/rsqrt (page does not exist)"> rsqrt rsqrtf rsqrtlrsqrtfN rsqrtfNxrsqrtdN rsqrtdNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the inverse square root x-1/2<br/> <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/compoundn&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/compoundn (page does not exist)"> compoundn compoundnf compoundnlcompoundnfN compoundnfNxcompoundndN compoundndNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute compound interest, (1+x)n<br/> <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/rootn&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/rootn (page does not exist)"> rootn rootnf rootnlrootnfN rootnfNxrootndN rootndNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the nth root of x, x1/n<br/> <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/pown&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/pown (page does not exist)"> pown pownf pownlpownfN pownfNxpowndN powndNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute x raised to the nth power, where n is integer <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/powr&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/powr (page does not exist)"> powr powrf powrlpowrfN powrfNxpowrdN powrdNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute x raised to the y power, xy<br/> <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/acospi&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/acospi (page does not exist)"> acospi acospif acospilacospifN acospifNxacospidN acospidNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute arccos(x)/\xcf\x80 (measuring the angle in half-revolutions) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/asinpi&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/asinpi (page does not exist)"> asinpi asinpif asinpilasinpifN asinpifNxasinpidN asinpidNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute arcsin(x)/\xcf\x80 (measuring the angle in half-revolutions) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/atanpi&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/atanpi (page does not exist)"> atanpi atanpif atanpilatanpifN atanpifNxatanpidN atanpidNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute arctan(x)/\xcf\x80 (measuring the angle in half-revolutions) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/atan2pi&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/atan2pi (page does not exist)"> atan2pi atan2pif atan2pilatan2pifN atan2pifNxatan2pidN atan2pidNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute arctan(y/x)/\xcf\x80 (measuring the angle in half-revolutions) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/cospi&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/cospi (page does not exist)"> cospi cospif cospilcospifN cospifNxcospidN cospidNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute cos(\xcf\x80x) (measuring the angle in half-revolutions) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/sinpi&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/sinpi (page does not exist)"> sinpi sinpif sinpilsinpifN sinpifNxsinpidN sinpidNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute sin(\xcf\x80x) (measuring the angle in half-revolutions) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/tanpi&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/tanpi (page does not exist)"> tanpi tanpif tanpiltanpifN tanpifNxtanpidN tanpidNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute tan(\xcf\x80x) (measuring the angle in half-revolutions) <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/reduc_sum&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/reduc sum (page does not exist)"> reduc_sum reduc_sumf reduc_sumlreduc_sumfN reduc_sumfNxreduc_sumdN reduc_sumdNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the sum of n members of an array <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/reduc_sumabs&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/reduc sumabs (page does not exist)"> reduc_sumabs reduc_sumabsf reduc_sumabslreduc_sumabsfN reduc_sumabsfNxreduc_sumabsdN reduc_sumabsdNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the sum of the absolute values of n members of an array <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/reduc_sumsq&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/reduc sumsq (page does not exist)"> reduc_sumsq reduc_sumsqf reduc_sumsqlreduc_sumsqfN reduc_sumsqfNxreduc_sumsqdN reduc_sumsqdNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the sum of squares of n members of an array <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/reduc_sumprod&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/reduc sumprod (page does not exist)"> reduc_sumprod reduc_sumprodf reduc_sumprodlreduc_sumprodfN reduc_sumprodfNxreduc_sumproddN reduc_sumproddNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the dot product between n members of two arrays <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/scaled_prod&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/scaled prod (page does not exist)"> scaled_prod scaled_prodf scaled_prodlscaled_prodfN scaled_prodfNxscaled_proddN scaled_proddNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the product of n members of an array as a scaled value and a scale factor <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/scaled_prodsum&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/scaled prodsum (page does not exist)"> scaled_prodsum scaled_prodsumf scaled_prodsumlscaled_prodsumfN scaled_prodsumfNxscaled_prodsumdN scaled_prodsumdNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the dot product of n members of two arrays as a scaled value and a scale factor <br/> (function) </td></tr><tr><td> <div><div><a class="new" href="/mwiki/index.php?title=c/experimental/fpext4/scaled_proddiff&amp;action=edit&amp;redlink=1" title="c/experimental/fpext4/scaled proddiff (page does not exist)"> scaled_proddiff scaled_proddifff scaled_proddifflscaled_proddifffN scaled_proddifffNxscaled_proddiffdN scaled_proddiffdNx</a></div><div>(FP Ext 4 TS)</div></div></td><td>  compute the product of the differences between corresponding n members of two arrays as a scaled value and a scale factor <br/> (function) </td></tr><tr><td> <div><div>crexp(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/exp" title="c/numeric/math/exp">exp</a> <br/> (function)</td></tr><tr><td> <div><div>crexpm1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/expm1" title="c/numeric/math/expm1">expm1</a> <br/> (function)</td></tr><tr><td> <div><div>crexp2(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/exp2" title="c/numeric/math/exp2">exp2</a> <br/> (function)</td></tr><tr><td> <div><div>crexp2m1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of exp2m1 <br/> (function)</td></tr><tr><td> <div><div>crexp10(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of exp10 <br/> (function)</td></tr><tr><td> <div><div>crexp10m1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of exp10m1 <br/> (function)</td></tr><tr><td> <div><div>crlog(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/log" title="c/numeric/math/log">log</a> <br/> (function)</td></tr><tr><td> <div><div>crlog2(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of log2 <br/> (function)</td></tr><tr><td> <div><div>crlog10(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/log10" title="c/numeric/math/log10">log10</a> <br/> (function)</td></tr><tr><td> <div><div>crlog1p(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/log1p" title="c/numeric/math/log1p">log1p</a> <br/> (function)</td></tr><tr><td> <div><div>crlogp1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of logp1 <br/> (function)</td></tr><tr><td> <div><div>crlog2p1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of log2p1 <br/> (function)</td></tr><tr><td> <div><div>crlog10p1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of log10p1 <br/> (function)</td></tr><tr><td> <div><div>crrsqrt(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of rsqrt <br/> (function)</td></tr><tr><td> <div><div>crcompoundn(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of compoundn <br/> (function)</td></tr><tr><td> <div><div>crrootn(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of rootn <br/> (function)</td></tr><tr><td> <div><div>crpown(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of pown <br/> (function)</td></tr><tr><td> <div><div>crpow(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/pow" title="c/numeric/math/pow">pow</a> <br/> (function)</td></tr><tr><td> <div><div>crpowr(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of powr <br/> (function)</td></tr><tr><td> <div><div>crsin(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/sin" title="c/numeric/math/sin">sin</a> <br/> (function)</td></tr><tr><td> <div><div>crcos(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/cos" title="c/numeric/math/cos">cos</a> <br/> (function)</td></tr><tr><td> <div><div>crtan(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/tan" title="c/numeric/math/tan">tan</a> <br/> (function)</td></tr><tr><td> <div><div>crsinpi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of sinpi <br/> (function)</td></tr><tr><td> <div><div>crcospi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of cospi <br/> (function)</td></tr><tr><td> <div><div>crtanpi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of tanpi <br/> (function)</td></tr><tr><td> <div><div>crasinpi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of asinpi <br/> (function)</td></tr><tr><td> <div><div>cracospi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of acospi <br/> (function)</td></tr><tr><td> <div><div>cracospi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of acospi <br/> (function)</td></tr><tr><td> <div><div>cratanpi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of atanpi <br/> (function)</td></tr><tr><td> <div><div>cratan2pi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of atan2pi <br/> (function)</td></tr><tr><td> <div><div>crasin(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/asin" title="c/numeric/math/asin">asin</a> <br/> (function)</td></tr><tr><td> <div><div>cracos(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/acos" title="c/numeric/math/acos">acos</a> <br/> (function)</td></tr><tr><td> <div><div>cratan(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/atan" title="c/numeric/math/atan">atan</a> <br/> (function)</td></tr><tr><td> <div><div>cratan2(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/atan2" title="c/numeric/math/atan2">atan2</a> <br/> (function)</td></tr><tr><td> <div><div>crsinh(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/sinh" title="c/numeric/math/sinh">sinh</a> <br/> (function)</td></tr><tr><td> <div><div>crcosh(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/cosh" title="c/numeric/math/cosh">cosh</a> <br/> (function)</td></tr><tr><td> <div><div>crtanh(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/tanh" title="c/numeric/math/tanh">tanh</a> <br/> (function)</td></tr><tr><td> <div><div>crasinh(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/asinh" title="c/numeric/math/asinh">asinh</a> <br/> (function)</td></tr><tr><td> <div><div>cracosh(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/acosh" title="c/numeric/math/acosh">acosh</a> <br/> (function)</td></tr><tr><td> <div><div>cratanh(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/atanh" title="c/numeric/math/atanh">atanh</a> <br/> (function)</td></tr><tr><td> <div><div>crhypot(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   correctly-rounded version of <a href="http://en.cppreference.com/w/c/numeric/math/hypot" title="c/numeric/math/hypot">hypot</a> <br/> (function)</td></tr><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code> </div></td></tr><tr><td> <div><div>cexp2m1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of exp2m1 <br/> (function)</td></tr><tr><td> <div><div>cexp10(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of exp10 <br/> (function)</td></tr><tr><td> <div><div>cexp10m1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of exp10m1 <br/> (function)</td></tr><tr><td> <div><div>clogp1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of logp1 <br/> (function)</td></tr><tr><td> <div><div>clog2p1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of log2p1 <br/> (function)</td></tr><tr><td> <div><div>clog10p1(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of log10p1 <br/> (function)</td></tr><tr><td> <div><div>crsqrt (optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of rsqrt <br/> (function)</td></tr><tr><td> <div><div>ccompoundn (optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of compoundn <br/> (function)</td></tr><tr><td> <div><div>crootn(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of rootn <br/> (function)</td></tr><tr><td> <div><div>cpown (optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of pown <br/> (function)</td></tr><tr><td> <div><div>cpowr(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of powr <br/> (function)</td></tr><tr><td> <div><div>cacospi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of acospi <br/> (function)</td></tr><tr><td> <div><div>casinpi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of asinpi <br/> (function)</td></tr><tr><td> <div><div>catanpi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of atanpi <br/> (function)</td></tr><tr><td> <div><div>ccospi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of cospi <br/> (function)</td></tr><tr><td> <div><div>csinpi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of sinpi <br/> (function)</td></tr><tr><td> <div><div>ctanpi(optional)</div><div>(FP Ext 4 TS)</div></div></td><td>   complex number version of tanpi <br/> (function)</td></tr></table></section>	http://en.cppreference.com/w/c/experimental/fpext4
getline, getwline, getdelim, getwdelim	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>ssize_t getline(char **lineptr, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> *n, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream);</code></div></td><td> (1) </td><td> (dynamic memory TR) </td></tr><tr><td> <div><code>ssize_t getwline(wchar_t **lineptr, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> *n, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream);</code></div></td><td> (2) </td><td> (dynamic memory TR) </td></tr><tr><td> <div><code>ssize_t getdelim(char ** restrict lineptr, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> * restrict n,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0int delimiter, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream);</code></div></td><td> (3) </td><td> (dynamic memory TR) </td></tr><tr><td> <div><code>ssize_t getwdelim(wchar_t ** restrict lineptr, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> * restrict n,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0wint_t delimiter, <a href="http://en.cppreference.com/w/c/io">FILE</a> * stream);</code></div></td><td> (4) </td><td> (dynamic memory TR) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Behaves like <code>getdelim(lineptr, n, '\n', stream)</code></div><div>2) Behaves like <code>getwdelim(lineptr, n, L'\n', stream)</code></div><div>3) Reads from the stream <code>stream</code> as if by <a href="http://en.cppreference.com/w/c/io/fgetc" title="c/io/fgetc">fgetc</a>, until <code>delimiter</code> is encountered, storing the characters in the buffer of size <code>*n</code> pointed to by <code>*lineptr</code>, automatically increasing its size as if by <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc</a> to fit the entire input, including the delimiter, and adding a null terminator. <code>*lineptr</code> may be null, in which case <code>*n</code> is ignored and <code>getline</code> allocates a new buffer as if by <a href="http://en.cppreference.com/w/c/memory/malloc" title="c/memory/malloc">malloc</a>.The behavior is undefined if <code>delimiter</code> has a value that is outside the range of <code>unsigned char</code> or <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a>.</div><div>4) Same as (3), except the characters are read as if by <a href="http://en.cppreference.com/w/c/io/fgetwc" title="c/io/fgetwc">fgetwc</a> and that <code>delimiter</code> must be a valid <code>wchar_t</code> or WEOF.</div><p>If <code>*lineptr</code> is not null, the behavior is undefined if <code>*lineptr</code> is not a pointer that can be passed to <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> or if <code>*n</code> is less than the size of the allocated memory pointed to by <code>*lineptr</code></p><p>As all functions from Dynamic Memory TS, <code>getline</code> is only guaranteed to be available if <code>__STDC_ALLOC_LIB__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT2__</code> to the integer constant <code>1</code> before including <code>stdio.h</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lineptr</td><td> -</td><td>  pointer to a pointer to the initial buffer or to a null pointer</td></tr><tr><td>  n</td><td> -</td><td>  pointer to the size of the initial buffer</td></tr><tr><td>  delimiter</td><td> -</td><td>  the delimiter character</td></tr><tr><td>  stream</td><td> -</td><td>  valid input stream, opened by <a href="http://en.cppreference.com/w/c/io/fopen" title="c/io/fopen">fopen</a></td></tr></table><span class="prog__sub"> Return value</span><p>The number of characters stored in the buffer, including the delimiter, but excluding the null terminator.<br></p><p>On error, returns <code>-1</code> and sets <a href="http://en.cppreference.com/w/c/io/feof" title="c/io/feof">feof</a> or <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror</a> on <code>stream</code>.</p></section>	http://en.cppreference.com/w/c/experimental/dynamic/getline
strdup	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char * strdup(const char *str1);</code></div></td><td> </td><td> (dynamic memory TR) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns a pointer to a null-terminated byte string, which is a duplicateof the string pointed to by str1. The returned pointer must be passed to <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> to avoid a memory leak.</p><p>If an error occurs, a null pointer is returned and <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> may be set.</p><p>As all functions from Dynamic Memory TS, <code>strdup</code> is only guaranteed to be available if <code>__STDC_ALLOC_LIB__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT2__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str1</td><td> -</td><td>  pointer to the null-terminated byte string to duplicate</td></tr></table><span class="prog__sub"> Return value</span><p>A pointer to the newly allocated string, or a null pointer if an error occurred.<br></p></section>	http://en.cppreference.com/w/c/experimental/dynamic/strdup
strndup	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char *strndup(const char *str, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size);</code></div></td><td> </td><td> (dynamic memory TR) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns a pointer to a null-terminated byte string, which contains copies of at most  <code>size</code> bytes from the string pointed to by <code>str</code>. If the null terminator is not encountered in the first <code>size</code> bytes, it is added to the duplicated string.</p><p>The returned pointer must be passed to <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> to avoid a memory leak.</p><p>If an error occurs, a null pointer is returned and <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> may be set.</p><p>As all functions from Dynamic Memory TS, <code>strndup</code> is only guaranteed to be available if <code>__STDC_ALLOC_LIB__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT2__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to duplicate</td></tr><tr><td>  size</td><td> -</td><td>  max number of bytes to copy from <code>str</code></td></tr></table><span class="prog__sub"> Return value</span><p>A pointer to the newly allocated string, or a null pointer if an error occurred.<br></p></section>	http://en.cppreference.com/w/c/experimental/dynamic/strndup
clearerr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void clearerr( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Resets the error flags and the <code>EOF</code> indicator for the given file stream.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  the file to reset the error flags for</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io">FILE</a>* tmpf = <a href="http://en.cppreference.com/w/c/io/tmpfile">tmpfile</a>();    <a href="http://en.cppreference.com/w/c/io/fputs">fputs</a>("abcde\n", tmpf);    <a href="http://en.cppreference.com/w/c/io/rewind">rewind</a>(tmpf);    int ch;    while ((ch=<a href="http://en.cppreference.com/w/c/io/fgetc">fgetc</a>(tmpf)) != <a href="http://en.cppreference.com/w/c/io">EOF</a>)          <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%c", ch);    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(<a href="http://en.cppreference.com/w/c/io/feof">feof</a>(tmpf)); // the loop is expected to terminate by eof    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("End of file reached");\xc2\xa0    clearerr(tmpf);  // clear eof\xc2\xa0    if (<a href="http://en.cppreference.com/w/c/io/feof">feof</a>(tmpf))        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("EOF indicator set");    else        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("EOF indicator cleared\n");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>abcde<br>End of file reached<br>EOF indicator cleared</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/clearerr
fclose	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fclose( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.<br></p><p>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by <a href="http://en.cppreference.com/w/c/io/setbuf" title="c/io/setbuf">setbuf</a> or <a href="http://en.cppreference.com/w/c/io/setvbuf" title="c/io/setvbuf">setvbuf</a>, if any, is also disassociated and deallocated if automatic allocation was used.</p><p>The behavior is undefined if the value of the pointer <code>stream</code> is used after <code>fclose</code> returns.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  the file stream to close</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> on success, <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> otherwise</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io">FILE</a>* fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.txt", "r");    if(!fp) {        <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("File opening failed");        return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>;    }\xc2\xa0    int c; // note: int, not char, required to handle EOF    while ((c = <a href="http://en.cppreference.com/w/c/io/fgetc">fgetc</a>(fp)) != <a href="http://en.cppreference.com/w/c/io">EOF</a>) { // standard C I/O file reading loop       <a href="http://en.cppreference.com/w/c/io/putchar">putchar</a>(c);    }\xc2\xa0    if (<a href="http://en.cppreference.com/w/c/io/ferror">ferror</a>(fp))        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("I/O error when reading");    else if (<a href="http://en.cppreference.com/w/c/io/feof">feof</a>(fp))        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("End of file reached successfully");\xc2\xa0    fclose(fp);}</code></pre></div></div><p><br/></p></div></section>	http://en.cppreference.com/w/c/io/fclose
feof	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int feof( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the end of the given file stream has been reached.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  the file stream to check</td></tr></table><span class="prog__sub"> Return value</span><p>nonzero value if the end of the stream has been reached, otherwise <code>\xe2\x80\x8b0\xe2\x80\x8b</code></p></section>	http://en.cppreference.com/w/c/io/feof
ferror	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int ferror( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks the given stream for errors.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  the file stream to check</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero value if the file stream has errors occurred, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise </p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;locale.h&gt;#include &lt;wchar.h&gt;\xc2\xa0int main(void){    char* fname = <a href="http://en.cppreference.com/w/c/io/tmpnam">tmpnam</a>(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>);    <a href="http://en.cppreference.com/w/c/io">FILE</a>* f = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>(fname, "wb");    <a href="http://en.cppreference.com/w/c/io/fputs">fputs</a>("\xff\xff\n", f); // not a valid UTF-8 character sequence    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(f);\xc2\xa0    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    f = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>(fname, "rb");    wint_t ch;    while ((ch=<a href="http://en.cppreference.com/w/c/io/fgetwc">fgetwc</a>(f)) != WEOF) // attempt to read as UTF-8 fails          <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x ", ch);\xc2\xa0    if (<a href="http://en.cppreference.com/w/c/io/feof">feof</a>(f))        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("EOF indicator set");    if (ferror(f))        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("Error indicator set");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Error indicator set</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/ferror
fflush	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fflush( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the <code>stream</code>'s buffer to the associated output device.</p><p>For input streams (and for update streams on which the last operation was input), the behavior is undefined.<br></p><p>If <code>stream</code> is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  the file stream to write out</td></tr></table><span class="prog__sub"> Return value</span><p>Returns zero on success. Otherwise <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> is returned and the error indicator of the file stream is set.</p></section>	http://en.cppreference.com/w/c/io/fflush
fgetc, getc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>int fgetc( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>int getc( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads the next character from the given input stream. <code>getc()</code> may be implemented as a macro. </p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  to read the character from</td></tr></table><span class="prog__sub"> Return value</span><p>The obtained character on success or <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> on failure. </p><p>If the failure has been caused by end-of-file condition, additionally sets the <i>eof</i> indicator (see <a href="http://en.cppreference.com/w/c/io/feof" title="c/io/feof">feof()</a>) on <code>stream</code>. If the failure has been caused by some other error, sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror()</a>) on <code>stream</code>.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io">FILE</a>* fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.txt", "r");    if(!fp) {        <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("File opening failed");        return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>;    }\xc2\xa0    int c; // note: int, not char, required to handle EOF    while ((c = fgetc(fp)) != <a href="http://en.cppreference.com/w/c/io">EOF</a>) { // standard C I/O file reading loop       <a href="http://en.cppreference.com/w/c/io/putchar">putchar</a>(c);    }\xc2\xa0    if (<a href="http://en.cppreference.com/w/c/io/ferror">ferror</a>(fp))        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("I/O error when reading");    else if (<a href="http://en.cppreference.com/w/c/io/feof">feof</a>(fp))        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("End of file reached successfully");\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(fp);}</code></pre></div></div><p><br/></p></div></section>	http://en.cppreference.com/w/c/io/fgetc
fgetpos	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>int fgetpos( <a href="http://en.cppreference.com/w/c/io">FILE</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*stream, <a href="http://en.cppreference.com/w/c/io">fpos_t</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*pos );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int fgetpos( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, <a href="http://en.cppreference.com/w/c/io">fpos_t</a> *restrict pos );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Obtains the file position indicator and the current parse state (if any) for the file stream <code>stream</code> and stores them in the object pointed to by <code>pos</code>. The value stored is only meaningful as the input to <a href="http://en.cppreference.com/w/c/io/fsetpos" title="c/io/fsetpos">fsetpos</a>.</p><p><br/></p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  file stream to examine</td></tr><tr><td>  pos</td><td> -</td><td>  pointer to a <a href="http://en.cppreference.com/w/c/io" title="c/io">fpos_t</a> object to store the file position indicator to</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> upon success, nonzero value otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;\xc2\xa0int main(void){    // prepare a file holding 4 values of type double    enum {SIZE = 4};    <a href="http://en.cppreference.com/w/c/io">FILE</a>* fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.bin", "wb");    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(fp);    int rc = <a href="http://en.cppreference.com/w/c/io/fwrite">fwrite</a>((double[SIZE]){1.1, 2.2, 3.3, 4.4}, sizeof(double), SIZE, fp);    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(rc == SIZE);    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(fp);\xc2\xa0    // demo using fsetpos to return to the beginning of a file    fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.bin", "rb");    <a href="http://en.cppreference.com/w/c/io">fpos_t</a> pos;    fgetpos(fp, &amp;pos);               // store start of file in pos    double d;    rc = <a href="http://en.cppreference.com/w/c/io/fread">fread</a>(&amp;d, sizeof d, 1, fp); // read the first double    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(rc == 1);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("First value in the file:\xc2\xa0%.1f\n", d);    <a href="http://en.cppreference.com/w/c/io/fsetpos">fsetpos</a>(fp,&amp;pos);                 // move file position back to the start of the file    rc = <a href="http://en.cppreference.com/w/c/io/fread">fread</a>(&amp;d, sizeof d, 1, fp);  // read the first double again    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(rc == 1);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("First value in the file again:\xc2\xa0%.1f\n", d);    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(fp);\xc2\xa0    // demo error handling    rc = <a href="http://en.cppreference.com/w/c/io/fsetpos">fsetpos</a>(<a href="http://en.cppreference.com/w/c/io">stdin</a>, &amp;pos);    if(rc) <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("could not fsetpos stdin");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>First value in the file: 1.1<br>First value in the file again: 1.1<br>could not fsetpos stdin: Illegal seek</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/fgetpos
fgets	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>char *fgets( char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*str, int count, <a href="http://en.cppreference.com/w/c/io">FILE</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*stream );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>char *fgets( char *restrict str, int count, <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads at most <code>count - 1</code> characters from the given file stream and stores them in the character array pointed to by <code>str</code>. Parsing stops if end-of-file occurs or a newline character is found, in which case <code>str</code> will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to <code>str</code>.</p><p>The behavior is undefined if <code>count</code> is less than 1.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to an element of a char array</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of characters to write (typically the length of <code>str</code>)</td></tr><tr><td>  stream</td><td> -</td><td>  file stream to read the data from</td></tr></table><span class="prog__sub"> Return value</span><p><code>str</code> on success, null pointer on failure.</p><p>If the failure has been caused by end-of-file condition, additionally sets the <i>eof</i> indicator (see <a href="http://en.cppreference.com/w/c/io/feof" title="c/io/feof">feof()</a>) on <code>stream</code>. The contents of the array pointed to by <code>str</code> are not altered in this case.</p><p>If the failure has been caused by some other error, sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror()</a>) on <code>stream</code>. The contents of the array pointed to by <code>str</code> are indeterminate (it may not even be null-terminated).</p></section>	http://en.cppreference.com/w/c/io/fgets
fgetwc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>wint_t fgetwc( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td> <div><code>wint_t getwc( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (since C95) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads the next wide character from the given input stream. <code>getwc()</code> may be implemented as a macro and may evaluate <code>stream</code> more than once.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  to read the wide character from</td></tr></table><span class="prog__sub"> Return value</span><p>The next wide character from the stream or <code>WEOF</code> if an error has occurred or the end of file has been reached. If an encoding error occurred, <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> is set to <code>EILSEQ</code>.</p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/io/fgetwc
fgetws	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wchar_t *fgetws( wchar_t *str, int count, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads at most <code>count - 1</code> wide characters from the given file stream and stores them in <code>str</code>. The produced wide string is always null-terminated. Parsing stops if end-of-file occurs or a newline wide character is found, in which case <code>str</code> will contain that wide newline character.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  wide string to read the characters to</td></tr><tr><td>  count</td><td> -</td><td>  the length of <code>str</code></td></tr><tr><td>  stream</td><td> -</td><td>  file stream to read the data from</td></tr></table><span class="prog__sub"> Return value</span><p><code>str</code> on success, <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> on an error</p></section>	http://en.cppreference.com/w/c/io/fgetws
fopen, fopen_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/io">FILE</a> *fopen( const char *filename, const char *mode );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/io">FILE</a> *fopen( const char *restrict filename, const char *restrict mode );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t fopen_s(<a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict *restrict streamptr,<br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char *restrict filename,<br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char *restrict mode);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Opens a file indicated by <code>filename</code> and returns a pointer to the file stream associated with that file. <code>mode</code> is used to determine the file access mode. </div><div>2) Same as (1), except that the pointer to the file stream is written to <code>streamptr</code> and the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>streamptr</code> is a null pointer</li><li> <code>filename</code> is a null pointer</li><li> <code>mode</code> is a null pointer</li></ul></dd><dd>As all bounds-checked functions, <code>fopen_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  filename</td><td> -</td><td>  file name to associate the file stream to</td></tr><tr><td>  mode</td><td> -</td><td>  null-terminated character string determining file access mode<table><tr><th> File access <br/>mode string</th><th> Meaning</th><th> Explanation</th><th> Action if file <br/> already exists</th><th> Action if file <br/> does not exist</th></tr><tr><td> <code>"r"</code></td><td> read</td><td> Open a file for reading</td><td> read from start</td><td> failure to open</td></tr><tr><td> <code>"w"</code></td><td> write</td><td> Create a file for writing</td><td> destroy contents</td><td> create new</td></tr><tr><td> <code>"a"</code></td><td> append</td><td> Append to a file</td><td> write to end</td><td> create new</td></tr><tr><td> <code>"r+"</code></td><td> read extended</td><td> Open a file for read/write</td><td> read from start</td><td> error</td></tr><tr><td> <code>"w+"</code></td><td> write extended</td><td> Create a file for read/write</td><td> destroy contents</td><td> create new</td></tr><tr><td> <code>"a+"</code></td><td> append extended</td><td> Open a file for read/write</td><td> write to end</td><td> create new</td></tr><tr><td> File access mode flag <code>"b"</code> can optionally be specified to open a file in binary mode. This flag has effect only on Windows systems. <br/> On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.</td></tr><tr><td> When a file is opened with update mode ('+' as the second or third character in the above list of mode argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the <a href="http://en.cppreference.com/w/c/io/fflush" title="c/io/fflush">fflush</a> function or to a file positioning function (<a href="http://en.cppreference.com/w/c/io/fseek" title="c/io/fseek">fseek</a>, <a href="http://en.cppreference.com/w/c/io/fsetpos" title="c/io/fsetpos">fsetpos</a>, or <a href="http://en.cppreference.com/w/c/io/rewind" title="c/io/rewind">rewind</a>), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end- of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.</td></tr><tr><td> File access mode flag <code>"x"</code> can optionally be appended to "w" or "w+" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11)</td></tr><tr><td> When using <code>fopen_s</code> or <code>freopen_s</code>, file access permissions for any file created with "w" or "a" prevents other users from accessing it. File access mode flag <code>"u"</code> can optionally be prepended to any specifier that begins with "w" or "a", to enable the default <code>fopen</code> permissions. (C11)</td></tr></table></td></tr><tr><td>  streamptr</td><td> -</td><td>  pointer to a pointer where the function stores the result (an out-parameter)</td></tr></table><span class="prog__sub"> Return value</span><div>1) If successful, returns a pointer to the new file stream. The stream is fully buffered unless <code>filename</code> refers to an interactive device.  On error, returns a null pointer. <a class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html" rel="nofollow">POSIX requires</a> that <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> is set in this case.</div><div>2) If successful, returns zero and a pointer to the new file stream is written to <code>*streamptr</code>.  On error, returns a non-zero error code and writes the null pointer to <code>*streamptr</code> (unless <code>streamptr</code> is a null pointer itself).</div></section>	http://en.cppreference.com/w/c/io/fopen
printf, fprintf, sprintf, snprintf, printf_s, fprintf_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>\xe2\x80\x8bint printf( const char *format, ... );\xe2\x80\x8b</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>\xe2\x80\x8bint printf( const char *restrict format, ... );\xe2\x80\x8b</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(2)</td><td></td></tr><tr><td> <div><code>int fprintf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream, const char *format, ... );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int fprintf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, const char *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(3)</td><td></td></tr><tr><td> <div><code>int sprintf( char *buffer, const char *format, ... );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int sprintf( char *restrict buffer, const char *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>int snprintf( char *restrict buffer, int bufsz, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char *restrict format, ... );</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td> <div><code>int printf_s(const char *restrict format, ...);</code></div></td><td> (5) </td><td> (since C11) </td></tr><tr><td> <div><code>int fprintf_s(<a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, const char *restrict format, ...);</code></div></td><td> (6) </td><td> (since C11) </td></tr><tr><td> <div><code>int sprintf_s(char *restrict buffer, rsize_t bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char *restrict format, ...);</code></div></td><td> (7) </td><td> (since C11) </td></tr><tr><td> <div><code>int snprintf_s(char *restrict buffer, rsize_t bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const char *restrict format, ...);</code></div></td><td> (8) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.<br></p><div>1) Writes the results to the output stream <a href="http://en.cppreference.com/w/c/io" title="c/io">stdout</a>.</div><div>2) Writes the results to the output stream <code>stream</code>.</div><div>3) Writes the results to a character string <code>buffer</code>. The behavior is undefined if the string to be written (plus the terminating null character) exceeds the size of the array pointed to by <code>buffer</code>.</div><div>4) Writes the results to a character string <code>buffer</code>. At most <code>bufsz</code> - 1 characters are written. The resulting character string will be terminated with a null character, unless <code>bufsz</code> is zero. If <code>bufsz</code> is zero, nothing is written and <code>buffer</code> may be a null pointer, however the return value (number of bytes that would be written) is still calculated and returned.</div><div>5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> the conversion specifier <code>%n</code> is present in <code>format</code></li><li> any of the arguments corresponding to <code>%s</code> is a null pointer</li><li> <code>format</code> or <code>buffer</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than RSIZE_MAX</li><li> encoding errors occur in any of string and character conversion specifiers</li><li> (for <code>sprintf_s</code> only), the string to be stored in <code>buffer</code> (including the trailing null) would be exceed <code>bufsz</code></li></ul></dd><dd>As all bounds-checked functions, <code>printf_s</code>, <code>fprintf_s</code>, <code>sprintf_s</code>, and <code>snrintf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  output file stream to write to</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a character string to write to</td></tr><tr><td>  bufsz</td><td> -</td><td>  up to bufsz - 1 characters may be written, plus the null terminator</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated multibyte string specifying how to interpret the data.<p>The format string consists of ordinary multibyte characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) one or more flags that modify the behavior of the conversion:</li></ul><dl><dd><ul><li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified)</li><li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative)</li><li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present.</li><li> <code>#</code>\xc2\xa0: <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.</li><li> <code>0</code>\xc2\xa0: for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present.</li></ul></dd></dl></dd></dl><dl><dd><ul><li> (optional) integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.)</li></ul></dd></dl><dl><dd><ul><li> (optional) <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the argument</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table><tr><th rowspan="1"> Conversion<br/> specifier</th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p>(C99)</p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p>(C99)</p></th><th> <code>j</code><p>(C99)</p></th><th> <code>z</code><p>(C99)</p></th><th> <code>t</code><p>(C99)</p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td><dl><dd> writes a <b>single character</b>.</dd></dl><p>The argument is first converted to <code>unsigned char</code>.If the <b>l</b> modifier is used, the argument is first converted to a character string as if by <b>%ls</b> with a <code>wchar_t[2]</code> argument.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>int</code></div></div></td><td> <div><div><code>wint_t</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td><dl><dd> writes a <b>character string</b></dd></dl><p>The argument must be a pointer to the initial element of an array of characters. <i>Precision</i> specifies the maximum number of bytes to be written. If <i>Precision</i> is not specified, writes every byte up to and not including the first null terminator.If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>, which is converted to char array as if by a call to <a href="http://en.cppreference.com/w/c/string/multibyte/wcrtomb" title="c/string/multibyte/wcrtomb">wcrtomb</a> with zero-initialized conversion state.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>char*</code></div></div></td><td> <div><div><code>wchar_t*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>d</code><br/> <code>i</code></th><td><dl><dd>converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br/> If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.</p></td><td> <div><div><code>signed char</code></div></div></td><td> <div><div><code>short</code></div></div></td><td> <div><div><code>int</code></div></div></td><td> <div><div><code>long</code></div></div></td><td> <div><div><code>long long</code></div></div></td><td> <div><div><code>intmax_t</code></div></div></td><td> <div><div>signed <code>size_t</code></div></div></td><td> <div><div><code>ptrdiff_t</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>o</code></th><td><dl><dd>converts a <b>unsigned integer</b> into octal representation <i>oooo</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero.In that case if both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, single <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is written.</p></td><td> <div><div><code>unsigned char</code></div></div></td><td> <div><div><code>unsigned short</code></div></div></td><td> <div><div><code>unsigned int</code></div></div></td><td> <div><div><code>unsigned long</code></div></div></td><td> <div><div><code>unsigned long long</code></div></div></td><td> <div><div><code>uintmax_t</code></div></div></td><td> <div><div><code>size_t</code></div></div></td><td> <div><div>unsigned version of <code>ptrdiff_t</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>x</code><br/> <code>X</code></th><td><dl><dd>converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.</dd></dl><p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br/>For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br/><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.</p></td><td> <small>N/A</small></td></tr><tr><th> <code>u</code></th><td><dl><dd>converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.</p></td><td> <small>N/A</small></td></tr><tr><th> <code>f</code><br/> <code>F</code></th><td><dl><dd>converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear after the decimal point character. The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>double</code></div></div></td><td> <div><div><code>double</code> (C99)</div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>long double</code></div></div></td></tr><tr><th> <code>e</code> <br/> <code>E</code></th><td><dl><dd>converts <b>floating-point number</b> to the decimal exponent notation.</dd></dl><p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>\xc2\xb1dd</i> is used.<br/>For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>\xc2\xb1dd</i> is used.<br/>The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the exponent is also <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>a</code> <br/> <code>A</code><p>(C99)</p></th><td><dl><dd>converts <b>floating-point number</b> to the hexadecimal exponent notation.</dd></dl><p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>\xc2\xb1d</i> is used.<br/>For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>\xc2\xb1d</i> is used.<br/>The first hexadecimal digit is <code>0</code> if the argument is not a normalized floating point value.If the value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the exponent is also <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is sufficient for exact representation of the value.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>g</code> <br/> <code>G</code></th><td><dl><dd>converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.</dd></dl><p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br/>For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br/>Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:</p><ul><li> if <i>P &gt; X \xe2\x89\xa5 \xe2\x88\x924</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P \xe2\x88\x92 1 \xe2\x88\x92 X</i>.</li><li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P \xe2\x88\x92 1</i>.</li></ul><p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>n</code></th><td><dl><dd>returns the <b>number of characters written</b> so far by this call to the function.</dd></dl><p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>.</p></td><td> <div><div><code>signed char*</code></div></div></td><td> <div><div><code>short*</code></div></div></td><td> <div><div><code>int*</code></div></div></td><td> <div><div><code>long*</code></div></div></td><td> <div><div><code>long long*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a>*</code></div></div></td><td> <div><div>signed <code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/ptrdiff_t">ptrdiff_t</a>*</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>p</code></th><td> writes an implementation defined character sequence defining a <b>pointer</b>.</td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <code>void*</code></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr></table><p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p><p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p><p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p><p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p><p>The correct conversion specifications for the fixed-width character types (<a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">int8_t</a>, etc) are defined in the header <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;inttypes.h&gt;</a> (although <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">PRIdMAX</a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">PRIuMAX</a>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable and printing the value stored by <code>%n</code> earlier within the same call.</p><p>If a conversion specification is invalid, the behavior is undefined.<br></p><p><br/></p></td></tr><tr><td>  ...</td><td> -</td><td>  arguments specifying data to print</td></tr></table><span class="prog__sub"> Return value</span><div>1,2) number of characters transmitted to the output stream or negative value if an output error  or an encoding error (for string and character conversion specifiers) occurred</div><div>3) number of characters written to <code>buffer</code> (not counting the terminating null character), or a negative value if an encoding error (for string and character conversion specifiers) occurred</div><div>4) number of characters (not including the terminating null character) which would have been written to <code>buffer</code> if <code>bufsz</code> was ignored, or a negative value if an encoding error (for string and character conversion specifiers) occurred</div><div>5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.</div><div>7) number of characters written to <code>buffer</code>, not counting the null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX</code>), or zero on runtime constraint violations, and negative value on encoding errors</div><div>8) number of characters not including the terminating null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX</code>), which would have been written to <code>buffer</code> if <code>bufsz</code> was ignored, or a negative value if a runtime constraints violation or an encoding error occurred</div></section>	http://en.cppreference.com/w/c/io/fprintf
fputc, putc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>int fputc( int ch, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>int putc( int ch, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes a character <code>ch</code> to the given output stream <code>stream</code>. <code>putc()</code> may be implemented as a macro and evaluate <code>stream</code> more than once, so the corresponding argument should never be an expression with side effects. </p><p>Internally, the character is converted to <code>unsigned char</code> just before being written.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to be written</td></tr><tr><td>  stream</td><td> -</td><td>  output stream</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns the written character.<br></p><p>On failure, returns <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> and sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror()</a>) on <code>stream</code>.</p><span class="prog__sub"> Example</span><div><p> putc with error checking<br></p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    int ret_code = 0;    for (char c = 'a'; (ret_code != <a href="http://en.cppreference.com/w/c/io">EOF</a>) &amp;&amp; (c != 'z'); c++)        ret_code = putc(c, <a href="http://en.cppreference.com/w/c/io">stdout</a>);\xc2\xa0    /* Test whether EOF was reached. */    if (ret_code == <a href="http://en.cppreference.com/w/c/io">EOF</a>)       if (<a href="http://en.cppreference.com/w/c/io/ferror">ferror</a>(<a href="http://en.cppreference.com/w/c/io">stdout</a>))        {          <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("putc()");          <a href="http://en.cppreference.com/w/c/io/fprintf">fprintf</a>(<a href="http://en.cppreference.com/w/c/io">stderr</a>,"putc() failed in file\xc2\xa0%s at line #\xc2\xa0%d\n", __FILE__,__LINE__-7);          <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(<a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>);       }    putc('\n', <a href="http://en.cppreference.com/w/c/io">stdout</a>);\xc2\xa0    return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_SUCCESS</a>;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>abcdefghijklmnopqrstuvwxy</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/fputc
fputs	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>int fputs( const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*str, <a href="http://en.cppreference.com/w/c/io">FILE</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*stream );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int fputs( const char *restrict str, <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes every character from the null-terminated string <code>str</code> to the output stream <code>stream</code>, as if by repeatedly executing <a href="http://en.cppreference.com/w/c/io/fputc" title="c/io/fputc">fputc</a>.</p><p>The terminating null character from <code>str</code> is not written.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  null-terminated character string to be written</td></tr><tr><td>  stream</td><td> -</td><td>  output stream</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns a non-negative value<br></p><p>On failure, returns <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> and sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror()</a>) on <code>stream</code>.</p></section>	http://en.cppreference.com/w/c/io/fputs
fputwc, putwc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>wint_t fputwc( wchar_t ch, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td> <div><code>wint_t putwc( wchar_t ch, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (since C95) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes a wide character <code>ch</code> to the given output stream <code>stream</code>. <code>putwc()</code> may be implemented as a macro and may evaluate <code>stream</code> more than once.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character to be written</td></tr><tr><td>  stream</td><td> -</td><td>  the output stream</td></tr></table><span class="prog__sub"> Return value</span><p><code>ch</code> on success, <code>WEOF</code> on failure. If an encoding error occurs, <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> is set to <code>EILSEQ</code>.</p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/io/fputwc
fputws	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>int fputws( const wchar_t *str, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (until C99) <br/>(since C95) </td></tr><tr><td> <div><code>int fputws( const wchar_t * restrict str, <a href="http://en.cppreference.com/w/c/io">FILE</a> * restrict stream );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes every character from the null-terminated wide string <code>str</code> to the output stream <code>stream</code>, as if by repeatedly executing <a href="http://en.cppreference.com/w/c/io/fputwc" title="c/io/fputwc">fputwc</a>.</p><p>The terminating null wide character from <code>str</code> is not written.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  null-terminated wide string to be written</td></tr><tr><td>  stream</td><td> -</td><td>  output stream</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns a non-negative value<br></p><p>On failure, returns <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> and sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror</a>) on <code>stream</code>.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;locale.h&gt;#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    int rc = fputws(L"\xe5\xbe\xa1\xe4\xbc\x91\xe3\x81\xbf\xe3\x81\xaa\xe3\x81\x95\xe3\x81\x84", <a href="http://en.cppreference.com/w/c/io">stdout</a>);\xc2\xa0    if (rc == <a href="http://en.cppreference.com/w/c/io">EOF</a>)       <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("fputws()"); // POSIX requires that errno is set}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>\xe5\xbe\xa1\xe4\xbc\x91\xe3\x81\xbf\xe3\x81\xaa\xe3\x81\x95\xe3\x81\x84</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/fputws
fread	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> fread( void \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*buffer, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 <a href="http://en.cppreference.com/w/c/io">FILE</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*stream );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> fread( void *restrict buffer, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads up to <code>count</code> objects into the array <code>buffer</code> from the given input stream <code>stream</code> as if by calling <a href="http://en.cppreference.com/w/c/io/fgetc" title="c/io/fgetc">fgetc</a> <code>size</code> times for each object, and storing the results, in the order obtained, into the successive positions of <code>buffer</code>, which is reinterpreted as an array of <code>unsigned char</code>. The file position indicator for the stream is advanced by the number of characters read.</p><p>If an error occurs, the resulting value of the file position indicator for the stream is<br>indeterminate. If a partial element is read, its value is indeterminate.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  buffer</td><td> -</td><td>  pointer to the array where the read objects are stored</td></tr><tr><td>  size</td><td> -</td><td>  size of each object in bytes</td></tr><tr><td>  count</td><td> -</td><td>  the number of the objects to be read</td></tr><tr><td>  stream</td><td> -</td><td>  the stream to read</td></tr></table><span class="prog__sub"> Return value</span><p>Number of objects read successfully, which may be less than <code>count</code> if an error or end-of-file condition occurs. </p><p>If <code>size</code> or <code>count</code> is zero, <code>fread</code> returns zero and performs no other action.</p><p><code>fread</code> does not distinguish between end-of-file and error, and callers must use <a href="http://en.cppreference.com/w/c/io/feof" title="c/io/feof">feof</a> and <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror</a> to determine which occurred.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0enum { SIZE = 5 };int main(void){    double a[SIZE] = {1.,2.,3.,4.,5.};    <a href="http://en.cppreference.com/w/c/io">FILE</a> *fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.bin", "wb"); // must use binary mode    <a href="http://en.cppreference.com/w/c/io/fwrite">fwrite</a>(a, sizeof *a, SIZE, fp); // writes an array of doubles    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(fp);\xc2\xa0    double b[SIZE];    fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.bin","rb");    <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> ret_code = fread(b, sizeof *b, SIZE, fp); // reads an array of doubles    if(ret_code == SIZE) {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("Array read successfully, contents: ");        for(int n = 0; n &lt; SIZE; ++n) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f ", b[n]);        <a href="http://en.cppreference.com/w/c/io/putchar">putchar</a>('\n');    } else { // error handling       if (<a href="http://en.cppreference.com/w/c/io/feof">feof</a>(fp))          <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Error reading test.bin: unexpected end of file\n");       else if (<a href="http://en.cppreference.com/w/c/io/ferror">ferror</a>(fp)) {           <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("Error reading test.bin");       }    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(fp);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>1.000000 2.000000 3.000000 4.000000 5.000000</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/fread
freopen, freopen_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/io">FILE</a> *freopen( const char *filename, const char *mode,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/io">FILE</a> *freopen( const char *restrict filename, const char *restrict mode, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t freopen_s(<a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict *restrict newstreamptr,<br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char *restrict filename, const char *restrict mode,<br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) First, attempts to close the file associated with <code>stream</code>, ignoring any errors. Then, if <code>filename</code> is not null, attempts to open the file specified by <code>filename</code> using <code>mode</code> as if by <a href="http://en.cppreference.com/w/c/io/fopen" title="c/io/fopen">fopen</a>, and associates that file with the file stream pointed to by <code>stream</code>. If <code>filename</code> is a null pointer, then the function attempts to reopen the file that is already associated with <code>stream</code> (it is implementation defined which mode changes are allowed in this case).</div><div>2) Same as (1), except that <code>mode</code> is treated as in fopen_s and that the pointer to the file stream is written to <code>newstreamptr</code> and the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>newstreamptr</code> is a null pointer</li><li> <code>stream</code> is a null pointer</li><li> <code>mode</code> is a null pointer</li></ul></dd><dd>As all bounds-checked functions, <code>freopen_s</code> is only guaranteed to be available of <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><p><br/></p><span class="prog__sub"> Parameters</span><table><tr><td>  filename</td><td> -</td><td>  file name to associate the file stream to</td></tr><tr><td>  mode</td><td> -</td><td>  null-terminated character string determining new file access mode<table><tr><th> File access <br/>mode string</th><th> Meaning</th><th> Explanation</th><th> Action if file <br/> already exists</th><th> Action if file <br/> does not exist</th></tr><tr><td> <code>"r"</code></td><td> read</td><td> Open a file for reading</td><td> read from start</td><td> failure to open</td></tr><tr><td> <code>"w"</code></td><td> write</td><td> Create a file for writing</td><td> destroy contents</td><td> create new</td></tr><tr><td> <code>"a"</code></td><td> append</td><td> Append to a file</td><td> write to end</td><td> create new</td></tr><tr><td> <code>"r+"</code></td><td> read extended</td><td> Open a file for read/write</td><td> read from start</td><td> error</td></tr><tr><td> <code>"w+"</code></td><td> write extended</td><td> Create a file for read/write</td><td> destroy contents</td><td> create new</td></tr><tr><td> <code>"a+"</code></td><td> append extended</td><td> Open a file for read/write</td><td> write to end</td><td> create new</td></tr><tr><td> File access mode flag <code>"b"</code> can optionally be specified to open a file in binary mode. This flag has effect only on Windows systems. <br/> On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.</td></tr><tr><td> When a file is opened with update mode ('+' as the second or third character in the above list of mode argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the <a href="http://en.cppreference.com/w/c/io/fflush" title="c/io/fflush">fflush</a> function or to a file positioning function (<a href="http://en.cppreference.com/w/c/io/fseek" title="c/io/fseek">fseek</a>, <a href="http://en.cppreference.com/w/c/io/fsetpos" title="c/io/fsetpos">fsetpos</a>, or <a href="http://en.cppreference.com/w/c/io/rewind" title="c/io/rewind">rewind</a>), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end- of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.</td></tr><tr><td> File access mode flag <code>"x"</code> can optionally be appended to "w" or "w+" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11)</td></tr><tr><td> When using <code>fopen_s</code> or <code>freopen_s</code>, file access permissions for any file created with "w" or "a" prevents other users from accessing it. File access mode flag <code>"u"</code> can optionally be prepended to any specifier that begins with "w" or "a", to enable the default <code>fopen</code> permissions. (C11)</td></tr></table></td></tr><tr><td>  stream</td><td> -</td><td>  the file stream to modify</td></tr><tr><td>  newstreamptr</td><td> -</td><td>  pointer to a pointer where the function stores the result (an out-parameter)</td></tr></table><span class="prog__sub"> Return value</span><div>1) A copy of the value of <code>stream</code> on success, null pointer on failure.</div><div>2) zero on success (and a copy of the value of <code>stream</code> is written to <code>*newstreamptr</code>, non-zero on error (and null pointer is written to <code>*newstreamptr</code> unless <code>newstreamptr</code> is itself a null pointer).</div></section>	http://en.cppreference.com/w/c/io/freopen
scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>\xe2\x80\x8bint scanf( const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*format, ... );\xe2\x80\x8b</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>\xe2\x80\x8bint scanf( const char *restrict format, ... );\xe2\x80\x8b</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(2)</td><td></td></tr><tr><td> <div><code>int fscanf( <a href="http://en.cppreference.com/w/c/io">FILE</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*stream, const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*format, ... );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int fscanf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, const char *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(3)</td><td></td></tr><tr><td> <div><code>int sscanf( const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*buffer, const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*format, ... );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int sscanf( const char *restrict buffer, const char *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>int scanf_s(const char *restrict format, ...);</code></div></td><td> (4) </td><td> (since C11) </td></tr><tr><td> <div><code>int fscanf_s(<a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, const char *restrict format, ...);</code></div></td><td> (5) </td><td> (since C11) </td></tr><tr><td> <div><code>int sscanf_s(const char *restrict buffer, const char *restrict format, ...);</code></div></td><td> (6) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads data from the a variety of sources, interprets it according to <code>format</code> and stores the results into given locations.</p><div>1) reads the data from <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a></div><div>2) reads the data from file stream <code>stream</code></div><div>3) reads the data from null-terminated character string <code>buffer</code>. Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fscanf</code></div><div>4-6) Same as (1-3), except that <code>%c</code>, <code>%s</code>, and <code>%[</code> conversion specifiers each expect two arguments (the usual pointer and a value of type rsize_t indicating the size of the receiving array, which may be 1 when reading with a\xc2\xa0%c into a single char) and except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> any of the arguments of pointer type is a null pointer</li><li> <code>format</code>, <code>stream</code>, or <code>buffer</code> is a null pointer</li><li> the number of characters that would be written by\xc2\xa0%c,\xc2\xa0%s, or\xc2\xa0%[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers</li><li> optionally, any other detectable error, such as unknown conversion specifier</li></ul></dd><dd>As all bounds-checked functions, <code>scanf_s</code>, <code>fscanf_s</code>, and <code>sscanf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  input file stream to read from</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a null-terminated character string to read from</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated character string specifying how to read the input.<p>The format string consists of <br></p><ul><li> non-whitespace multibyte characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li><li> whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling <a href="http://en.cppreference.com/w/c/string/byte/isspace" title="c/string/byte/isspace"><tt>isspace</tt></a> in a loop). Note that there is no difference between <code>"\n"</code>, <code>" "</code>, <code>"\t\t"</code>, or other whitespace in the format string.</li><li> conversion specifications. Each conversion specification has the following format:</li></ul><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) assignment-suppressing character <code>*</code>. If this option is present, the function does not assign the result of the conversion to any receiving argument.</li></ul></dd></dl><dl><dd><ul><li> (optional) integer number (greater than zero) that specifies <i>maximum field width</i>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that\xc2\xa0%s and\xc2\xa0%[ may lead to buffer overflow if the width is not provided.</li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table><tr><th rowspan="1"> Conversion<br/> specifier</th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p>(C99)</p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p>(C99)</p></th><th> <code>j</code><p>(C99)</p></th><th> <code>z</code><p>(C99)</p></th><th> <code>t</code><p>(C99)</p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td> matches literal <code>%</code></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td><dl><dd> matches a <b>character</b> or a sequence of <b>characters</b></dd></dl><p>If a width specifier is used, matches exactly <i>width</i>  characters (the argument must be a pointer to an array with sufficient room). Unlike\xc2\xa0%s and\xc2\xa0%[, does not append the null character to the array.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>char*</code></div></div></td><td> <div><div><code>wchar_t*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td><dl><dd> matches a sequence of non-whitespace characters (a <b>string</b>)</dd></dl><p>If width specifier is used, matches up to <i>width</i> or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>[</code>set<code>]</code></th><td><dl><dd>matches a non-empty sequence of character from set of characters.</dd></dl><p>If the first character of the set is <code>^</code>, then all characters not in the set are matched. If the set begins with <code>]</code> or <code>^]</code> then the <code>]</code> character is also included into the set. It is implementation-defined whether the character <code>-</code> in the non-initial position in the scanset may be indicating a range, as in <code>[0-9]</code>. If width specifier is used, matches only up to <i>width</i>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>d</code></th><td><dl><dd>matches a <b>decimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtol" title="c/string/byte/strtol"><tt>strtol()</tt></a> with the value <code>10</code> for the <code>base</code> argument</p></td><td> <div><div><code>signed char*</code> or <code>unsigned char*</code></div></div></td><td> <div><div><code>signed short*</code> or <code>unsigned short*</code></div></div></td><td> <div><div><code>signed int*</code> or <code>unsigned int*</code></div></div></td><td> <div><div><code>signed long*</code> or <code>unsigned long*</code></div></div></td><td> <div><div><code>signed long long*</code> or <code>unsigned long long*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a>*</code> or <code><a href="http://en.cppreference.com/w/c/types/integer">uintmax_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/ptrdiff_t">ptrdiff_t</a>*</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>i</code></th><td><dl><dd>matches an <b>integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtol" title="c/string/byte/strtol"><tt>strtol()</tt></a> with the value <code>\xe2\x80\x8b0\xe2\x80\x8b</code> for the <code>base</code> argument (base is determined by the first characters parsed)</p></td></tr><tr><th> <code>u</code></th><td><dl><dd>matches an unsigned <b>decimal integer</b>. </dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtoul" title="c/string/byte/strtoul"><tt>strtoul()</tt></a> with the value <code>10</code> for the <code>base</code> argument.</p></td></tr><tr><th> <code>o</code></th><td><dl><dd>matches an unsigned <b>octal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtoul" title="c/string/byte/strtoul"><tt>strtoul()</tt></a> with the value <code>8</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>x</code>, <code>X</code></th><td><dl><dd>matches an unsigned <b>hexadecimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtoul" title="c/string/byte/strtoul"><tt>strtoul()</tt></a> with the value <code>16</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>n</code></th><td><dl><dd>returns the <b>number of characters read so far</b>.</dd></dl><p>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined<br></p></td></tr><tr><th> <code>a</code>, <code>A</code>(C99)<br/> <code>e</code>, <code>E</code><br/> <code>f</code>, <code>F</code><br/> <code>g</code>, <code>G</code></th><td><dl><dd>matches a <b>floating-point number</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtof" title="c/string/byte/strtof"><tt>strtof()</tt></a></p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>float*</code></div></div></td><td> <div><div><code>double*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>long double*</code></div></div></td></tr><tr><th> <code>p</code></th><td><dl><dd>matches implementation defined character sequence defining a <b>pointer</b>.</dd></dl><p><code>printf</code> family of functions should produce the same sequence using <code>%p</code> format specifier</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>void**</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr></table><p>For every conversion specifier other than <code>n</code>, the longest sequence of input characters which does not exceed any speci\xef\xac\x81ed \xef\xac\x81eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \xef\xac\x81rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\xef\xac\x81le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p><p>All conversion specifiers other than <code>[</code>, <code>c</code>, and <code>n</code> consume and discard all leading whitespace characters (determined as if by calling <a href="http://en.cppreference.com/w/c/string/byte/isspace" title="c/string/byte/isspace"><tt>isspace</tt></a>) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</p><p>The conversion specifiers <code>lc</code>, <code>ls</code>, and <code>l[</code> perform multibyte-to-wide character conversion as if by calling <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtowc" title="c/string/multibyte/mbrtowc"><tt>mbrtowc()</tt></a> with an <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t" title="c/string/multibyte/mbstate t"><tt>mbstate_t</tt></a> object initialized to zero before the first character is converted.</p><p>The conversion specifiers <code>s</code> and <code>[</code> always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width.</p><p>The correct conversion specifications for the <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">fixed-width integer types</a> (<code>int8_t</code>, etc) are defined in the header <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;inttypes.h&gt;</a> (although <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer"><tt>SCNdMAX</tt></a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer"><tt>SCNuMAX</tt></a>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple fields in the same "sink" variable.</p><p>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing <code>"100er"</code> with the conversion specifier <code>%f</code>, the sequence <code>"100e"</code> (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with <code>"r"</code> remaining. Existing implementations do not follow this rule and roll back to consume only <code>"100"</code>, leaving <code>"er"</code>, e.g. <a class="external text" href="https://sourceware.org/bugzilla/show_bug.cgi?id=1765" rel="nofollow">glibc bug 1765</a></p><p><br/></p></td></tr><tr><td>  ...</td><td> -</td><td>  receiving arguments</td></tr></table><span class="prog__sub"> Return value</span><div>1-3) Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> if input failure occurs before the first receiving argument was assigned.</div><div>4-6) Same as (1-3), except that <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> is also returned if there is a runtime constraint violation.</div></section>	http://en.cppreference.com/w/c/io/fscanf
fseek	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fseek( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream, long offset, int origin );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Sets the file position indicator for the file stream <code>stream</code> to the value pointed to by <code>offset</code>.</p><p>If the <code>stream</code> is open in binary mode, the new position is exactly <code>offset</code> bytes measured from the beginning of the file if <code>origin</code> is <a href="http://en.cppreference.com/w/c/io" title="c/io">SEEK_SET</a>, from the current file position if <code>origin</code> is <a href="http://en.cppreference.com/w/c/io" title="c/io">SEEK_CUR</a>, and from the end of the file if <code>origin</code> is <a href="http://en.cppreference.com/w/c/io" title="c/io">SEEK_END</a>. Binary streams are not required to support <a href="http://en.cppreference.com/w/c/io" title="c/io">SEEK_END</a>, in particular if additional null bytes are output.</p><p>If the <code>stream</code> is open in text mode, the only supported values for <code>offset</code> are zero (which works with any <code>origin</code>) and a value returned by an earlier call to <a href="http://en.cppreference.com/w/c/io/ftell" title="c/io/ftell">ftell</a> on a stream associated with the same file (which only works with <code>origin</code> of <a href="http://en.cppreference.com/w/c/io" title="c/io">SEEK_SET</a>).</p><p>If the <code>stream</code> is wide-oriented, the restrictions of both text and binary streams apply (result of <a href="http://en.cppreference.com/w/c/io/ftell" title="c/io/ftell">ftell</a> is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</p><p>In addition to changing the file position indicator, <code>fseek</code> undoes the effects of <a href="http://en.cppreference.com/w/c/io/ungetc" title="c/io/ungetc">ungetc</a> and clears the end-of-file status, if applicable.</p><p>If a read or write error occurs, the error indicator for the stream (<a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror</a>) is set and the file position is unaffected.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  file stream to modify</td></tr><tr><td>  offset</td><td> -</td><td>  number of characters to shift the position relative to origin</td></tr><tr><td>  origin</td><td> -</td><td>  position to which <code>offset</code> is added. It can have one of the following values: <a href="http://en.cppreference.com/w/c/io" title="c/io">SEEK_SET</a>, <a href="http://en.cppreference.com/w/c/io" title="c/io">SEEK_CUR</a>, <a href="http://en.cppreference.com/w/c/io" title="c/io">SEEK_END</a></td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> upon success, nonzero value otherwise.</p></section>	http://en.cppreference.com/w/c/io/fseek
fsetpos	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fsetpos( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream, const <a href="http://en.cppreference.com/w/c/io">fpos_t</a> *pos );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Sets the file position indicator and the multibyte parsing state (if any) for the file stream <code>stream</code> according to the value pointed to by <code>pos</code>. </p><p>Besides establishing new parse state and position, a call to this function undoes the effects of <a href="http://en.cppreference.com/w/c/io/ungetc" title="c/io/ungetc">ungetc</a> and clears the end-of-file state, if it is set.</p><p>If a read or write error occurs, the error indicator (<a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror</a>) for the stream is set.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  file stream to modify</td></tr><tr><td>  pos</td><td> -</td><td>  pointer to a <a href="http://en.cppreference.com/w/c/io" title="c/io">fpos_t</a> object to use as new value of file position indicator</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> upon success, nonzero value otherwise.</p></section>	http://en.cppreference.com/w/c/io/fsetpos
ftell	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>long ftell( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the file position indicator for the file stream <code>stream</code>. </p><p>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.<br></p><p>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to <a href="http://en.cppreference.com/w/c/io/fseek" title="c/io/fseek">fseek()</a>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  file stream to examine</td></tr></table><span class="prog__sub"> Return value</span><p>File position indicator on success or <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> if failure occurs.</p><p>On error, the <code>errno</code> variable is set to implementation-defined positive value.</p><span class="prog__sub"> Example</span><div><p> ftell with error checking<br> </p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    /* Prepare an array of f-p values. */    #define SIZE 5    double A[SIZE] = {1.,2.,3.,4.,5.};    /* Write array to a file. */    <a href="http://en.cppreference.com/w/c/io">FILE</a> * fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.bin", "wb");    <a href="http://en.cppreference.com/w/c/io/fwrite">fwrite</a>(A,sizeof(double),SIZE,fp);    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a> (fp);\xc2\xa0    /* Read the f-p values into array B. */    double B[SIZE];    fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.bin","rb");    long int pos = ftell(fp);   /* position indicator at start of file */    if (pos == -1L)    {       <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("ftell()");       <a href="http://en.cppreference.com/w/c/io/fprintf">fprintf</a>(<a href="http://en.cppreference.com/w/c/io">stderr</a>,"ftell() failed in file\xc2\xa0%s at line #\xc2\xa0%d\n", __FILE__,__LINE__-4);       <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(<a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>);    }    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", pos);\xc2\xa0    int ret_code = <a href="http://en.cppreference.com/w/c/io/fread">fread</a>(B,sizeof(double),1,fp);   /* read one f-p value */    pos = ftell(fp);   /* position indicator after reading one f-p value */    if (pos == -1L)    {       <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("ftell()");       <a href="http://en.cppreference.com/w/c/io/fprintf">fprintf</a>(<a href="http://en.cppreference.com/w/c/io">stderr</a>,"ftell() failed in file\xc2\xa0%s at line #\xc2\xa0%d\n", __FILE__,__LINE__-4);       <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(<a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>);    }    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", pos);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%.1f\n", B[0]);   /* print one f-p value */\xc2\xa0    return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_SUCCESS</a>; }</code></pre></div></div><p>Output:<br></p><div><div><pre><code>0<br>8<br>1.0</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/ftell
fwide	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fwide( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream, int mode );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>If <code>mode &gt; 0</code>, attempts to make <code>stream</code> wide-oriented. If <code>mode &lt; 0</code>, attempts to make <code>stream</code> byte-oriented. If <code>mode==0</code>, only queries the current orientation of the stream.</p><p>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  pointer to the C I/O stream to modify or query</td></tr><tr><td>  mode</td><td> -</td><td>  integer value greater than zero to set the stream wide, less than zero to set the stream narrow, or zero to query only</td></tr></table><span class="prog__sub"> Return value</span><p>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.<br></p><span class="prog__sub"> Example</span><div><p> The following code sets and resets the stream orientation.<br> </p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;wchar.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void try_read(<a href="http://en.cppreference.com/w/c/io">FILE</a>* fp){    int c = <a href="http://en.cppreference.com/w/c/io/fgetc">fgetc</a>(fp);    if(c == <a href="http://en.cppreference.com/w/c/io">EOF</a>) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("narrow character read failed");    else <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("narrow character read '%c'\n", c);\xc2\xa0    wint_t wc = <a href="http://en.cppreference.com/w/c/io/fgetwc">fgetwc</a>(fp);    if(wc == WEOF) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("wide character read failed");    else <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("wide character read '%lc'\n", wc);}void show(int n){    if(n == 0) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("no orientation");    else if (n &lt; 0) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("narrow orientation");    else <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("wide orientation");}int main(void){    <a href="http://en.cppreference.com/w/c/io">FILE</a>* fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("main.cpp","r");    if (!fp) {        <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("fopen() failed");        return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>;    }\xc2\xa0    // A newly opened stream has no orientation.    show(fwide(fp, 0));\xc2\xa0    // Establish byte orientation.    show(fwide(fp, -1));    try_read(fp);\xc2\xa0    // Only freopen() can reset stream orientation.    if (<a href="http://en.cppreference.com/w/c/io/freopen">freopen</a>("main.cpp","r",fp) == <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>)    {       <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("freopen() failed");       return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>;    }\xc2\xa0    // A reopened stream has no orientation.    show(fwide(fp, 0));\xc2\xa0    // Establish wide orientation.    show(fwide(fp, 1));    try_read(fp);\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(fp);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>no orientation<br>narrow orientation<br>narrow character read '#'<br>wide character read failed<br>no orientation<br>wide orientation<br>narrow character read failed<br>wide character read '#'</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/fwide
wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>int wprintf( const wchar_t *format, ... );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int wprintf( const wchar_t *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(2)</td><td></td></tr><tr><td> <div><code>int fwprintf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream, const wchar_t* format, ... );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int fwprintf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(3)</td><td></td></tr><tr><td> <div><code>int swprintf( wchar_t *buffer, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t* format, ... );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int swprintf( wchar_t *restrict buffer, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>int wprintf_s( const wchar_t *restrict format, ...);</code></div></td><td> (4) </td><td> (since C11) </td></tr><tr><td> <div><code>int fwprintf_s( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict format, ...);</code></div></td><td> (5) </td><td> (since C11) </td></tr><tr><td> <div><code>int swprintf_s( wchar_t *restrict buffer, rsize_t bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t* restrict format, ...);</code></div></td><td> (6) </td><td> (since C11) </td></tr><tr><td> <div><code>int snwprintf_s( wchar_t * restrict s, rsize_t n,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t * restrict format, ...);</code></div></td><td> (7) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.<br></p><div>1) Writes the results to <a href="http://en.cppreference.com/w/c/io" title="c/io">stdout</a>.</div><div>2) Writes the results to a file stream <code>stream</code>.</div><div>3) If <code>bufsz</code> is greater than zero, writes the results to a wide string <code>buffer</code>. At most <code>bufsz-1</code> wide characters are written followed by null wide character. If <code>bufsz</code> is zero, nothing is written (and <code>buffer</code> may be a null pointer), however the return value (number of wide characters that would be written) is still calculated and returned.</div><div>4-6) Same as (1-3), except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> the conversion specifier <code>%n</code> is present in <code>format</code></li><li> any of the arguments corresponding to <code>%s</code> is a null pointer</li><li> <code>format</code> or <code>buffer</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> encoding errors occur in any of string and character conversion specifiers</li><li> (only for <code>swprintf_s</code>) the number of wide characters to be written, including the null, would exceed <code>bufsz</code>.</li></ul></dd></dl></div><div>7) Same as (6), except it will truncate the result to fit within the array pointed to by s.<dl><dd>As all bounds-checked functions, <code>wprintf_s</code>, <code>wfprintf_s</code>, and <code>wsprintf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  output file stream to write to</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a wide character string to write to</td></tr><tr><td>  bufsz</td><td> -</td><td>  up to <code>bufsz-1</code> wide characters may be written, plus the null terminator</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated wide string specifying how to interpret the data.<p>The format string consists of ordinary wide characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) one or more flags that modify the behavior of the conversion:</li></ul><dl><dd><ul><li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified)</li><li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative)</li><li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present.</li><li> <code>#</code>\xc2\xa0: <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.</li><li> <code>0</code>\xc2\xa0: for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present.</li></ul></dd></dl></dd></dl><dl><dd><ul><li> (optional) integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.)</li></ul></dd></dl><dl><dd><ul><li> (optional) <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the argument</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table><tr><th rowspan="1"> Conversion<br/> specifier</th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p>(C99)</p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p>(C99)</p></th><th> <code>j</code><p>(C99)</p></th><th> <code>z</code><p>(C99)</p></th><th> <code>t</code><p>(C99)</p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td><dl><dd> writes a <b>single character</b>.</dd></dl><p>The argument is first converted to <code>wchar_t</code> as if by calling <a href="http://en.cppreference.com/w/c/string/multibyte/btowc" title="c/string/multibyte/btowc">btowc</a>.If the <b>l</b> modifier is used, the <code>wint_t</code> argument is first converted to <code>wchar_t</code>.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>int</code></div></div></td><td> <div><div><code>wint_t</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td><dl><dd> writes a <b>character string</b></dd></dl><p>The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtowc" title="c/string/multibyte/mbrtowc">mbrtowc</a> with zero-initialized conversion state.<i>Precision</i> specifies the maximum number of wide characters to be written. If <i>Precision</i> is not specified, writes every wide characters up to and not including the first null terminator.If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>char*</code></div></div></td><td> <div><div><code>wchar_t*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>d</code><br/> <code>i</code></th><td><dl><dd>converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br/> If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.</p></td><td> <div><div><code>signed char</code></div></div></td><td> <div><div><code>short</code></div></div></td><td> <div><div><code>int</code></div></div></td><td> <div><div><code>long</code></div></div></td><td> <div><div><code>long long</code></div></div></td><td> <div><div><code>intmax_t</code></div></div></td><td> <div><div>signed <code>size_t</code></div></div></td><td> <div><div><code>ptrdiff_t</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>o</code></th><td><dl><dd>converts a <b>unsigned integer</b> into octal representation <i>oooo</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero.In that case if both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, single <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is written.</p></td><td> <div><div><code>unsigned char</code></div></div></td><td> <div><div><code>unsigned short</code></div></div></td><td> <div><div><code>unsigned int</code></div></div></td><td> <div><div><code>unsigned long</code></div></div></td><td> <div><div><code>unsigned long long</code></div></div></td><td> <div><div><code>uintmax_t</code></div></div></td><td> <div><div><code>size_t</code></div></div></td><td> <div><div>unsigned version of <code>ptrdiff_t</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>x</code><br/> <code>X</code></th><td><dl><dd>converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.</dd></dl><p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br/>For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br/><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.</p></td><td> <small>N/A</small></td></tr><tr><th> <code>u</code></th><td><dl><dd>converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.</p></td><td> <small>N/A</small></td></tr><tr><th> <code>f</code><br/> <code>F</code></th><td><dl><dd>converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear after the decimal point character. The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>double</code></div></div></td><td> <div><div><code>double</code> (C99)</div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>long double</code></div></div></td></tr><tr><th> <code>e</code> <br/> <code>E</code></th><td><dl><dd>converts <b>floating-point number</b> to the decimal exponent notation.</dd></dl><p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>\xc2\xb1dd</i> is used.<br/>For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>\xc2\xb1dd</i> is used.<br/>The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the exponent is also <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>a</code> <br/> <code>A</code><p>(C99)</p></th><td><dl><dd>converts <b>floating-point number</b> to the hexadecimal exponent notation.</dd></dl><p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>\xc2\xb1d</i> is used.<br/>For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>\xc2\xb1d</i> is used.<br/>The first hexadecimal digit is <code>0</code> if the argument is not a normalized floating point value.If the value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the exponent is also <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is sufficient for exact representation of the value.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>g</code> <br/> <code>G</code></th><td><dl><dd>converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.</dd></dl><p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br/>For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br/>Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:</p><ul><li> if <i>P &gt; X \xe2\x89\xa5 \xe2\x88\x924</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P \xe2\x88\x92 1 \xe2\x88\x92 X</i>.</li><li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P \xe2\x88\x92 1</i>.</li></ul><p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>n</code></th><td><dl><dd>returns the <b>number of characters written</b> so far by this call to the function.</dd></dl><p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>.</p></td><td> <div><div><code>signed char*</code></div></div></td><td> <div><div><code>short*</code></div></div></td><td> <div><div><code>int*</code></div></div></td><td> <div><div><code>long*</code></div></div></td><td> <div><div><code>long long*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a>*</code></div></div></td><td> <div><div>signed <code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/ptrdiff_t">ptrdiff_t</a>*</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>p</code></th><td> writes an implementation defined character sequence defining a <b>pointer</b>.</td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <code>void*</code></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr></table><p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p><p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p><p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p><p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p><p>The correct conversion specifications for the fixed-width character types (<a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">int8_t</a>, etc) are defined in the header <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;inttypes.h&gt;</a> (although <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">PRIdMAX</a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">PRIuMAX</a>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable and printing the value stored by <code>%n</code> earlier within the same call.</p><p>If a conversion specification is invalid, the behavior is undefined.<br></p><p><br/></p></td></tr><tr><td>  ...</td><td> -</td><td>  arguments specifying data to print</td></tr></table><span class="prog__sub"> Return value</span><div>1,2) Number of wide characters written if successful or negative value if an error occurred.</div><div>3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than <code>size</code> (including when <code>size</code> is zero).</div><div>4,5) Number of wide characters written if successful or negative value if an error occurred.</div><div>6) Number of wide characters (not counting the terminating null) that were written to <code>buffer</code>. Returns a negative value on encoding errors and on overflow. Returns zero on all other errors.</div><div>7) Number of wide characters (not counting the terminating null) that would have been written to <code>buffer</code> had <code>bufsz</code> been sufficiently large, or a negative value if an error occurs. (meaning, write was successful and complete only if the return is nonnegative and less than <code>bufsz</code>)</div></section>	http://en.cppreference.com/w/c/io/fwprintf
fwrite	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> fwrite( const void *buffer, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> fwrite( const void *restrict buffer, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes <code>count</code> of objects from the given array <code>buffer</code> to the output stream <code>stream</code>. The objects are written as if by reinterepreting each object as an array of <code>unsigned char</code> and calling <a href="http://en.cppreference.com/w/c/io/fputc" title="c/io/fputc">fputc</a> <code>size</code> times for each object to write those <code>unsigned char</code>s into <code>stream</code>, in order. The file position indicator for the stream is advanced by the number of characters written.</p><span class="prog__sub"> Parameters</span><table><tr><td>  buffer</td><td> -</td><td>  pointer to the first object in the array to be written</td></tr><tr><td>  size</td><td> -</td><td>  size of each object</td></tr><tr><td>  count</td><td> -</td><td>  the number of the objects to be written</td></tr><tr><td>  stream</td><td> -</td><td>  pointer to the output stream</td></tr></table><span class="prog__sub"> Return value</span><p>The number of objects written successfully, which may be less than <code>count</code> if an error occurs.</p><p>If <code>size</code> or <code>count</code> is zero, <code>fwrite</code> returns zero and performs no other action.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;enum { SIZE = 5 };int main(void){    double a[SIZE] = {1, 2, 3, 4, 5};    <a href="http://en.cppreference.com/w/c/io">FILE</a> *f1 = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("file.bin", "wb");    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(f1);    int r1 = fwrite(a, sizeof a[0], SIZE, f1);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("wrote\xc2\xa0%d elements out of\xc2\xa0%d requested\n", r1,  SIZE);    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(f1);\xc2\xa0    double b[SIZE];    <a href="http://en.cppreference.com/w/c/io">FILE</a> *f2 = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("file.bin", "rb");    int r2 = <a href="http://en.cppreference.com/w/c/io/fread">fread</a>(b, sizeof b[0], SIZE, f2);    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(f2);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("read back: ");    for(int i = 0; i &lt; r2; i++)        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f ", b[i]);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>wrote 5 elements out of 5 requested<br>read back: 1.000000 2.000000 3.000000 4.000000 5.000000</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/fwrite
wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>int wscanf( const wchar_t *format, ... );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int wscanf( const wchar_t *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(2)</td><td></td></tr><tr><td> <div><code>int fwscanf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream, const wchar_t *format, ... );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int fwscanf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(3)</td><td></td></tr><tr><td> <div><code>int swscanf( const wchar_t *buffer, const wchar_t *format, ... );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int swscanf( const wchar_t *restrict buffer,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict format, ... );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>int wscanf_s( const wchar_t *restrict format, ...);</code></div></td><td> (4) </td><td> (since C11) </td></tr><tr><td> <div><code>int fwscanf_s( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict format, ...);</code></div></td><td> (5) </td><td> (since C11) </td></tr><tr><td> <div><code>int swscanf_s( const wchar_t *restrict s,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict format, ...);</code></div></td><td> (6) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads data from the a variety of sources, interprets it according to <code>format</code> and stores the results into given locations.</p><div>1) Reads the data from <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a>.</div><div>2) Reads the data from file stream <code>stream</code>.</div><div>3) Reads the data from null-terminated wide string <code>buffer</code>. Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fwscanf</code></div><div>4-6) Same as (1-3), except that <code>%c</code>, <code>%s</code>, and <code>%[</code> conversion specifiers each expect two arguments (the usual pointer and a value of type rsize_t indicating the size of the receiving array, which may be 1 when reading with a\xc2\xa0%lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> any of the arguments of pointer type is a null pointer</li><li> <code>format</code>, <code>stream</code>, or <code>buffer</code> is a null pointer</li><li> the number of characters that would be written by\xc2\xa0%c,\xc2\xa0%s, or\xc2\xa0%[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers</li><li> optionally, any other detectable error, such as unknown conversion specifier</li></ul></dd><dd>As all bounds-checked functions, <code>wscanf_s</code>, <code>fwscanf_s</code>, and <code>swscanf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;wchar.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  input file stream to read from</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a null-terminated wide string to read from</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated wide string specifying how to read the input. The format string consists of<ul><li> non-whitespace wide characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li><li> whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling <a href="http://en.cppreference.com/w/c/string/wide/iswspace" title="c/string/wide/iswspace"><tt>iswspace</tt></a> in a loop). Note that there is no difference between <code>"\n"</code>, <code>" "</code>, <code>"\t\t"</code>, or other whitespace in the format string.</li><li> conversion specifications. Each conversion specification has the following format:</li></ul><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) assignment-suppressing character <code>*</code>. If this option is present, the function does not assign the result of the conversion to any receiving argument.</li></ul></dd></dl><dl><dd><ul><li> (optional) integer number (greater than zero) that specifies <i>maximum field width</i>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that\xc2\xa0%s and\xc2\xa0%[ may lead to buffer overflow if the width is not provided.</li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table><tr><th rowspan="1"> Conversion<br/> specifier</th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p>(C99)</p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p>(C99)</p></th><th> <code>j</code><p>(C99)</p></th><th> <code>z</code><p>(C99)</p></th><th> <code>t</code><p>(C99)</p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td> matches literal <code>%</code></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td><dl><dd> matches a <b>character</b> or a sequence of <b>characters</b></dd></dl><p>If a width specifier is used, matches exactly <i>width</i> wide characters (the argument must be a pointer to an array with sufficient room). Unlike\xc2\xa0%s and\xc2\xa0%[, does not append the null character to the array.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>char*</code></div></div></td><td> <div><div><code>wchar_t*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td><dl><dd> matches a sequence of non-whitespace characters (a <b>string</b>)</dd></dl><p>If width specifier is used, matches up to <i>width</i> or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>[</code>set<code>]</code></th><td><dl><dd>matches a non-empty sequence of character from set of characters.</dd></dl><p>If the first character of the set is <code>^</code>, then all characters not in the set are matched. If the set begins with <code>]</code> or <code>^]</code> then the <code>]</code> character is also included into the set. It is implementation-defined whether the character <code>-</code> in the non-initial position in the scanset may be indicating a range, as in <code>[0-9]</code>. If width specifier is used, matches only up to <i>width</i>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>d</code></th><td><dl><dd>matches a <b>decimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstol" title="c/string/wide/wcstol"><tt>wcstol()</tt></a> with the value <code>10</code> for the <code>base</code> argument</p></td><td> <div><div><code>signed char*</code> or <code>unsigned char*</code></div></div></td><td> <div><div><code>signed short*</code> or <code>unsigned short*</code></div></div></td><td> <div><div><code>signed int*</code> or <code>unsigned int*</code></div></div></td><td> <div><div><code>signed long*</code> or <code>unsigned long*</code></div></div></td><td> <div><div><code>signed long long*</code> or <code>unsigned long long*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a>*</code> or <code><a href="http://en.cppreference.com/w/c/types/integer">uintmax_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/ptrdiff_t">ptrdiff_t</a>*</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>i</code></th><td><dl><dd>matches an <b>integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstol" title="c/string/wide/wcstol"><tt>wcstol()</tt></a> with the value <code>\xe2\x80\x8b0\xe2\x80\x8b</code> for the <code>base</code> argument (base is determined by the first characters parsed)</p></td></tr><tr><th> <code>u</code></th><td><dl><dd>matches an unsigned <b>decimal integer</b>. </dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstoul" title="c/string/wide/wcstoul"><tt>wcstoul()</tt></a> with the value <code>10</code> for the <code>base</code> argument.</p></td></tr><tr><th> <code>o</code></th><td><dl><dd>matches an unsigned <b>octal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstoul" title="c/string/wide/wcstoul"><tt>wcstoul()</tt></a> with the value <code>8</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>x</code>, <code>X</code></th><td><dl><dd>matches an unsigned <b>hexadecimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstoul" title="c/string/wide/wcstoul"><tt>wcstoul()</tt></a> with the value <code>16</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>n</code></th><td><dl><dd>returns the <b>number of characters read so far</b>.</dd></dl><p>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined<br></p></td></tr><tr><th> <code>a</code>, <code>A</code>(C99)<br/> <code>e</code>, <code>E</code><br/> <code>f</code>, <code>F</code><br/> <code>g</code>, <code>G</code></th><td><dl><dd>matches a <b>floating-point number</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstof" title="c/string/wide/wcstof"><tt>wcstof()</tt></a></p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>float*</code></div></div></td><td> <div><div><code>double*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>long double*</code></div></div></td></tr><tr><th> <code>p</code></th><td><dl><dd>matches implementation defined character sequence defining a <b>pointer</b>.</dd></dl><p><code>printf</code> family of functions should produce the same sequence using <code>%p</code> format specifier</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>void**</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr></table><p>For every conversion specifier other than <code>n</code>, the longest sequence of input characters which does not exceed any speci\xef\xac\x81ed \xef\xac\x81eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \xef\xac\x81rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\xef\xac\x81le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p><p>All conversion specifiers other than <code>[</code>, <code>c</code>, and <code>n</code> consume and discard all leading whitespace characters (determined as if by calling <a href="http://en.cppreference.com/w/c/string/wide/iswspace" title="c/string/wide/iswspace"><tt>iswspace</tt></a>) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</p><p>If the length specifier <code>l</code> is not used, the conversion specifiers <code>c</code>, <code>s</code>, and <code>[</code> perform wide-to-multibyte character conversion as if by calling <a href="http://en.cppreference.com/w/c/string/multibyte/wcrtomb" title="c/string/multibyte/wcrtomb"><tt>wcrtomb()</tt></a> with an <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t" title="c/string/multibyte/mbstate t"><tt>mbstate_t</tt></a> object initialized to zero before the first character is converted.</p><p>The conversion specifiers <code>s</code> and <code>[</code> always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width.</p><p>The correct conversion specifications for the <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">fixed-width integer types</a> (<code>int8_t</code>, etc) are defined in the header <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;inttypes.h&gt;</a> (although <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer"><tt>SCNdMAX</tt></a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer"><tt>SCNuMAX</tt></a>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple fields in the same "sink" variable.</p><p>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing <code>"100er"</code> with the conversion specifier <code>%f</code>, the sequence <code>"100e"</code> (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with <code>"r"</code> remaining. Existing implementations do not follow this rule and roll back to consume only <code>"100"</code>, leaving <code>"er"</code>, e.g. <a class="external text" href="https://sourceware.org/bugzilla/show_bug.cgi?id=1765" rel="nofollow">glibc bug 1765</a></p><p><br/></p></td></tr><tr><td>  ...</td><td> -</td><td>  receiving arguments</td></tr></table><span class="prog__sub"> Return value</span><div>1-3) Number of receiving arguments successfully assigned, or <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> if read failure occurs before the first receiving argument was assigned.</div><div>4-6) Same as (1-3), except that <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> is also returned if there is a runtime constraint violation.</div><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/io/fwscanf
getchar	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int getchar(void);</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads the next character from <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a>.</p><p>Equivalent to <code><a href="http://en.cppreference.com/w/c/io/fgetc">getc</a>(<a href="http://en.cppreference.com/w/c/io">stdin</a>)</code>.</p><span class="prog__sub"> Parameters</span><p>(none)<br></p><span class="prog__sub"> Return value</span><p>The obtained character on success or <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> on failure. </p><p>If the failure has been caused by end-of-file condition, additionally sets the <i>eof</i> indicator (see <a href="http://en.cppreference.com/w/c/io/feof" title="c/io/feof">feof()</a>) on <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a>. If the failure has been caused by some other error, sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror()</a>) on <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a>.</p><span class="prog__sub"> Example</span><div><p> getchar with error checking<br> </p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){     int ch;    while ((ch=getchar()) != <a href="http://en.cppreference.com/w/c/io">EOF</a>)   /* read/print "abcde" from stdin */          <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%c", ch);\xc2\xa0    /* Test reason for reaching EOF. */    if (<a href="http://en.cppreference.com/w/c/io/feof">feof</a>(<a href="http://en.cppreference.com/w/c/io">stdin</a>))          /* if failure caused by end-of-file condition */       <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("End of file reached");    else if (<a href="http://en.cppreference.com/w/c/io/ferror">ferror</a>(<a href="http://en.cppreference.com/w/c/io">stdin</a>))   /* if failure caused by some other error      */         {            <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("getchar()");            <a href="http://en.cppreference.com/w/c/io/fprintf">fprintf</a>(<a href="http://en.cppreference.com/w/c/io">stderr</a>,"getchar() failed in file\xc2\xa0%s at line #\xc2\xa0%d\n", __FILE__,__LINE__-9);            <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(<a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>);         }\xc2\xa0    return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_SUCCESS</a>;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>abcde<br>End of file reached</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/getchar
gets, gets_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>char *gets( char *str );</code></div></td><td> </td><td> (until C11) </td></tr><tr><td> <div><code>char *gets_s( char *str, rsize_t n );</code></div></td><td> </td><td> (since C11) <br/>(optional) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Reads <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a> into the character array pointed to by <code>str</code> until a newline character is found or end-of-file occurs. A null character is written immediately after the last character read into the array. The newline character is discarded but not stored in the buffer.</div><div>2) Reads characters from <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a> until a newline is found or end-of-file occurs. Writes only at most <code>n-1</code> characters into the array pointed to by <code>str</code>, and always writes the terminating null character (unless str is a null pointer). The newline character, if found, is discarded and does not count toward the number of characters written to the buffer.<dl><dd>The following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<ul><li> <code>n</code> is zero</li><li> <code>n</code> is greater than <code>RSIZE_MAX</code></li><li> <code>str</code> is a null pointer</li><li> endline or eof not encountered after storing <code>n-1</code> characters to the buffer.</li></ul></dd><dd>In any case, <code>gets_s</code> first finishes reading and discarding the characters from <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a> until new-line character, end-of-file condition, or read error before calling the constraint handler.</dd><dd>As all bounds-checked functions, <code>gets_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  character string to be written</td></tr></table><span class="prog__sub"> Return value</span><p><code>str</code> on success, <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> on failure.</p><p>If the failure has been caused by end of file condition, additionally sets the <i>eof</i> indicator (see <a href="http://en.cppreference.com/w/c/io/feof" title="c/io/feof">feof()</a>) on <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a>. If the failure has been caused by some other error, sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror()</a>) on <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a>.</p></section>	http://en.cppreference.com/w/c/io/gets
getwchar	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wint_t getwchar(void);</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads the next wide character from <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a>.</p><span class="prog__sub"> Parameters</span><p>(none)<br></p><span class="prog__sub"> Return value</span><p>the obtained wide character or <code>WEOF</code> if an error has occurred or the end of file reached</p></section>	http://en.cppreference.com/w/c/io/getwchar
perror	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void perror( const char *s );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Prints to <a href="http://en.cppreference.com/w/c/io" title="c/io">stderr</a> the contents of the null-terminated character string pointed to by <code>s</code> (unless <code>s</code> is a null pointer), followed by the two characters <code>": "</code>, followed by the implementation-defined error message describing the error code currently stored in the system variable <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> (identical to the output of <code><a href="http://en.cppreference.com/w/c/string/byte/strerror">strerror</a>(errno)</code>), followed by <code>'\n'</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  s</td><td> -</td><td>  pointer to a null-terminated string with explanatory message</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io">FILE</a>* f = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("non_existent", "r");    if (f == <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>) {        perror("open()");    } else {        <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(f);    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>open(): No such file or directory</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/perror
putchar	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int putchar( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes a character <code>ch</code> to <code>stdout</code>. Internally, the character is converted to <code>unsigned char</code> just before being written.</p><p>Equivalent to <code><a href="http://en.cppreference.com/w/c/io/fputc">putc</a>(ch, <a href="http://en.cppreference.com/w/c/io">stdout</a>)</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to be written</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns the written character.<br></p><p>On failure, returns <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> and sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror()</a>) on <a href="http://en.cppreference.com/w/c/io" title="c/io">stdout</a>.</p><span class="prog__sub"> Example</span><div><p> putchar with error checking<br></p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    int ret_code = 0;    for (char c = 'a'; (ret_code != <a href="http://en.cppreference.com/w/c/io">EOF</a>) &amp;&amp; (c != 'z'); c++)        ret_code = putchar(c);\xc2\xa0    /* Test whether EOF was reached. */    if (ret_code == <a href="http://en.cppreference.com/w/c/io">EOF</a>)       if (<a href="http://en.cppreference.com/w/c/io/ferror">ferror</a>(<a href="http://en.cppreference.com/w/c/io">stdout</a>))        {          <a href="http://en.cppreference.com/w/c/io/fprintf">fprintf</a>(<a href="http://en.cppreference.com/w/c/io">stderr</a>,"putchar() failed in file\xc2\xa0%s at line #\xc2\xa0%d\n", __FILE__,__LINE__-6);          <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("putchar()");          <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(<a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>);       }    putchar('\n');\xc2\xa0    // putchar return value is not equal to the argument    int r = 0x1070;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n0x%x\n", r);    r = putchar(r);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n0x%x\n", r);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>abcdefghijklmnopqrstuvwxy<br>\xc2\xa0<br>0x1070<br>p<br>0x70</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/putchar
puts	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int puts( const char *str );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes every character from the null-terminated string <code>str</code> and one additional newline character <code>'\n'</code> to the output stream <code>stdout</code>, as if by repeatedly executing <a href="http://en.cppreference.com/w/c/io/fputc" title="c/io/fputc">fputc</a>.</p><p>The terminating null character from <code>str</code> is not written.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  character string to be written</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns a non-negative value<br></p><p>On failure, returns <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> and sets the <i>error</i> indicator (see <a href="http://en.cppreference.com/w/c/io/ferror" title="c/io/ferror">ferror()</a>) on <code>stream</code>.</p></section>	http://en.cppreference.com/w/c/io/puts
putwchar	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wint_t putwchar( wchar_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Writes a wide character <code>ch</code> to <code>stdout</code></p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character to be written</td></tr></table><span class="prog__sub"> Return value</span><p><code>ch</code> on success, <code>WEOF</code> on failure.</p></section>	http://en.cppreference.com/w/c/io/putwchar
remove	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int remove( const char *fname );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Deletes the file identified by character string pointed to by <code>fname</code>.</p><p>If the file is currently open by this or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name although the file system space is not reclaimed until the last running process closes the file; Windows does not allow the file to be deleted).<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  fname</td><td> -</td><td>  pointer to a null-terminated string containing the path identifying the file to delete</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> upon success or non-zero value on error.</p></section>	http://en.cppreference.com/w/c/io/remove
rename	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int rename( const char *old_filename, const char *new_filename );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Changes the filename of a file. The file is identified by character string pointed to by <code>old_filename</code>. The new filename is identified by character string pointed to by <code>new_filename</code>.</p><p>If <code>new_filename</code> exists, the behavior is implementation-defined.</p><span class="prog__sub"> Parameters</span><table><tr><td>  old_filename</td><td> -</td><td>  pointer to a null-terminated string containing the path identifying the file to rename</td></tr><tr><td>  new_filename</td><td> -</td><td>  pointer to a null-terminated string containing the new path of the file</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> upon success or non-zero value on error.</p></section>	http://en.cppreference.com/w/c/io/rename
rewind	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void rewind( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Moves the file position indicator to the beginning of the given file stream. <br></p><p>The function is equivalent to <code><a href="http://en.cppreference.com/w/c/io/fseek">fseek</a>(stream, 0, <a href="http://en.cppreference.com/w/c/io">SEEK_SET</a>);</code>, except that end-of-file and error indicators are cleared. </p><p>The function drops any effects from previous calls to <a href="http://en.cppreference.com/w/c/io/ungetc" title="c/io/ungetc">ungetc</a>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  file stream to modify</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><p> This example shows how to read a file twice<br></p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0char str[20];\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io">FILE</a> *f;    char ch;\xc2\xa0    f = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("file.txt", "w");    for (ch = '0'; ch &lt;= '9'; ch++) {        <a href="http://en.cppreference.com/w/c/io/fputc">fputc</a>(ch, f);    }    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(f);\xc2\xa0    f = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("file.txt", "r");    <a href="http://en.cppreference.com/w/c/io/fread">fread</a>(str, 1, 10, f);    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>(str);\xc2\xa0    rewind(f);    <a href="http://en.cppreference.com/w/c/io/fread">fread</a>(str, 1, 10, f);    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>(str);    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(f);\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>0123456789<br>0123456789</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/io/rewind
setbuf	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>void setbuf( <a href="http://en.cppreference.com/w/c/io">FILE</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*stream, char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*buffer );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>void setbuf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, char *restrict buffer );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Sets the internal buffer to use for stream operations. It should be at least <code>BUFSIZ</code> characters long. </p><p>If <code>buffer</code> is not null, equivalent to <code><a href="http://en.cppreference.com/w/c/io/setvbuf">setvbuf</a>(stream, buffer, <a href="http://en.cppreference.com/w/c/io">_IOFBF</a>, <a href="http://en.cppreference.com/w/c/io">BUFSIZ</a>)</code>.</p><p>If <code>buffer</code> is null, equivalent to <code><a href="http://en.cppreference.com/w/c/io/setvbuf">setvbuf</a>(stream, <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, <a href="http://en.cppreference.com/w/c/io">_IONBF</a>, 0)</code>, which turns off buffering.</p><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  the file stream to set the buffer to</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a buffer for the stream to use. If <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> is supplied, the buffering is turned off</td></tr></table><span class="prog__sub"> Return value</span><p>None.<br></p></section>	http://en.cppreference.com/w/c/io/setbuf
setvbuf	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>int setvbuf( <a href="http://en.cppreference.com/w/c/io">FILE</a> * \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 stream, char * \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 buffer, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0int mode, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int setvbuf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, char *restrict buffer, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0int mode, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Changes the the buffering mode of the given file stream <code>stream</code> as indicated by the argument <code>mode</code>. In addition,</p><ul><li> If <code>buffer</code> is a null pointer, resizes of the internal buffer to <code>size</code>.</li><li> If <code>buffer</code> is not a null pointer, instructs the stream to use the user-provided buffer of size <code>size</code> beginning at <code>buffer</code>. The stream must be closed (with <a href="http://en.cppreference.com/w/c/io/fclose" title="c/io/fclose">fclose</a>) before the <a href="http://en.cppreference.com/w/c/language/lifetime" title="c/language/lifetime">lifetime</a> of the array pointed to by <code>buffer</code> ends. The contents of the array after a successful call to <code>setvbuf</code> are indeterminate and any attempt to use it is undefined behavior.</li></ul><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  the file stream to set the buffer to or null pointer to change size and mode only</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a buffer for the stream to use</td></tr><tr><td>  mode</td><td> -</td><td> buffering mode to use. It can be one of the following values:<table><tr><td> <code>_IOFBF</code></td><td> full buffering</td></tr><tr><td> <code>_IOLBF</code></td><td> line buffering</td></tr><tr><td> <code>_IONBF</code></td><td> no buffering</td></tr></table></td></tr><tr><td>  size</td><td> -</td><td>  size of the buffer</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> on success or nonzero on failure.</p></section>	http://en.cppreference.com/w/c/io/setvbuf
tmpfile, tmpfile_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/io">FILE</a> *tmpfile(void);</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t tmpfile_s(<a href="http://en.cppreference.com/w/c/io">FILE</a> * restrict * restrict streamptr);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Creates and opens a temporary file. The file is opened as binary file for update (as if by <a href="http://en.cppreference.com/w/c/io/fopen" title="c/io/fopen">fopen</a> with <code>"wb+"</code> mode). The filename of the file is guaranteed to be unique within the filesystem. At least <a href="http://en.cppreference.com/w/c/io" title="c/io">TMP_MAX</a> files may be opened during the lifetime of a program (this limit may be shared with <a href="http://en.cppreference.com/w/c/io/tmpnam" title="c/io/tmpnam">tmpnam</a> and may be further limited by <a href="http://en.cppreference.com/w/c/io" title="c/io">FOPEN_MAX</a>).</div><div>2) Same as (1), except that at least TMP_MAX_S files may be opened (the limit may be shared with tmpnam_s), and if <code>streamptr</code> is a null pointer, the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function is called. <dl><dd>As all bounds-checked functions, <code>tmpfile_s</code> is only guaranteed to be available of <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><p>The temporary file created by this function is closed and deleted when the program exits normally. Whether it's deleted on abnormal termination is implementation-defined.<br></p><span class="prog__sub"> Parameters</span><div>1) (none)</div><div>2) pointer to a pointer that will be updated by this function call</div><span class="prog__sub"> Return value</span><div>1) Pointer to the file stream associated with the file or null pointer if an error has occurred.</div><div>2) Zero if the file was created and open successfully, non-zero if the file was not created or open or if <code>streamptr</code> was a null pointer. In addition, pointer to the associated file stream is stored in <code>*streamptr</code> on success, and a null pointer value is stored in <code>*streamptr</code> on error.</div></section>	http://en.cppreference.com/w/c/io/tmpfile
tmpnam, tmpnam_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char *tmpnam( char *filename );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t tmpnam_s(char *filename_s, rsize_t maxsize);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Creates a unique valid file name (no longer than <a href="http://en.cppreference.com/w/c/io" title="c/io">L_tmpnam</a> in length) and stores it in character string pointed to by <code>filename</code>. The function is capable of generating up to <a href="http://en.cppreference.com/w/c/io" title="c/io">TMP_MAX</a> of unique filenames, but some or all of them may be in use in the filesystem and thus not suitable return values. </div><div>2) Same as (1), except that up to TMP_MAX_S names may be generated, no longer than L_tmpnam_s in length, and he following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>filename_s</code> is a null pointer</li><li> <code>maxsize</code> is greater than <code>RSIZE_MAX</code></li><li> <code>maxsize</code> is less than the generated file name string</li></ul></dd><dd>As all bounds-checked functions, <code>tmpnam_s</code> is only guaranteed to be available of <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><p><code>tmpnam</code> and <code>tmpnam_s</code> modify static state (which may be shared between these functions) and are not required to be thread-safe.</p><span class="prog__sub"> Parameters</span><table><tr><td>  filename</td><td> -</td><td>  pointer to the character array capable of holding at least <a href="http://en.cppreference.com/w/c/io" title="c/io">L_tmpnam</a> bytes, to be used as a result buffer. If null pointer is passed, a pointer to an internal static buffer is returned.</td></tr><tr><td>  filename_s</td><td> -</td><td>  pointer to the character array capable of holding at least L_tmpnam_s bytes, to be used as a result buffer.</td></tr><tr><td>  maxsize</td><td> -</td><td>  maximum number of characters the function is allowed to write (typically the size of the <code>filename_s</code> array).</td></tr></table><span class="prog__sub"> Return value</span><div>1) <code>filename</code> if <code>filename</code> was not a null pointer. Otherwise a pointer to an internal static buffer is returned. If no suitable filename can be generated, null pointer is returned.</div><div>2) Returns zero and writes the file name to <code>filename_s</code> on success. On error, returns non-zero and writes the null character to <code>filename_s[0]</code> (only if <code>filename_s</code> is not null and <code>maxsize</code> is not zero and is not greater than RSIZE_MAX).</div></section>	http://en.cppreference.com/w/c/io/tmpnam
ungetc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int ungetc( int ch, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>If <code>ch</code> does not equal <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a>, pushes the character <code>ch</code> (reinterpreted as <code>unsigned char</code>) into the input buffer associated with the stream <code>stream</code> in such a manner that subsequent read operation from <code>stream</code> will retrieve that character. The external device associated with the stream is not modified.</p><p>Stream repositioning operations <a href="http://en.cppreference.com/w/c/io/fseek" title="c/io/fseek">fseek</a>, <a href="http://en.cppreference.com/w/c/io/fsetpos" title="c/io/fsetpos">fsetpos</a>, and <a href="http://en.cppreference.com/w/c/io/rewind" title="c/io/rewind">rewind</a> discard the effects of <code>ungetc</code>.</p><p>If <code>ungetc</code> is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful <code>ungetc</code> were performed, read operations retrieve the pushed-back characters in reverse order of <code>ungetc</code></p><p>If <code>ch</code> equals <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a>, the operation fails and the stream is not affected.</p><p>A successful call to <code>ungetc</code> clears the end of file status flag <a href="http://en.cppreference.com/w/c/io/feof" title="c/io/feof">feof</a>.</p><p>A successful call to <code>ungetc</code> on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</p><p>A successful call to <code>ungetc</code> on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before <code>ungetc</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to be pushed into the input stream buffer</td></tr><tr><td>  stream</td><td> -</td><td>  file stream to put the character back to</td></tr></table><span class="prog__sub"> Return value</span><p>On success <code>ch</code> is returned.</p><p>On failure <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> is returned and the given stream remains unchanged.</p></section>	http://en.cppreference.com/w/c/io/ungetc
ungetwc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wint_t ungetwc( wint_t ch, <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>If <code>ch</code> does not equal WEOF, pushes the wide character <code>ch</code> into the input buffer associated with the stream <code>stream</code> in such a manner that subsequent read operation from <code>stream</code> will retrieve that wide character. The external device associated with the stream is not modified.</p><p>Stream repositioning operations <a href="http://en.cppreference.com/w/c/io/fseek" title="c/io/fseek">fseek</a>, <a href="http://en.cppreference.com/w/c/io/fsetpos" title="c/io/fsetpos">fsetpos</a>, and <a href="http://en.cppreference.com/w/c/io/rewind" title="c/io/rewind">rewind</a> discard the effects of <code>ungetwc</code>.</p><p>If <code>ungetwc</code> is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful <code>ungetwc</code> were performed, read operations retrieve the pushed-back wide characters in reverse order of <code>ungetwc</code></p><p>If <code>ch</code> equals WEOF, the operation fails and the stream is not affected.</p><p>A successful call to <code>ungetwc</code> clears the end of file status flag <a href="http://en.cppreference.com/w/c/io/feof" title="c/io/feof">feof</a>.</p><p>A successful call to <code>ungetwc</code> on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before <code>ungetwc</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character to be put back</td></tr><tr><td>  stream</td><td> -</td><td>  file stream to put the wide character back to</td></tr></table><span class="prog__sub"> Return value</span><p>On success <code>ch</code> is returned.</p><p>On failure <code>WEOF</code> is returned and the given stream remains unchanged.</p></section>	http://en.cppreference.com/w/c/io/ungetwc
vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>\xe2\x80\x8bint vprintf( const char *format, va_list vlist );\xe2\x80\x8b</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>\xe2\x80\x8bint vprintf( const char *restrict format, va_list vlist );\xe2\x80\x8b</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(2)</td><td></td></tr><tr><td> <div><code>int vfprintf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *stream, const char *format, va_list vlist );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int vfprintf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, const char *restrict format, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 va_list vlist );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(3)</td><td></td></tr><tr><td> <div><code>int vsprintf( char *buffer, const char *format, va_list vlist );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int vsprintf( char *restrict buffer, const char *restrict format, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 va_list vlist );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>int vsnprintf( char *restrict buffer, int bufsz, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const char *restrict format, va_list vlist );</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td> <div><code>int vprintf_s( const char *restrict format, va_list arg);</code></div></td><td> (5) </td><td> (since C11) </td></tr><tr><td> <div><code>int vfprintf_s( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, const char *restrict format,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 va_list arg);</code></div></td><td> (6) </td><td> (since C11) </td></tr><tr><td> <div><code>int vsprintf_s( char *restrict buffer, rsize_t bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char *restrict format, va_list arg);</code></div></td><td> (7) </td><td> (since C11) </td></tr><tr><td> <div><code>int vsnprintf_s(char *restrict buffer, rsize_t bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char * restrict format, va_list arg);</code></div></td><td> (8) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Loads the data from the locations, defined by <code>vlist</code>, converts them to character string equivalents and writes the results to a variety of sinks.</p><div>1) Writes the results to <a href="http://en.cppreference.com/w/c/io" title="c/io">stdout</a>.</div><div>2) Writes the results to a file stream <code>stream</code>.</div><div>3) Writes the results to a character string <code>buffer</code>.</div><div>4) Writes the results to a character string <code>buffer</code>. At most <code>buf_size</code> characters are written. The resulting character string will be terminated with a null character, unless <code>buf_size</code> is zero. If <code>buf_size</code> is zero, nothing is written and <code>buffer</code> may be a null pointer, however the return value (number of bytes that would be written) is still calculated and returned.</div><div>5-8) Same as (1-4), except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> the conversion specifier <code>%n</code> is present in <code>format</code></li><li> any of the arguments corresponding to <code>%s</code> is a null pointer</li><li> <code>format</code> or <code>buffer</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than RSIZE_MAX</li><li> encoding errors occur in any of string and character conversion specifiers</li><li> (for <code>vsprintf_s</code> only), the string to be stored in <code>buffer</code> (including the trailing null)) would be exceed <code>bufsz</code></li></ul></dd><dd>As all bounds-checked functions, <code>vprintf_s</code>, <code>vfprintf_s</code>, <code>vsprintf_s</code>, and <code>vsnrintf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  output file stream to write to</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a character string to write to</td></tr><tr><td>  bufsz</td><td> -</td><td>  up to bufsz - 1 characters may be written, plus the null terminator</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated character string specifying how to interpret the data.<p>The format string consists of ordinary multibyte characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) one or more flags that modify the behavior of the conversion:</li></ul><dl><dd><ul><li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified)</li><li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative)</li><li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present.</li><li> <code>#</code>\xc2\xa0: <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.</li><li> <code>0</code>\xc2\xa0: for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present.</li></ul></dd></dl></dd></dl><dl><dd><ul><li> (optional) integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.)</li></ul></dd></dl><dl><dd><ul><li> (optional) <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the argument</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table><tr><th rowspan="1"> Conversion<br/> specifier</th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p>(C99)</p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p>(C99)</p></th><th> <code>j</code><p>(C99)</p></th><th> <code>z</code><p>(C99)</p></th><th> <code>t</code><p>(C99)</p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td><dl><dd> writes a <b>single character</b>.</dd></dl><p>The argument is first converted to <code>unsigned char</code>.If the <b>l</b> modifier is used, the argument is first converted to a character string as if by <b>%ls</b> with a <code>wchar_t[2]</code> argument.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>int</code></div></div></td><td> <div><div><code>wint_t</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td><dl><dd> writes a <b>character string</b></dd></dl><p>The argument must be a pointer to the initial element of an array of characters. <i>Precision</i> specifies the maximum number of bytes to be written. If <i>Precision</i> is not specified, writes every byte up to and not including the first null terminator.If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>, which is converted to char array as if by a call to <a href="http://en.cppreference.com/w/c/string/multibyte/wcrtomb" title="c/string/multibyte/wcrtomb">wcrtomb</a> with zero-initialized conversion state.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>char*</code></div></div></td><td> <div><div><code>wchar_t*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>d</code><br/> <code>i</code></th><td><dl><dd>converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br/> If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.</p></td><td> <div><div><code>signed char</code></div></div></td><td> <div><div><code>short</code></div></div></td><td> <div><div><code>int</code></div></div></td><td> <div><div><code>long</code></div></div></td><td> <div><div><code>long long</code></div></div></td><td> <div><div><code>intmax_t</code></div></div></td><td> <div><div>signed <code>size_t</code></div></div></td><td> <div><div><code>ptrdiff_t</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>o</code></th><td><dl><dd>converts a <b>unsigned integer</b> into octal representation <i>oooo</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero.In that case if both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, single <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is written.</p></td><td> <div><div><code>unsigned char</code></div></div></td><td> <div><div><code>unsigned short</code></div></div></td><td> <div><div><code>unsigned int</code></div></div></td><td> <div><div><code>unsigned long</code></div></div></td><td> <div><div><code>unsigned long long</code></div></div></td><td> <div><div><code>uintmax_t</code></div></div></td><td> <div><div><code>size_t</code></div></div></td><td> <div><div>unsigned version of <code>ptrdiff_t</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>x</code><br/> <code>X</code></th><td><dl><dd>converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.</dd></dl><p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br/>For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br/><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.</p></td><td> <small>N/A</small></td></tr><tr><th> <code>u</code></th><td><dl><dd>converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.</p></td><td> <small>N/A</small></td></tr><tr><th> <code>f</code><br/> <code>F</code></th><td><dl><dd>converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear after the decimal point character. The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>double</code></div></div></td><td> <div><div><code>double</code> (C99)</div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>long double</code></div></div></td></tr><tr><th> <code>e</code> <br/> <code>E</code></th><td><dl><dd>converts <b>floating-point number</b> to the decimal exponent notation.</dd></dl><p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>\xc2\xb1dd</i> is used.<br/>For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>\xc2\xb1dd</i> is used.<br/>The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the exponent is also <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>a</code> <br/> <code>A</code><p>(C99)</p></th><td><dl><dd>converts <b>floating-point number</b> to the hexadecimal exponent notation.</dd></dl><p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>\xc2\xb1d</i> is used.<br/>For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>\xc2\xb1d</i> is used.<br/>The first hexadecimal digit is <code>0</code> if the argument is not a normalized floating point value.If the value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the exponent is also <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is sufficient for exact representation of the value.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>g</code> <br/> <code>G</code></th><td><dl><dd>converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.</dd></dl><p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br/>For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br/>Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:</p><ul><li> if <i>P &gt; X \xe2\x89\xa5 \xe2\x88\x924</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P \xe2\x88\x92 1 \xe2\x88\x92 X</i>.</li><li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P \xe2\x88\x92 1</i>.</li></ul><p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>n</code></th><td><dl><dd>returns the <b>number of characters written</b> so far by this call to the function.</dd></dl><p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>.</p></td><td> <div><div><code>signed char*</code></div></div></td><td> <div><div><code>short*</code></div></div></td><td> <div><div><code>int*</code></div></div></td><td> <div><div><code>long*</code></div></div></td><td> <div><div><code>long long*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a>*</code></div></div></td><td> <div><div>signed <code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/ptrdiff_t">ptrdiff_t</a>*</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>p</code></th><td> writes an implementation defined character sequence defining a <b>pointer</b>.</td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <code>void*</code></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr></table><p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p><p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p><p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p><p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p><p>The correct conversion specifications for the fixed-width character types (<a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">int8_t</a>, etc) are defined in the header <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;inttypes.h&gt;</a> (although <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">PRIdMAX</a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">PRIuMAX</a>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable and printing the value stored by <code>%n</code> earlier within the same call.</p><p>If a conversion specification is invalid, the behavior is undefined.<br></p><p><br/></p></td></tr><tr><td>  vlist</td><td> -</td><td>  variable argument list containing the data to print</td></tr></table><span class="prog__sub"> Return value</span><div>1-3) The number of characters written if successful or negative value if an error occurred.</div><div>4) The number of characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to <code>buf_size</code> limit, function returns the total number of characters (not including the terminating null-byte) which would have been written, if the limit was not imposed. </div><div>5,6) number of characters transmitted to the output stream or negative value if an output error, a runtime constrants violation error, or an encoding error occurred.</div><div>7) number of characters written to <code>buffer</code>, not counting the null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX</code>), or zero on runtime constraint violations, and negative value on encoding errors</div><div>8) number of characters not including the terminating null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX</code>), which would have been written to <code>buffer</code> if <code>bufsz</code> was ignored, or a negative value if a runtime constraints violation or an encoding error occurred</div></section>	http://en.cppreference.com/w/c/io/vfprintf
vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>\xe2\x80\x8bint vscanf( const char *restrict format, va_list vlist );\xe2\x80\x8b</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>int vfscanf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, const char *restrict format, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0va_list vlist );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>int vsscanf( const char *restrict buffer, const char *restrict format, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0va_list vlist );</code></div></td><td> (3) </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>int vscanf_s(const char *restrict format, va_list vlist);</code></div></td><td> (4) </td><td> (since C11) </td></tr><tr><td> <div><code>int vfscanf_s( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream, const char *restrict format,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0va_list vlist);</code></div></td><td> (5) </td><td> (since C11) </td></tr><tr><td> <div><code>int vsscanf_s( const char *restrict buffer, const char *restrict format,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0va_list vlist);</code></div></td><td> (6) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads data from the a variety of sources, interprets it according to <code>format</code> and stores the results into locations defined by <code>vlist</code>.</p><div>1) Reads the data from <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a></div><div>2) Reads the data from file stream <code>stream</code></div><div>3) Reads the data from null-terminated character string <code>buffer</code>. Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fscanf</code></div><div>4-6) Same as (1-3), except that <code>%c</code>, <code>%s</code>, and <code>%[</code> conversion specifiers each expect two arguments (the usual pointer and a value of type rsize_t indicating the size of the receiving array, which may be 1 when reading with a\xc2\xa0%c into a single char) and except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> any of the arguments of pointer type is a null pointer</li><li> <code>format</code>, <code>stream</code>, or <code>buffer</code> is a null pointer</li><li> the number of characters that would be written by\xc2\xa0%c,\xc2\xa0%s, or\xc2\xa0%[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers</li><li> optionally, any other detectable error, such as unknown conversion specifier</li></ul></dd><dd>As all bounds-checked functions, <code>vscanf_s</code>, <code>vfscanf_s</code>, and <code>vsscanf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;stdio.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  input file stream to read from</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a null-terminated character string to read from</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated character string specifying how to read the input.<p>The format string consists of <br></p><ul><li> non-whitespace multibyte characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li><li> whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling <a href="http://en.cppreference.com/w/c/string/byte/isspace" title="c/string/byte/isspace"><tt>isspace</tt></a> in a loop). Note that there is no difference between <code>"\n"</code>, <code>" "</code>, <code>"\t\t"</code>, or other whitespace in the format string.</li><li> conversion specifications. Each conversion specification has the following format:</li></ul><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) assignment-suppressing character <code>*</code>. If this option is present, the function does not assign the result of the conversion to any receiving argument.</li></ul></dd></dl><dl><dd><ul><li> (optional) integer number (greater than zero) that specifies <i>maximum field width</i>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that\xc2\xa0%s and\xc2\xa0%[ may lead to buffer overflow if the width is not provided.</li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table><tr><th rowspan="1"> Conversion<br/> specifier</th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p>(C99)</p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p>(C99)</p></th><th> <code>j</code><p>(C99)</p></th><th> <code>z</code><p>(C99)</p></th><th> <code>t</code><p>(C99)</p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td> matches literal <code>%</code></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td><dl><dd> matches a <b>character</b> or a sequence of <b>characters</b></dd></dl><p>If a width specifier is used, matches exactly <i>width</i>  characters (the argument must be a pointer to an array with sufficient room). Unlike\xc2\xa0%s and\xc2\xa0%[, does not append the null character to the array.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>char*</code></div></div></td><td> <div><div><code>wchar_t*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td><dl><dd> matches a sequence of non-whitespace characters (a <b>string</b>)</dd></dl><p>If width specifier is used, matches up to <i>width</i> or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>[</code>set<code>]</code></th><td><dl><dd>matches a non-empty sequence of character from set of characters.</dd></dl><p>If the first character of the set is <code>^</code>, then all characters not in the set are matched. If the set begins with <code>]</code> or <code>^]</code> then the <code>]</code> character is also included into the set. It is implementation-defined whether the character <code>-</code> in the non-initial position in the scanset may be indicating a range, as in <code>[0-9]</code>. If width specifier is used, matches only up to <i>width</i>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>d</code></th><td><dl><dd>matches a <b>decimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtol" title="c/string/byte/strtol"><tt>strtol()</tt></a> with the value <code>10</code> for the <code>base</code> argument</p></td><td> <div><div><code>signed char*</code> or <code>unsigned char*</code></div></div></td><td> <div><div><code>signed short*</code> or <code>unsigned short*</code></div></div></td><td> <div><div><code>signed int*</code> or <code>unsigned int*</code></div></div></td><td> <div><div><code>signed long*</code> or <code>unsigned long*</code></div></div></td><td> <div><div><code>signed long long*</code> or <code>unsigned long long*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a>*</code> or <code><a href="http://en.cppreference.com/w/c/types/integer">uintmax_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/ptrdiff_t">ptrdiff_t</a>*</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>i</code></th><td><dl><dd>matches an <b>integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtol" title="c/string/byte/strtol"><tt>strtol()</tt></a> with the value <code>\xe2\x80\x8b0\xe2\x80\x8b</code> for the <code>base</code> argument (base is determined by the first characters parsed)</p></td></tr><tr><th> <code>u</code></th><td><dl><dd>matches an unsigned <b>decimal integer</b>. </dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtoul" title="c/string/byte/strtoul"><tt>strtoul()</tt></a> with the value <code>10</code> for the <code>base</code> argument.</p></td></tr><tr><th> <code>o</code></th><td><dl><dd>matches an unsigned <b>octal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtoul" title="c/string/byte/strtoul"><tt>strtoul()</tt></a> with the value <code>8</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>x</code>, <code>X</code></th><td><dl><dd>matches an unsigned <b>hexadecimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtoul" title="c/string/byte/strtoul"><tt>strtoul()</tt></a> with the value <code>16</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>n</code></th><td><dl><dd>returns the <b>number of characters read so far</b>.</dd></dl><p>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined<br></p></td></tr><tr><th> <code>a</code>, <code>A</code>(C99)<br/> <code>e</code>, <code>E</code><br/> <code>f</code>, <code>F</code><br/> <code>g</code>, <code>G</code></th><td><dl><dd>matches a <b>floating-point number</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/byte/strtof" title="c/string/byte/strtof"><tt>strtof()</tt></a></p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>float*</code></div></div></td><td> <div><div><code>double*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>long double*</code></div></div></td></tr><tr><th> <code>p</code></th><td><dl><dd>matches implementation defined character sequence defining a <b>pointer</b>.</dd></dl><p><code>printf</code> family of functions should produce the same sequence using <code>%p</code> format specifier</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>void**</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr></table><p>For every conversion specifier other than <code>n</code>, the longest sequence of input characters which does not exceed any speci\xef\xac\x81ed \xef\xac\x81eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \xef\xac\x81rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\xef\xac\x81le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p><p>All conversion specifiers other than <code>[</code>, <code>c</code>, and <code>n</code> consume and discard all leading whitespace characters (determined as if by calling <a href="http://en.cppreference.com/w/c/string/byte/isspace" title="c/string/byte/isspace"><tt>isspace</tt></a>) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</p><p>The conversion specifiers <code>lc</code>, <code>ls</code>, and <code>l[</code> perform multibyte-to-wide character conversion as if by calling <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtowc" title="c/string/multibyte/mbrtowc"><tt>mbrtowc()</tt></a> with an <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t" title="c/string/multibyte/mbstate t"><tt>mbstate_t</tt></a> object initialized to zero before the first character is converted.</p><p>The conversion specifiers <code>s</code> and <code>[</code> always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width.</p><p>The correct conversion specifications for the <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">fixed-width integer types</a> (<code>int8_t</code>, etc) are defined in the header <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;inttypes.h&gt;</a> (although <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer"><tt>SCNdMAX</tt></a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer"><tt>SCNuMAX</tt></a>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple fields in the same "sink" variable.</p><p>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing <code>"100er"</code> with the conversion specifier <code>%f</code>, the sequence <code>"100e"</code> (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with <code>"r"</code> remaining. Existing implementations do not follow this rule and roll back to consume only <code>"100"</code>, leaving <code>"er"</code>, e.g. <a class="external text" href="https://sourceware.org/bugzilla/show_bug.cgi?id=1765" rel="nofollow">glibc bug 1765</a></p><p><br/></p></td></tr><tr><td>  vlist</td><td> -</td><td>  variable argument list containing the receiving arguments</td></tr></table><span class="prog__sub"> Return value</span><div>1-3) Number of receiving arguments successfully assigned, or <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> if read failure occurs before the first receiving argument was assigned.</div><div>4-6) Same as (1-3), except that <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> is also returned if there is a runtime constraint violation.</div></section>	http://en.cppreference.com/w/c/io/vfscanf
vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>int vwprintf( const wchar_t *format, va_list vlist );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int vwprintf( const wchar_t *restrict format, va_list vlist );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(2)</td><td></td></tr><tr><td> <div><code>int vfwprintf( <a href="http://en.cppreference.com/w/c/io">FILE</a>* stream, const wchar_t *format, va_list vlist );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int vfwprintf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict format, va_list vlist );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(3)</td><td></td></tr><tr><td> <div><code>int vswprintf( wchar_t *buffer, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *format, va_list vlist );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>int vswprintf( wchar_t *restrict buffer, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict format, va_list vlist );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>int vwprintf_s( const wchar_t *restrict format, va_list vlist);</code></div></td><td> (4) </td><td> (since C11) </td></tr><tr><td> <div><code>int vfwprintf_s( <a href="http://en.cppreference.com/w/c/io">FILE</a> * restrict stream,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict format, va_list vlist);</code></div></td><td> (5) </td><td> (since C11) </td></tr><tr><td> <div><code>int vswprintf_s( wchar_t *restrict buffer, rsize_t bufsz, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t * restrict format, va_list vlist);</code></div></td><td> (6) </td><td> (since C11) </td></tr><tr><td> <div><code>int vsnwprintf_s( wchar_t *restrict buffer, rsize_t bufsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict format, va_list vlist);</code></div></td><td> (7) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Loads the data from locations, defined by <code>vlist</code>, converts them to wide string equivalents and writes the results to a variety of sinks.</p><div>1) Writes the results to <a href="http://en.cppreference.com/w/c/io" title="c/io">stdout</a>.</div><div>2) Writes the results to a file stream <code>stream</code>.</div><div>3) Writes the results to a wide string <code>buffer</code>. At most <code>bufsz-1</code> wide characters are written followed by null wide character. The resulting wide character string will be terminated with a null wide character, unless <code>bufsz</code> is zero.</div><div>4-7) Same as (1-3), except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> the conversion specifier <code>%n</code> is present in <code>format</code></li><li> any of the arguments corresponding to <code>%s</code> is a null pointer</li><li> <code>format</code> or <code>buffer</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> encoding errors occur in any of string and character conversion specifiers</li><li> (for <code>vswprintf_s</code> only), the string to be stored in <code>buffer</code> (including the trailing wide null)) would be exceed <code>bufsz</code></li></ul></dd></dl></div><div>8) Same as (7), except it will truncate the result to fit within the array pointed to by s.<dl><dd>As all bounds-checked functions, <code>vwprintf_s</code>, <code>vfwprintf_s</code>, <code>vswprintf_s</code>, and <code>vsnwprintf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;wchar.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  output wide stream to write to</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a wide string to write to</td></tr><tr><td>  bufsz</td><td> -</td><td>  maximum number of wide characters to write</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated wide string specifying how to interpret the data.<p>The format string consists of ordinary wide characters (except <code>%</code>), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</p><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) one or more flags that modify the behavior of the conversion:</li></ul><dl><dd><ul><li> <code>-</code>: the result of the conversion is left-justified within the field (by default it is right-justified)</li><li> <code>+</code>: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative)</li><li> <i>space</i>: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if <code>+</code> flag is present.</li><li> <code>#</code>\xc2\xa0: <i>alternative form</i> of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined.</li><li> <code>0</code>\xc2\xa0: for integer and floating point number conversions, leading zeros are used to pad the field instead of <i>space</i> characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if <code>-</code> flag is present.</li></ul></dd></dl></dd></dl><dl><dd><ul><li> (optional) integer value or <code>*</code> that specifies minimum field width. The result is padded with <i>space</i> characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when <code>*</code> is used, the width is specified by an additional argument of type <code>int</code>. If the value of the argument is negative, it results with the <code>-</code> flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.)</li></ul></dd></dl><dl><dd><ul><li> (optional) <code>.</code> followed by integer number or <code>*</code>, or neither that specifies <i>precision</i> of the conversion. In the case when <code>*</code> is used, the <i>precision</i> is specified by an additional argument of type <code>int</code>. If the value of this argument is negative, it is ignored. If neither a number nor <code>*</code> is used, the precision is taken as zero. See the table below for exact effects of <i>precision</i>. </li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the argument</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table><tr><th rowspan="1"> Conversion<br/> specifier</th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p>(C99)</p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p>(C99)</p></th><th> <code>j</code><p>(C99)</p></th><th> <code>z</code><p>(C99)</p></th><th> <code>t</code><p>(C99)</p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td> writes literal <code>%</code>. The full conversion specification must be <code>%%</code>.</td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td><dl><dd> writes a <b>single character</b>.</dd></dl><p>The argument is first converted to <code>wchar_t</code> as if by calling <a href="http://en.cppreference.com/w/c/string/multibyte/btowc" title="c/string/multibyte/btowc">btowc</a>.If the <b>l</b> modifier is used, the <code>wint_t</code> argument is first converted to <code>wchar_t</code>.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>int</code></div></div></td><td> <div><div><code>wint_t</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td><dl><dd> writes a <b>character string</b></dd></dl><p>The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtowc" title="c/string/multibyte/mbrtowc">mbrtowc</a> with zero-initialized conversion state.<i>Precision</i> specifies the maximum number of wide characters to be written. If <i>Precision</i> is not specified, writes every wide characters up to and not including the first null terminator.If the <b>l</b> specifier is used, the argument must be a pointer to the initial element of an array of <code>wchar_t</code>.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>char*</code></div></div></td><td> <div><div><code>wchar_t*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>d</code><br/> <code>i</code></th><td><dl><dd>converts a <b>signed integer</b> into decimal representation <i>[-]dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.<br/> If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.</p></td><td> <div><div><code>signed char</code></div></div></td><td> <div><div><code>short</code></div></div></td><td> <div><div><code>int</code></div></div></td><td> <div><div><code>long</code></div></div></td><td> <div><div><code>long long</code></div></div></td><td> <div><div><code>intmax_t</code></div></div></td><td> <div><div>signed <code>size_t</code></div></div></td><td> <div><div><code>ptrdiff_t</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>o</code></th><td><dl><dd>converts a <b>unsigned integer</b> into octal representation <i>oooo</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.In the <i>alternative implementation</i> precision is increased if necessary, to write one leading zero.In that case if both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, single <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is written.</p></td><td> <div><div><code>unsigned char</code></div></div></td><td> <div><div><code>unsigned short</code></div></div></td><td> <div><div><code>unsigned int</code></div></div></td><td> <div><div><code>unsigned long</code></div></div></td><td> <div><div><code>unsigned long long</code></div></div></td><td> <div><div><code>uintmax_t</code></div></div></td><td> <div><div><code>size_t</code></div></div></td><td> <div><div>unsigned version of <code>ptrdiff_t</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>x</code><br/> <code>X</code></th><td><dl><dd>converts an <b>unsigned integer</b> into hexadecimal representation <i>hhhh</i>.</dd></dl><p>For the <code>x</code> conversion letters <code>abcdef</code> are used.<br/>For the <code>X</code> conversion letters <code>ABCDEF</code> are used.<br/><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>.If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.In the <i>alternative implementation</i> <code>0x</code> or <code>0X</code> is prefixed to results if the converted value is nonzero.</p></td><td> <small>N/A</small></td></tr><tr><th> <code>u</code></th><td><dl><dd>converts an <b>unsigned integer</b> into decimal representation <i>dddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear. The default precision is <code>1</code>. If both the converted value and the precision are <code>\xe2\x80\x8b0\xe2\x80\x8b</code> the conversion results in no characters.</p></td><td> <small>N/A</small></td></tr><tr><th> <code>f</code><br/> <code>F</code></th><td><dl><dd>converts <b>floating-point number</b> to the decimal notation in the style <i>[-]ddd.ddd</i>.</dd></dl><p><i>Precision</i> specifies the minimum number of digits to appear after the decimal point character. The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>double</code></div></div></td><td> <div><div><code>double</code> (C99)</div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>long double</code></div></div></td></tr><tr><th> <code>e</code> <br/> <code>E</code></th><td><dl><dd>converts <b>floating-point number</b> to the decimal exponent notation.</dd></dl><p>For the <code>e</code> conversion style <i>[-]d.ddd</i><code>e</code><i>\xc2\xb1dd</i> is used.<br/>For the <code>E</code> conversion style <i>[-]d.ddd</i><code>E</code><i>\xc2\xb1dd</i> is used.<br/>The exponent contains at least two digits, more digits are used only if necessary. If the value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the exponent is also <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is <code>6</code>.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>a</code> <br/> <code>A</code><p>(C99)</p></th><td><dl><dd>converts <b>floating-point number</b> to the hexadecimal exponent notation.</dd></dl><p>For the <code>a</code> conversion style <i>[-]</i><code>0x</code><i>h.hhh</i><code>p</code><i>\xc2\xb1d</i> is used.<br/>For the <code>A</code> conversion style <i>[-]</i><code>0X</code><i>h.hhh</i><code>P</code><i>\xc2\xb1d</i> is used.<br/>The first hexadecimal digit is <code>0</code> if the argument is not a normalized floating point value.If the value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the exponent is also <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.<i>Precision</i> specifies the minimum number of digits to appear after the decimal point character.The default precision is sufficient for exact representation of the value.In the <i>alternative implementation</i> decimal point character is written even if no digits follow it.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>g</code> <br/> <code>G</code></th><td><dl><dd>converts <b>floating-point number</b> to decimal or decimal exponent notation depending on the value and the <i>precision</i>.</dd></dl><p>For the <code>g</code> conversion style conversion with style <code>e</code> or <code>f</code> will be performed.<br/>For the <code>G</code> conversion style conversion with style <code>E</code> or <code>F</code> will be performed.<br/>Let <code>P</code> equal the precision if nonzero, <code>6</code> if the precision is not specified, or <code>1</code> if the precision is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>. Then, if a conversion with style <code>E</code> would have an exponent of <code>X</code>:</p><ul><li> if <i>P &gt; X \xe2\x89\xa5 \xe2\x88\x924</i>, the conversion is with style <code>f</code> or <code>F</code> and precision <i>P \xe2\x88\x92 1 \xe2\x88\x92 X</i>.</li><li> otherwise, the conversion is with style <code>e</code> or <code>E</code> and precision <i>P \xe2\x88\x92 1</i>.</li></ul><p>Unless <i>alternative representation</i> is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left.For infinity and not-a-number conversion style see notes.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>n</code></th><td><dl><dd>returns the <b>number of characters written</b> so far by this call to the function.</dd></dl><p>The result is <i>written</i> to the value pointed to by the argument. The specification may not contain any <i>flag</i>, <i>field width</i>, or <i>precision</i>.</p></td><td> <div><div><code>signed char*</code></div></div></td><td> <div><div><code>short*</code></div></div></td><td> <div><div><code>int*</code></div></div></td><td> <div><div><code>long*</code></div></div></td><td> <div><div><code>long long*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a>*</code></div></div></td><td> <div><div>signed <code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/ptrdiff_t">ptrdiff_t</a>*</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>p</code></th><td> writes an implementation defined character sequence defining a <b>pointer</b>.</td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <code>void*</code></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr></table><p>The floating point conversion functions convert infinity to <code>inf</code> or <code>infinity</code>. Which one is used is implementation defined.</p><p>Not-a-number is converted to <code>nan</code> or <code>nan(<i>char_sequence</i>)</code>. Which one is used is implementation defined.</p><p>The conversions <code>F</code>, <code>E</code>, <code>G</code>, <code>A</code> output <code>INF</code>, <code>INFINITY</code>, <code>NAN</code> instead.</p><p>Even though <code>%c</code> expects <code>int</code> argument, it is safe to pass a <code>char</code> because of the integer promotion that takes place when a variadic function is called.</p><p>The correct conversion specifications for the fixed-width character types (<a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">int8_t</a>, etc) are defined in the header <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;inttypes.h&gt;</a> (although <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">PRIdMAX</a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">PRIuMAX</a>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>The memory-writing conversion specifier <code>%n</code> is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked <code>printf_s</code> family of functions.</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple <code>%n</code> results in the same variable and printing the value stored by <code>%n</code> earlier within the same call.</p><p>If a conversion specification is invalid, the behavior is undefined.<br></p><p><br/></p></td></tr><tr><td>  vlist</td><td> -</td><td> <a href="http://en.cppreference.com/w/c/language/variadic" title="c/language/variadic">variable argument list</a> containing the data to print</td></tr></table><span class="prog__sub"> Return value</span><div>1-3) The number of wide characters written if successful or negative value if an error occurred.</div><div>4) The number of wide characters written if successful or negative value if an error occurred. If the resulting string gets truncated due to <code>bufsz</code> limit, function returns the total number of characters (not including the terminating null wide character) which would have been written, if the limit were not imposed. </div><div>5,6) number of wide characters transmitted to the output stream or negative value if an output error, a runtime constraints violation error, or an encoding error occurred.</div><div>7) number of wide characters written to <code>buffer</code>, not counting the null wide character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>), or zero on runtime constraint violations, and negative value on encoding errors</div><div>8) number of wide characters not including the terminating null character (which is always written as long as <code>buffer</code> is not a null pointer and <code>bufsz</code> is not zero and not greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>), which would have been written to <code>buffer</code> if <code>bufsz</code> was ignored, or a negative value if a runtime constraints violation or an encoding error occurred</div></section>	http://en.cppreference.com/w/c/io/vfwprintf
vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int vwscanf( const wchar_t *restrict format, va_list vlist );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>int vfwscanf( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict format, va_list vlist );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>int vswscanf( const wchar_t *restrict buffer,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict format, va_list vlist );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div><code>int vwscanf_s( const wchar_t *restrict format, va_list vlist );</code></div></td><td> (4) </td><td> (since C11) </td></tr><tr><td> <div><code>int vfwscanf_s( <a href="http://en.cppreference.com/w/c/io">FILE</a> *restrict stream,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict format, va_list vlist );</code></div></td><td> (5) </td><td> (since C11) </td></tr><tr><td> <div><code>int vswscanf_s( const wchar_t *restrict buffer,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict format, va_list vlist );</code></div></td><td> (6) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Reads data from the a variety of sources, interprets it according to <code>format</code> and stores the results into locations defined by <code>vlist</code>.</p><div>1) Reads the data from <a href="http://en.cppreference.com/w/c/io" title="c/io">stdin</a>.</div><div>2) Reads the data from file stream <code>stream</code>.</div><div>3) Reads the data from null-terminated wide string <code>buffer</code>. Reaching the end of the string is equivalent to reaching the end-of-file condition for <code>fwscanf</code></div><div>4-6) Same as (1-3), except that <code>%c</code>, <code>%s</code>, and <code>%[</code> conversion specifiers each expect two arguments (the usual pointer and a value of type rsize_t indicating the size of the receiving array, which may be 1 when reading with a\xc2\xa0%lc into a single wide character) and except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> any of the arguments of pointer type is a null pointer</li><li> <code>format</code>, <code>stream</code>, or <code>buffer</code> is a null pointer</li><li> the number of characters that would be written by\xc2\xa0%c,\xc2\xa0%s, or\xc2\xa0%[, plus the terminating null character, would exceed the second (rsize_t) argument provided for each of those conversion specifiers</li><li> optionally, any other detectable error, such as unknown conversion specifier</li></ul></dd><dd>As all bounds-checked functions, <code>vwscanf_s</code>, <code>vfwscanf_s</code>, and <code>vswscanf_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>&lt;wchar.h&gt;</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  stream</td><td> -</td><td>  input file stream to read from</td></tr><tr><td>  buffer</td><td> -</td><td>  pointer to a null-terminated wide string to read from</td></tr><tr><td>  format</td><td> -</td><td>  pointer to a null-terminated wide string specifying how to read the input. The format string consists of<ul><li> non-whitespace wide characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li><li> whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling <a href="http://en.cppreference.com/w/c/string/wide/iswspace" title="c/string/wide/iswspace"><tt>iswspace</tt></a> in a loop). Note that there is no difference between <code>"\n"</code>, <code>" "</code>, <code>"\t\t"</code>, or other whitespace in the format string.</li><li> conversion specifications. Each conversion specification has the following format:</li></ul><dl><dd><ul><li> introductory <code>%</code> character</li></ul></dd></dl><dl><dd><ul><li> (optional) assignment-suppressing character <code>*</code>. If this option is present, the function does not assign the result of the conversion to any receiving argument.</li></ul></dd></dl><dl><dd><ul><li> (optional) integer number (greater than zero) that specifies <i>maximum field width</i>, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that\xc2\xa0%s and\xc2\xa0%[ may lead to buffer overflow if the width is not provided.</li></ul></dd></dl><dl><dd><ul><li> (optional) <i>length modifier</i> that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below).</li></ul></dd></dl><dl><dd><ul><li> conversion format specifier</li></ul></dd></dl><p>The following format specifiers are available:<br></p><table><tr><th rowspan="1"> Conversion<br/> specifier</th><th rowspan="1"> Explanation</th><th colspan="9"> Argument type</th></tr><tr><th colspan="2" style="text-align:right; font-weight:normal;"> length modifier</th><th> <code>hh</code><p>(C99)</p></th><th> <code>h</code></th><th style="font-weight:normal;"> (none)</th><th> <code>l</code></th><th> <code>ll</code><p>(C99)</p></th><th> <code>j</code><p>(C99)</p></th><th> <code>z</code><p>(C99)</p></th><th> <code>t</code><p>(C99)</p></th><th> <code>L</code></th></tr><tr><th> <code>%</code></th><td> matches literal <code>%</code></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>c</code></th><td><dl><dd> matches a <b>character</b> or a sequence of <b>characters</b></dd></dl><p>If a width specifier is used, matches exactly <i>width</i> wide characters (the argument must be a pointer to an array with sufficient room). Unlike\xc2\xa0%s and\xc2\xa0%[, does not append the null character to the array.</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>char*</code></div></div></td><td> <div><div><code>wchar_t*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr><tr><th> <code>s</code></th><td><dl><dd> matches a sequence of non-whitespace characters (a <b>string</b>)</dd></dl><p>If width specifier is used, matches up to <i>width</i> or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>[</code>set<code>]</code></th><td><dl><dd>matches a non-empty sequence of character from set of characters.</dd></dl><p>If the first character of the set is <code>^</code>, then all characters not in the set are matched. If the set begins with <code>]</code> or <code>^]</code> then the <code>]</code> character is also included into the set. It is implementation-defined whether the character <code>-</code> in the non-initial position in the scanset may be indicating a range, as in <code>[0-9]</code>. If width specifier is used, matches only up to <i>width</i>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least <i>width+1</i> characters)</p></td></tr><tr><th> <code>d</code></th><td><dl><dd>matches a <b>decimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstol" title="c/string/wide/wcstol"><tt>wcstol()</tt></a> with the value <code>10</code> for the <code>base</code> argument</p></td><td> <div><div><code>signed char*</code> or <code>unsigned char*</code></div></div></td><td> <div><div><code>signed short*</code> or <code>unsigned short*</code></div></div></td><td> <div><div><code>signed int*</code> or <code>unsigned int*</code></div></div></td><td> <div><div><code>signed long*</code> or <code>unsigned long*</code></div></div></td><td> <div><div><code>signed long long*</code> or <code>unsigned long long*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a>*</code> or <code><a href="http://en.cppreference.com/w/c/types/integer">uintmax_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>*</code></div></div></td><td> <div><div><code><a href="http://en.cppreference.com/w/c/types/ptrdiff_t">ptrdiff_t</a>*</code></div></div></td><td> <small>N/A</small></td></tr><tr><th> <code>i</code></th><td><dl><dd>matches an <b>integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstol" title="c/string/wide/wcstol"><tt>wcstol()</tt></a> with the value <code>\xe2\x80\x8b0\xe2\x80\x8b</code> for the <code>base</code> argument (base is determined by the first characters parsed)</p></td></tr><tr><th> <code>u</code></th><td><dl><dd>matches an unsigned <b>decimal integer</b>. </dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstoul" title="c/string/wide/wcstoul"><tt>wcstoul()</tt></a> with the value <code>10</code> for the <code>base</code> argument.</p></td></tr><tr><th> <code>o</code></th><td><dl><dd>matches an unsigned <b>octal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstoul" title="c/string/wide/wcstoul"><tt>wcstoul()</tt></a> with the value <code>8</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>x</code>, <code>X</code></th><td><dl><dd>matches an unsigned <b>hexadecimal integer</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstoul" title="c/string/wide/wcstoul"><tt>wcstoul()</tt></a> with the value <code>16</code> for the <code>base</code> argument</p></td></tr><tr><th> <code>n</code></th><td><dl><dd>returns the <b>number of characters read so far</b>.</dd></dl><p>No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined<br></p></td></tr><tr><th> <code>a</code>, <code>A</code>(C99)<br/> <code>e</code>, <code>E</code><br/> <code>f</code>, <code>F</code><br/> <code>g</code>, <code>G</code></th><td><dl><dd>matches a <b>floating-point number</b>.</dd></dl><p>The format of the number is the same as expected by <a href="http://en.cppreference.com/w/c/string/wide/wcstof" title="c/string/wide/wcstof"><tt>wcstof()</tt></a></p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>float*</code></div></div></td><td> <div><div><code>double*</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>long double*</code></div></div></td></tr><tr><th> <code>p</code></th><td><dl><dd>matches implementation defined character sequence defining a <b>pointer</b>.</dd></dl><p><code>printf</code> family of functions should produce the same sequence using <code>%p</code> format specifier</p></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <div><div><code>void**</code></div></div></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td><td> <small>N/A</small></td></tr></table><p>For every conversion specifier other than <code>n</code>, the longest sequence of input characters which does not exceed any speci\xef\xac\x81ed \xef\xac\x81eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \xef\xac\x81rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\xef\xac\x81le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p><p>All conversion specifiers other than <code>[</code>, <code>c</code>, and <code>n</code> consume and discard all leading whitespace characters (determined as if by calling <a href="http://en.cppreference.com/w/c/string/wide/iswspace" title="c/string/wide/iswspace"><tt>iswspace</tt></a>) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</p><p>If the length specifier <code>l</code> is not used, the conversion specifiers <code>c</code>, <code>s</code>, and <code>[</code> perform wide-to-multibyte character conversion as if by calling <a href="http://en.cppreference.com/w/c/string/multibyte/wcrtomb" title="c/string/multibyte/wcrtomb"><tt>wcrtomb()</tt></a> with an <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t" title="c/string/multibyte/mbstate t"><tt>mbstate_t</tt></a> object initialized to zero before the first character is converted.</p><p>The conversion specifiers <code>s</code> and <code>[</code> always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width.</p><p>The correct conversion specifications for the <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">fixed-width integer types</a> (<code>int8_t</code>, etc) are defined in the header <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;inttypes.h&gt;</a> (although <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer"><tt>SCNdMAX</tt></a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer"><tt>SCNuMAX</tt></a>, etc is synonymous with <code>%jd</code>, <code>%ju</code>, etc).</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the action of each conversion specifier; this permits storing multiple fields in the same "sink" variable.</p><p>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing <code>"100er"</code> with the conversion specifier <code>%f</code>, the sequence <code>"100e"</code> (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with <code>"r"</code> remaining. Existing implementations do not follow this rule and roll back to consume only <code>"100"</code>, leaving <code>"er"</code>, e.g. <a class="external text" href="https://sourceware.org/bugzilla/show_bug.cgi?id=1765" rel="nofollow">glibc bug 1765</a></p><p><br/></p></td></tr><tr><td>  vlist</td><td> -</td><td>  variable argument list containing the receiving arguments</td></tr></table><span class="prog__sub"> Return value</span><div>1-3) Number of receiving arguments successfully assigned, or <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> if read failure occurs before the first receiving argument was assigned.</div><div>4-6) Same as (1-3), except that <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> is also returned if there is a runtime constraint violation.</div></section>	http://en.cppreference.com/w/c/io/vfwscanf
C keywords: _Alignas (since C11)	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/_Alignas" title="c/language/ Alignas"><tt>_Alignas</tt></a> alignment specifier.</li></ul></section>	http://en.cppreference.com/w/c/keyword/_Alignas
C keywords: _Alignof (since C11)	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof"> <code>_Alignof</code> operator</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/_Alignof
C keywords: _Atomic	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic"> atomic type specifier and qualifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/_Atomic
C keywords: _Bool	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/arithmetic_types#Boolean_type" title="c/language/arithmetic types"> boolean type</a>: as the declaration of the type</li></ul></section>	http://en.cppreference.com/w/c/keyword/_Bool
C keywords: _Complex	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/arithmetic_types#Complex_floating_types" title="c/language/arithmetic types"> <code>_Complex</code> type</a>: as the declaration of the type</li></ul></section>	http://en.cppreference.com/w/c/keyword/_Complex
C keywords: _Generic	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic"> Type-generic expression</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/_Generic
C keywords: _Imaginary	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/arithmetic_types#Imaginary_floating_types" title="c/language/arithmetic types"> imaginary floating type</a> specifier</li></ul></section>	http://en.cppreference.com/w/c/keyword/_Imaginary
C keywords: _Noreturn (since C11)	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/_Noreturn" title="c/language/ Noreturn"> _Noreturn function specifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/_Noreturn
C keywords: _Static_assert	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/_Static_assert" title="c/language/ Static assert">static assert declaration</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/_Static_assert
C keywords: _Thread_local (since C11)	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration"> thread storage-class specifier</a>.</li></ul></section>	http://en.cppreference.com/w/c/keyword/_Thread_local
C keywords: auto	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration"> automatic duration storage-class specifier</a> with no linkage.</li></ul></section>	http://en.cppreference.com/w/c/keyword/auto
C keywords:  break	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/break" title="c/language/break"> <code>break</code> statement</a>: as the declaration of the statement</li></ul></section>	http://en.cppreference.com/w/c/keyword/break
C keywords: case	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch"> <code>switch</code> statement</a>: as the declaration of the case labels</li></ul></section>	http://en.cppreference.com/w/c/keyword/case
C keywords: char	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <i>type specifier</i> for the <a href="http://en.cppreference.com/w/c/language/arithmetic_types#Character_types" title="c/language/arithmetic types"> character types</a> (<code>char</code>, <code>signed char</code>, and <code>unsigned char</code>).</li></ul></section>	http://en.cppreference.com/w/c/keyword/char
C keywords: const	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const"> <code>const</code> type qualifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/const
C keywords: continue	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/continue" title="c/language/continue"> <code>continue</code> statement</a>: as the declaration of the statement</li></ul></section>	http://en.cppreference.com/w/c/keyword/continue
C keywords: default	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch"> <code>switch</code> statement</a>: as the declaration of the default case label</li></ul><table><tr><td><ul><li> <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic"> type-generic expression</a>: as the declaration of the default generic association</li></ul></td><td>(since C11)</td></tr></table></section>	http://en.cppreference.com/w/c/keyword/default
C keywords: do	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do"> <code>do-while</code> loop</a>: as the declaration of the loop</li></ul></section>	http://en.cppreference.com/w/c/keyword/do
C keywords: double	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types"> <code>double</code> type</a>: as the declaration of the type</li></ul></section>	http://en.cppreference.com/w/c/keyword/double
C keywords: else	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/if" title="c/language/if"> <code>if</code> statement</a>: as the declaration of the alternative branch</li></ul></section>	http://en.cppreference.com/w/c/keyword/else
C keywords: enum	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum"> declaration of an enumeration type</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/enum
C keywords: extern	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration"> static duration storage-class specifier</a> with either internal or more usually external linkage.</li></ul></section>	http://en.cppreference.com/w/c/keyword/extern
C keywords: float	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types"> <code>float</code> type</a>: as the declaration of the type</li></ul></section>	http://en.cppreference.com/w/c/keyword/float
C keywords: for	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for"> <code>for</code> loop</a>: as the declaration of the loop</li></ul></section>	http://en.cppreference.com/w/c/keyword/for
C keywords: fortran	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> conditionally-supported type specifier for Fortran language linkage. May be used with <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declarations</a> and other <a href="http://en.cppreference.com/w/c/language/extern" title="c/language/extern">external declarations</a> to indicate that the calling convention and name mangling is suitable for linking with translation units written in the Fortran programming language.</li></ul></section>	http://en.cppreference.com/w/c/keyword/fortran
C keywords: goto	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto"> <code>goto</code> statement</a>: as the declaration of the statement</li></ul></section>	http://en.cppreference.com/w/c/keyword/goto
C keywords: if	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/if" title="c/language/if"> <code>if</code> statement</a>: as the declaration of the <code>if</code> statement</li></ul></section>	http://en.cppreference.com/w/c/keyword/if
C keywords: inline (since C99)	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/inline" title="c/language/inline"> inline function specifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/inline
C keywords: int	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types"> <code>int</code> type</a>: as the declaration of the type</li></ul></section>	http://en.cppreference.com/w/c/keyword/int
C keywords: long	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types"> <code>long</code> type modifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/long
C keywords: register	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration"> automatic duration storage-class specifier</a> with no linkage. Hints that the variable will be used heavily.</li></ul></section>	http://en.cppreference.com/w/c/keyword/register
C keywords: restrict	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict"> <code>restrict</code> type qualifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/restrict
C keywords: return	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return"> <code>return</code> statement</a>: as the declaration of the statement</li></ul></section>	http://en.cppreference.com/w/c/keyword/return
C keywords: short	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types"> <code>short</code> type modifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/short
C keywords: signed	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types"> <code>signed</code> type modifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/signed
C keywords: sizeof	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof"> <code>sizeof</code> operator</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/sizeof
C keywords: static	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration"> static duration storage-class specifier</a> with internal linkage at file scope and no linkage at block scope.</li></ul><table><tr><td><ul><li> static <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array indices</a> in function parameter declarations.</li></ul></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/keyword/static
C keywords: struct	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct"> declaration of a compound type</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/struct
C keywords: switch	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch"> <code>switch</code> statement</a>: as the declaration of the statement</li></ul></section>	http://en.cppreference.com/w/c/keyword/switch
C keywords: typedef	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef"> <code>typedef</code> declaration</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/typedef
C keywords: union	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union"> declaration of a union type</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/union
C keywords: unsigned	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types"> <code>unsigned</code> type modifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/unsigned
C keywords: void	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types"> <code>void</code> type</a>: as the declaration of the incomplete type</li><li> <a class="new" href="/mwiki/index.php?title=c/language/function&amp;action=edit&amp;redlink=1" title="c/language/function (page does not exist)"> <code>void</code></a>: in a function with no parameter or no return value</li></ul></section>	http://en.cppreference.com/w/c/keyword/void
C keywords: volatile	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile"> <code>volatile</code> type qualifier</a></li></ul></section>	http://en.cppreference.com/w/c/keyword/volatile
C keywords: while	A										<section class="prog__container"><span class="prog__sub"> Usage</span><ul><li> <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while"> <code>while</code> loop</a>: as the declaration of the loop</li><li> <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do"> <code>do-while</code> loop</a>: as the declaration of the terminating condition of the loop</li></ul></section>	http://en.cppreference.com/w/c/keyword/while
alignas	A										<section class="prog__container"><p>Appears in the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a> syntax as one of the type specifiers to modify the <a href="http://en.cppreference.com/w/c/language/object#Alignment" title="c/language/object">alignment requirement</a> of the object being declared.</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Alignas</code> <code>(</code> expression <code>)</code></td><td> (1)</td><td> (since C11)</td></tr><tr><td></td></tr><tr><td> <code>_Alignas</code> <code>(</code> type <code>)</code></td><td> (2)</td><td> (since C11)</td></tr><tr><td></td></tr></table><table><tr><td> expression</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">integer constant expression</a> whose value is a valid <a href="http://en.cppreference.com/w/c/language/object#Alignment" title="c/language/object">alignment</a> or zero</td></tr><tr><td> type</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/type#Type_names" title="c/language/type">type name</a></td></tr></table><p>This keyword is also available as convenience macro <a href="http://en.cppreference.com/w/c/types" title="c/types"><tt>alignas</tt></a>, available in the header <code>&lt;stdalign.h&gt;</code>.</p><span class="prog__sub"> Explanation</span><p>The alignas specifier can only be used when declaring objects that aren't <a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field">bit fields</a>, and don't have the <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">register</a> storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.</p><p>When used in a declaration, the declared object will have its <a href="http://en.cppreference.com/w/c/language/object#Alignment" title="c/language/object">alignment requirement</a> set to </p><div>1) the result of the expression, unless it is zero</div><div>2) to the alignment requirement of type, that is, to <code>alignof(type)</code></div><p>except when this would weaken the alignment the type would have had naturally.<br></p><p>If expression evaluates to zero, this specifier has no effect.</p><p>When multiple alignas specifiers appear in the same declaration, the strictest one is used.<br></p><p>Alignas specifier only needs to appear on the <a href="http://en.cppreference.com/w/c/language/declarations#Definitions" title="c/language/declarations">definition</a> of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.</p></section>	http://en.cppreference.com/w/c/language/_Alignas
_Alignof operator	A										<section class="prog__container"><p>Queries the alignment requirement of its operand type.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Alignof(</code> type-name <code>)</code></td><td></td><td> (since C11)</td></tr><tr><td></td></tr></table><p>This operator is typically used through the convenience macro <a href="http://en.cppreference.com/w/c/types" title="c/types"><tt>alignof</tt></a>, which is provided in the header <code>stdalign.h</code></p><span class="prog__sub"> Explanation</span><p>Returns the <a href="http://en.cppreference.com/w/c/language/object#Alignment" title="c/language/object">alignment requirement</a> of the type <a href="http://en.cppreference.com/w/c/language/type#Type_names" title="c/language/type">named</a> by type-name. If type-name is an array type, the result is the alignment requirement of the array element type. The type-name cannot be function type or an incomplete type.</p><p>The result is an integer constant of type <a href="http://en.cppreference.com/w/c/types/size_t" title="c/types/size t">size_t</a>.</p><p>The operand is not evaluated (so external identifiers used in the operand do not have to be defined)<br></p></section>	http://en.cppreference.com/w/c/language/_Alignof
_Noreturn function specifier	A										<section class="prog__container"><p>Specifies that the function does not return to its point of invocation.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Noreturn</code> function_declaration</td><td></td><td> (since C11)</td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>The <code>_Noreturn</code> keyword appears in a function declaration and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a>). If the function declared <code>_Noreturn</code> returns, the behavior is undefined. A compiler diagnostic is recommended if this can be detected.</p><p>The <code>_Noreturn</code> specifier may appear more than once in the same function declaration, the behavior is the same as if it appeared once.</p><p>This specifier is typically used through the convenience macro <a href="http://en.cppreference.com/w/c/types" title="c/types"><tt>noreturn</tt></a>, which is provided in the header <code>stdnoreturn.h</code></p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/_Noreturn" title="c/keyword/ Noreturn"><tt>_Noreturn</tt></a></p><span class="prog__sub"> Standard library</span><p>The following functions are <code>noreturn</code> in the standard library:</p><ul><li> <a href="http://en.cppreference.com/w/c/program/abort" title="c/program/abort">abort()</a></li><li> <a href="http://en.cppreference.com/w/c/program/exit" title="c/program/exit">exit()</a></li><li> <a href="http://en.cppreference.com/w/c/program/_Exit" title="c/program/ Exit">_Exit()</a></li><li> <a href="http://en.cppreference.com/w/c/program/quick_exit" title="c/program/quick exit">quick_exit()</a></li><li> <a href="http://en.cppreference.com/w/c/thread/thrd_exit" title="c/thread/thrd exit">thrd_exit()</a></li><li> <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp()</a></li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdnoreturn.h&gt;\xc2\xa0// causes undefined behavior if i &lt;= 0// exits if i &gt; 0noreturn void stop_now(int i) // or _Noreturn void stop_now(int i){    if (i &gt; 0) <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(i);}\xc2\xa0int main(void){  <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("Preparing to stop...");  stop_now(2);  <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("This code is never executed.");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Preparing to stop...</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/_Noreturn
static assert declaration	A										<section class="prog__container"><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Static_assert</code> <code>(</code> expression <code>,</code> message <code>)</code></td><td></td><td> (since C11)</td></tr><tr><td></td></tr></table><table><tr><td> expression</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">integer constant expression</a></td></tr><tr><td> message</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literal</a></td></tr></table><p>This keyword is also available as convenience macro <a href="http://en.cppreference.com/w/c/error/static_assert" title="c/error/static assert"><tt>static_assert</tt></a>, available in the header <code>&lt;assert.h&gt;</code>.</p><span class="prog__sub"> Explanation</span><p>The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message as part of the error message (except that characters not in <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">basic source character set</a> aren't required to be displayed).</p><p>Otherwise, if expression does not equal zero, nothing happens; no code is emitted.</p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/_Static_assert" title="c/keyword/ Static assert"><tt>_Static_assert</tt></a></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;assert.h&gt;int main(void){    // Test if math works.    static_assert(2 + 2 == 4, "Whoa dude!"); // or _Static_assert(...\xc2\xa0    // This will produce an error at compile time.    static_assert(sizeof(int) &lt; sizeof(char),                 "this program requires that int is less than char");}</code></pre></div></div><p><br/></p></div></section>	http://en.cppreference.com/w/c/language/_Static_assert
alignas	A										<section class="prog__container"><p>Appears in the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a> syntax as one of the type specifiers to modify the <a href="http://en.cppreference.com/w/c/language/object#Alignment" title="c/language/object">alignment requirement</a> of the object being declared.</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Alignas</code> <code>(</code> expression <code>)</code></td><td> (1)</td><td> (since C11)</td></tr><tr><td></td></tr><tr><td> <code>_Alignas</code> <code>(</code> type <code>)</code></td><td> (2)</td><td> (since C11)</td></tr><tr><td></td></tr></table><table><tr><td> expression</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">integer constant expression</a> whose value is a valid <a href="http://en.cppreference.com/w/c/language/object#Alignment" title="c/language/object">alignment</a> or zero</td></tr><tr><td> type</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/type#Type_names" title="c/language/type">type name</a></td></tr></table><p>This keyword is also available as convenience macro <a href="http://en.cppreference.com/w/c/types" title="c/types"><tt>alignas</tt></a>, available in the header <code>&lt;stdalign.h&gt;</code>.</p><span class="prog__sub"> Explanation</span><p>The alignas specifier can only be used when declaring objects that aren't <a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field">bit fields</a>, and don't have the <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">register</a> storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.</p><p>When used in a declaration, the declared object will have its <a href="http://en.cppreference.com/w/c/language/object#Alignment" title="c/language/object">alignment requirement</a> set to </p><div>1) the result of the expression, unless it is zero</div><div>2) to the alignment requirement of type, that is, to <code>alignof(type)</code></div><p>except when this would weaken the alignment the type would have had naturally.<br></p><p>If expression evaluates to zero, this specifier has no effect.</p><p>When multiple alignas specifiers appear in the same declaration, the strictest one is used.<br></p><p>Alignas specifier only needs to appear on the <a href="http://en.cppreference.com/w/c/language/declarations#Definitions" title="c/language/declarations">definition</a> of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.</p></section>	http://en.cppreference.com/w/c/language/alignas
_Alignof operator	A										<section class="prog__container"><p>Queries the alignment requirement of its operand type.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Alignof(</code> type-name <code>)</code></td><td></td><td> (since C11)</td></tr><tr><td></td></tr></table><p>This operator is typically used through the convenience macro <a href="http://en.cppreference.com/w/c/types" title="c/types"><tt>alignof</tt></a>, which is provided in the header <code>stdalign.h</code></p><span class="prog__sub"> Explanation</span><p>Returns the <a href="http://en.cppreference.com/w/c/language/object#Alignment" title="c/language/object">alignment requirement</a> of the type <a href="http://en.cppreference.com/w/c/language/type#Type_names" title="c/language/type">named</a> by type-name. If type-name is an array type, the result is the alignment requirement of the array element type. The type-name cannot be function type or an incomplete type.</p><p>The result is an integer constant of type <a href="http://en.cppreference.com/w/c/types/size_t" title="c/types/size t">size_t</a>.</p><p>The operand is not evaluated (so external identifiers used in the operand do not have to be defined)<br></p></section>	http://en.cppreference.com/w/c/language/alignof
Analyzability	A										<section class="prog__container"><p>This optional extension to the C language limits the potential results of executing some forms of undefined behavior, which improves the effectiveness of static analysis of such programs. Analyzability is only guaranteed to be enabled if the <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace">predefined macro constant</a> <code>__STDC_ANALYZABLE__</code>(C11) is defined by the compiler.</p><p>If the compiler supports analyzability, any language or library construct whose behavior is undefined is further classified between <i>critical</i> and <i>bounded</i> undefined behavior, and the behavior of all bounded UB cases is limited as specified below. </p><span class="prog__sub"> Critical undefined behavior</span><p>Critical UB is undefined behavior that might perform a memory write or a volatile memory read out of bounds of any object. A program that has critical undefined behavior may be susceptible to security exploits.<br></p><p>Only the following undefined behaviors are critical:<br></p><ul><li> access to an object outside of its <a href="http://en.cppreference.com/w/c/language/lifetime" title="c/language/lifetime">lifetime</a> (e.g. through a dangling pointer)</li><li> write to an object whose declarations are not <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a></li><li> function call through a function pointer whose type is not <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> with the type of the function it points to</li><li> <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue expression</a> is evaluated, but does not designate an object</li><li> attempted modification of a <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literal</a></li><li> <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">dereferencing</a> an invalid (null, indeterminate, etc) or  <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">past-the-end</a> pointer</li><li> modification of a <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const object</a> through a non-const pointer</li><li> call to a standard library function or macro with an invalid argument</li><li> call to a variadic standard library function with unexpected argument type (e.g. call to <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">printf</a> with an argument of the type that doesn't match its conversion specifier)</li><li> <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a> where there is no <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a> up the calling scope, across threads, or from within the scope of a VM type.</li><li> any use of the pointer that was deallocated by <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> or <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc</a></li><li> any <a href="http://en.cppreference.com/w/c/string/byte" title="c/string/byte">string</a> or <a href="http://en.cppreference.com/w/c/string/wide" title="c/string/wide">wide string</a> library function accesses an array out of bounds</li></ul><span class="prog__sub"> Bounded undefined behavior</span><p>Bounded UB is undefined behavior that cannot perform an illegal memory write, although it may trap and may produce or store indeterminate values.<br></p><ul><li> All undefined behavior not listed as critical is bounded, including</li></ul><dl><dd><ul><li> multithreaded data races</li><li> use of a <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">indeterminate values</a> with automatic storage duration</li><li> <a href="http://en.cppreference.com/w/c/language/object#Strict_aliasing" title="c/language/object">strict aliasing</a> violations</li><li> <a href="http://en.cppreference.com/w/c/language/object#alignment" title="c/language/object">misaligned</a> object access</li><li> signed integer overflow</li><li> <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">unsequenced side-effects</a> modify the same scalar or modify and read the same scalar</li><li> floating-to-integer or pointer-to-integer <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">conversion</a> overflow</li><li> <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">bitwise shift</a> by a negative or too large bit count</li><li> <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">integer division</a> by zero</li><li> use of a void expression</li><li> direct <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">assignment</a> or <a href="http://en.cppreference.com/w/c/string/byte/memcpy" title="c/string/byte/memcpy">memcpy</a> of inexactly-overlapped objects</li><li> <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> violations</li><li> etc.. ALL undefined behavior that's not in the critical list.</li></ul></dd></dl></section>	http://en.cppreference.com/w/c/language/analyzability
Arithmetic types	A										<section class="prog__container"><p><small>(See also <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">type</a> for type system overview and <a href="http://en.cppreference.com/w/c/types" title="c/types"> the list of type-related utilities</a> that are provided by the C library)</small></p><table><tr><td><span class="prog__sub"> Boolean type</span><dl><dd><ul><li> <code>_Bool</code> (also accessible as the macro <a href="http://en.cppreference.com/w/c/types/boolean" title="c/types/boolean">bool</a>) - type, capable of holding one of the two values: 1 and 0 (also accessible as the macros <a href="http://en.cppreference.com/w/c/types/boolean" title="c/types/boolean">true</a> and <a href="http://en.cppreference.com/w/c/types/boolean" title="c/types/boolean">false</a>).</li></ul></dd></dl><p>Note that <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">conversion</a> to _Bool does not work the same as conversion to other integer types: <code>(bool)0.5</code> evaluates to <code>1</code>, whereas <code>(int)0.5</code> evaluates to <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.</p></td><td>(since C99)</td></tr></table><span class="prog__sub"> Character types</span><dl><dd><ul><li><code>signed char</code> - type for signed character representation.</li><li><code>unsigned char</code> - type for unsigned character representation. Also used to inspect <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">object representations</a> (raw memory).</li><li><code>char</code> - type for character representation. Equivalent to either <code>signed char</code> or <code>unsigned char</code> (which one is implementation-defined and may be controlled by a compiler commandline switch), but <code>char</code> is a distinct type, different from both <code>signed char</code> both <code>unsigned char</code></li></ul></dd></dl><p>Note that the standard library also defines <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a> names <a href="http://en.cppreference.com/w/c/string/wide" title="c/string/wide">wchar_t</a> , <a href="http://en.cppreference.com/w/c/string/multibyte" title="c/string/multibyte">char16_t</a>, and <a href="http://en.cppreference.com/w/c/string/multibyte" title="c/string/multibyte">char32_t</a> (since C11) to represent wide characters.</p><span class="prog__sub"> Integer types</span><dl><dd><ul><li><code>short int</code> (also accessible as <code>short</code>, may use the keyword <code>signed</code>)</li><li><code>unsigned short int</code> (also accessible as <code>unsigned short</code>)</li><li><code>int</code> (also accessible as <code>signed int</code>)</li></ul><dl><dd> This is the most optimal integer type for the platform, and is guaranteed to be at least 16 bits. Most current systems use 32 bits (see Data models below).</dd></dl><ul><li><code>unsigned int</code> (also accessible as <code>unsigned</code>), the unsigned counterpart of <code>int</code>,  implementing modulo arithmetic. Suitable for bit manipulations.</li><li><code>long int</code> (also accessible as <code>long</code>)</li><li><code>unsigned long int</code> (also accessible as <code>unsigned long</code>)</li></ul></dd></dl><table><tr><td><dl><dd><ul><li><code>long long int</code> (also accessible as <code>long long</code>)</li><li><code>unsigned long long int</code> (also accessible as <code>unsigned long long</code>)</li></ul></dd></dl></td><td>(since C99)</td></tr></table><p>Note: as with all type specifiers, any order is permitted: <code>unsigned long long int</code> and <code>long int unsigned long</code> name the same type.</p><p>The following table summarizes all available integer types and their properties:<br></p><table><tr><th rowspan="2"> Type specifier</th><th rowspan="2"> Equivalent type</th><th colspan="5"> Width in bits by data model</th></tr><tr><th> C standard</th><th> LP32</th><th> ILP32</th><th> LLP64</th><th> LP64</th></tr><tr><td> <div><code>short</code></div></td><td> <code>short int</code></td><td> at least<br/> <b>16</b></td><td> <b>16</b></td><td> <b>16</b></td><td> <b>16</b></td><td> <b>16</b></td></tr><tr><td> <div><code>short int</code></div></td></tr><tr><td> <div><code>signed short</code></div></td></tr><tr><td> <div><code>signed short int</code></div></td></tr><tr><td> <div><code>unsigned short</code></div></td><td> <code>unsigned short int</code></td></tr><tr><td> <div><code>unsigned short int</code></div></td></tr><tr><td> <div><code>int</code></div></td><td> <code>int</code></td><td> at least<br/> <b>16</b></td><td> <b>16</b></td><td> <b>32</b></td><td> <b>32</b></td><td> <b>32</b></td></tr><tr><td> <div><code>signed</code></div></td></tr><tr><td> <div><code>signed int</code></div></td></tr><tr><td> <div><code>unsigned</code></div></td><td> <code>unsigned int</code></td></tr><tr><td> <div><code>unsigned int</code></div></td></tr><tr><td> <div><code>long</code></div></td><td> <code>long int</code></td><td> at least<br/> <b>32</b></td><td> <b>32</b></td><td> <b>32</b></td><td> <b>32</b></td><td> <b>64</b></td></tr><tr><td> <div><code>long int</code></div></td></tr><tr><td> <div><code>signed long</code></div></td></tr><tr><td> <div><code>signed long int</code></div></td></tr><tr><td> <div><code>unsigned long</code></div></td><td> <code>unsigned long int</code></td></tr><tr><td> <div><code>unsigned long int</code></div></td></tr><tr><td> <div><code>long long</code></div></td><td> <code>long long int</code> <br/> (C99)</td><td> at least<br/> <b>64</b></td><td> <b>64</b></td><td> <b>64</b></td><td> <b>64</b></td><td> <b>64</b></td></tr><tr><td> <div><code>long long int</code></div></td></tr><tr><td> <div><code>signed long long</code></div></td></tr><tr><td> <div><code>signed long long int</code></div></td></tr><tr><td> <div><code>unsigned long long</code></div></td><td> <code>unsigned long long int</code> <br/> (C99)</td></tr><tr><td> <div><code>unsigned long long int</code></div></td></tr></table><p>Besides the minimal bit counts, the C Standard guarantees that<br></p><dl><dd><code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>.</dd></dl><p>Note: this allows the extreme case in which <a class="extiw" href="http://en.wikipedia.com/wiki/Byte" title="enwiki:Byte">bytes</a> are sized 64 bits, all types (including <code>char</code>) are 64 bits wide, and <code>sizeof</code> returns 1 for every type.</p><p>Note: integer arithmetic is defined differently for the signed and unsigned integer types. See <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a>, in particular  <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Overflows" title="c/language/operator arithmetic">integer overflows</a>.</p><h4> Data models</h4><p>The choices made by each implementation about the sizes of the fundamental types are collectively known as <i>data model</i>. Four data models found wide acceptance:</p><p>32 bit systems:<br></p><dl><dd><ul><li><b>LP32</b> or <b>2/4/4</b> (int is 16-bit, long and pointer are 32-bit)</li></ul><dl><dd><ul><li> Win16 API</li></ul></dd></dl><ul><li><b>ILP32</b> or <b>4/4/4</b> (int, long, and pointer are 32-bit);</li></ul><dl><dd><ul><li> Win32 API</li><li> Unix and Unix-like systems (Linux, Mac OS X)</li></ul></dd></dl></dd></dl><p>64 bit systems:<br></p><dl><dd><ul><li> <b>LLP64</b> or <b>4/4/8</b> (int and long are 32-bit, pointer is 64-bit)</li></ul><dl><dd><ul><li> Win64 API</li></ul></dd></dl><ul><li> <b>LP64</b> or <b>4/8/8</b> (int is 32-bit, long and pointer are 64-bit)</li></ul><dl><dd><ul><li> Unix and Unix-like systems (Linux, Mac OS X)</li></ul></dd></dl></dd></dl><p>Other models are very rare. For example, <b>ILP64</b> (<b>8/8/8</b>: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).</p><p>Note that exact-width integer types are available in <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">&lt;stdint.h&gt;</a> since C99</p><span class="prog__sub"> Real floating types</span><p>C has three types for representing real floating-point values:<br></p><dl><dd><ul><li><code>float</code> - single precision floating point type. Matches IEEE-754 32 bit floating point type if supported.</li><li><code>double</code> - double precision floating point type. Matches IEEE-754 64 bit floating point type if supported</li><li><code>long double</code> - extended precision floating point type. Matches IEEE-754 extended floating-point type if supported, otherwise matches some non-standard extended floating-point type as long as its precision is better than <code>double</code> and range is at least as good as <code>double</code>, otherwise matches the type <code>double</code>. Some x86 and x86_64 implementations use the 80-bit x87 floating point type.</li></ul></dd></dl><p>Floating-point types may support special values:<br></p><ul><li> <i>infinity</i> (positive and negative), see <a href="http://en.cppreference.com/w/c/numeric/math/INFINITY" title="c/numeric/math/INFINITY"><tt>INFINITY</tt></a></li><li> the <i>negative zero</i>, <code>-0.0</code>. It compares equal to the positive zero, but is meaningful in some arithmetic operations, e.g. <code>1.0/0.0 == INFINITY</code>, but <code>1.0/-0.0 == -INFINITY</code>)</li><li> <i>not-a-number</i> (NaN), which does not compare equal with anything (including itself). Multiple bit patterns represent NaNs, see <a href="http://en.cppreference.com/w/c/numeric/math/nan" title="c/numeric/math/nan">nan</a>, <a href="http://en.cppreference.com/w/c/numeric/math/NAN" title="c/numeric/math/NAN"><tt>NAN</tt></a>. Note that C takes no special notice of signalling NaNs (specified by IEEE-754), and treates all NaNs as quiet.</li></ul><p>Real floating-point numbers may be used with <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> + - / * and various mathematical functions from <a href="http://en.cppreference.com/w/c/numeric/math" title="c/numeric/math">math.h</a>. Both built-in operators and library functions may raise floating-point exceptions and set <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> as described in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling"><tt>math_errhandling</tt></a></p><p>Floating-point expressions may have greater range and precision than indicated by their types, see <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a>. <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">Assignment</a>, <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return">return</a>, and <a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast">cast</a> force the range and precision to the one associated with the declared type. </p><p>Floating-point expressions may also be <i>contracted</i>, that is, calculated as if all intermediate values have infinite range and precision, see <a href="http://en.cppreference.com/w/c/preprocessor/impl#Standard_pragmas" title="c/preprocessor/impl">#pragma STDC FP_CONTRACT</a>.</p><p>Some operations on floating-point numbers are affected by and modify the state of <a href="http://en.cppreference.com/w/c/numeric/fenv" title="c/numeric/fenv">the floating-point environment</a> (most notably, the rounding direction)</p><p><a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">Implicit conversions</a> are defined between real floating types and integer, complex, and imaginary types.</p><p>See <a href="http://en.cppreference.com/w/c/types/limits#Limits_of_floating_point_types" title="c/types/limits">Limits of floating point types</a> and <a href="http://en.cppreference.com/w/c/numeric/math" title="c/numeric/math">the math.h library</a> for additional details, limits, and properties of the floating-point types.</p><table><tr><td><span class="prog__sub"> Complex floating types</span><p>Complex floating types model the mathematical <a class="extiw" href="http://en.wikipedia.com/wiki/Complex_number" title="enwiki:Complex number">complex numbers</a>, that is the numbers that can be written as a sum of a real number and a real number multiplied by the imaginary unit: a + bi</p><p>The three complex types are<br></p><dl><dd><ul><li> <code>float _Complex</code> (also available as <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> if <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included)</li><li> <code>double _Complex</code> (also available as <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> if <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included)</li><li> <code>long double _Complex</code> (also available as <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> if <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included)</li></ul></dd></dl><p>Note: as with all type specifiers, any order is permitted: <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code><a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> long double</code>, and even <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> long</code> name the same type.</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;complex.h&gt;#include &lt;stdio.h&gt;int main(void){    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z = 1 + 2*I;    z = 1/z;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1/(1.0+2.0i) =\xc2\xa0%.1f%+.1fi\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>1/(1.0+2.0i) = 0.2-0.4i</code></pre></div></div></div><table><tr><td>If the macro constant <code>__STDC_NO_COMPLEX__</code>(C11) is defined by the implementation, the complex types (as well as the library header <code>&lt;complex.h&gt;</code>) are not provided.</td><td>(since C11)</td></tr></table><p>Each complex type has the same <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">object representation</a> and <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">alignment requirements</a> as an <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array</a> of two elements of the corresponding real type (<code>float</code> for <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>double</code> for <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>long double</code> for <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>). The first element of the array holds the real part, and the second element of the array holds the imaginary component.</p><div><div><pre><code>float a[4] = {1, 2, 3, 4};float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z1, z2;<a href="http://en.cppreference.com/w/c/string/byte/memcpy">memcpy</a>(&amp;z1, a, sizeof z1); // z1 becomes 1.0 + 2.0i<a href="http://en.cppreference.com/w/c/string/byte/memcpy">memcpy</a>(&amp;z2, a+2, sizeof z2); // z2 becomes 3.0 + 4.0i</code></pre></div></div><p>Complex numbers may be used with <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> + - * and /, possibly mixed with imaginary and real numbers. There are many mathematical functions defined for complex numbers in <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">complex.h</a>. Both built-in operators and library functions may raise floating-point exceptions and set <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> as described in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling"><tt>math_errhandling</tt></a></p><p>Increment and decrement are not defined for complex types<br></p><p>Relational operators are not defined for complex types (there is no notion of "less than")<br></p><table><tr><td></td><td>This section is incomplete<br/>Reason: review other ops, link library </td></tr></table><a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">Implicit conversions</a> are defined between complex types and other arithmetic types.<p>In order to support the one-infinity model of complex number arithmetic, C regards any complex value with at least one infinite part as an infinity even if its other part is a NaN, guarantees that all operators and functions honor basic properties of inifinities and provides <a href="http://en.cppreference.com/w/c/numeric/complex/cproj" title="c/numeric/complex/cproj">cproj</a> to map all infinities to the canonical one (see <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> for the exact rules)</p><div><div><div>Run this code</div></div><div><div><pre><code>#include&lt;stdio.h&gt;#include &lt;stdio.h&gt;#include &lt;complex.h&gt;#include &lt;math.h&gt;int main(void){   double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z = (1 + 0*I) * (INFINITY + I*INFINITY);// textbook formula would give// (1+i0)(\xe2\x88\x9e+i\xe2\x88\x9e) \xe2\x87\x92 (1\xc3\x97\xe2\x88\x9e \xe2\x80\x93 0\xc3\x97\xe2\x88\x9e) + i(0\xc3\x97\xe2\x88\x9e+1\xc3\x97\xe2\x88\x9e) \xe2\x87\x92 NaN + I*NaN// but C gives a complex infinity   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f + i*%f\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z));\xc2\xa0// textbook formula would give// cexp(\xe2\x88\x9e+iNaN) \xe2\x87\x92 exp(\xe2\x88\x9e)\xc3\x97(cis(NaN)) \xe2\x87\x92 NaN + I*NaN// but C gives  \xc2\xb1\xe2\x88\x9e+i*nan   double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> y = <a href="http://en.cppreference.com/w/c/numeric/complex/cexp">cexp</a>(INFINITY + I*NAN);   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f + i*%f\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(y), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(y));\xc2\xa0}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>inf + i*inf <br>inf + i*nan</code></pre></div></div></div><p>C also treats multiple infinities so as to preserve directional information where possible, despite the inherent limitations of the Cartesian representation:<br></p><p>multiplying the imaginary unit by real infinity gives the correctly-signed imaginary infinity: i \xc3\x97 \xe2\x88\x9e = i\xe2\x88\x9e. Also, i \xc3\x97 (\xe2\x88\x9e \xe2\x80\x93 i\xe2\x88\x9e) = \xe2\x88\x9e + i\xe2\x88\x9e indicates the reasonable quadrant<br></p><table><tr><td></td><td>This section is incomplete<br/>Reason: wording </td></tr></table><span class="prog__sub"> Imaginary floating types</span><p>Imaginary floating types model the mathematical <a class="extiw" href="http://en.wikipedia.com/wiki/Imaginary_number" title="enwiki:Imaginary number">imaginary numbers</a>, that is numbers that can be written as a real number multiplied by the imaginary unit: biThe three imaginary types are</p><dl><dd><ul><li> <code>float _Imaginary</code> (also available as <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code> if <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included)</li><li> <code>double _Imaginary</code> (also available as <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code> if <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included)</li><li> <code>long double _Imaginary</code> (also available as <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code> if <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included)</li></ul></dd></dl><p>Note: as with all type specifiers, any order is permitted: <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code><a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a> long double</code>, and even <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a> long</code> name the same type.</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;complex.h&gt;#include &lt;stdio.h&gt;int main(void){    double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a> z = 3*I;    z = 1/z;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1/(3.0i) =\xc2\xa0%+.1fi\n", <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>1/(3.0i) = -0.3i</code></pre></div></div></div><table><tr><td><p>A compiler that defines <code>__STDC_IEC_559_COMPLEX__</code> is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro <a href="http://en.cppreference.com/w/c/numeric/complex/Imaginary_I" title="c/numeric/complex/Imaginary I">_Imaginary_I</a> is defined to identify imaginary number support.</p></td><td>(since C99)<br/>(until C11)</td></tr><tr><td><p>Imaginary numbers are supported if <code>__STDC_IEC_559_COMPLEX__</code> is defined.</p></td><td>(since C11)</td></tr></table><p>Each of the three imaginary types has the same <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">object representation</a> and <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">alignment requirement</a> as its <i>corresponding real type</i> (<code>float</code> for <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>double</code> for <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>long double</code> for <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>). </p><p>Note: despite that, imaginary types are distinct and <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">not compatible</a> with their corresponding real types, which prohibits aliasing.</p><p>Imaginary numbers may be used with <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> + - * and /, possibly mixed with complex and real numbers. There are many mathematical functions defined for imaginary numbers in <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">complex.h</a>. Both built-in operators and library functions may raise floating-point exceptions and set <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> as described in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling"><tt>math_errhandling</tt></a></p><p>Increment and decrement are not defined for imaginary types<br></p><table><tr><td></td><td>This section is incomplete<br/>Reason: review other ops, link library </td></tr></table><a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">Implicit conversions</a> are defined between imaginary types and other arithmetic types.<p>The imaginary numbers make it possible to express all complex numbers using the natural notation <code>x + I*y</code> (where I is defined as <a href="http://en.cppreference.com/w/c/numeric/complex/Imaginary_I" title="c/numeric/complex/Imaginary I">_Imaginary_I</a>). Without imaginary types, certain special complex values cannot be created naturally. For example, if I is defined as <a href="http://en.cppreference.com/w/c/numeric/complex/Complex_I" title="c/numeric/complex/Complex I">_Complex_I</a>, then writing <code>0.0 + I*INFINITY</code> gives NaN as the real part, and <code><a href="http://en.cppreference.com/w/c/numeric/complex/CMPLX">CMPLX</a>(0.0, INFINITY)</code> must be used instead. Same goes for the numbers with the negative zero imaginary component, which are meaningful when working with the library functions with branch cuts, such as <a href="http://en.cppreference.com/w/c/numeric/complex/csqrt" title="c/numeric/complex/csqrt">csqrt</a>: <code>1.0 - 0.0*I</code> results in the positive zero imaginary component if I is defined as <a href="http://en.cppreference.com/w/c/numeric/complex/Complex_I" title="c/numeric/complex/Complex I">_Complex_I</a> and the negative zero imaginary part requires the use of <a href="http://en.cppreference.com/w/c/numeric/complex/CMPLX" title="c/numeric/complex/CMPLX">CMPLX</a> or <a href="http://en.cppreference.com/w/c/numeric/complex/conj" title="c/numeric/complex/conj">conj</a>.</p><p>Imaginary types also simplify implementations; multiplication of an imaginary by a complex can be implemented straightforwardly with two multiplications if the imaginary types are supported, instead of four multiplications and two additions.<br></p></td><td>(since C99)</td></tr></table><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/char" title="c/keyword/char"><tt>char</tt></a>, <a href="http://en.cppreference.com/w/c/keyword/int" title="c/keyword/int"><tt>int</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/short" title="c/keyword/short"><tt>short</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/long" title="c/keyword/long"><tt>long</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/signed" title="c/keyword/signed"><tt>signed</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/unsigned" title="c/keyword/unsigned"><tt>unsigned</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/float" title="c/keyword/float"><tt>float</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/double" title="c/keyword/double"><tt>double</tt></a>.<a href="http://en.cppreference.com/w/c/keyword/_Bool" title="c/keyword/ Bool"><tt>_Bool</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/_Complex" title="c/keyword/ Complex"><tt>_Complex</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/_Imaginary" title="c/keyword/ Imaginary"><tt>_Imaginary</tt></a></p><span class="prog__sub"> Range of values</span><p>The following table provides a reference for the limits of common numeric representations. As the C Standard allows any signed integer representation, the table gives both the minimum guaranteed requirements (which correspond to the limits of <a class="extiw" href="http://en.wikipedia.com/wiki/One%27s_complement" title="enwiki:One's complement">one's complement</a> or <a class="extiw" href="http://en.wikipedia.com/wiki/Signed_number_representations#Sign-and-magnitude_method" title="enwiki:Signed number representations">sign-and-magnitude</a>) and the limits of the most commonly used implementation, <a class="extiw" href="http://en.wikipedia.com/wiki/Two%27s_complement" title="enwiki:Two's complement">two's complement</a>. All popular data models (including all of ILP32, LP32, LP64, LLP64) use two's complement representation, though.</p><table><tr><th rowspan="2"> Type</th><th rowspan="2"> Size in bits</th><th rowspan="2"> Format</th><th colspan="2"> Value range</th></tr><tr><th> Approximate</th><th> Exact</th></tr><tr><th rowspan="3"> character</th><td> 8</td><td> signed (one's complement)</td><td> <b>-127</b> to <b>127</b></td></tr><tr><td> signed (two's complement)</td><td> <b>-128</b> to <b>127</b></td></tr><tr><td> unsigned</td><td> <b>0</b> to <b>255</b></td></tr><tr><th rowspan="9"> integral</th><td> 16</td><td> signed (one's complement)</td><td> <b>\xc2\xb1 3.27 \xc2\xb7 10<sup>4</sup></b></td><td> <b>-32767</b> to <b>32767</b></td></tr><tr><td> signed (two's complement)</td><td> <b>-32768</b> to <b>32767</b></td></tr><tr><td> unsigned</td><td> <b>0</b> to <b>6.55 \xc2\xb7 10<sup>4</sup></b></td><td> <b>0</b> to <b>65535</b></td></tr><tr><td> 32</td><td> signed (one's complement)</td><td> <b>\xc2\xb1 2.14 \xc2\xb7 10<sup>9</sup></b></td><td> <b>-2,147,483,647</b> to <b>2,147,483,647</b></td></tr><tr><td> signed (two's complement)</td><td> <b>-2,147,483,648</b> to <b>2,147,483,647</b></td></tr><tr><td> unsigned</td><td> <b>0</b> to <b>4.29 \xc2\xb7 10<sup>9</sup></b></td><td> <b>0</b> to <b>4,294,967,295</b></td></tr><tr><td> 64</td><td> signed (one's complement)</td><td> <b>\xc2\xb1 9.22 \xc2\xb7 10<sup>18</sup></b></td><td> <b>-9,223,372,036,854,775,807</b> to <b>9,223,372,036,854,775,807</b></td></tr><tr><td> signed (two's complement)</td><td> <b>-9,223,372,036,854,775,808</b> to <b>9,223,372,036,854,775,807</b></td></tr><tr><td> unsigned</td><td> <b>0</b> to <b>1.84 \xc2\xb7 10<sup>19</sup></b></td><td> <b>0</b> to <b>18,446,744,073,709,551,615</b></td></tr><tr><th rowspan="2"> floating<br/> point</th><td> 32</td><td> <a class="extiw" href="http://en.wikipedia.com/wiki/IEEE-754" title="enwiki:IEEE-754">IEEE-754</a></td><td> <b>\xc2\xb1 3.4 \xc2\xb7 10<sup>\xc2\xb1 38</sup></b><br/> (~7 digits)</td><td><div><ul><li>min subnormal: <b>\xc2\xb1 1.401,298,4 \xc2\xb7 10<sup>-47</sup></b></li><li>min normal: <b>\xc2\xb1 1.175,494,3 \xc2\xb7 10<sup>-38</sup></b></li><li>max: <b>\xc2\xb1 3.402,823,4 \xc2\xb7 10<sup>38</sup></b></li></ul></div></td></tr><tr><td> 64</td><td> IEEE-754</td><td> <b>\xc2\xb1 1.7 \xc2\xb7 10<sup>\xc2\xb1 308</sup></b><br/> (~15 digits)</td><td> <div><ul><li>min subnormal: <b>\xc2\xb1 4.940,656,458,412 \xc2\xb7 10<sup>-324</sup></b></li><li>min normal: <b>\xc2\xb1 2.225,073,858,507,201,4 \xc2\xb7 10<sup>-308</sup></b></li><li>max: <b>\xc2\xb1 1.797,693,134,862,315,7 \xc2\xb7 10<sup>308</sup></b></li></ul></div></td></tr></table><p>Note: actual (as opposed to guaranteed minimal) ranges are available in the library headers <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">&lt;limits.h&gt; and &lt;float.h&gt;</a></p></section>	http://en.cppreference.com/w/c/language/arithmetic_types
Array declaration	A										<section class="prog__container"><p>Array is a type consisting of a contiguously allocated nonempty sequence of objects with aparticular <i>element type</i>. The number of those objects (the array size) never changes during the array lifetime.</p><span class="prog__sub"> Syntax</span><p>In the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration grammar</a> of an array declaration, the <i>type-specifier</i> sequence designates the <i>element type</i> (which must be a complete object type), and the <i>declarator</i> has the form:</p><table><tr><td></td></tr><tr><td> <code>[</code> <code>static</code>(optional) qualifiers(optional) expression(optional) <code>]</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>[</code> qualifiers(optional) <code>static</code>(optional) expression(optional) <code>]</code></td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>[</code> qualifiers(optional) <code>*</code> <code>]</code></td><td> (3)</td><td></td></tr><tr><td></td></tr></table><div>1,2) General array declarator syntax</div><div>3) Declarator for VLA of unspecified size (can appear in function prototype scope only)where</div><table><tr><td> expression</td><td> -</td><td>  any expression other than <a href="http://en.cppreference.com/w/c/language/operator_other#Comma_operator" title="c/language/operator other">comma operator</a>, designates the number of elements in the array</td></tr><tr><td> qualifiers</td><td> -</td><td>  any combination of <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a>, or <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> qualifiers, only allowed in function parameter lists; this qualifies the pointer type to which this array parameter is transformed</td></tr></table><div><div><pre><code>float fa[11], *afp[17]; // fa is an array of 11 floats                        // afp is an array of 17 pointers to floats</code></pre></div></div><span class="prog__sub"> Explanation</span><p>There are several variations of array types: arrays of known constant size, variable-length arrays, and arrays of unknown size.<br></p><h4> Arrays of constant known size</h4><p>If expression in an array declarator is an <a href="http://en.cppreference.com/w/c/language/constant_expression#Integer_constant_expression" title="c/language/constant expression">integer constant expression</a> with a value greater than zero and the element type is a type with a known constant size (that is, elements are not VLA) (since C99), then the declarator declares an array of constant known size:</p><div><div><pre><code>int n[10]; // integer constants are constant expressionschar o[sizeof(double)]; // sizeof is a constant expressionenum { MAX_SZ=100 };int n[MAX_SZ]; // enum constants are constant expressions</code></pre></div></div><p>Arrays of constant known size can use <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">array initializers</a> to provide their initial values:</p><div><div><pre><code>int a[5] = {1,2,3}; // declares int[5] initalized to 1,2,3,0,0char str[] = "abc"; // declares char[4] initialized to 'a','b','c','\x00'</code></pre></div></div><table><tr><td><p>In function parameter lists, additional syntax elements are allowed within the array declarators: the keyword <code>static</code> and qualifiers, which may appear in any order before the size expression (they may also appear even when the size expression is omitted).</p><p>In each <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call</a> to a function where a parameter of array type uses the keyword <code>static</code> between <code>[</code> and <code>]</code>, the value of the actual parameter must be a valid pointer to the first element of an array with at least as many elements as specified by expression:</p><div><div><pre><code>void fadd(double a[static 10], const double b[static 10]){     for (int i = 0; i &lt; 10; i++) {        if (a[i] &lt; 0.0) return;        a[i] += b[i];    }}// a call to fadd performs compile-time bounds checking// and also permits optimizations such as prefetching 10 doubles int main(void){    double a[10] = {0}, b[20] = {0};    fadd(a, b); // OK    double x[5] = {0};    fadd(x, b); // error: array argument is too small}</code></pre></div></div><p>If qualifiers are present, they qualify the pointer type to which the array parameter type is transformed:</p><div><div><pre><code>int f(const int a[20]){ // in this function, a has type const int* (pointer to const int)}int g(const int a[const 20]){ // in this function, a has type const int* const (const pointer to const int)}</code></pre></div></div><p>This is commonly used with the <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> type qualifier:</p><div><div><pre><code>void fadd(double a[static restrict 10],          const double b[static restrict 10]){    for (int i = 0; i &lt; 10; i++) { // loop can be unrolled and reordered        if (a[i] &lt; 0.0) break;        a[i] += b[i];    }}</code></pre></div></div><h4> Variable-length arrays</h4><p>If expression is not an <a href="http://en.cppreference.com/w/c/language/constant_expression#Integer_constant_expression" title="c/language/constant expression">integer constant expression</a>, the declarator is for an array of variable size.</p><p>Each time the flow of control passes over the declaration, expression is evaluated (and it must always evaluate to a value greater than zero), and the array is allocated (correspondingly, <a href="http://en.cppreference.com/w/c/language/lifetime" title="c/language/lifetime">lifetime</a> of a VLA ends when the declaration goes out of scope). The size of each VLA instance does not change during its lifetime, but on another pass over the same code, it may be allocated with a different size.</p><div><div><pre><code>{   int n = 1;label:   int a[n]; // re-allocated 10 times, each with a different size   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The array has\xc2\xa0%zu elements\n", sizeof a / sizeof *a);   if (n++ &lt; 10) goto label; // leaving the scope of a VLA ends its lifetime}</code></pre></div></div><p>If the size is <code>*</code>, the declaration is for a VLA of unspecified size. Such declaration may only appear in a function prototype scope, and declares an array of a complete type. In fact, all VLA declarators in function prototype scope are treated as if expression were replaced by <code>*</code>.</p><div><div><pre><code>void foo(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> x, int a[*]);void foo(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> x, int a[x]) {    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu\n", sizeof a); // same as sizeof(int*)}</code></pre></div></div><p>Variable-length arrays and the types derived from them (pointers to them, etc) are commonly known as "variably-modified types" (VM). Objects of any variably-modified type may only be declared at block scope or function prototype scope.<br></p><div><div><pre><code>extern int n;int A[n];            // Error: file scope VLAextern int (*p2)[n]; // Error: file scope VMint B[100];          // OK: file-scope array of constant known sizevoid fvla(int m, int C[m][m]); // OK: prototype-scope VLA</code></pre></div></div><p>VLA must have automatic storage duration. Pointers to VLA, but not VLA themselves may also have static storage duration. No VM type may have linkage.<br></p><div><div><pre><code>void fvla(int m, int C[m][m]) // OK: block scope/auto duration pointer to VLA{    typedef int VLA[m][m]; // OK: block scope VLA    int D[m];              // OK: block scope/auto duration VLA//  static int E[m]; // Error: static duration VLA//  extern int F[m]; // Error: VLA with linkage    int (*s)[m];     // OK: block scope/auto duration VM//  extern int (*r)[m]; // Error: VM with linkage    static int (*q)[m] = &amp;B; // OK: block scope/static duration VM}}</code></pre></div></div><p>Variably-modified types cannot be members of structs or unions.<br></p><div><div><pre><code>struct tag {    int z[n]; // Error: VLA struct member    int (*y)[n]; // Error: VM struct member};</code></pre></div></div></td><td>(since C99)</td></tr><tr><td><p>If the compiler defines the macro constant <code>__STDC_NO_VLA__</code> to integer constant <code>1</code>, then VLA and VM types are not supported.</p></td><td>(since C11)</td></tr></table><h4> Arrays of unknown size</h4><p>If expression in an array declarator is omitted, it declares an array of unknown size. Except in function parameter lists (where such arrays are transformed to pointers) and when an  <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">initializer</a> is available, such type is an <a href="http://en.cppreference.com/w/c/language/type#Incomplete_types" title="c/language/type">incomplete type</a> (note that VLA of unspecified size, declared with <code>*</code> as the size, is a complete type) (since C99):</p><div><div><pre><code>extern int x[]; // the type of x is "array of unknown bound of int"int a[] = {1,2,3}; // the type of a is "array of 3 int"</code></pre></div></div><table><tr><td><p>Within a <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> definition, an array of unknown size may appear as the last member (as long as there is at least one other named member), in which case it is a special case known as <i>flexible array member</i>. See <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> for details:</p><div><div><pre><code>struct s { int n; double d[]; }; // s.d is a flexible array member struct s *s1 = <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(sizeof (struct s) + (sizeof (double) * 8)); // as if d was double d[8]</code></pre></div></div></td><td>(since C99)</td></tr></table><span class="prog__sub"> Qualifiers</span><p>If an array type is declared with a <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> (since C99), or <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">_Atomic</a> (since C11) qualifier (which is possible through the use of <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>), the array type is not qualified, but its element type is:</p><div><div><pre><code>typedef int A[2][3];const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const intint* pi = a[0]; // Error: a[0] has type const int*</code></pre></div></div><h4> Assignment</h4><p>Objects of array type are not <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">modifiable lvalues</a>, and although their address may be taken, they cannot appear on the left hand side of an assignment operator. However, structs with array members are modifiable lvalues and can be assigned:</p><div><div><pre><code>int a[3] = {1,2,3}, b[3] = {4,5,6};int (*p)[3] = &amp;a; // okay, address of a can be taken// a = b;            // error, a is an arraystruct { int c[3]; } s1, s2 = {3,4,5};s1 = s2; // okay: can assign structs holding array members</code></pre></div></div><h4> Array to pointer conversion</h4><p>Any <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue expression</a> of array type, when used in any context other than </p><ul><li> as the operand of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">address-of operator</a></li><li> as the operand of <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a></li><li> as the string literal used for <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">array initialization</a></li></ul><table><tr><td><ul><li> as the operand of <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">_Alignof</a></li></ul></td><td>(since C11)</td></tr></table><p>undergoes an <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicit conversion</a> to the pointer to its first element. The result is not an lvalue.</p><p>If the array was declared <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">register</a>, the behavior of the program that attempts such conversion is undefined.</p><div><div><pre><code>int a[3] = {1,2,3};int* p = a;<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu\n", sizeof a); // prints size of array<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu\n", sizeof p); // prints size of a pointer</code></pre></div></div><p>When an array type is used in a function parameter list, it is transformed to the corresponding pointer type: <code>int f(int a[2])</code> and <code>int f(int* a)</code> declare the same function. Since the function's actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:</p><div><div><pre><code>void f(int a[], int sz) // actually declares int f(int* a, int sz){    for(int i = 0; i &lt; sz; ++i)       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", a[i]);}int main(void){    int a[10];    f(a, 10); // converts a to int*, passes the pointer}</code></pre></div></div><h4> Multidimensional arrays</h4><p>When the element type of an array is another array, it is said that the array is multidimensional:<br></p><div><div><pre><code>// array of 2 arrays of 3 ints eachint a[2][3] = {{1,2,3},  // can be viewed as a 2x3 matrix               {4,5,6}}; // with row-major layout</code></pre></div></div><p>Note that when array-to-pointer conversion is applied, a multidimensional array is converted to a pointer to its first element, e.g., pointer to the first row:<br></p><div><div><pre><code>int a[2][3]; // 2x3 matrixint (*p1)[3] = a; // pointer to the first 3-element rowint b[3][3][3]; // 3x3x3 cubeint (*p2)[3][3] = a; // pointer to the first 3x3 plane</code></pre></div></div><table><tr><td><p>Multidimensional arrays may be variably modified in every dimension:<br></p><div><div><pre><code>int n = 10;int a[n][2*n];</code></pre></div></div></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/array
Array initialization	A										<section class="prog__container"><p>When <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">initializing</a> an object of <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array</a> type, the initializer must be either a <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literal</a> (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:</p><table><tr><td></td></tr><tr><td> <code>=</code> string_literal</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>=</code> <code>{ </code> expression <code>,</code> <code>...</code> <code>} </code><p><code>=</code> <code>{ </code> designator(optional) expression <code>,</code> <code>...</code> <code>} </code></p></td><td> (2)</td><td> (until C99)<br/>(since C99)</td></tr><tr><td></td></tr></table><div>1) string literal initializer for character and wide character arrays</div><div>2) comma-separated list of expressions that are initializers for array elements, optionally using array designators of the form <code>[</code> constant-expression <code>]</code> <code>=</code>  (since C99)</div><p>Arrays of known size and arrays of unknown size may be initialized, but not VLAs. (since C99)</p><p>All array elements that are not initialized explicitly are <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">initialized implicitly</a> the same way as objects that have static storage duration.</p><span class="prog__sub"> Initialization from strings</span><p><a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literal</a> (optionally enclosed in braces) may be used as the initializer for an array of matching type:</p><ul><li> ordinary string literals and UTF-8 string literals (since C11) can initialize arrays of any character type (<code>char</code>, <code>signed char</code>, <code>unsigned char</code>)</li><li> L-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications) wchar_t</li></ul><table><tr><td><ul><li> u-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications) char16_t</li><li> U-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications char32_t</li></ul></td><td>(since C11)</td></tr></table><p>Successive bytes of the string literal or wide characters of the wide string literal, including the terminating null byte/character, initialize the elements of the array:<br></p><div><div><pre><code>char str[] = "abc"; // str has type char[4] and holds 'a', 'b'. 'c', '\x00'wchar_t wstr[4] = L"\xe7\x8c\xab"; // str has type wchar_t[4] and holds L'\xe7\x8c\xab', '\x00', '\x00', '\x00'</code></pre></div></div><p>If the size of the array is known, it may be one less than the size of the string literal, in which case the terminating null character is ignored:<br></p><div><div><pre><code>char str[3] = "abc"; // str has type char[3] and holds 'a', 'b', 'c'</code></pre></div></div><p>Note that the contents of such array are modifiable, unlike when accessing a string literal directly with <code>char* str = "abc";</code>.</p><span class="prog__sub"> Initialization from brace-enclosed lists</span><p>When an array is initialized with a brace-enclosed list of initializers, the first initializer in the list initializes the array element at index zero (unless a designator is specified) (since C99), and each subsequent initializers without a designator  (since C99)initializes the array element at index one greater than the one initialized by the previous initializer.</p><div><div><pre><code>int x[] = {1,2,3}; // x has type int[3] and holds 1,2,3int y[5] = {1,2,3}; // y has type int[5] and holds 1,2,3,0,0int z[3] = {0}; // z has type int[3] and holds all zeroes</code></pre></div></div><p>It's an error to provide more initializers than elements when initializing an array of known size (except when initializing character arrays from string literals).<br></p><table><tr><td><p>A designator causes the following initializer to initialize of the array element described by the designator. Initialization then continues forward in order, beginning with the next element after the one described by the designator.<br></p><div><div><pre><code>int n[5] = {[4]=5,[0]=1,2,3,4} // holds 1,2,3,4,5\xc2\xa0int a[MAX] = { // starts initializing a[0] = 1, a[1] = 3, ...    1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0}// for MAX=6,  array holds 1,8,6,4,2,0// for MAX=13, array holds 1,3,5,7,9,0,0,0,8,6,4,2,0 ("sparse array")</code></pre></div></div></td><td>(since C99)</td></tr></table><p>When initializing an array of unknown size, the largest subscript for which an initializer is specified determines the size of the array being declared.<br></p><span class="prog__sub"> Nested arrays</span><p>If the elements of an array are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:<br></p><p>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding array element:<br></p><div><div><pre><code>int y[4][3] = { // array of 4 arrays of 3 ints each (4x3 matrix)    { 1 },      // row 0 initialized to {1, 0, 0}    { 0, 1 },   // row 1 initialized to {0, 1, 0}    { [2]=1 },  // row 2 initialized to {0, 0, 1}};              // row 3 initialized to {0, 0, 0}</code></pre></div></div><p>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the sub-array, struct or union; any remaining initializers are left to initialize the next array element:<br></p><div><div><pre><code>int y[4][3] = {    // array of 4 arrays of 3 ints each (4x2 matrix)1, 3, 5, 2, 4, 6, 3, 5, 7 // row 0 initialized to {1, 3, 5}};                        // row 1 initialized to {2, 4, 6}                          // row 2 initialized to {3, 5, 7}                          // row 3 initialized to {0, 0, 0}\xc2\xa0struct { int a[3], b; } w[] = { { 1 }, 2 }; // array of structs   // { 1 } is taken to be a fully-braced initializer for element #0 of the array   // that element is initialized to { {1, 0, 0}, 0}   // 2 is taken to be the first initialized for element #1 of the array   // that element is initialized { {2, 0, 0}, 0}</code></pre></div></div><table><tr><td><p>Array designators may be nested; the bracketed constant expression for nested arrays follows the bracketed constant expression for the outer array:<br></p><div><div><pre><code>int y[4][3] = {[0][0]=1, [1][1]=1, [2][0]=1};  // row 0 initialized to {1, 0, 0}                                               // row 1 initialized to {0, 1, 0}                                               // row 2 initialized to {1, 0, 0}                                               // row 3 initialized to {0, 0, 0}</code></pre></div></div></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/array_initialization
ASCII Chart	A										<section class="prog__container"><p>The following chart contains all 128 ASCII decimal <b>(dec)</b>, octal <b>(oct)</b>, hexadecimal <b>(hex)</b> and character <b>(ch)</b> codes.</p><table><tr><th> <code>dec</code> </th><th> <code>oct</code> </th><th> <code>hex</code></th><th style="text-align: left;"> <code>ch</code></th><td></td><th> <code>dec</code> </th><th> <code>oct</code> </th><th> <code>hex</code></th><th style="text-align: left;"> <code>ch</code></th><td></td><th> <code>dec</code> </th><th> <code>oct</code> </th><th> <code>hex</code></th><th style="text-align: left;"> <code>ch</code></th><td></td><th> <code>dec</code> </th><th> <code>oct</code> </th><th> <code>hex</code></th><th style="text-align: left;"> <code>ch</code></th></tr><tr><td> <code> 0</code></td><td> <code>0</code></td><td><code>00</code></td><td><code>NUL</code> (null) </td><td> <code>32</code></td><td><code>40</code></td><td><code>20</code></td><td>(space) </td><td> <code>64</code></td><td><code>100</code></td><td><code>40</code></td><td><code>@</code> </td><td> <code> 96</code></td><td><code>140</code></td><td><code>60</code></td><td><code>`</code></td></tr><tr><td> <code> 1</code></td><td> <code>1</code></td><td><code>01</code></td><td><code>SOH</code> (start of header) </td><td> <code>33</code></td><td><code>41</code></td><td><code>21</code></td><td><code>!</code> </td><td> <code>65</code></td><td><code>101</code></td><td><code>41</code></td><td><code>A</code> </td><td> <code> 97</code></td><td><code>141</code></td><td><code>61</code></td><td><code>a</code></td></tr><tr><td> <code> 2</code></td><td> <code>2</code></td><td><code>02</code></td><td><code>STX</code> (start of text) </td><td> <code>34</code></td><td><code>42</code></td><td><code>22</code></td><td><code>"</code> </td><td> <code>66</code></td><td><code>102</code></td><td><code>42</code></td><td><code>B</code> </td><td> <code> 98</code></td><td><code>142</code></td><td><code>62</code></td><td><code>b</code></td></tr><tr><td> <code> 3</code></td><td> <code>3</code></td><td><code>03</code></td><td><code>ETX</code> (end of text) </td><td> <code>35</code></td><td><code>43</code></td><td><code>23</code></td><td><code>#</code> </td><td> <code>67</code></td><td><code>103</code></td><td><code>43</code></td><td><code>C</code> </td><td> <code> 99</code></td><td><code>143</code></td><td><code>63</code></td><td><code>c</code></td></tr><tr><td> <code> 4</code></td><td> <code>4</code></td><td><code>04</code></td><td><code>EOT</code> (end of transmission) </td><td> <code>36</code></td><td><code>44</code></td><td><code>24</code></td><td><code>$</code> </td><td> <code>68</code></td><td><code>104</code></td><td><code>44</code></td><td><code>D</code> </td><td> <code>100</code></td><td><code>144</code></td><td><code>64</code></td><td><code>d</code></td></tr><tr><td> <code> 5</code></td><td> <code>5</code></td><td><code>05</code></td><td><code>ENQ</code> (enquiry) </td><td> <code>37</code></td><td><code>45</code></td><td><code>25</code></td><td><code>%</code> </td><td> <code>69</code></td><td><code>105</code></td><td><code>45</code></td><td><code>E</code> </td><td> <code>101</code></td><td><code>145</code></td><td><code>65</code></td><td><code>e</code></td></tr><tr><td> <code> 6</code></td><td> <code>6</code></td><td><code>06</code></td><td><code>ACK</code> (acknowledge) </td><td> <code>38</code></td><td><code>46</code></td><td><code>26</code></td><td><code>&amp;</code> </td><td> <code>70</code></td><td><code>106</code></td><td><code>46</code></td><td><code>F</code> </td><td> <code>102</code></td><td><code>146</code></td><td><code>66</code></td><td><code>f</code></td></tr><tr><td> <code> 7</code></td><td> <code>7</code></td><td><code>07</code></td><td><code>BEL</code> (bell) </td><td> <code>39</code></td><td><code>47</code></td><td><code>27</code></td><td><code>'</code> </td><td> <code>71</code></td><td><code>107</code></td><td><code>47</code></td><td><code>G</code> </td><td> <code>103</code></td><td><code>147</code></td><td><code>67</code></td><td><code>g</code></td></tr><tr><td> <code> 8</code></td><td><code>10</code></td><td><code>08</code></td><td><code>BS</code> (backspace) </td><td> <code>40</code></td><td><code>50</code></td><td><code>28</code></td><td><code>(</code> </td><td> <code>72</code></td><td><code>110</code></td><td><code>48</code></td><td><code>H</code> </td><td> <code>104</code></td><td><code>150</code></td><td><code>68</code></td><td><code>h</code></td></tr><tr><td> <code> 9</code></td><td><code>11</code></td><td><code>09</code></td><td><code>HT</code> (horizontal tab) </td><td> <code>41</code></td><td><code>51</code></td><td><code>29</code></td><td><code>)</code> </td><td> <code>73</code></td><td><code>111</code></td><td><code>49</code></td><td><code>I</code> </td><td> <code>105</code></td><td><code>151</code></td><td><code>69</code></td><td><code>i</code></td></tr><tr><td> <code>10</code></td><td><code>12</code></td><td><code>0a</code></td><td><code>LF</code> (line feed - new line) </td><td> <code>42</code></td><td><code>52</code></td><td><code>2a</code></td><td><code>*</code> </td><td> <code>74</code></td><td><code>112</code></td><td><code>4a</code></td><td><code>J</code> </td><td> <code>106</code></td><td><code>152</code></td><td><code>6a</code></td><td><code>j</code></td></tr><tr><td> <code>11</code></td><td><code>13</code></td><td><code>0b</code></td><td><code>VT</code> (vertical tab) </td><td> <code>43</code></td><td><code>53</code></td><td><code>2b</code></td><td><code>+</code> </td><td> <code>75</code></td><td><code>113</code></td><td><code>4b</code></td><td><code>K</code> </td><td> <code>107</code></td><td><code>153</code></td><td><code>6b</code></td><td><code>k</code></td></tr><tr><td> <code>12</code></td><td><code>14</code></td><td><code>0c</code></td><td><code>FF</code> (form feed - new page) </td><td> <code>44</code></td><td><code>54</code></td><td><code>2c</code></td><td><code>,</code> </td><td> <code>76</code></td><td><code>114</code></td><td><code>4c</code></td><td><code>L</code> </td><td> <code>108</code></td><td><code>154</code></td><td><code>6c</code></td><td><code>l</code></td></tr><tr><td> <code>13</code></td><td><code>15</code></td><td><code>0d</code></td><td><code>CR</code> (carriage return) </td><td> <code>45</code></td><td><code>55</code></td><td><code>2d</code></td><td><code>-</code> </td><td> <code>77</code></td><td><code>115</code></td><td><code>4d</code></td><td><code>M</code> </td><td> <code>109</code></td><td><code>155</code></td><td><code>6d</code></td><td><code>m</code></td></tr><tr><td> <code>14</code></td><td><code>16</code></td><td><code>0e</code></td><td><code>SO</code> (shift out) </td><td> <code>46</code></td><td><code>56</code></td><td><code>2e</code></td><td><code>.</code> </td><td> <code>78</code></td><td><code>116</code></td><td><code>4e</code></td><td><code>N</code> </td><td> <code>110</code></td><td><code>156</code></td><td><code>6e</code></td><td><code>n</code></td></tr><tr><td> <code>15</code></td><td><code>17</code></td><td><code>0f</code></td><td><code>SI</code> (shift in) </td><td> <code>47</code></td><td><code>57</code></td><td><code>2f</code></td><td><code>/</code> </td><td> <code>79</code></td><td><code>117</code></td><td><code>4f</code></td><td><code>O</code> </td><td> <code>111</code></td><td><code>157</code></td><td><code>6f</code></td><td><code>o</code></td></tr><tr><td> <code>16</code></td><td><code>20</code></td><td><code>10</code></td><td><code>DLE</code> (data link escape) </td><td> <code>48</code></td><td><code>60</code></td><td><code>30</code></td><td><code>0</code> </td><td> <code>80</code></td><td><code>120</code></td><td><code>50</code></td><td><code>P</code> </td><td> <code>112</code></td><td><code>160</code></td><td><code>70</code></td><td><code>p</code></td></tr><tr><td> <code>17</code></td><td><code>21</code></td><td><code>11</code></td><td><code>DC1</code> (device control 1) </td><td> <code>49</code></td><td><code>61</code></td><td><code>31</code></td><td><code>1</code> </td><td> <code>81</code></td><td><code>121</code></td><td><code>51</code></td><td><code>Q</code> </td><td> <code>113</code></td><td><code>161</code></td><td><code>71</code></td><td><code>q</code></td></tr><tr><td> <code>18</code></td><td><code>22</code></td><td><code>12</code></td><td><code>DC2</code> (device control 2) </td><td> <code>50</code></td><td><code>62</code></td><td><code>32</code></td><td><code>2</code> </td><td> <code>82</code></td><td><code>122</code></td><td><code>52</code></td><td><code>R</code> </td><td> <code>114</code></td><td><code>162</code></td><td><code>72</code></td><td><code>r</code></td></tr><tr><td> <code>19</code></td><td><code>23</code></td><td><code>13</code></td><td><code>DC3</code> (device control 3) </td><td> <code>51</code></td><td><code>63</code></td><td><code>33</code></td><td><code>3</code> </td><td> <code>83</code></td><td><code>123</code></td><td><code>53</code></td><td><code>S</code> </td><td> <code>115</code></td><td><code>163</code></td><td><code>73</code></td><td><code>s</code></td></tr><tr><td> <code>20</code></td><td><code>24</code></td><td><code>14</code></td><td><code>DC4</code> (device control 4) </td><td> <code>52</code></td><td><code>64</code></td><td><code>34</code></td><td><code>4</code> </td><td> <code>84</code></td><td><code>124</code></td><td><code>54</code></td><td><code>T</code> </td><td> <code>116</code></td><td><code>164</code></td><td><code>74</code></td><td><code>t</code></td></tr><tr><td> <code>21</code></td><td><code>25</code></td><td><code>15</code></td><td><code>NAK</code> (negative acknowledge) </td><td> <code>53</code></td><td><code>65</code></td><td><code>35</code></td><td><code>5</code> </td><td> <code>85</code></td><td><code>125</code></td><td><code>55</code></td><td><code>U</code> </td><td> <code>117</code></td><td><code>165</code></td><td><code>75</code></td><td><code>u</code></td></tr><tr><td> <code>22</code></td><td><code>26</code></td><td><code>16</code></td><td><code>SYN</code> (synchronous idle) </td><td> <code>54</code></td><td><code>66</code></td><td><code>36</code></td><td><code>6</code> </td><td> <code>86</code></td><td><code>126</code></td><td><code>56</code></td><td><code>V</code> </td><td> <code>118</code></td><td><code>166</code></td><td><code>76</code></td><td><code>v</code></td></tr><tr><td> <code>23</code></td><td><code>27</code></td><td><code>17</code></td><td><code>ETB</code> (end of transmission block) </td><td> <code>55</code></td><td><code>67</code></td><td><code>37</code></td><td><code>7</code> </td><td> <code>87</code></td><td><code>127</code></td><td><code>57</code></td><td><code>W</code> </td><td> <code>119</code></td><td><code>167</code></td><td><code>77</code></td><td><code>w</code></td></tr><tr><td> <code>24</code></td><td><code>30</code></td><td><code>18</code></td><td><code>CAN</code> (cancel) </td><td> <code>56</code></td><td><code>70</code></td><td><code>38</code></td><td><code>8</code> </td><td> <code>88</code></td><td><code>130</code></td><td><code>58</code></td><td><code>X</code> </td><td> <code>120</code></td><td><code>170</code></td><td><code>78</code></td><td><code>x</code></td></tr><tr><td> <code>25</code></td><td><code>31</code></td><td><code>19</code></td><td><code>EM</code> (end of medium) </td><td> <code>57</code></td><td><code>71</code></td><td><code>39</code></td><td><code>9</code> </td><td> <code>89</code></td><td><code>131</code></td><td><code>59</code></td><td><code>Y</code> </td><td> <code>121</code></td><td><code>171</code></td><td><code>79</code></td><td><code>y</code></td></tr><tr><td> <code>26</code></td><td><code>32</code></td><td><code>1a</code></td><td><code>SUB</code> (substitute) </td><td> <code>58</code></td><td><code>72</code></td><td><code>3a</code></td><td><code>:</code> </td><td> <code>90</code></td><td><code>132</code></td><td><code>5a</code></td><td><code>Z</code> </td><td> <code>122</code></td><td><code>172</code></td><td><code>7a</code></td><td><code>z</code></td></tr><tr><td> <code>27</code></td><td><code>33</code></td><td><code>1b</code></td><td><code>ESC</code> (escape) </td><td> <code>59</code></td><td><code>73</code></td><td><code>3b</code></td><td><code>;</code> </td><td> <code>91</code></td><td><code>133</code></td><td><code>5b</code></td><td><code>[</code> </td><td> <code>123</code></td><td><code>173</code></td><td><code>7b</code></td><td><code>{</code></td></tr><tr><td> <code>28</code></td><td><code>34</code></td><td><code>1c</code></td><td><code>FS</code> (file separator) </td><td> <code>60</code></td><td><code>74</code></td><td><code>3c</code></td><td><code>&lt;</code> </td><td> <code>92</code></td><td><code>134</code></td><td><code>5c</code></td><td><code>\\ </code> </td><td> <code>124</code></td><td><code>174</code></td><td><code>7c</code></td><td><code>|</code></td></tr><tr><td> <code>29</code></td><td><code>35</code></td><td><code>1d</code></td><td><code>GS</code> (group separator) </td><td> <code>61</code></td><td><code>75</code></td><td><code>3d</code></td><td><code>=</code> </td><td> <code>93</code></td><td><code>135</code></td><td><code>5d</code></td><td><code>]</code> </td><td> <code>125</code></td><td><code>175</code></td><td><code>7d</code></td><td><code>}</code></td></tr><tr><td> <code>30</code></td><td><code>36</code></td><td><code>1e</code></td><td><code>RS</code> (record separator) </td><td> <code>62</code></td><td><code>76</code></td><td><code>3e</code></td><td><code>&gt;</code> </td><td> <code>94</code></td><td><code>136</code></td><td><code>5e</code></td><td><code>^</code> </td><td> <code>126</code></td><td><code>176</code></td><td><code>7e</code></td><td><code>~</code></td></tr><tr><td> <code>31</code></td><td><code>37</code></td><td><code>1f</code></td><td><code>US</code> (unit separator) </td><td> <code>63</code></td><td><code>77</code></td><td><code>3f</code></td><td><code>?</code> </td><td> <code>95</code></td><td><code>137</code></td><td><code>5f</code></td><td><code>_</code> </td><td> <code>127</code></td><td><code>177</code></td><td><code>7f</code></td><td><code>DEL</code> (delete)</td></tr></table><p>Note: in Unicode, the ASCII character block is known as <a class="external text" href="http://www.unicode.org/charts/PDF/U0000.pdf" rel="nofollow"><code>U+0000..U+007F</code> Basic Latin</a>.</p></section>	http://en.cppreference.com/w/c/language/ascii
atomic types	A										<section class="prog__container"><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Atomic</code> <code>(</code> type-name <code>)</code></td><td> (1)</td><td> (since C11)</td></tr><tr><td></td></tr><tr><td> <code>_Atomic</code> type-name</td><td> (2)</td><td> (since C11)</td></tr><tr><td></td></tr></table><div>1) Use as a type specifier; this designates a new atomic type</div><div>2) Use as a type qualifier; this designates the atomic version of type-name. In this role, it may be mixed with <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, and <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a>), although unlike other qualifiers, the atomic version of type-name may have a different size, alignment, and object representation.</div><table><tr><td> type-name</td><td> -</td><td>  any type other than array or function. For (1), type-name also cannot be atomic or cvr-qualified</td></tr></table><p>The header <code>&lt;stdatomic.h&gt;</code> defines <a href="http://en.cppreference.com/w/c/atomic" title="c/atomic">37 convenience macros</a>, from <code>atomic_bool</code> to <code>atomic_uintmax_t</code>, which simplify the use of this keyword with built-in and library types.</p><div><div><pre><code>_Atomic const int * p1;  // p is a pointer to an atomic const intconst <a href="http://en.cppreference.com/w/c/atomic">atomic_int</a> * p2;   // sameconst _Atomic(int) * p3; // same</code></pre></div></div><span class="prog__sub"> Explanation</span><p>Objects of atomic types are the only objects that are free from <a href="http://en.cppreference.com/w/c/language/memory_model" title="c/language/memory model">data races</a>, that is, they may be modified by two threads concurrently or modified by one and read by another.</p><p>Each atomic object has its own associated <i>modification order</i>, which is a total order of modifications made to that object. If, from some thread's point of view, modification <code>A</code> of some atomic M <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">happens-before</a> modification <code>B</code> of the same atomic M, then in the modification order of M, A occurs before B.</p><p>Note that although each atomic object has its own modification order, it is not a total order; different threads may observe modifications to different atomic objects in different orders.<br></p><p>There are four coherences that are guaranteed for all atomic operations:<br></p><ul><li> <b>write-write coherence</b>: If an operation A that modifies an atomic object M <i>happens-before</i> an operation B that modifies M, then A appears earlier than B in the modification order of M.</li><li> <b>read-read coherence</b>: If a value computation A of an atomic object M happens before a value computation B of M, and A takes its value from a side effect X on M, then the value computed by B is either the value stored by X or is the value stored by a side effect Y on M, where Y appears later than X in the modification order of M.</li><li> <b>read-write coherence</b>: If a value computation A of an atomic object M <i>happens-before</i> an operation B on M, then A takes its value from a side effect X on M, where X appears before B in the modification order of M.</li><li> <b>write-read coherence</b>: If a side effect X on an atomic object M <i>happens-before</i> a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that appears after X in the modification order of M.</li></ul><p>Some atomic operations are also synchronization operations; they may have additional release semantics, acquire semantics, or sequentially-consistent semantics. See <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order</a>. </p><p>Built-in <a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec">increment and decrement operators</a> and <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">compound assignment</a> are read-modify-write atomic operations with total sequentially consistent ordering (as if using <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>). If less strict synchronization semantics are desired, the <a href="http://en.cppreference.com/w/c/atomic" title="c/atomic">standard library functions</a> may be used instead.</p><p>Atomic properties are only meaningful for <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue expressions</a>. Lvalue-to-rvalue conversion (which models a memory read from an atomic location to a CPU register) strips atomicity along with other qualifiers.</p><table><tr><td></td><td>This section is incomplete<br/>Reason: more, review interaction with memory_order and atomic library pages </td></tr></table></section>	http://en.cppreference.com/w/c/language/atomic
Basic concepts	A										<section class="prog__container"><p>This section provides definitions for the specific terminology and the concepts used when describing the C programming language.<br></p><p>A C program is a sequence of text files (typically header and source files) that contain <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>. They undergo <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">translation</a> to become an executable program, which is executed when the OS calls its <a href="http://en.cppreference.com/w/c/language/main_function" title="c/language/main function">main function</a> (unless it is itself the OS or another <i>freestanding</i> program, in which case the entry point is implementation-defined).</p><p>Certain words in a C program have special meaning, they are <a href="http://en.cppreference.com/w/cpp/keyword" title="cpp/keyword">keywords</a>. Others can be used as <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifiers</a>, which may be used to identify <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">objects</a>, <a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions">functions</a>, <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a>, <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a>, or <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enumeration</a> tags, their members, <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a> names, <a href="http://en.cppreference.com/w/c/language/statements#Labels" title="c/language/statements">labels</a>, or  <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace">macros</a>.</p><p>Each identifier (other than macro) is only valid within a part of the program called its <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">scope</a> and belongs to one of four kinds of <a href="http://en.cppreference.com/w/c/language/name_space" title="c/language/name space">name spaces</a>. Some identifiers have <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">linkage</a> which makes them refer to the same entities when they appear in different scopes or translation units.</p><p>Definitions of functions include sequences of <a href="http://en.cppreference.com/w/c/language/statements" title="c/language/statements">statements</a> and <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>, some of which include <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expressions</a>, which specify the computations to be performed by the program.</p><p><a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">Declarations</a> and <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expressions</a> create, destroy, access, and manipulate <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">objects</a>. Each <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">object</a>, <a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions">function</a>, and <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> in C is associated with a <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">type</a>.</p></section>	http://en.cppreference.com/w/c/language/basic_concepts
Undefined behavior	A										<section class="prog__container"><p>The C language standard precisely specifies the <a class="new" href="/mwiki/index.php?title=c/language/as_if&amp;action=edit&amp;redlink=1" title="c/language/as if (page does not exist)">observable behavior</a> of C language programs, except for the ones in the following categories:</p><ul><li> <i>undefined behavior</i> - there are no restrictions on the behavior of the program. Examples of undefined behavior are memory accesses outside of array bounds, signed integer overflow, null pointer dereference, modification of the same scalar <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">more than once</a> in an expression without sequence points, access to an object through a pointer of a different type, etc. Compilers are not required to diagnose undefined behavior (although many simple situations are diagnosed), and the compiled program is not required to do anything meaningful.</li></ul><ul><li> <i>unspecified behavior</i> - two or more behaviors are permitted and the implementation is not required to document the effects of each behavior. For example, <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">order of evaluation</a>, whether identical <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literals</a> are distinct, etc. Each unspecified behavior results in one of a set of valid results and may produce a different result when repeated in the same program.</li></ul><ul><li> <i>implementation-defined behavior</i> - unspecified behavior where each implementation documents how the choice is made. For example, number of bits in a byte, or whether signed integer right shift is arithmetic or logical.</li></ul><ul><li> <i>locale-specific behavior</i> - implementation-defined behavior that depends on the <a href="http://en.cppreference.com/w/c/locale/setlocale" title="c/locale/setlocale">currently chosen locale</a>. For example, whether <a href="http://en.cppreference.com/w/c/string/byte/islower" title="c/string/byte/islower">islower</a> returns true for any character other than the 26 lowercase Latin letters.</li></ul><p>(Note: <a href="http://en.cppreference.com/w/c/language/conformance" title="c/language/conformance">Strictly conforming</a> programs do not depend on any unspecified, undefined, or implementation-defined behavior)</p><p>The compilers are requires to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.<br></p><span class="prog__sub"> UB and optimization</span><p>Because correct C programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:<br></p><p>For example, <br></p><h4> Signed overflow</h4><div><div><pre><code>int foo(int x) {    return x+1 &gt; x; // either true or UB due to signed overflow}</code></pre></div></div><p>may be compiled as (<a class="external text" href="https://godbolt.org/g/u1MDjW" rel="nofollow">demo</a>)</p><div><div><pre><code>foo(int):        movl    $1, %eax        ret</code></pre></div></div><h4> Access out of bounds</h4><div><div><pre><code>int table[4] = {};int exists_in_table(int v){    // return true in one of the first 4 iterations or UB due to out-of-bounds access    for (int i = 0; i &lt;= 4; i++) {        if (table[i] == v) return 1;    }    return 0;}</code></pre></div></div><p>May be compiled as (<a class="external text" href="https://godbolt.org/g/Mc6Qu1" rel="nofollow">demo</a>)</p><div><div><pre><code>exists_in_table(int):        movl    $1, %eax        ret</code></pre></div></div><h4> Uninitialized scalar</h4><div><div><pre><code>bool p; // uninitialized local variableif(p) // UB access to uninitialized scalar    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("p is true");if(!p) // UB access to uninitialized scalar    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("p is false");</code></pre></div></div><p>May produce the following output (observed with an older version of gcc):<br></p><div><div><pre><code>p is truep is false</code></pre></div></div><div><div><div>Run this code</div></div><div><div><pre><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> f(int x){    <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> a;    if(x) // either x nonzero or UB        a = 42;    return a; }</code></pre></div></div><p><br/></p></div><p>May be compiled as (<a class="external text" href="https://godbolt.org/g/CZKrdp" rel="nofollow">demo</a>)</p><div><div><pre><code>f(int):        mov     eax, 42        ret</code></pre></div></div><h4> Access to pointer passed to realloc</h4><div><p>Choose clang to observe the output shown<br></p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void) {    int *p = (int*)<a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(sizeof(int));    int *q = (int*)<a href="http://en.cppreference.com/w/c/memory/realloc">realloc</a>(p, sizeof(int));    *p = 1; // UB access to a pointer that was passed to realloc    *q = 2;    if (p == q) // UB access to a pointer that was passed to realloc        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d%d\n", *p, *q);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>12</code></pre></div></div></div><h4> Infinite loop without side-effects</h4><div><p>Choose clang to observe the output shown<br></p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0int fermat() {  const int MAX = 1000;  int a=1,b=1,c=1;  // Endless loop with no side effects is UB  while (1) {    if (((a*a*a) == ((b*b*b)+(c*c*c)))) return 1;    a++;    if (a&gt;MAX) { a=1; b++; }    if (b&gt;MAX) { b=1; c++; }    if (c&gt;MAX) { c=1;}  }  return 0;}\xc2\xa0int main(void) {  if (fermat())    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("Fermat's Last Theorem has been disproved.");  else    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("Fermat's Last Theorem has not been disproved.");}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>Fermat's Last Theorem has been disproved.</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/behavior
Bit fields	A										<section class="prog__container"><p>Declares a member with explicit width, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.<br></p><p>A bit field declaration is a <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> member declaration which uses the following <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarator</a>:</p><table><tr><td></td></tr><tr><td> identifier(optional) <code>:</code> width</td><td></td><td></td></tr><tr><td></td></tr></table><table><tr><td> identifier</td><td> -</td><td>  the name of the bit field that is being declared. The name is optional: nameless bitfields introduce the specified number of bits of padding</td></tr><tr><td> width</td><td> -</td><td>  an integer <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">constant expression</a> with a value greater or equal to zero and less or equal the number of bits in the underlying type. When greater than zero, this is the number of bits that this bit field will occupy. The value zero is only allowed for nameless bitfields and has special meaning: it specifies that the next bit field in the class definition will begin at an allocation unit's boundary.</td></tr></table><span class="prog__sub"> Explanation</span><p>Bit fields can have only one of four types (possibly <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a> or <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> qualified):</p><ul><li> <code>unsigned int</code>, for unsigned bit fields (<code>unsigned int b:3;</code> has the range <code>0..7</code>)</li><li> <code>signed int</code>, for signed bit fields (<code>signed int b:3;</code> has the range <code>-4..3</code>)</li><li> <code>int</code>, for bit fields with implementation-defined signedness (Note that this differs from the meaning of the keyword <code>int</code> everywhere else, where it means "signed int"). For example, <code>int b:3;</code> may have the range of values <code>0..7</code> or <code>-4..3</code>.</li><li> <code>_Bool</code>, for single-bit bit fields (<code>bool x:1;</code> has the range <code>0..1</code> and <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicit conversions</a> to and from it follow the boolean conversion rules.</li></ul><p>Additional implementation-defined types may be acceptable. It is also implementation-defined whether a bit field may have <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a> type. (since C11)The number of bits in a bit field (width) sets the limit to the range of values it can hold:</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;struct S { // three-bit unsigned field, // allowed values are 0...7 unsigned int b : 3;};int main(void){    struct S s = {7};    ++s.b; // unsigned overflow    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", s.b); // output: 0}</code></pre></div></div><p><br/></p></div><p>Multiple adjacent bit fields are permitted to be (and usually are) packed together:<br></p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;struct S {    // will usually occupy 4 bytes:    // 5 bits: value of b1    // 11 bits: unused    // 6 bits: value of b2    // 2 bits: value of b3    // 8 bits: unused    unsigned b1 : 5, : 11, b2 : 6, b3 : 2;};int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu\n",sizeof(struct S)); // usually prints 4}</code></pre></div></div><p><br/></p></div><p>The special <i>unnamed bit field</i> of width zero breaks up padding: it specifies that the next bit field begins at the beginning of the next allocation unit:</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;struct S {    // will usually occupy 8 bytes:    // 5 bits: value of b1    // 27 bits: unused    // 6 bits: value of b2    // 15 bits: value of b3    // 11 bits: unused    unsigned b1 : 5;    unsigned :0; // start a new unsigned int    unsigned b2 : 6;    unsigned b3 : 15;};int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu\n", sizeof(struct S)); // usually prints 8}</code></pre></div></div><p><br/></p></div><p>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers to bit fields are not possible. Bit fields cannot be used with <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a> and <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/alignas" title="c/language/alignas">alignas</a>  (since C11)</p></section>	http://en.cppreference.com/w/c/language/bit_field
break statement	A										<section class="prog__container"><p>Causes the enclosing <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for</a>, <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while</a> or <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do">do-while</a> loop or <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch"> switch statement</a> to terminate.</p><p>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>break</code> <code>;</code></td><td></td><td></td></tr><tr><td></td></tr></table><p>Appears only within the statement of a loop body (<a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while</a>, <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do">do</a>, <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for</a>) or within the statement of a <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch">switch</a>.</p><span class="prog__sub"> Explanation</span><p>After this statement the control is transferred to the statement or declaration immediately following the enclosing loop or switch, as if by <a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto">goto</a>.</p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/break" title="c/keyword/break"><tt>break</tt></a></p></section>	http://en.cppreference.com/w/c/language/break
cast operator	A										<section class="prog__container"><p>Performs explicit type conversion<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>(</code> type-name <code>)</code> expression</td><td></td><td></td></tr><tr><td></td></tr></table><p>where<br></p><table><tr><td> type-name</td><td> -</td><td>  either the type <code>void</code> or any <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">scalar type</a></td></tr><tr><td> expression</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> of <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">scalar type</a> (unless type-name is void, in which case it can be anything)</td></tr></table><span class="prog__sub"> Explanation</span><p>If type-name is <code>void</code>, then expression is evaluated for its side-effects and its returned value is discarded, same as when expression is used on its own, as an <a href="http://en.cppreference.com/w/c/language/statements#Expression_statements" title="c/language/statements">expression statement</a>.</p><p>Otherwise, if type-name is exactly the type of expression, nothing is done (except that if expression has floating type and is represented with greater range and precision than its type indicates -- see below)</p><p>Otherwise, the value of expression is converted to the type named by type-name, as follows:</p><p>Every <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicit conversion as if by assignment</a> is allowed. </p><p>In addition to the implicit conversions, the following conversions are allowed:<br></p><ul><li> Any integer can be cast to any pointer type. Except for the null pointer constants such as <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> (which <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">doesn't need a cast</a>), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">trap representation</a>.</li><li> Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer)</li><li> Any pointer to object can be cast to any other pointer to object. If the value is not correctly aligned for the target type, the behavior is undefined. Otherwise, if the value is converted back to the original type, it compares equal to the original value. If a pointer to object is cast to pointer to any character type, the result points at the lowest byte of the object and may be incremented up to sizeof the target type (in other words, can be used to examine <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">object representation</a> or to make a copy via <a href="http://en.cppreference.com/w/c/string/byte/memcpy" title="c/string/byte/memcpy">memcpy</a> or <a href="http://en.cppreference.com/w/c/string/byte/memmove" title="c/string/byte/memmove">memmove</a>).</li><li> Any pointer to function can be cast to a pointer to any other function type. If the resulting pointer is converted back to the original type, it compares equal to the original value. If the converted pointer is used to make a function call, the behavior is undefined (unless the function types are <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a>)</li><li> When casting between pointers (either object or function), if the original value is a null pointer value of its type, the result is the correct null pointer value for the target type.</li></ul><p>In any case (both when executing an implicit conversion and in the same-type cast), if expression and type-name are floating types and expression is represented with greater range and precision than its type indicates (see <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a>, the range and precision are stripped off to match the target type.</p><p>The <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">value category</a> of the cast expression is always non-lvalue.</p></section>	http://en.cppreference.com/w/c/language/cast
Type	A										<section class="prog__container"><p><small>(See also <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic types</a> for the details on most built-in types and <a href="http://en.cppreference.com/w/c/types" title="c/types"> the list of type-related utilities</a> that are provided by the C library)</small></p><p><a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">Objects</a>, <a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions">functions</a>, and <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expressions</a> have a property called <i>type</i>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</p><span class="prog__sub"> Type classification</span><p>The C type system consists of the following types:<br></p><ul><li>the type <code>void</code></li><li>basic types</li></ul><dl><dd><ul><li>the type <code>char</code></li><li>signed integer types</li></ul><dl><dd><ul><li>standard: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>  (since C99)</li><li>extended: implementation defined, e.g. <code>__int128</code></li></ul></dd></dl><ul><li>unsigned integer types</li></ul><dl><dd><ul><li>standard: <code>_Bool</code>  (since C99), <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>  (since C99)</li><li>extended: implementation-defined, e.g. <code>__uint128</code></li></ul></dd></dl><ul><li>floating types</li></ul><dl><dd><ul><li>real floating types: <code>float</code>, <code>double</code>, <code>long double</code></li><li>complex types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code></li><li>imaginary types: <code>float _Imaginary</code>, <code>double _Imaginary</code>, <code>long double _Imaginary</code></li></ul></dd></dl></dd></dl><ul><li> <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enumerated types</a></li></ul><ul><li> derived types</li></ul><dl><dd><ul><li> <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array types</a></li><li> <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">structure types</a></li><li> <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union types</a></li><li> <a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions">function types</a></li><li> <a href="http://en.cppreference.com/w/c/language/pointer" title="c/language/pointer">pointer types</a></li><li> <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic types</a></li></ul></dd></dl><p>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, and <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> qualifiers (where allowed by the qualifier's semantics).</p><h4> Type groups</h4><ul><li> <i>object types</i>: all types that aren't function types</li><li> <i>character types</i>: <code>char</code>, <code>signed char</code>, <code>unsigned char</code></li><li> <i>integer types</i>: <code>char</code>, signed integer types, unsigned integer types, enumerated types</li><li> <i>real types</i>: integer types and real floating types </li><li> <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>: integer types and floating types</li><li> <i>scalar types</i>: arithmetic types and pointer types</li><li> <i>aggregate types</i>: array types and structure types</li><li> <i>derived declarator types</i>: array types, function types, and pointer types </li></ul><span class="prog__sub"> Compatible types</span><p>In a C program, the declarations referring to the same object or function in <i>different translation units</i> do not have to use the same type. They only have to use sufficiently similar types, formally known as <i>compatible types</i>. Same applies to function calls and lvalue accesses; argument types must be <i>compatible</i> with parameter types and lvalue expression type must be <i>compatible</i> with the object type that is accessed.</p><p>The types <code>T</code> and <code>U</code> are compatible, if</p><ul><li> they are the same type (same name or aliases introduced by a <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>)</li><li> they are identically cvr-qualified versions of compatible unqualified types</li><li> they are pointer types and are pointing to compatible types</li><li> they are array types, and</li></ul><dl><dd><ul><li> their element types are compatible, and</li><li> if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. VLA is compatible with any array of compatible element type. (since C99)</li></ul></dd></dl><ul><li> they are both structure/union/enumeration types, and</li></ul><dl><dd><ul><li>(C99)if one is declared with a tag, the other must also be declared with the same tag.</li><li> if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.</li><li> additionally, if they are enumerations, corresponding members must also have the same values.</li><li> additionally, if they are structures or unions,</li></ul><dl><dd><ul><li> Corresponding members must be declared in the same order (structures only)</li><li> Corresponding bit fields must have the same widths.</li></ul></dd></dl></dd></dl><ul><li> one is an enumerated type and the other is that enumeration's underlying type</li><li> they are function types, and</li></ul><dl><dd><ul><li> their return types are compatible</li><li> they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, the corresponding parameters have compatible types</li><li> one is an old-style (parameter-less) definition, the other has a parameter list, the parameter list does not use an ellipsis and each parameter is compatible (after function parameter type adjustment) with the corresponding old-style parameter after default argument promotions</li><li> one is an old-style (parameter-less) declaration, the other has a parameter list, the parameter list does not use an ellipsis, and all parameters (after function parameter type adjustment) are unaffected by default argument promotions</li></ul></dd></dl><p>The type <code>char</code> is not compatible with <code>signed char</code> and not compatible with <code>unsigned char</code>.</p><p>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.<br></p><div><div><pre><code>// Translation Unit 1struct S {int a;};extern struct S *x;  // compatible with TU2's x, but not with TU3's x// Translation Unit 2struct S;extern struct S *x; // compatible with both x's// Translation Unit 3struct S {float a;};extern struct S *x; // compatible with TU2's x, but not with TU1's x\xc2\xa0// the behavior is undefined</code></pre></div></div><div><div><pre><code>// Translation Unit 1#include &lt;stdio.h&gt;struct s {int i;}; // compatible with TU3's s, but not TU2'sextern struct s x = {0}; // compatible with TU3's xextern void f(void); // compatible with TU2's fint main(){   f();   return x.i;}// Translation Unit 2struct s {float f;}; // compatible with TU4's s, but not TU1's sextern struct s y = {3.14}; // compatible with TU4's yvoid f() // compatible with TU1's f{   return;}// Translation Unit 3struct s {int i;}; // compatible with TU1's s, but not TU2's sextern struct s x; // compatible with TU1's x// Translation Unit 4struct s {float f;}; // compatible with TU2's s, but not TU1's sextern struct s y; // compatible iwth TU2's y\xc2\xa0// the behavior is well-defined: only multiple declarations// of objects and functions must have compatible types, not the types themselves</code></pre></div></div><p>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.<br></p><span class="prog__sub"> Composite types</span><table><tr><td></td><td>This section is incomplete </td></tr></table><span class="prog__sub"> Incomplete types</span><p>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.<br></p><p>The following types are incomplete:<br></p><ul><li> the type <code>void</code>. This type cannot be completed.</li><li> array type of unknown size. It can be completed by a later declaration that specifies the size.</li><li> structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.</li></ul><span class="prog__sub"> Type names</span><p>A type may have to be named in context other than the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a>. In these situations, <i>type name</i> is used, which is, grammatically, exactly the same as a list of <i>type-specifiers</i> and <i>type-qualifiers</i>, followed by the <i>declarator</i> (see <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>) as would be used to declare a single object or function of this type, except that the identifier is omitted:</p><div><div><pre><code>int n; // declaration of an intsizeof(int); // use of type name\xc2\xa0int *a[3]; // declaration of an array of 3 pointers to intsizeof(int *[3]); // use of type name\xc2\xa0int (*p)[3]; // declaration of a pointer to array of 3 intsizeof(int (*)[3]); // use of type name\xc2\xa0int (*a)[*] // declaration of pointer to VLA (in a function parameter)sizeof(int (*)[*]) // use of type name (in a function parameter)\xc2\xa0int *f(void); // declaration of functionsizeof(int *(void)); // use of type name\xc2\xa0int (*p)(void); // declaration of pointer to functionsizeof(int (*)(void)); // use of type name\xc2\xa0int (*const a[])(unsigned int, ...) = {0}; // array of pointers to functionssizeof(int (*const [])(unsigned int, ...)); // use of type name</code></pre></div></div><p>Except the redundant parentheses around the identifier are meaningful in a type-name and represent "function with no parameter specification":<br></p><div><div><pre><code>int (n); // declares n of type intsizeof(int ()); // uses type "function returning int"</code></pre></div></div><p>Type names are used in the following situations:<br></p><ul><li> <a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast">cast</a></li><li> <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a></li></ul><table><tr><td><ul><li> <a href="http://en.cppreference.com/w/c/language/compound_literal" title="c/language/compound literal">compound literal</a></li></ul></td><td>(since C99)</td></tr><tr><td><ul><li> <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic selection</a></li><li> <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">alignof</a></li><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/alignas" title="c/language/alignas">alignas</a></li><li> <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">_Atomic</a> (when used as a type specifier)</li></ul></td><td>(since C11)</td></tr></table><p><br/>A type name may introduce a new type: </p><div><div><pre><code>void* p = (void*)(struct X {int i;} *)0;// type name "struct X {int i;}*" used in the cast expression// introduces the new type "struct X"struct X x = {1}; // struct X is now in scope</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/compatible_type
compound literals	A										<section class="prog__container"><p>Constructs an unnamed object of specified type in-place, used when a variable of array, struct, or union type would be needed only once.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>(</code> type <code>)</code> <code>{ </code> initializer-list <code>} </code></td><td></td><td> (since C99)</td></tr><tr><td></td></tr></table><p>where<br></p><table><tr><td> type</td><td> -</td><td>  a <a href="http://en.cppreference.com/w/c/language/type#Type_names" title="c/language/type">type name</a> specifying any complete object type or an array of unknown size, but not a VLA</td></tr><tr><td> initializer-list</td><td> -</td><td>  list of initializers suitable for <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">initialization</a> of an object of type</td></tr></table><span class="prog__sub"> Explanation</span><p>The compound literal expression constructs an unnamed object of the type specified by type and initializes it as specified by initializer-list.</p><p>The type of the compound literal is type (except when type is an array of unknown size; its size is deduced from the initializer-list as in <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">array initialization</a>).</p><p>The value category of a compound literal is <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue</a> (its address can be taken).</p><p>The unnamed object to which the compound literal evaluates has static <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> if the compound literal occurs at file scope and automatic <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> if the compound literal occurs at block scope (in which case the object's <a href="http://en.cppreference.com/w/c/language/lifetime" title="c/language/lifetime">lifetime</a> ends at the end of the enclosing block).</p></section>	http://en.cppreference.com/w/c/language/compound_literal
Conformance	A										<section class="prog__container"><p><i>Conformance</i> has a three-fold definition:</p><ul><li> <i>strictly conforming program</i> - uses only well-defined language constructs, that is constructs with a single behavior. It excludes unspecified, undefined, or implementation-defined behavior, and does not exceed any minimum implementation limit.</li><li> <i>conforming program</i> - acceptable to a conforming implementation.</li><li> <i>conforming implementation</i> - A conforming hosted implementation shall accept any strictly conforming program. A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers &lt;float.h&gt;, &lt;iso646.h&gt;, &lt;limits.h&gt;, &lt;stdalign.h&gt;, &lt;stdarg.h&gt;, &lt;stdbool.h&gt;, &lt;stddef.h&gt;, &lt;stdint.h&gt;, and &lt;stdnoreturn.h&gt;. A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any strictly conforming program.</li></ul><span class="prog__sub"> Explanation</span><p>The standard does not define any minimum implementation limit on translation units. A hosted environment has an operating system; a freestanding environment does not. A program running in a hosted environment may use all features described in the library clause (clause 7); a program running in a freestanding environment may use a subset of library <br>features required by clause 4.<br></p></section>	http://en.cppreference.com/w/c/language/conformance
const type qualifier	A										<section class="prog__container"><p>Each individual type in the C <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">type system</a> has several <i>qualified</i> versions of that type, corresponding to one, two, or all three of the <i>const</i>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, and, for pointers to object types, <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> qualifiers. This page describes the effects of the <i>const</i> qualifier.</p><p>Objects <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declared</a> with const-qualified types may be placed in read-only memory by the compiler, and if the address of a const object is never taken in a program, it may not be stored at all. </p><p><code>const</code> semantics apply to <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue</a> expressions only; whenever a const lvalue expression is used in context that does not require an lvalue, its <code>const</code> qualifier is lost (note that volatile qualifier, if present, isn't lost).</p><p>The lvalue expressions that designate objects of const-qualified type and the lvalue expressions that designate objects of struct or union type with at least one member of const-qualified type (including members of recursively contained aggregates or unions), are not <i>modifiable lvalues</i>. In particular, they are not assignable:</p><div><div><pre><code>const int n = 1; // object of const typen = 2; // error: the type of n is const-qualified\xc2\xa0int x = 2; // object of unqualified typeconst int* p = &amp;x;*p = 3; // error: the type of the lvalue *p is const-qualified\xc2\xa0struct {int a; const int b; } s1 = {.b=1}, s2 = {.b=2};s1 = s2; // error: the type of s1 is unqualified, but it has a const member</code></pre></div></div><p>A member of a const-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the <code>.</code> operator or the <code>-&gt;</code> operator).</p><div><div><pre><code>struct s { int i; const int ci; } s;// the type of s.i is int, the type of s.ci is const intconst struct s cs;// the types of cs.i and cs.ci are both const int</code></pre></div></div><p>If an array type is declared with the const type qualifier (through the use of <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>), the array type is not const-qualified, but its element type is. If a function type is declared with the const type qualifier (through the use of <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>), the behavior is undefined.</p><div><div><pre><code>typedef int A[2][3];const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const intint* pi = a[0]; // Error: a[0] has type const int*</code></pre></div></div><table><tr><td><p>const-qualified compound literals do not necessarily designate distinct objects; they may share storage with other compound literals and with string literals that happen to have the same or overlapping representation.<br></p><div><div><pre><code>const int* p1 = (const int[]){1,2,3};const int* p2 = (const int[]){2,3,4}; // the value of p2 may equal p1+1bool b = "abd" == (const char[]){"abc"}; // the value of b may be 1</code></pre></div></div></td><td>(since C99)</td></tr></table><p>A pointer to an non-const type can be implicitly converted to a pointer to const-qualified version of the same or <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/compatible_type" title="c/language/compatible type">compatible type</a>. The reverse conversion can be performed with a cast expression.</p><div><div><pre><code>int* p = 0;const int* cp = p; // OK: adds qualifiers (int to const int)p = cp; // Error: discards qualifiers (const int to int)p = (int*)cp; // OK: cast</code></pre></div></div><p>Note that pointer to pointer to <code>T</code> is not convertible to pointer to pointer to <code>const T</code>; for two types to be compatible, their qualifications must be identical.</p><div><div><pre><code>char *p = 0;const char **cpp = &amp;p; // Error: char* and const char* are not compatible typeschar * const *pcp = &amp;p; // OK, adds qualifiers (char* to char*const)</code></pre></div></div><p>Any attempt to modify an object whose type is const-qualified results in undefined behavior.<br></p><div><div><pre><code>const int n = 1; // object of const-qualified typeint* p = (int*)&amp;n;*p = 2; // undefined behavior</code></pre></div></div><table><tr><td><p>In a function declaration, the keyword <code>const</code> may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</p><p>The following two declarations declare the same function:<br></p><div><div><pre><code>void f(double x[const], const double y[const]);void f(double * const x, const double * const y);</code></pre></div></div></td><td>(since C99)</td></tr></table><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/cpp/keyword/const" title="cpp/keyword/const"><tt>const</tt></a></p></section>	http://en.cppreference.com/w/c/language/const
Constant expressions	A										<section class="prog__container"><p>Several varieties of expressions are known as <i>constant expressions</i></p><span class="prog__sub"> Preprocessor constant expression</span><p>The expression following <a href="http://en.cppreference.com/w/c/preprocessor/conditional" title="c/preprocessor/conditional">#if or #elif</a> must expand to</p><ul><li> <a href="http://en.cppreference.com/w/c/language/expressions#Operators" title="c/language/expressions">operators</a> other than <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">assignment</a>, <a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec">increment, decrement</a>, <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function-call</a>, or <a href="http://en.cppreference.com/w/c/language/operator_other#Comma_operator" title="c/language/operator other">comma</a> whose arguments are preprocessor constant expressions</li><li> <a href="http://en.cppreference.com/w/c/language/integer_constant" title="c/language/integer constant">integer constants</a></li><li> <a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant">character constants</a></li><li> the special preprocessor operator <code>defined</code></li></ul><p>Character constants, when evaluated in <code>#if</code>-expressions, may be interpreted in the sourcecharacter set, the execution character set, or some other implementation-defined character set.</p><table><tr><td><p>Integer arithmetic in <code>#if</code>-expressions is performed using the semantics of <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">intmax_t</a> for signed types and <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">uintmax_t</a> for unsigned types.</p></td><td>(since C99)</td></tr></table><span class="prog__sub"> Integer constant expression</span><p>An integer constant expression is an expression that consists only of<br></p><ul><li> <a href="http://en.cppreference.com/w/c/language/expressions#Operators" title="c/language/expressions">operators</a> other than <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">assignment</a>, <a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec">increment, decrement</a>, <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function-call</a>, or <a href="http://en.cppreference.com/w/c/language/operator_other#Comma_operator" title="c/language/operator other">comma</a>, except that <a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast">cast</a> operators can only cast arithmetic types to integer types</li><li> <a href="http://en.cppreference.com/w/c/language/integer_constant" title="c/language/integer constant">integer constants</a></li><li> <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enumeration constants</a></li><li> <a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant">character constants</a></li><li> <a href="http://en.cppreference.com/w/c/language/floating_constant" title="c/language/floating constant">floating constants</a>, but only if they are immediately used as operands of casts to integer type</li><li> <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a> operators whose operands are not VLA (since C99)</li></ul><table><tr><td><ul><li> <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">_Alignof</a> operators</li></ul></td><td>(since C11)</td></tr></table><p>Integer constant expressions are evaluated at compile time. The following contexts require expressions that are known as <i>integer constant expressions':</i></p><ul><li> The size of a <a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field">bit field</a>.</li><li> The value of an <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enumeration constant</a></li><li> The <code>case</code> label of a <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch">switch statement</a></li><li> The size of a  non-VLA (since C99) array</li><li> Integer to pointer implicit <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">conversion</a>.</li></ul><table><tr><td><ul><li> The index in an <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">array designator</a></li></ul></td><td>(since C99)</td></tr><table><tr><td><ul><li> The first argument of _Static_assert</li><li> The integer argument of _Alignas</li></ul></td><td>(since C11)</td></tr></table><span class="prog__sub"> Static initializer</span><p>Expressions that are used in the <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">initializers</a> of objects with static and thread_local <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> must be expressions that may be one of the following</p><div>1) <i>arithmetic constant expression</i>, which is an expression of any arithmetic type that consists of<dl><dd><ul><li> <a href="http://en.cppreference.com/w/c/language/expressions#Operators" title="c/language/expressions">operators</a> other than <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">assignment</a>, <a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec">increment, decrement</a>, <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function-call</a>, or <a href="http://en.cppreference.com/w/c/language/operator_other#Comma_operator" title="c/language/operator other">comma</a>, except that <a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast">cast</a> operators must be converting arithmetic types to other arithmetic types</li><li> <a href="http://en.cppreference.com/w/c/language/integer_constant" title="c/language/integer constant">integer constants</a></li><li> <a href="http://en.cppreference.com/w/c/language/floating_constant" title="c/language/floating constant">floating constants</a></li><li> <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enumeration constants</a></li><li> <a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant">character constants</a></li><li> <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a> operators whose operands are not VLA (since C99)</li></ul></dd></dl></div></table><table><tr><td><dl><dd><ul><li> <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">_Alignof</a> operators</li></ul></dd></dl></td><td>(since C11)</td></tr></table><div>2) the null pointer constant <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a></div><div>3) <i>address constant expression</i>, which is <dl><dd><ul><li> a null pointer</li><li> <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue</a> designating an object of static <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> or a function designator, converted to a pointer either</li></ul><dl><dd><ul><li> by using the unary address-of operator</li><li> by casting an integer constant to a pointer</li><li> by array-to-pointer or function-to-pointer implicit <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">conversion</a></li></ul></dd></dl></dd></dl></div><div>4) <i>address constant expression</i> of some complete object type, plus or minus an <i>integer constant expression</i></div><p>Unlike with integer constant expressions, static initializer expressions are not required to be evaluated at compile time; the compiler is at liberty to turn such initializers into executable code which is invoked prior to program startup.<br></p><div><div><pre><code>static int i = 2 || 1 / 0; // initializes i to value 1</code></pre></div></div><table><tr><td></td><td>This section is incomplete<br/>Reason: other mini-examples </td></tr></table><p>The value of a floating-point static initializer is never less accurate than the value of the same expression executed at run time, but it may be better.<br></p><span class="prog__sub"> Floating-point constant expressions</span><p>Arithmetic constant expressions of floating-point types that are not used in static initializers are always evaluated as-if during run-time and are affected by the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">current rounding</a> (if <a href="http://en.cppreference.com/w/c/preprocessor/impl" title="c/preprocessor/impl">FENV_ACCESS</a> is on) and report errors as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><div><div><pre><code>void f(void){#pragma STDC FENV_ACCESS ON    static float x = 0.0/0.0; // static initializer: does not raise an exception    float w[] = { 0.0/0.0 }; // raises an exception    float y = 0.0/0.0; // raises an exception    double z = 0.0/0.0; // raises an exception}</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/constant_expression
continue statement	A										<section class="prog__container"><p>Causes the remaining portion of the enclosing <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for</a>, <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while</a> or <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do"> do-while</a> loop body to be skipped.</p><p>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>continue</code> <code>;</code></td><td></td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>The <code>continue</code> statement causes a jump, as if by <a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto">goto</a>, to the end of the loop body (it may only appear within the loop body of <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for</a>, <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while</a>, and <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do">do-while</a> loops).</p><p>For <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while</a> loop, it acts as</p><div><div><pre><code>while (/* ... */) {   // ...    continue; // acts as goto contin;   // ...    contin:;}</code></pre></div></div><p>For <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do">do-while</a> loop, it acts as:</p><div><div><pre><code>do {    // ...     continue; // acts as goto contin;    // ...     contin:;} while (/* ... */);</code></pre></div></div><p>For <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for</a> loop, it acts as:</p><div><div><pre><code>for (/* ... */) {    // ...     continue; // acts as goto contin;    // ...     contin:;}</code></pre></div></div><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/continue" title="c/keyword/continue"><tt>continue</tt></a></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0int main(void) {    for (int i = 0; i &lt; 10; i++) {        if (i != 5) continue;        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d ", i);       //this statement is skipped each time i!=5    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");\xc2\xa0    for (int j = 0; j &lt; 2; j++) {        for (int k = 0; k &lt; 5; k++) { //only this loop is affected by continue            if (k == 3) continue;            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d%d ", j, k);    //this statement is skipped each time k==3        }    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>5<br>00 01 02 04 10 11 12 14</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/continue
Implicit conversions	A										<section class="prog__container"><p>When an expression is used in the context where a value of a different type is expected, <i>conversion</i> may occur:</p><div><div><pre><code>int n = 1L; // expression 1L has type long, int is expectedn = 2.1; // expression 2.1 has type double, int is expectedchar *p = <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(10); // expression malloc(10) has type void*, char* is expected</code></pre></div></div><p>Conversions take place in the following situations:<br></p><span class="prog__sub"> Conversion as if by assignment</span><ul><li> In the <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">assignment</a> operator, the value of the right-hand operand is converted to the unqualified type of the left-hand operand.</li><li> In <a href="http://en.cppreference.com/w/c/language/scalar_initialization" title="c/language/scalar initialization">scalar initialization</a>, the value of the initializer expression is converted to the unqualified type of the object being initialized</li><li> In a <a href="http://en.cppreference.com/w/c/language/operator_other" title="c/language/operator other">function-call expression</a>, to a function that has a prototype, the value of each argument expression is converted to the type of the unqualified declared types of the corresponding parameter</li><li> In a <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return">return statement</a>, the value of the operand of <code>return</code> is converted to an object having the return type of the function</li></ul><p>Note that actual assignment, in addition to the conversion, also removes extra range and precision from floating-point types and prohibits overlaps; those characteristics do not apply to conversion as if by assignment.<br></p><span class="prog__sub"> Default argument promotions</span><p>In a <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call expression</a> when the call is made to</p><div>1) a <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function without a prototype</a></div><div>2) a <a href="http://en.cppreference.com/w/c/language/variadic" title="c/language/variadic">variadic function</a>, where the argument expression is one of the trailing arguments that are matched against the ellipsis parameter</div><p>Each argument of integer type undergoes <i>integer promotion</i> (see below), and each argument of type <code>float</code> is implicitly converted to the type <code>double</code></p><div><div><pre><code>int add_nums(int count, ...);int sum = add_nums(2, 'c', true); // add_nums is called with three ints: (2, 99, 1)</code></pre></div></div><p>Note that <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> and <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code> are not promoted to <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> and <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code> in this context.</p><span class="prog__sub"> Usual arithmetic conversions</span><p>The arguments of the following arithmetic operators undergo implicit conversions for the purpose of obtaining the <i>common real type</i>, which is the type in which the calculation is performed:</p><ul><li> <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">binary arithmetic</a> *, /,\xc2\xa0%, +, -</li><li> <a href="http://en.cppreference.com/w/c/language/operator_comparison" title="c/language/operator comparison">relational operators</a> &lt;, &gt;, &lt;=, &gt;=, ==,\xc2\xa0!=</li><li> <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">binary bitwise arithmetic</a> &amp;, ^, |, </li><li> the <a href="http://en.cppreference.com/w/c/language/operator_other" title="c/language/operator other">conditional operator</a>\xc2\xa0?:</li></ul><div>1) If one operand is <code>long double</code>, <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, or <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, the other operand is implicitly converted as follows:<dl><dd><ul><li>integer or real floating type to <code>long double</code></li><li>complex type to <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code></li><li>imaginary type to <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code></li></ul></dd></dl></div><div>2) Otherwise, if one operand is <code>double</code>, <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, or <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, the other operand is implicitly converted as follows:<dl><dd><ul><li>integer or real floating type to <code>double</code></li><li>complex type to <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code></li><li>imaginary type to <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code></li></ul></dd></dl></div><div>3) Otherwise, if one operand is <code>float</code>, <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, or <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, the other operand is implicitly converted as follows:<dl><dd><ul><li>integer type to <code>float</code> (the only real type possible is float, which remains as-is)</li><li>complex type remains <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code></li><li>imaginary type remains <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code></li></ul></dd></dl></div><div>4) Otherwise, both operands are integers. In that case, <dl><dd>First of all, both operands undergo <i>integer promotions</i> (see below). Then<ul><li> If the types after promotion are the same, that type is the common type</li><li> Otherwise, if both operands after promotion have the same signedness (both signed or both unsigned), the operand with the lesser <i>conversion rank</i> (see below) is implicitly converted to the type of the operand with the greater <i>conversion rank</i></li><li> Otherwise, the signedness is different: If the operand with the unsigned type has <i>conversion rank</i> greater or equal than the rank of the type of the signed operand, then the operand with the signed type is implicitly converted to the unsigned type</li><li> Otherwise, the signedness is different and the signed operand's rank is greater than unsigned operand's rank. In this case, if the signed type can represent all values of the unsigned type, then the operand with the unsigned type is implicitly converted to the type of the signed operand.</li><li> Otherwise, both operands undergo implicit conversion to the unsigned type counterpart of the signed operand's type.</li></ul></dd></dl><div><div><pre><code>1.f + 20000001; // int is converted to float, giving 20000000.00                // addition and then rounding to float gives 20000000.00(char)'a' + 1L; // First, char is promoted back to int.                // this is signed + signed case, different rank                // int is converted to long, the result is 98 signed long2u - 10; // signed / unsigned, same rank         // 10 is converted to unsigned, unsigned math is modulo UINT_MAX+1         // assuming 32 bit ints, result is 4294967288 of type unsigned int (aka UINT_MAX-7)0UL - 1LL; // signed/unsigned diff rank, rank of signed is greater.           // If sizeof(long) == sizeof(long long), signed cannot represent all unsigned           // this is the last case: both operands are converted to unsigned long long           // the result is 18446744073709551615 (ULLONG_MAX) of type unsigned long long</code></pre></div></div></div><p>The result type is determined as follows:<br></p><ul><li> if both operands are complex, the result type is complex</li><li> if both operands are imaginary, the result type is imaginary </li><li> if both operands are real, the result type is real</li><li> if the two floating-point operands have different type domains (complex vs. real, complex vs imaginary, or imaginary vs. real), the result type is complex</li></ul><div><div><pre><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z = 1 + 2*I;double f = 3.0;z + f; // z remains as-is, f is converted to double, the result is double complex</code></pre></div></div><p>As always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a>).</p><p>Note: real and imaginary operands are not implicitly converted to complex because doing so would require extra computation, while producing undesirable results in certain cases involving infinities, NaNs and signed zeros. For example, if reals were converted to complex, 2.0\xc3\x97(3.0+i\xe2\x88\x9e)  would evaluate as (2.0+i0.0)\xc3\x97(3.0+i\xe2\x88\x9e) \xe2\x87\x92 (2.0\xc3\x973.0\xe2\x80\x930.0\xc3\x97\xe2\x88\x9e) + i(2.0\xc3\x97\xe2\x88\x9e+0.0\xc3\x973.0) \xe2\x87\x92 NaN+i\xe2\x88\x9e rather than the correct 6.0+i\xe2\x88\x9e. If imaginaries were converted to complex, i2.0\xc3\x97(\xe2\x88\x9e+i3.0) would evaluate as (0.0+i2.0) \xc3\x97 (\xe2\x88\x9e+i3.0) \xe2\x87\x92 (0.0\xc3\x97\xe2\x88\x9e \xe2\x80\x93 2.0\xc3\x973.0) + i(0.0\xc3\x973.0 + 2.0\xc3\x97\xe2\x88\x9e) \xe2\x87\x92 NaN + i\xe2\x88\x9e instead of \xe2\x80\x936.0 + i\xe2\x88\x9e.<br></p><p>Note: regardless of usual arithmetic conversions, the calculation may always be performed in a narrower type than specifier by these rules under the <a class="new" href="/mwiki/index.php?title=c/language/as_if&amp;action=edit&amp;redlink=1" title="c/language/as if (page does not exist)">as-if rule</a></p><span class="prog__sub"> Value transformations</span><h4> Lvalue conversion</h4><p>Any <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue expression</a> of any non-array type, when used in any context other than </p><ul><li> as the operand of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">address-of operator</a> (if allowed)</li><li> as the operand of the pre/post <a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec">increment and decrement operators</a>.</li><li> as the left-hand operand of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">member access</a> (dot) operator.</li><li> as the left-hand operand of the <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">assignment and compound assignment</a> operators.</li><li> as the operand of <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a></li></ul><p>undergoes <i>lvalue conversion</i>: the type remains the same, but loses <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>/<a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>/<a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a>-qualifiers and <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a> properties, if any. The value remains the same, but loses its lvalue properties (the address may no longer be taken). </p><p>If the lvalue has incomplete type, the behavior is undefined.<br></p><p>If the lvalue designates an object of automatic storage duration whose address was never taken and if that object was uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.<br></p><p>This conversion models the memory load of the value of the object from its location.<br></p><div><div><pre><code>volatile int n = 1;int x = n;            // lvalue conversion on n reads the value of nvolatile int* p = &amp;n; // no lvalue conversion: does not read the value of n</code></pre></div></div><h4> Array to pointer conversion</h4><p>Any <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue expression</a> of <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array type</a>, when used in any context other than </p><ul><li> as the operand of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">address-of operator</a></li><li> as the operand of <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a></li><li> as the string literal used for <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">array initialization</a></li></ul><p>undergoes a conversion to the non-lvalue pointer to its first element.<br></p><p>If the array was declared <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">register</a>, the behavior is undefined.</p><div><div><pre><code>int a[3], b[3][4];int* p = a;      // conversion to &amp;a[0]int (*q)[4] = b; // conversion to &amp;b[0]</code></pre></div></div><h4> Function  to pointer conversion</h4><p>Any function designator expression, when used in any context other than <br></p><ul><li> as the operand of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">address-of operator</a></li><li> as the operand of <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a></li></ul><p>undergoes a conversion to the non-lvalue pointer to the function designated by the expression.<br></p><div><div><pre><code>int f(int);int (*p)(int) = f; // conversion to &amp;f(***p)(1); // repeated dereference to f and conversion back to &amp;f</code></pre></div></div><span class="prog__sub"> Implicit conversion semantics</span><p>Implicit conversion, whether <i>as if by assignment</i> or a <i>usual arithmetic conversion</i>, consists of two stages:</p><div>1) value transformation (if applicable)</div><div>2) one of the conversions listed below (if it can produce the target type)</div><h4> Compatible types</h4><p>Conversion of a value of any type to any <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types#Compatible_type" title="c/language/types">compatible type</a> is always a no-op and does not change the representation.</p><div><div><pre><code><a href="http://en.cppreference.com/w/c/types/integer">uint8_t</a> (*a)[10];         // if uint8_t is a typedef to unsigned charunsigned char (*b)[] = a; // then these pointer types are compatible</code></pre></div></div><h4> Integer promotions</h4><p>Integer promotion is the implicit conversion of a value of any integer type with <i>rank</i> less or equal to <i>rank</i> of int or of a <a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field">bit field</a> of type _Bool, int, signed int, unsigned int, to the value of type <code>int</code> or <code>unsigned int</code></p><p>If <code>int</code> can represent the entire range of values of the original type (or the range of values of the original bit field), the value is converted to type <code>int</code>. Otherwise the value is converted to <code>unsigned int</code>.</p><p>Integer promotions preserve the value, including the sign:<br></p><div><div><pre><code>int main(void) {   void f(); // old-style function declaration   char x = 'a'; // integer conversion from int to char   f(x); // integer promotion from char back to int}void f(x) int x; {} // the function expects int</code></pre></div></div><p><i>rank</i> above is a property of every <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">integer type</a> and is defined as follows:</p><div>1) the ranks of all signed integer types are different and increase with their precision: rank of signed char &lt; rank of short &lt; rank of int &lt; rank of long int &lt; rank of long long int</div><div>2) the ranks of all signed integer types equal the ranks of the corresponding unsigned integer types</div><div>3) the rank of any standard integer type is greater than the rank of any extended integer type of the same size (that is, rank of __int64 &lt; rank of long long int, but rank of long long &lt; rank of __int128 due to the rule (1))</div><div>4) rank of char equals rank of signed char and rank of unsigned char</div><div>5) the rank of _Bool is less than the rank of any other standard integer type</div><div>6) the rank of any enumerated type equals the rank of its compatible integer type</div><div>7) ranking is transitive: if rank of T1 &lt; rank of T2 and rank of T2 &lt; rank of T3 then rank of T1 &lt; rank of T3</div><div>8) any aspects of relative ranking of extended integer types not covered above are implementation defined</div><p>Note: integer promotions are applied only<br></p><ul><li> as part of <i>usual arithmetic conversions</i> (see above)</li><li> as part of <i>default argument promotions</i> (see above)</li><li> to the operand of the unary arithmetic operators + and -</li><li> to the operand of the unary bitwise operator ~</li><li> to both operands of the shift operators &lt;&lt; and &gt;&gt;</li></ul><h4> Boolean conversion</h4><p>A value of any scalar type can be implicitly converted to _Bool. The values that compare equal to zero are converted to <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, all other values are converted to <code>1</code></p><div><div><pre><code>bool b1 = 0.5;              // b1 == 1 (0.5 converted to int would be zero)bool b2 = 2.0*<a href="http://en.cppreference.com/w/c/numeric/complex/Imaginary_I">_Imaginary_I</a>; // b2 == 1 (but converted to int would be zero)bool b3 = 0.0 + 3.0*I;      // b3 == 1 (but converted to int would be zero)bool b4 = 0.0/0.0;          // b4 == 1 (NaN does not compare equal to zero)</code></pre></div></div><h4> Integer conversions</h4><p>A value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:<br></p><ul><li> if the target type can represent the entire range of values of the source type, the value is unchanged</li><li> otherwise, if the target type is unsigned, the value 2b<br/>, where b is the number of bits in the target type, is repeatedly subtracted or added to the source value until the result fits in the target type. In other words, unsigned integers implement modulo arithmetic.</li><li> otherwise, if the target type is signed, the behavior is implementation-defined (which may include raising a signal)</li></ul><div><div><pre><code>char x = 'a'; // int -&gt; char, result unchangedunsigned char n = -123456; // target is unsigned, result is 192 (that is, -123456+483*256)signed char m = 123456;    // target is signed, result is implementation-defined</code></pre></div></div><h4> Real floating-integer conversions</h4><p>A finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:<br></p><ul><li> The fractional part is discarded (truncated towards zero).</li></ul><dl><dd><ul><li> If the resulting value can be represented by the target type, that value is used</li><li> otherwise, the behavior is undefined </li></ul></dd></dl><div><div><pre><code>int n = 3.14; // n == 3int x = 1e10; // undefined behavior for 32-bit int</code></pre></div></div><p>A value of any integer type can be implicitly converted to any real floating type. <br></p><ul><li> if the value can be represented exactly by the target type, it is unchanged</li><li> if the value can be represented, but cannot be represented exactly, the result is the nearest higher or the nearest lower value (in other words, rounding direction is implementation-defined), although if IEEE arithmetic is supported, rounding is to nearest. It is unspecified whether <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is raised in this case.</li><li> if the value cannot be represented, the behavior is undefined, although if IEEE arithmetic is supported, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised and the result value is unspecified.</li></ul><p>The result of this conversion may have greater range and precision than its target type indicates (see <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a>.</p><p>If control over <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is needed in floating-to-integer conversions, <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint">rint</a> and <a href="http://en.cppreference.com/w/c/numeric/math/nearbyint" title="c/numeric/math/nearbyint">nearbyint</a> may be used.</p><div><div><pre><code>double d = 10; // d = 10.00float f = 20000001; // f = 20000000.00 (FE_INEXACT)float x = 1+(long long)<a href="http://en.cppreference.com/w/c/types/limits">FLT_MAX</a>; // undefined behavior</code></pre></div></div><h4> Real floating point conversions</h4><p>A value of any real floating type can be implicitly converted to any other real floating type.<br></p><ul><li> If the value can be represented by the target type exactly, it is unchanged</li><li> if the value can be represented, but cannot be represented exactly, the result is the nearest higher or the nearest lower value (in other words, rounding direction is implementation-defined), although if IEEE arithmetic is supported, rounding is to nearest</li><li> if the value cannot be represented, the behavior is undefined <table><tr><td></td><td>This section is incomplete<br/>Reason: check IEEE if appropriately-signed infinity is required </td></tr></table></li></ul><p>The result of this conversion may have greater range and precision than its target type indicates (see <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a>.</p><div><div><pre><code>double d = 0.1; // d = 0.1000000000000000055511151231257827021181583404541015625float f = d;    // f = 0.100000001490116119384765625float x = 2*(double)<a href="http://en.cppreference.com/w/c/types/limits">FLT_MAX</a>; // undefined</code></pre></div></div><h4> Complex type conversions</h4><p>A value of any complex type can be implicitly converted to any other complex type. The real part and the imaginary part individually follow the conversion rules for the real floating types.<br></p><div><div><pre><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> d = 0.1 + 0.1*I;float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> f = d; // f is (0.100000001490116119384765625, 0.100000001490116119384765625)</code></pre></div></div><h4> Imaginary type conversions</h4><p>A value of any imaginary type can be implicitly converted to any other imaginary  type. The imaginary part follows the conversion rules for the real floating types.<br></p><div><div><pre><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a> d = 0.1*<a href="http://en.cppreference.com/w/c/numeric/complex/Imaginary_I">_Imaginary_I</a>;float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a> f = d; // f is 0.100000001490116119384765625*I</code></pre></div></div><h4> Real-complex conversions</h4><p>A value of any real floating type can be implicitly converted to any complex type. <br></p><ul><li> The real part of the result is determined by the conversion rules for the real floating types</li><li> The imaginary part of the result is positive zero (or unsigned zero on non-IEEE systems)</li></ul><p>A value of any complex type can be implicitly converted to any real floating type<br></p><ul><li> The real part is converted following the rules for the real floating types</li><li> The imaginary part is discarded</li></ul><p>Note: in complex-to-real conversion, a NaN in the imaginary part will not propagate to the real result.<br></p><div><div><pre><code>\xc2\xa0</code></pre></div></div><h4> Real-imaginary conversions</h4><p>A value of any imaginary type can be implicitly converted to any real type (integer or floating-point). The result is always a positive (or unsigned) zero, except when the target type is _Bool, in which case boolean conversion rules apply.<br></p><p>A value of any real type can be implicitly converted to any imaginary type. The result is always a positive imaginary zero.<br></p><div><div><pre><code>\xc2\xa0</code></pre></div></div><h4> Complex-imaginary conversions</h4><p>A value of any imaginary type can be implicitly converted to any complex type.<br></p><ul><li> The real part of the result is the positive zero</li><li> The imaginary part of the result follows the conversion rules for the corresponding real types</li></ul><p>A value of any complex type can be implicitly converted to any imaginary type<br></p><ul><li> The real part is discarded</li><li> The imaginary part of the result follows the conversion rules for the corresponding real types</li></ul><div><div><pre><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a> z = I * (3*I); // the complex result -3.0+0i loses real part, gives zero</code></pre></div></div><h4> Pointer conversions</h4><p>A pointer to <code>void</code> can be implicitly converted to and from any pointer to object type with the following semantics:</p><ul><li> If a pointer to object is converted to a pointer to void and back, its value compares equal to the original pointer.</li><li> No other guarantees are offered</li></ul><div><div><pre><code>int* p = <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(10 * sizeof(int)); // malloc returns void*</code></pre></div></div><p>A pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, and <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> qualifiers can be added. The original pointer and the result compare equal.</p><div><div><pre><code>int n;const int* p = &amp;n; // &amp;n has type int*</code></pre></div></div><p>Any integer <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">constant expression</a> with value <code>\xe2\x80\x8b0\xe2\x80\x8b</code> as well as integer pointer expression with value zero cast to the type <code>void*</code> can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void* expression is known as <i>null pointer constant</i> and the standard library provides one definition of this constant as the macro <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> .</p><div><div><pre><code>int* p = 0;double* q = <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>;</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/conversion
Declarations	A										<section class="prog__container"><p>A <i>declaration</i> is a C language construct that introduces one or more  <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifiers</a> into the program and specifies their meaning and properties.</p><p>Declarations may appear in any scope. Each declaration ends with a semicolon (just like <a href="http://en.cppreference.com/w/c/language/statements" title="c/language/statements">a statement</a>) and consists of two distinct parts:</p><table><tr><td></td></tr><tr><td> specifiers-and-qualifiers declarators-and-initializers <code>;</code></td><td></td><td></td></tr><tr><td></td></tr></table><p>where<br></p><table><tr><td> specifiers-and-qualifiers</td><td> -</td><td>  whitespace-separated list of, in any order,<ul><li> type specifiers:</li></ul><dl><dd><ul><li> <code>void</code></li><li> the name of an <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic type</a></li><li> the name of an <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic type</a></li><li> a name earlier introduced by a <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a> declaration</li><li> <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a>, <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a>, or <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enum</a> specifier</li></ul></dd></dl><ul><li> zero or one storage-class specifiers: <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>, <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">auto, register, static, extern, thread_local</a></li><li> zero or more type qualifiers: <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a>, <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">_Atomic</a></li><li> (only when declaring functions), zero or more function qualifiers: <a href="http://en.cppreference.com/w/c/language/inline" title="c/language/inline">inline</a>, <a href="http://en.cppreference.com/w/c/language/_Noreturn" title="c/language/ Noreturn">noreturn</a></li><li> zero or more alignment specifiers: <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/alignas" title="c/language/alignas">alignas</a></li></ul></td></tr><tr><td> declarators-and-initializers</td><td> -</td><td>  comma-separated list of declarators (each declarator provides additional type information and/or the identifier to declare). Declarators may be accompanied by <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">initializers</a>. The <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enum</a>, <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a>, and <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> declarations may omit declarators, in which case they only introduce the enumeration constants and/or tags.<p><br/></p></td></tr></table><p>For example,<br></p><div><div><pre><code>int a, *b=<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>; // "int" is the type specifier,                // "a" is a declarator                // "*b" is a declarator and NULL is its initializerconst int *f(void); // "int" is the type specifier                    // "const" is the type qualifier                    // "*f(void)" is the declaratorenum COLOR {RED, GREEN, BLUE} c; // "enum COLOR {RED, GREEN, BLUE}" is the type specifier                                 // "c" is the declarator</code></pre></div></div><p>The type of each identifier introduced in a declaration is determined by a combination of the type specified by the type specifier and the type modifications applied by its declarator.</p><span class="prog__sub"> Declarators</span><p>Each declarator is one of the following:<br></p><table><tr><td></td></tr><tr><td> identifier</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>(</code> declarator <code>)</code></td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>*</code> qualifiers(optional) declarator</td><td> (3)</td><td></td></tr><tr><td></td></tr><tr><td> noptr-declarator <code>[</code> static(optional) qualifiers(optional) expression <code>]</code><p>noptr-declarator <code>[</code> qualifiers(optional) <code>*</code> <code>]</code></p></td><td> (4)</td><td></td></tr><tr><td></td></tr><tr><td> noptr-declarator <code>(</code> parameters-or-identifiers <code>)</code></td><td> (5)</td><td></td></tr><tr><td></td></tr></table><div>1) the identifier that this declarator introduces.</div><div>2) any declarator may be enclosed in parentheses; this is required to introduce pointers to arrays and pointers to functions.</div><div>3) <a href="http://en.cppreference.com/w/c/language/pointer" title="c/language/pointer">pointer declarator</a>: the declaration <code>S * cvr D</code>; declares <code>D</code> as a cvr-qualified pointer to the type determined by <code>S</code>.</div><div>4) <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array declarator</a>: the declaration <code>S D[N]</code> declares <code>D</code> as an array of <code>N</code> objects of the type determined by <code>S</code>. noptr-declarator is any other declarator except unparenthesized pointer declarator.</div><div>5) <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declarator</a>: the declaration <code>S D(params)</code> declared <code>D</code> as a function taking the parameters <code>params</code> and returning <code>S</code>. noptr-declarator is any other declarator except unparenthesized pointer declarator.</div><p>The reasoning behind this syntax is that when the identifier declared by the declarator appears in an expression of the same form as the declarator, it would have the type specified by the type specifier sequence.<br></p><div><div><pre><code>struct C {    int member; // "int" is the type specifier                 // "member" is the declarator} obj, *pObj = &amp;obj;// "struct C { int member; }" is the type specifier// declarator "obj" defines an object of type struct C// declarator "*pObj" declares a pointer to C,// initializer "= &amp;obj" provides the initial value for that pointer\xc2\xa0int a = 1, *p = <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, f(void), (*pf)(double);// the type specifier is "int"// declarator "a" defines an object of type int//   initializer "=1" provides its initial value// declarator "*p" defines an object of type pointer to int//   initializer "=NULL" provides its initial value// declarator "f(void)" declares a function taking void and returning int// declarator "(*pf)(double)" defines an object of type pointer//   to function taking double and returning int\xc2\xa0int (*(*foo)(double))[3] = <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>;// the type specifier is int// 1. declarator "(*(*foo)(double))[3]" is an array declarator://    the type declared is "/nested declarator/ array of 3 int"// 2. the nested declarator is "*(*foo)(double))", which is a pointer declarator//    the type declared is "/nested declarator/ pointer to array of 3 int"// 3. the nested declarator is "(*foo)(double)", which is a function declarator//    the type declared is "/nested declarator/ function taking double and returning//        pointer to array of 3 int"// 4. the nested declarator is "(*foo)" which is a (parenthesized, as required by//        function declarator syntax) pointer declarator.//    the type declared is "/nested declarator/ pointer to function taking double//        and returning pointer to array of 3 int"// 5. the nested declarator is "foo", which is an identifier.// The declaration introduces the identifier "foo" to refer to an object of type// "pointer to function taking double and returning pointer to array of 3 int"// The initializer "= NULL" provides the initial value of this pointer.\xc2\xa0// If "foo" is used in an expression of the form of the declarator, its type would be// int.int x = (*(*foo)(1.2))[0];</code></pre></div></div><p>The end of every declarator that is not part of another declarator is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a>.</p><span class="prog__sub"> Definitions</span><p>A <i>definition</i> is a declaration that provides all information about the identifiers it declares.</p><p>Every declaration of an <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enum</a> or a <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a> is a definition.</p><p>For functions, a declaration that includes the function body is a <a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition">function definition</a>:</p><div><div><pre><code>int foo(double); // declarationint foo(double x){ return x; } // definition</code></pre></div></div><p>For objects, a declaration that allocates storage (<a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">automatic or static</a>, but not extern) is a definition, while a declaration that does not allocate storage (<a href="http://en.cppreference.com/w/c/language/extern" title="c/language/extern">external declaration</a>) is not.</p><div><div><pre><code>extern int n; // declarationint n = 10; // definition</code></pre></div></div><p>For <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">structs</a> and <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">unions</a>, declarations that specify the list of members are definitions:</p><div><div><pre><code>struct X; // declarationstruct X { int n; }; // definition</code></pre></div></div><span class="prog__sub"> Redeclaration</span><p>A declaration cannot introduce an identifier if another declaration for the same identifier in the same <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">scope</a> appears earlier, except that</p><ul><li> Declarations of objects <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">with linkage</a> (external or internal) can be repeated:</li></ul><div><div><pre><code>extern int x;int x = 10; // OKextern int x; // OK\xc2\xa0static int n;static int n = 10; // OKstatic int n; // OK</code></pre></div></div><ul><li> Non-VLA <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a> can be repeated as long as it names the same type:</li></ul><div><div><pre><code>typedef int int_t; typedef int int_t; // OK</code></pre></div></div><ul><li> <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> and <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> declarations can be repeated:</li></ul><div><div><pre><code>struct X;struct X { int n; };struct X;</code></pre></div></div><p>These rules simplify the use of header files.<br></p></section>	http://en.cppreference.com/w/c/language/declarations
do-while loop	A										<section class="prog__container"><p>Executes a statement repeatedly until the value of condition becomes false. The test takes place after each iteration.</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>do</code> statement <code>while (</code> expression <code>)</code> <code>;</code></td><td></td><td></td></tr><tr><td></td></tr></table><table><tr><td> expression</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> of <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">scalar type</a>. This expression is evaluated after each iteration, and if it compares equal to zero, the loop is exited.</td></tr><tr><td> statement</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/statements" title="c/language/statements">statement</a>, typically a compound statement, which is the body of the loop</td></tr></table><span class="prog__sub"> Explanation</span><p>A <code>do-while</code> statement causes the statement (also called <i>the loop body</i>) to be executed repeatedly until the expression (also called <i>controlling expression</i>) compares equal to 0. The repetition occurs regardless of whether the loop body is entered normally or by a <a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto">goto</a> into the middle of statement.</p><p>The evaluation of expression takes place after each execution of statement (whether entered normally or by a goto). If the controlling expression needs to be evaluated before the loop body, the <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while loop</a> or the <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for loop</a> may be used.</p><p>If the execution of the loop needs to be terminated at some point, <a href="http://en.cppreference.com/w/c/language/break" title="c/language/break"> break statement</a> can be used as terminating statement. </p><p>If the execution of the loop needs to be continued at the end of the loop body, <a href="http://en.cppreference.com/w/c/language/continue" title="c/language/continue"> continue statement</a> can be used as a shortcut.</p><p>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; <code>do {...} while(true);</code> is always an endless loop.</p><table><tr><td><p>As with all other selection and iteration statements, the do-while statement establishes <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">block scope</a>: any identifier introduced in the expression goes out of scope after the statement.</p></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/do
Enumerations	A										<section class="prog__container"><p>An <i>enumerated type</i> is a distinct <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">type</a> whose value is a value of its <i>underlying type</i> (see below), which includes the values of explicitly named constants (<i>enumeration constants</i>).</p><span class="prog__sub"> Syntax</span><p>Enumerated type is declared using the following <i>enumeration specifier</i> as the type specifier in the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration grammar</a>:</p><table><tr><td></td></tr><tr><td> <code>enum</code> identifier(optional) <code>{</code> enumerator-list <code></code>}</td><td></td><td></td></tr><tr><td></td></tr></table><p>where enumerator-list is a comma-separated list (with trailing comma permitted) (since C99) of enumerators, each of which has the form:</p><table><tr><td></td></tr><tr><td> enumerator</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> enumerator <code>=</code> constant-expression</td><td> (2)</td><td></td></tr><tr><td></td></tr></table><p>where<br></p><table><tr><td> identifier, enumerator</td><td> -</td><td>  identifiers that are introduced by this declaration</td></tr><tr><td> constant-expression</td><td> -</td><td> <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">integer constant expression</a> whose value is representable as a value of type <code>int</code></td></tr></table><p>As with <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a>, a declaration that introduced an enumerated type and one or more enumeration constants may also declare one or more objects of that type or type derived from it.</p><div><div><pre><code>enum color_t {RED, GREEN, BLUE}, c = RED, *cp = &amp;c; // introduces the type enum color_t // the integer constants RED, GREEN, BLUE  // the object c of type enum color_t // the object cp of type pointer to enum color_t</code></pre></div></div><span class="prog__sub"> Explanation</span><p>Each enumerator that appears in the body of an enumeration specifier becomes an <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">integer constant</a> with type <code>int</code> in the enclosing scope and can be used whenever integer constants are required (e.g. as a case label or as a non-VLA array size).</p><div><div><pre><code>enum color_t { RED, GREEN, BLUE} r = RED;switch(r) {     case RED   : <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("red"); break;     case GREEN : <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("green"); break;     case BLUE  : <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("blue"); break;}</code></pre></div></div><p>If enumerator is followed by = constant-expression, its value is the value of that constant expression. If enumerator is not followed by = constant-expression, its value is the value one greater than the value of the previous enumerator in the same enumeration. The value of the first enumerator (if it does not use = constant-expression) is zero.</p><div><div><pre><code>enum Foo { A, B, C=10, D, E=1, F, G=F+C};//A=0, B=1, C=10, D=11, E=1, F=2, G=12</code></pre></div></div><p>The identifier itself, if used, becomes the name of the enumerated type in the tags <a href="http://en.cppreference.com/w/c/language/name_space" title="c/language/name space">name space</a> and requires the use of the keyword enum (unless typedef'd into the ordinary name space).</p><div><div><pre><code>enum color_t { RED, GREEN, BLUE};enum color_t r = RED; // OK// color_t x = GREEN: // Error: color_t is not in ordinary name spacetypedef enum color_t color;color x = GREEN; // OK</code></pre></div></div><p>Each enumerated type is <a href="http://en.cppreference.com/w/c/language/type#Compatible_type" title="c/language/type">compatible</a> with one of: <code>char</code>, a signed integer type, or an unsigned integer type. It is implementation-defined which type is compatible with any given enumerated type, but whatever it is, it must be capable of representing all enumerator values of that enumeration.</p><p>Enumerated types are integer types, and as such can be used anywhere other integer types can, including in <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicit conversions</a> and <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a>.</p><div><div><pre><code>enum { ONE = 1, TWO } e;long n = ONE; // promotiondouble d = ONE; // conversione = 1.2; // conversion, e is now ONEe = e + 1; // e is now TWO</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/enum
Order of evaluation	A										<section class="prog__container"><p>Order of evaluation of the operands of any C operator, including the order of evaluation of function arguments in a function-call expression, and the order of evaluation of the subexpressions within any expression is unspecified (except where noted below). The compiler will evaluate them in any order, and may choose another order when the same expression is evaluated again.<br></p><p>There is no concept of left-to-right or right-to-left evaluation in C, which is not to be confused with left-to-right and right-to-left associativity of operators: the expression <code>f1() + f2() + f3()</code> is parsed as <code>(f1() + f2()) + f3()</code> due to left-to-right associativity of operator+, but the function call to <code>f3</code> may be evaluated first, last, or between <code>f1()</code> or <code>f2()</code> at run time.</p><span class="prog__sub"> Definitions</span><h4> Evaluations</h4><p>There are two kinds of evaluations performed by the compiler for each expression or subexpression (both of which are optional):<br></p><ul><li> <i>value computation</i>: calculation of the value that is returned by the expression. This may involve determination of the identity of the object (<a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue evaluation</a>) or reading the value previously assigned to an object (rvalue evaluation) </li><li> <i>side effect</i>: access (read or write) to an object designated by a <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> lvalue, modification (writing) to an object, atomic synchronization (since C11), modifying a file, modifying the floating-point environment (if supported), or calling a function that does any of those operations.</li></ul><p>If no side effects are produced by an expression and the compiler can determine that the value is not used, the expression <a class="new" href="/mwiki/index.php?title=c/language/as-if&amp;action=edit&amp;redlink=1" title="c/language/as-if (page does not exist)">may not be evaluated</a>.</p><h4> Ordering</h4><p>"sequenced-before" is an asymmetric, transitive, pair-wise relationship between evaluations within the same thread (it may extend across threads if atomic types and memory barriers are involved).<br></p><ul><li> If a <i>sequence point</i> is present between the subexpressions E1 and E2, then both value computation and side effects of E1 are <i>sequenced-before</i> every value computation and side effect of E2</li></ul><table><tr><td><ul><li> If evaluation A is sequenced before evaluation B, then evaluation of A will be complete before evaluation of B begins.</li><li> If A is not sequenced before B and B is sequenced before A, then evaluation of B will be complete before evaluation of A begins.</li><li> If A is not sequenced before B and B is not sequenced before A, then two possibilities exist:<ul><li> evaluations of A and B are unsequenced: they may be performed in any order and may overlap (within a single thread of execution, the compiler may interleave the CPU instructions that comprise A and B)</li><li> evaluations of A and B are indeterminably-sequenced: they may be performed in any order but may not overlap: either A will be complete before B, or B will be complete before A. The order may be the opposite the next time the same expression is evaluated.</li></ul></li></ul></td><td>(since C11)</td></tr></table><span class="prog__sub"> Rules</span><div>1) There is a sequence point after the evaluation of all function arguments and of the function designator, and before the actual function call.</div><div>2) There is a sequence point after evaluation of the first (left) operand and before evaluation of the second (right) operand of the following binary operators: <code>&amp;&amp;</code> (logical AND), <code>||</code> (logical OR), and <code>,</code> (comma).</div><div>3) There is a sequence point after evaluation of the first (left) operand and before evaluation of the second or third operand (whichever is evaluated) of the conditional operator <code>?:</code></div><div>4) There is a sequence point after the evaluation of a full expression (an expression that is not a subexpression: typically something that ends with a semicolon or a controlling statement of if/switch/while/do) and before the next full expression.</div><table><tr><td><div>5) There is a sequence point at the end of a full declarator.</div><div>6) There is a sequence point immediately before the return of a library function.</div><div>7) There is a sequence point after the action associated with each conversion specifier in formatted I/O (in particular, it is well-formed for <a href="http://en.cppreference.com/w/c/io/fscanf" title="c/io/fscanf">scanf</a> to write different fields into the same variable and for <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">printf</a> to read and modify or modify the same variable more than once using <code>%n</code>)</div><div>8) There are sequence points before and immediately after each call to a comparison function made by the library functions <a href="http://en.cppreference.com/w/c/algorithm/qsort" title="c/algorithm/qsort">qsort</a> and <a href="http://en.cppreference.com/w/c/algorithm/bsearch" title="c/algorithm/bsearch">bsearch</a>, as well as between any call to the comparison function and the movement of the associated objects made by <a href="http://en.cppreference.com/w/c/algorithm/qsort" title="c/algorithm/qsort">qsort</a></div></td><td>(since C99)</td></tr><tr><td><div>9) The value computations (but not the side-effects) of the operands to any operator are sequenced before the value computation of the result of the operator (but not its side-effects).</div><div>10) The side effect (modification of the left argument) of the direct assignment operator and of all compound assignment operators is sequenced after the value computation (but not the side effects) of both left and right arguments.</div><div>11) The value computation of the postincrement and postdecrement operators is sequenced before its side-effect.</div><div>12) A function call that is not sequenced before or sequenced after another function call is indeterminately sequenced (CPU instructions that constitute different function calls cannot be interleaved, even if the functions are inlined)</div><div>13) In <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">initialization</a> list expressions, all evaluations are indeterminately sequenced</div><div>14) With respect to an indeterminately-sequenced function call, the operation of compound assignment operators, and both prefix and postfix forms of increment and decrement operators are single evaluations.</div></td><td>(since C11)</td></tr></table><span class="prog__sub"> Undefined behavior</span><div>1) If a side effect on a scalar object is unsequenced relative to another side effect on the same scalar object, the <a href="http://en.cppreference.com/w/c/language/behavior#UB_and_optimization" title="c/language/behavior">behavior is undefined</a>.<div><div><pre><code>i = ++i + i++; // undefined behaviori = i++ + 1; // undefined behaviorf(++i, ++i); // undefined behaviorf(i = -1, i = -1); // undefined behavior</code></pre></div></div></div><div>2) If a side effect on a scalar object is unsequenced relative to a value computation using the value of the same scalar object, the behavior is undefined.<div><div><pre><code>f(i, i++); // undefined behaviora[i] = i++; // undefined bevahior</code></pre></div></div></div><div>3) The above rules apply as long as at least one allowable ordering of subexpressions permits such an unsequenced side-effect.</div></section>	http://en.cppreference.com/w/c/language/eval_order
Expressions	A										<section class="prog__container"><p>An expression is a sequence of <i>operators</i> and their <i>operands</i>, that specifies a computation.</p><p>Expression evaluation may produce a result (e.g., evaluation of <code>2+2</code> produces the result <code>4</code>), may generate side-effects (e.g. evaluation of <code><a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d",4)</code> sends the character <code>'4'</code> to the standard output stream), and may designate objects or functions.</p><h4> General</h4><ul><li> <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">value categories</a> (lvalue, non-lvalue object, function designator) classify expressions by their values</li><li> <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">order of evaluation</a> of arguments and subexpressions specifies the order in which intermediate results are obtained</li></ul><span class="prog__sub"> Operators</span><table><tr><th colspan="7"> Common operators</th></tr><tr><td> <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment"> assignment</a></td><td> <a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec"> increment<br/>decrement</a></td><td> <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic"> arithmetic</a></td><td> <a href="http://en.cppreference.com/w/c/language/operator_logical" title="c/language/operator logical"> logical</a></td><td> <a href="http://en.cppreference.com/w/c/language/operator_comparison" title="c/language/operator comparison"> comparison</a></td><td> <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access"> member<br/>access</a></td><td> <a href="http://en.cppreference.com/w/c/language/operator_other" title="c/language/operator other"> other</a></td></tr><tr><td><p><code>a = b<br/>a += b<br/>a -= b<br/>a *= b<br/>a /= b<br/>a %= b<br/>a &amp;= b<br/>a |= b<br/>a ^= b<br/>a &lt;&lt;= b<br/>a &gt;&gt;= b</code></p></td><td><p><code>++a<br/>--a<br/>a++<br/>a--</code></p></td><td><p><code>+a<br/>-a<br/>a + b<br/>a - b<br/>a * b<br/>a / b<br/>a % b<br/>~a<br/>a &amp; b<br/>a | b<br/>a ^ b<br/>a &lt;&lt; b<br/>a &gt;&gt; b</code></p></td><td><p><code>!a<br/>a &amp;&amp; b<br/>a || b</code></p></td><td><p><code>a == b<br/>a != b<br/>a &lt; b<br/>a &gt; b<br/>a &lt;= b<br/>a &gt;= b</code></p></td><td><p><code>a[b]<br/>*a<br/>&amp;a<br/>a-&gt;b<br/>a.b</code></p></td><td><p><code>a(...)<br/>a, b<br/>(type) a<br/>? :<br/>sizeof<br/>_Alignof</code> (since C11)</p></td></tr></table><ul><li> <a href="http://en.cppreference.com/w/c/language/operator_precedence" title="c/language/operator precedence"> operator precedence</a> defines the order in which operators are bound to their arguments</li><li> <a href="http://en.cppreference.com/w/c/language/operator_alternative" title="c/language/operator alternative"> alternative representations</a> are alternative spellings for some operators </li></ul><h4> Conversions</h4><ul><li> <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">Implicit conversions</a> take place when types of operands do not match the expectations of operators</li><li> <a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast">Casts</a> may be used to explicitly convert values from one type to another.</li></ul><h4> Other</h4><ul><li> <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">constant expressions</a> can be evaluated at compile time and used in compile-time context (non-VLA array sizes, static initializers, etc)</li><li> <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic selections</a> can execute different expressions depending on the types of the arguments</li><li> Floating-point expressions may raise exceptions and report errors as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></li><li> The standard <a href="http://en.cppreference.com/w/c/preprocessor/impl" title="c/preprocessor/impl">#pragmas</a> <code>FENV_ACCESS</code>, <code>FP_CONTRACT</code>, and <code>CX_LIMITED_RANGE</code> as well as the <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">floating-point evaluation precision</a> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding direction</a> control the way floating-point expressions are executed.</li></ul><span class="prog__sub"> Primary expressions</span><p>The operands of any operator may be other expressions or they may be <i>primary expressions</i> (e.g. in <code>1+2*3</code>, the operands of operator+ are the subexpression <code>2*3</code> and the primary expression <code>1</code>).</p><p>Primary expressions are any of the following:<br></p><div>1) Constants and literals (e.g. <code>2</code> or <code>"Hello, world"</code>)</div><div>2) Suitably declared <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifiers</a> (e.g. <code>n</code> or <code>printf</code>)</div><div>3) <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">Generic selections</a></div><p>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator.<br></p><h4> Constants and literals</h4><p>Constant values of certain types may be embedded in the source code of a C program using specialized expressions known as literals (for lvalue expressions) and constants (for non-lvalue expressions)<br></p><ul><li> <a href="http://en.cppreference.com/w/c/language/integer_constant" title="c/language/integer constant">integer constants</a> are decimal, octal, or hexadecimal numbers of integer type.</li><li> <a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant">character constants</a> are individual characters of type int suitable for conversion to a character type or of type <code>char16_t</code>, <code>char32_t</code>,  (since C11)or <code>wchar_t</code></li><li> <a href="http://en.cppreference.com/w/c/language/floating_constant" title="c/language/floating constant">floating constants</a> are values of type <code>float</code>, <code>double</code>, or <code>long double</code></li><li> <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literals</a> are sequences of characters of type <code>char[]</code>, <code>char16_t[]</code>, <code>char32_t[]</code>, or <code>wchar_t[]</code> that represent null-terminated strings</li><li> <a href="http://en.cppreference.com/w/c/language/compound_literal" title="c/language/compound literal">compound literals</a> are values of struct, union, or array type directly embedded in program code</li></ul><span class="prog__sub"> Unevaluated expressions</span><p>The operands of the <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof operator</a> , the <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">_Alignof operator</a>, and the controlling expression of a <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic selection</a>, (since C11) are expressions that are not evaluated (unless they are VLAs) (since C99). Thus, <code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n = sizeof(<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d", 4));</code> does not perform console output.</p></section>	http://en.cppreference.com/w/c/language/expressions
External and tentative definitions	A										<section class="prog__container"><p>At the top level of a <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">translation unit</a> (that is, a source file with all the #includes after the preprocessor), every C program is a sequence of <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>, which declare functions and objects with <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">external linkage</a>. These declarations are known as <i>external declarations</i> because they appear outside of any function.</p><div><div><pre><code>extern int n; // external declaration with external linkageint b = 1;    // external definition with external linkagestatic const char *c = "abc"; // external definition with internal linkageint f(void) {  // external definition with external linkage    int a = 1; // non-external    return b; }static void x(void) { // external definition with internal linkage}</code></pre></div></div><p>Objects declared with an external declaration have static <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a>, and as such cannot use <code>auto</code> or <code>register</code> specifiers. The identifiers introduced by external declarations have <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">file scope</a>.</p><span class="prog__sub"> Tentative definitions</span><p>A <i>tentative definition</i> is an external declaration without an initializer, andeither without a <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage-class specifier</a> or with the specifier <code>static</code>.</p><p>A <i>tentative definition</i> is a declaration that may or may not act as a definition. If an actual external definition is found earlier or later in the same translation unit, then the tentative definition just acts as a declaration.</p><div><div><pre><code>int i1 = 1;     // definition, external linkageint i1;         // tentative definition, acts as declaration because i1 is definedextern int i1;  // declaration, refers to the earlier definition\xc2\xa0extern int i2 = 3; // definition, external linkageint i2;            // tentative definition, acts as declaration because i2 is definedextern int i2;     // declaration, refers to the external linkage definition</code></pre></div></div><p>If there are no definitions in the same translation unit, then the tentative definition acts as an actual definition with the initializer <code>= 0</code> (or, for array types, <code>= {0}</code>).</p><div><div><pre><code>int i3;        // tentative definition, external linkageint i3;        // tentative definition, external linkageextern int i3; // declaration, external linkage// in this translation unit, i3 is defined as if by "int i3 = 0;"</code></pre></div></div><p>Unlike the <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">extern</a> declarations, which don't change the linkage of an identifier if a previous declaration established it, tentative definitions may disagree in linkage with another declaration of the same identifier. If two declarations for the same identifier are in scope and have different linkage, the behavior is undefined:</p><div><div><pre><code>static int i4 = 2; // definition, internal linkageint i4;            // Undefined behavior: linkage disagreement with previous lineextern int i4;     // declaration, refers to the internal linkage definition\xc2\xa0static int i5; // tentative definition, internal linkageint i5;        // Undefined behavior: linkage disagreement with previous lineextern int i5; // refers to previous, whose linkage is internal</code></pre></div></div><p>A tentative definition with internal linkage must have complete type.<br></p><div><div><pre><code>static int i[]; // Error, incomplete type in a static tentative definitionint i[]; // OK, equivalent to int i[1] = {0}; unless redeclared later in this file</code></pre></div></div><span class="prog__sub"> One definition rule</span><p>Each translation unit may have zero or one external definition of every identifier with <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">internal linkage</a> (a <code>static</code> global).</p><p>If an identifier with internal linkage is used in any expression other than a non-VLA (since C99), <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a>, or <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/alignof" title="c/language/alignof">alignof</a>  (since C11), there must be one and only one external definition for that identifier in the translation unit.</p><p>The entire program may have zero or one external definition of every identifier (other than an <a href="http://en.cppreference.com/w/c/language/inline" title="c/language/inline">inline</a> function) (since C99) with <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">external linkage</a>.</p><p>If an identifier with external linkage is used in any expression other than a non-VLA (since C99), <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a>, or <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/alignof" title="c/language/alignof">alignof</a>  (since C11), there must be one and only one external definition for that identifier somewhere in the entire program.</p></section>	http://en.cppreference.com/w/c/language/extern
File scope	A										<section class="prog__container"><p>If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit.<br></p><p>So, placement of an identifier's declaration (in a declarator or type specifier) outside any block or list of parameters means that the identifier has file scope. File scope of an identifier extends from the declaration to the end of the translation unit in which the declaration appears.<br></p><span class="prog__sub"> Example</span><div><p>  Identifiers a, b, f, and g have file scope.<br> </p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0int a = 1;static int b = 2;\xc2\xa0void f (void) {<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("from function f()\n");}static void g (void) {<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("from function g()\n");}\xc2\xa0int main(void){    f();    g();\xc2\xa0    return 0;}/* end of this translation unit, end of file scope */</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>from function f()<br>from function g()</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/file_scope
floating constant	A										<section class="prog__container"><p>Allows values of floating type to be used directly in expressions.<br></p><span class="prog__sub"> Syntax</span><p>A floating constant is a <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">non-lvalue</a> expression having the form:</p><table><tr><td></td></tr><tr><td> significand exponent(optional) suffix(optional)</td><td></td><td></td></tr><tr><td></td></tr></table><p>Where the significand has the form</p><table><tr><td></td></tr><tr><td> whole-number(optional) <code>.</code>(optional) fraction(optional)</td><td></td><td></td></tr><tr><td></td></tr></table><p>The exponent has the form</p><table><tr><td></td></tr><tr><td> <code>e</code> | <code>E</code> exponent-sign(optional) digit-sequence</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>p</code> | <code>P</code> exponent-sign(optional) digit-sequence</td><td> (2)</td><td> (since C99)</td></tr><tr><td></td></tr></table><div>1) The exponent syntax for a decimal floating-point constant</div><div>2) The exponent syntax for hexadecimal floating-point constant</div><span class="prog__sub"> Explanation</span><table><tr><td><p>If the significand begins with the character sequence <code>0x</code> or <code>0X</code>, the floating constant is a <i>hexadecimal floating constant</i>. Otherwise, it is a <i>decimal floating constant</i>.</p><p>For a <i>hexadecimal floating constant</i>, the significand is interpreted as a hexadecimal rational number, and the digit-sequence of the exponent is interpreted as the integer power of 2 to which the significand has to be scaled.</p><div><div><pre><code>double d = 0x1.2p3; // hex fraction 1.2 (decimal 1.125) scaled by 2^3, that is 9.0</code></pre></div></div></td><td>(since C99)</td></tr></table><p>For a <i>decimal floating constant</i>, the significand is interpreted as a decimal rational number, and the digit-sequence of the exponent is interpreted as the integer power of 10 to which the significand has to be scaled.</p><div><div><pre><code>double d = 1.2e3; // decimal fraction 1.2 scaled by 10^3, that is 1200.0</code></pre></div></div><p>An unsuffixed floating constant has type <code>double</code>. If suffix is the letter <code>f</code> or <code>F</code>, the floating constant has type <code>float</code>. If suffix is the letter <code>l</code> or <code>L</code>, the floating constant has type <code>long double</code>.</p><p>The result of evaluating a floating constant is either the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner (in other words, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">default rounding direction</a> during translation is implementation-defined).</p><table><tr><td><p>Floating-point constants may convert to more range and precision than is indicated by their type, if indicated by <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a>. For example, the constant <code>0.1f</code> may act as if it were <code>0.1L</code> in an expression.</p></td><td>(since C99)</td></tr></table><table><tr><td><p>The result of evaluating a hexadecimal floating constant, if FLT_RADIX is 2, is the exact value represented by the floating constant, correctly rounded to the target type.<br></p></td><td>(since C99)</td></tr></table><p>If the exponent is present and fractional part is not used, the decimal separator may be omitted:<br></p><div><div><pre><code>double x = 1e0; // floating-point 1.0 (period not used)</code></pre></div></div><p>For decimal floating constants, the exponent part is optional. If it is omitted, the period is not optional, and either the whole-number or the fraction must be present.</p><div><div><pre><code>double x = 1.; // floating-point 1.0 (fractional part optional)double y = .1; // floating-point 0.1 (whole-number part optional)</code></pre></div></div><table><tr><td><p>For hexadecimal floating constants, the exponent is not optional to avoid ambiguity resulting from an f suffix being mistaken as a hexadecimal digit.<br></p></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/floating_constant
for loop	A										<section class="prog__container"><p>Executes a loop.<br></p><p>Used as a shorter equivalent of <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while loop</a>.</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>for (</code> init_clause <code>;</code> cond_expression <code>;</code> iteration_expression <code>)</code> loop_statement</td><td></td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>Behaves as follows:<br></p><ul><li> init_clause may be an expression or a declaration</li></ul><dl><dd><ul><li> If it is an expression, it is evaluated once, before the first evaluation of cond_expression and its result is discarded.</li><li> (C99) If it is a declaration, it is in scope in the entire loop body, including the remainder of init_clause, the entire cond_expression, the entire iteration_expression and the entire loop_statement. Only <code>auto</code> and <code>register</code> <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage classes</a> are allowed for the variables declared in this declaration.</li></ul></dd></dl><ul><li> cond_expression is evaluated before the loop body. If the result of the expression is zero, the loop statement is exited immediately.</li><li> iteration_expression is evaluated after the loop body and its result is discarded. After evaluating iteration_expression, control is transferred to cond_expression.</li></ul><p>init_clause, cond_expression, and iteration_expression are all optional:</p><div><div><pre><code>for(;;) {   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("endless loop!");}</code></pre></div></div><p>loop_statement is not optional, but it may be a null statement:</p><div><div><pre><code>for(int n = 0; n &lt; 10; ++n, <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", n))    ; // null statement</code></pre></div></div><p>If the execution of the loop needs to be terminated at some point, a <a href="http://en.cppreference.com/w/c/language/break" title="c/language/break"> break statement</a> can be used anywhere within the loop_statement.</p><p>The <a href="http://en.cppreference.com/w/c/language/continue" title="c/language/continue"> continue statement</a> used anywhere within the loop_statement transfers control to iteration_expression.</p><p>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its cond_expression, iteration_expression or loop_statement. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where cond_expression is omitted or is a constant expression; <code>for(;;)</code> is always an endless loop.</p><table><tr><td><p>As with all other selection and iteration statements, the for statement establishes <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">block scope</a>: any identifier introduced in the init_clause, cond_expression, or iteration_expression goes out of scope after the loop_statement.</p></td><td>(since C99)</td></tr></table><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/for" title="c/keyword/for"><tt>for</tt></a></p></section>	http://en.cppreference.com/w/c/language/for
Function declarations	A										<section class="prog__container"><p>A function declaration introduces an <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifier</a> that designates a function and, optionally, specifies the types of the function parameters (the <i>prototype</i>). Function declarations (unlike <a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition">definitions</a>) may appear at block scope as well as file scope.</p><span class="prog__sub"> Syntax</span><p>In the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration grammar</a> of a function declaration, the <i>type-specifier</i> sequence, possibly modified by the declarator, designates the <i>return type</i> (which may be any type other than array or function type), and the <i>declarator</i> has one of two forms:</p><table><tr><td></td></tr><tr><td> noptr-declarator <code>(</code> parameter-list <code>)</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> noptr-declarator <code>(</code> identifier-list(optional) <code>)</code></td><td> (2)</td><td></td></tr><tr><td></td></tr></table><p>where<br></p><table><tr><td> noptr-declarator</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/declarations#Declarators" title="c/language/declarations">declarator</a> except unparenthesized pointer declarator. The identifier that is contained in this declarator is the identifier that becomes the function designator.</td></tr><tr><td> parameter-list</td><td> -</td><td>  either the single keyword <code>void</code> or a comma-separated list of <i>parameters</i>, which may end with an <a href="http://en.cppreference.com/w/c/language/variadic" title="c/language/variadic">ellipsis parameter</a></td></tr><tr><td> identifier-list</td><td> -</td><td>  comma-separated list of identifiers (only if this declarator is used as part of old-style <a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition">function definition</a>), must be omitted for old-style declarations that are not definitions.</td></tr></table><div>1) New-style (C89) function declaration. This declaration both introduces the function designator itself and also serves as a function prototype for any future <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call expressions</a>, forcing conversions from argument expressions to the declared parameter types and compile-time checks for the number of arguments.<div><div><pre><code>int max(int a, int b); // declarationint n = max(12.01, 3.14); // OK, conversion from double to int</code></pre></div></div></div><div>2) Old-style (K&amp;R) function declaration. This declaration does not behave as a prototype and any future <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call expressions</a> will perform default argument promotions and will invoke undefined behavior if the number of arguments doesn't match the number of parameters.<div><div><pre><code>int max();int n = max(true, (char)'a'); // calls max with two int args (after promotions)int n = max(12.01f, 3.14); // calls max with two double args (after promotions)int max(a, b) int a, b; { return a&gt;b?a:b; } // definition expects ints; the second call is undefined</code></pre></div></div></div><span class="prog__sub"> Explanation</span><p>The return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>, must be a complete non-array object type or the type <code>void</code>.</p><div><div><pre><code>void f(char *s); // return type is voidint sum(int a, int b); // return type of sum is int.int (*foo(const void *p))[3]; // return type is pointer to array of 3 int</code></pre></div></div><p>Function declarators can be combined with other declarators as long as they can share their type specifiers and qualifiers<br></p><div><div><pre><code>int f(void), *fip(), (*pfi)(), *ap[3]; // declares two functions and two objectsinline int g(int), n; // error: inline qualifier is for functions onlytypedef int array_t[3];array_t a, h(); // error: array type cannot be a return type for a function</code></pre></div></div><p>If a function declaration appears outside of any function, the identifier it introduces has <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">file scope</a> and <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">external linkage</a>, unless <code>static</code> is used or an earlier static declaration is visible. If the declaration occurs inside another function, the identifier has block scope (and also either internal or external linkage).</p><div><div><pre><code>int main(void){    int f(int); // external linkage, file scope    f(1); // definition needs to be available somewhere in the program}</code></pre></div></div><p>The parameters in a declaration that is not part of a <a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition">function definition</a> do not need to be named:</p><div><div><pre><code>int f(int, int); // declaration// int f(int, int) { return 7; } // Error, parameters must be named in definitions</code></pre></div></div><p>Each parameter in a parameter-list is a <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a> that introduced a single variable, with the following additional properties:</p><ul><li> the identifier in the declarator is optional (except if this function declaration is part of a function definition)</li></ul><div><div><pre><code>int f(int, double); // OKint g(int a, double b); // also OKint f(int, double) { return 1; } // Error: definition must name parameters</code></pre></div></div><ul><li> the only <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage class specifier</a> allowed for parameters is <code>register</code>, and it is ignored in function declarations that are not definitions</li></ul><div><div><pre><code>int f(static int x); // Errorint f(int [static 10]); // OK (array index static is not a storage class specifier)</code></pre></div></div><ul><li> any parameter of array type is adjusted to the corresponding pointer type, which may be qualified if there are qualifiers between the square brackets of the array declarator (since C99)</li></ul><div><div><pre><code>int f(int[]); // declares int f(int*)int g(const int[10]); // declares int g(const int*)int h(int[const volatile]); // declares int h(int * const volatile)int x(int[*]); // declares int x(int*)</code></pre></div></div><ul><li> any parameter of function type is adjusted to the corresponding pointer type</li></ul><div><div><pre><code>int f(char g(double)); // declares int f(char (*g)(double))int h(int(void)); // declares int h(int (*)(void))</code></pre></div></div><ul><li> the parameter list may terminate with <code>, ...</code>, see <a href="http://en.cppreference.com/w/c/language/variadic" title="c/language/variadic">variadic functions</a> for details.</li></ul><div><div><pre><code>int f(int, ...);</code></pre></div></div><ul><li> parameters cannot have type <code>void</code> (but can have type pointer to void). The special parameter list that consists entirely of the keyword <code>void</code> is used to declare functions that take no parameters.</li></ul><div><div><pre><code>int f(void); // OKint g(void x); // Error</code></pre></div></div><ul><li> any identifier that appears in a parameter list that could be treated as a typedef name or as a parameter name is treated as a typedef name: <code>int f(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>, <a href="http://en.cppreference.com/w/c/types/integer">uintptr_t</a>)</code> is parsed as a new-style declarator for a function taking two unnamed parameters of type size_t and uintptr_t, not an old-style declarator that begins the definition of a function taking two parameters named "size_t" and "uintptr_t"</li><li> parameters may have incomplete type and may use the VLA notation [*] (since C99) (except that in a <a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition">function definition</a>, the parameter types after array-to-pointer and functino-to-pointer adjustment must be complete)</li></ul><p>See <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call operator</a> for other details on the mechanics of a function call and <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return">return</a> for returning from functions.</p></section>	http://en.cppreference.com/w/c/language/function_declaration
Function definitions	A										<section class="prog__container"><p>A function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list. Unlike <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declaration</a>, function definitions are allowed at file scope only (there are no nested functions).</p><p>C supports two different forms of function definitions:<br></p><table><tr><td></td></tr><tr><td> specifiers-and-qualifiers parameter-list-declarator function-body</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> specifiers-and-qualifiers identifier-list-declarator declaration-list function-body</td><td> (2)</td><td></td></tr><tr><td></td></tr></table><p>where<br></p><table><tr><td> specifiers-and-qualifiers</td><td> -</td><td>  a combination of<ul><li> <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">type specifiers</a> that, possibly modified by the declarator, form the <i>return type</i></li><li> <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage class specifiers</a>, which determine the linkage of the identifier (<code>static</code>, <code>extern</code>, or none)</li><li> function specifiers <a href="http://en.cppreference.com/w/c/language/inline" title="c/language/inline">inline</a>, <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/noreturn" title="c/language/noreturn">noreturn</a>, or none </li></ul></td></tr><tr><td> parameter-list-declarator</td><td> -</td><td>  a declarator for a function type which uses a <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">parameter list</a> to designate function parameters</td></tr><tr><td> identifier-list-declarator</td><td> -</td><td>  a declarator for a function type which uses a <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">identifier list</a> to designate function parameters</td></tr><tr><td> declaration-list</td><td> -</td><td>  sequence of declarations that declare every identifier in identifier-list-declarator. These declarations cannot use initializers and the only <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage-class specifier</a> allowed is <code>register</code>.</td></tr><tr><td> function-body</td><td> -</td><td>  a <a href="http://en.cppreference.com/w/c/language/statements#Compound_statements" title="c/language/statements">compound statement</a>, that is a brace-enclosed sequence of declarations and statements, that is executed whenever this function is called</td></tr></table><div>1) New-style (C89) function definition. This definition both introduces the function itself and serves as a function prototype for any future <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call expressions</a>, forcing conversions from argument expressions to the declared parameter types.<div><div><pre><code>int max(int a, int b){    return a&gt;b?a:b;}\xc2\xa0double g(void){    return 0.1;}</code></pre></div></div></div><div>2) Old-style (K&amp;R) function definition. This definition does not behave as a prototype and any future <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call expressions</a> will perform default argument promotions.<div><div><pre><code>int max(a, b)int a, b;{    return a&gt;b?a:b;}double g(){    return 0.1;}</code></pre></div></div></div><span class="prog__sub"> Explanation</span><p>As with <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declarations</a>, the return type of the function, determined by the type specifier in specifiers-and-qualiifiers and possibly modified by the declarator as usual in <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>, must be a complete non-array object type or the type <code>void</code>.</p><div><div><pre><code>void f(char *s) { <a href="http://en.cppreference.com/w/c/io/puts">puts</a>(s); } // return type is voidint sum(int a, int b) { return a+b: } // return type is intint (*foo(const void *p))[3] { // return type is pointer to array of 3 int    return <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(sizeof(int[3]));}</code></pre></div></div><p>As with <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declarations</a>, the types of the parameters are adjusted from functions to pointers and from arrays to pointers and their top-level qualifiers are stripped for the purpose of constructing the function type.</p><p>Unlike <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declarations</a>, unnamed formal parameters are not allowed, they must be named even if they are not used within the function. The only exception is the special parameter list <code>(void)</code></p><div><div><pre><code>int f(int, int); // declaration// int f(int, int) { return 7; } // Errorint f(int a, int b) { return 7; } // definitionint g(void) { return 8; } // OK, void doesn't declare a parameter</code></pre></div></div><p>Within the function body, every parameter is an <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue</a> expression, they have automatic <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> and <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">block scope</a>. The layout of the parameters in memory (or if they are stored in memory at all) is unspecified: it is a part of the <a class="extiw" href="http://en.wikipedia.com/wiki/Calling_convention" title="enwiki:Calling convention">calling convention</a>.</p><div><div><pre><code>int main(int ac, char **av){    ac = 2; // parameters are lvalues    av = (char *[]){"abc", "def", <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>};    f(ac, av);}</code></pre></div></div><p>See <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call operator</a> for other details on the mechanics of a function call and <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return">return</a> for returning from functions.</p><table><tr><td><span class="prog__sub"> __func__</span><p>WIthin every function-body, the special predefined variable <code>__func__</code> with block scope and static storage duration is available,  as if defined immediately after the opening brace by</p><div><div><pre><code>static const char __func__[] = "function name";</code></pre></div></div><p>This special identifier is sometimes used in combination with the <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace">predefined macro constants</a> <code>__FILE__</code> and <code>__LINE__</code>, for example, by <a href="http://en.cppreference.com/w/c/error/assert" title="c/error/assert">assert</a>.</p></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/function_definition
Functions	A										<section class="prog__container"><p>A function is a C language construct that associates a <a href="http://en.cppreference.com/w/c/language/statements#Compound_statements" title="c/language/statements">compound statement</a> (the function body) with an <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifier</a> (the function name). Every C program begins execution from the <a href="http://en.cppreference.com/w/c/language/main_function" title="c/language/main function">main function</a>, which either terminates, or invokes other, user-defined or library functions.</p><div><div><pre><code>// function definition.// defines a function with the name "sum" and with the body "{ return x+y; }"int sum(int x, int y) {    return x + y;}</code></pre></div></div><p>Functions may accept zero or more <i>parameters</i>, which are initialized from the <i>arguments</i> of a <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call operator</a>, and may return a value to its caller by means of the <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return">return statement</a>.</p><div><div><pre><code>int n = sum(1, 2); // parameters x and y are initialized with the arguments 1 and 2</code></pre></div></div><p>The body of a function is provided in a <a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition">function definition</a>. Each function must be defined only once in a program, unless the function is <a href="http://en.cppreference.com/w/c/language/inline" title="c/language/inline">inline</a>.</p><p>There are no nested functions (except where allowed through non-standard compiler extensions): each function definition must appear at file scope, and functions have no access to the local variables from the caller:<br></p><div><div><pre><code>int main(void) // the main function definition{    int sum(int, int); // function declaration (may appear at any scope)    int x = 1;  // local variable in main    sum(1, 2); // function call\xc2\xa0//    int sum(int a, int b) // error: no nested functions//    {//        return  a + b; //    }}int sum(int a, int b) // function definition{//    return x + a + b; //  error: main's x is not accessible within sum    return a + b;}</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/functions
Generic selection	A										<section class="prog__container"><p>Provides a way to choose one of several expressions at compile time, based on a type of a controlling expression<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Generic</code> <code>(</code> controlling-expression <code>,</code> association-list <code>)</code></td><td></td><td> (since C11)</td></tr><tr><td></td></tr></table><p>where association-list is a comma-separated list of associations, each of which has the syntax</p><table><tr><td></td></tr><tr><td> type-name <code>:</code> expression</td><td></td><td></td></tr><tr><td></td></tr><tr><td> <code>default</code> <code>:</code> expression</td><td></td><td></td></tr><tr><td></td></tr></table><p>where<br></p><table><tr><td> type-name</td><td> -</td><td>  any complete <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">object type</a> that isn't variably-modified (that is, not VLA or pointer to VLA).</td></tr><tr><td> controlling-expression</td><td> -</td><td>  any expression (except for the <a href="http://en.cppreference.com/w/c/language/operator_other#Comma_operator" title="c/language/operator other">comma operator</a>) whose type must be compatible with one of the type-names if the <code>default</code> association is not used</td></tr><tr><td> expression</td><td> -</td><td>  any expression (except for the <a href="http://en.cppreference.com/w/c/language/operator_other#Comma_operator" title="c/language/operator other">comma operator</a>) of any type and value category</td></tr></table><p>No two type-names in the association-list may specify <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible types</a>. There may be only one association that uses the keyword <code>default</code>. If <code>default</code> is not used and none of the type-names are compatible with the type of the controlling expression, the program will not compile.</p><span class="prog__sub"> Explanation</span><p>The type of controlling-expression (after applying <a href="http://en.cppreference.com/w/c/language/conversion#Lvalue_conversions" title="c/language/conversion">lvalue conversions</a> if applicable and if supported -- see notes below), is compared with type-names from the list of associations.</p><p>If the type is <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> with the type-name of one of the associations, then the type, value, and <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">value category</a> of the generic selection are the type, value, and value category of the  expression that appears after the colon for that type-name.</p><p>If none of the type-names are compatible with the type of the controlling-expression, and the <code>default</code> association is provided, then the type, value, and value category of the generic selection are the type, value, and value category of the expression after the <code>default\xc2\xa0:</code> label.</p></section>	http://en.cppreference.com/w/c/language/generic
goto statement	A										<section class="prog__container"><p>Transfers control unconditionally to the desired location.<br></p><p>Used when it is otherwise impossible to transfer control to the desired location using conventional constructs.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>goto</code> label <code>;</code></td><td></td><td></td></tr><tr><td></td></tr><tr><td> label <code>:</code> statement</td><td></td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>The <code>goto</code> statement causes an unconditional jump (transfer of control) to the statement prefixed by the named label (which must appear in the same function as the goto statement), except when this jump would enter the scope of a <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">variable-length array</a> or another <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">variably-modified type</a>. (since C99)</p><p>A label is an identifier followed by a colon (:) and a statement. Labels are the only identifiers that have <i>function scope</i>: they can be used (in a goto statement) anywhere in the same function in which they appear. There may be multiple labels before any statement.</p><table><tr><td><p>Entering the scope of a non-variably modified variable is permitted:<br></p><div><div><pre><code>goto lab1; // OK: going into the scope of a regular variable    int n = 5;lab1:; // Note, n is uninitialized, as if declared by int n;\xc2\xa0//   goto lab2;   // Error: going into the scope of two VM types     double a[n]; // a VLA     int (*p)[n]; // a VM pointerlab2:</code></pre></div></div><p>If <code>goto</code> leaves the scope of a VLA, it is deallocated (and may be reallocated if its initialization is executed again): </p><div><div><pre><code>{   int n = 1;label:;   int a[n]; // re-allocated 10 times, each with a different size   if (n++ &lt; 10) goto label; // leaving the scope of a VM}</code></pre></div></div></td><td>(since C99)</td></tr></table><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/goto" title="c/keyword/goto"><tt>goto</tt></a></p></section>	http://en.cppreference.com/w/c/language/goto
History of C	A										<section class="prog__container"><h2> Early C</h2><ul><li> 1969: B created, based on BCPL, to replace PDP-7 assembler as the system programming language for Unix</li></ul><dl><dd><ul><li> added operators ++, --, compound assignment, remained a typeless language like BCPL</li></ul></dd></dl><ul><li> 1971: NB ("new B") created when porting B to PDP-11</li></ul><dl><dd><ul><li> types (int, char, arrays and pointers), array-to-pointer conversion, compilation to machine code</li></ul></dd></dl><ul><li> 1972: Language renamed to C</li></ul><dl><dd><ul><li> structs, operators &amp;&amp; and ||, preprocessor, portable I/O</li></ul></dd></dl><ul><li> 1973: Unix re-written in C</li></ul><dl><dd><ul><li> unsigned, long, unions, enumerations, increased type safety</li></ul></dd></dl><ul><li> 1978: The C Programming Language, 1st edition</li></ul><h2> Standard C</h2><ul><li> 1983: ANSI established X3J11 committee</li><li> 1988: The C Programming Language, 2nd edition</li><li> 1989: <code>C89</code>, the ANSI C standard published</li></ul><ol><li> codified existing practices</li><li> new features: volatile, enum, signed, void, locales</li><li> From C++: const, function prototypes</li></ol><ul><li> 1990: <code>C90</code>, the ANSI C standard accepted as ISO/IEC 9899-1990</li><li> 1995: <code>C95</code> (ISO/IEC 9899 AM1) (<a class="external text" href="http://infostore.saiglobal.com/store/Details.aspx?DocN=isoc000767513" rel="nofollow">online store</a>)</li></ul><ol><li> multibyte character support (wchar_t and all wide and multibyte character functions, wchar.h, wctype.h, and those added to existing headers and corresponding changes to stream I/O, etc)</li><li> digraphs, iso646.h, </li></ol><ul><li> 1995: Technical corrigendum 1 (ISO/IEC 9899 TCOR1)</li></ul><dl><dd><ul><li> <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/tc1.htm" rel="nofollow">44 small changes</a></li></ul></dd></dl><ul><li> 1996: Technical corrigendum 2 (ISO/IEC 9899 TCOR2)</li></ul><dl><dd><ul><li> <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/tc2.htm" rel="nofollow">24 small changes</a></li></ul></dd></dl><ul><li> 1999: <code>C99</code> (ISO/IEC 9899:1999)</li></ul><ol><li> new features: bool, long long, stdint.h, inttypes.h, restrict, compound literals, variable length arrays, flexible array members, designated initializers, fenv.h, variadic macros, complex numbers, __func__, hexadecimal floating point format (%a), monetary formatting in lconv, isblank, concatenation of narrow and wide string literals, trailing comma in enumerations, empty arguments in function-like macros, STDC_* pragmas, va_copy, null return of tmpnam, null pointer in setvbuf, hh and ll lengthspecifiers in printf, snprintf, _Exit, tgmath.h, POSIX-like strftime specifiers</li><li> from C++: inline, mix declarations and code, declarations in the init clause of the for loop, <code>//</code> comments, universal character names in source code</li><li> removed implicit functions and implicit int</li></ol><ul><li> 2001: Technical corrigendum 1 (ISO/IEC 9899:1999/Cor.1:2001(E))</li></ul><dl><dd><ul><li> <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/9899tc1/" rel="nofollow">11 defects fixed</a></li></ul></dd></dl><ul><li> 2004: Technical corrigendum 2 (ISO/IEC 9899:1999/Cor.2:2004(E))</li><li> 2004: Unicode TR (ISO/IEC TR 19769:2004) (<a class="external text" href="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=33907" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1040.pdf" rel="nofollow">November 7, 2003 draft</a>)</li><li> 2007: Technical corrigendum 3 (ISO/IEC 9899:1999/Cor.3:2007(E)) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf" rel="nofollow">September 7, 2007 draft</a>)</li></ul><dl><dd><ul><li> deprecated <a href="http://en.cppreference.com/w/c/io/gets" title="c/io/gets">gets</a></li></ul></dd></dl><ul><li> 2007: Bounds-checking interfaces TR (ISO/IEC TR 24731-1:2007) (<a class="external text" href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=38841" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1225.pdf" rel="nofollow">March 28, 2007 draft</a>)</li><li> 2008: Embedded TR (ISO/IEC TR 18037:2008) (<a class="external text" href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=51126" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1021.pdf" rel="nofollow">September 24, 2003 draft</a>)</li><li> 2009: Decimal floating-point TR (ISO/IEC TR 24732:2009) (<a class="external text" href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=38842" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1241.pdf" rel="nofollow">July 5, 2007 draft</a>)</li><li> 2009: Mathematical special functions TR (ISO/IEC TR 24747:2009) (<a class="external text" href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=38857" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1182.pdf" rel="nofollow">August 2, 2006 draft</a>)</li><li> 2010: Dynamic allocations functions TR (ISO/IEC TR 24731-2:2010) (<a class="external text" href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=51678" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1248.pdf" rel="nofollow">August 15, 2007 draft</a>)</li><li> 2011: <code>C11</code> (ISO/IEC 9899:2011) (<a class="external text" href="http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=57853" rel="nofollow">ISO store</a>) (<a class="external text" href="http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS%2fISO%2fIEC+9899-2012#.UGCvLIHyaHM" rel="nofollow">ANSI store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf" rel="nofollow">April 12, 2011 draft</a>)</li></ul><ol><li> thread-aware memory model, stdatomic.h, threads.h, type-generic functions, alignas/alignof, noreturn, static assert, analyzability extensions, extensions to complex and imaginary types, anonymous structures and unions, exclusive file open mode. quick_exit</li><li> removed <a href="http://en.cppreference.com/w/c/io/gets" title="c/io/gets">gets</a></li><li> from Bounds-checking interfaces TR: bounds-checking interfaces, </li><li> from Unicode TR: char16_t, char32_t, and uchar.h</li></ol><ul><li> 2012: Technical corrigendum 1 (ISO/IEC 9899:2011/Cor 1:2012) (<a class="external text" href="http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=61717" rel="nofollow">ISO store</a>)</li></ul><dl><dd><ul><li> <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1606.pdf" rel="nofollow">2 minor bug fixes</a></li></ul></dd></dl><ul><li> 2013: Secure Coding Rules TS (ISO/IEC TS 17961:2013) (<a class="external text" href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=61134" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1624.pdf" rel="nofollow">June 26, 2012</a>)</li><li> 2014: FP TS part 1: Binary floating-point arithmetic (ISO/IEC TS 18661-1:2014) (<a class="external text" href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=63146" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1778.pdf" rel="nofollow">2013 draft</a> )</li></ul><ol><li> provides changes to C11 (mostly to Annex F) that cover all basic requirements and some recommendations of IEC 60559:2011 (C11 was built on IEC 60559:1989)</li></ol><ul><li> 2015: FP TS part 2: Decimal floating-point arithmetic (ISO/IEC TS 18661-2:2015) (<a class="external text" href="http://www.iso.org/iso/home/store/catalogue_ics/catalogue_detail_ics.htm?csnumber=68882" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1912.pdf" rel="nofollow">2015 draft</a>)</li></ul><ol><li> provides changes to C11 to support all the requirements, plus some basic recommendations, of IEC 60559:2011 for decimal floating-point arithmetic. This supersedes ISO/IEC TR 24732:2009.</li></ol><ul><li> 2015: FP TS part 3: Interchange and extended types (ISO/IEC TS 18661-3:2015) (<a class="external text" href="http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=65615" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1945.pdf" rel="nofollow">2015 draft</a>)</li></ul><ol><li> provides changes to C11 to support the recommendations of IEC 60559:2011 for extended floating\xe2\x80\x90point formats and the interchange formats, both arithmetic and non-arithmetic.</li></ol><ul><li> 2015: FP TS part 4: Supplementary functions (ISO/IEC TS 18661-4:2015) (<a class="external text" href="http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=65616" rel="nofollow">ISO store</a>) (<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1950.pdf" rel="nofollow">2015 draft</a>)</li></ul><ol><li> provides changes to C11 to support all mathematical operations recommended by IEC 60559:2011, including trigonometry in \xcf\x80 units, inverse square root, compounded interest, etc.</li></ol><ul><li> 2016: FP TS part 5: Supplementary attributes (ISO/IEC TS 18661-5:2016) (<a class="external text" href="http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=65617" rel="nofollow">ISO store</a>)(<a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2004.pdf" rel="nofollow">2016 draft</a>)</li></ul><ol><li> provides changes to C11 to support all supplementary attributes (evaluation model, exception handling, reproducibility, etc) recommended by IEC 60559:2011</li></ol><span class="prog__sub"> Future development</span><ul><li> Parallelism TS (Draft <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2017.pdf" rel="nofollow">n2017</a> 2016-03-10)</li><li> Transactional Memory TS (Draft <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1961.pdf" rel="nofollow">n1961</a> 2015-09-23)</li><li> <code>C2x</code> Next C language standard revision </li></ul><dl><dd><ul><li> List of C11 defect reports: <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2059.htm" rel="nofollow">n2059  (august 2016)</a></li><li> List of issues that were not granted DR status: <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2087.htm" rel="nofollow">n2087 (september 2016)</a></li></ul></dd></dl></section>	http://en.cppreference.com/w/c/language/history
if statement	A										<section class="prog__container"><p>Conditionally executes code.<br></p><p>Used where code needs to be executed only if some condition is true.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>if (</code> expression <code>)</code> statement_true</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>if (</code> expression <code>)</code> statement_true <code>else</code> statement_false</td><td> (2)</td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>expression must be an expression of any <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">scalar type</a>.</p><p>If expression compares not equal to the integer zero, statement_true is executed.</p><p>In the form (2), if expression compares equal to the integer zero, statement_false is executed.</p><table><tr><td><p>As with all other selection and iteration statements, the entire if-statement has its own block scope:<br></p><div><div><pre><code>enum {a, b};int different(void){    if (sizeof(enum {b, a}) != sizeof(int))        return a; // a == 1    return b; // b == 0 in C89, b == 1 in C99}</code></pre></div></div></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/if
Initialization	A										<section class="prog__container"><p>A <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a> of an object may provide its initial value through the process known as <i>initialization</i>.</p><p>For each <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarator</a>, the initializer, if not omitted, may be one of the following:</p><table><tr><td></td></tr><tr><td> <code>=</code> expression</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>=</code> <code>{ </code> initializer-list <code>} </code></td><td> (2)</td><td></td></tr><tr><td></td></tr></table><p>where initializer-list is a non-empty comma-separated list of initializers (with an optional trailing comma), where each initializer has one of three possible forms:</p><table><tr><td></td></tr><tr><td> expression</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>{ </code> initializer-list <code>} </code></td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> designator-list <code>=</code> initializer</td><td> (3)</td><td></td></tr><tr><td></td></tr></table><p>where designator-list is a list of either array designators of the form <code>[</code> constant-expression <code>]</code> or struct/union member designators of the form <code>.</code> identifier; see <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">array initialization</a> and <a href="http://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization">struct initialization</a>.</p><span class="prog__sub"> Explanation</span><p>The initializer specifies the initial value stored in an object.<br></p><h4> Explicit initialization</h4><p>If an initializer is provided, see<br></p><ul><li> <a href="http://en.cppreference.com/w/c/language/scalar_initialization" title="c/language/scalar initialization">scalar initialization</a> for the initialization of scalar types</li><li> <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">array initialization</a> for the initialization of array types</li><li> <a href="http://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization">struct initialization</a> for the initialization of struct and union types.</li></ul><h4> Implicit initialization</h4><p>If an initializer is not provided:<br></p><ul><li> objects with automatic <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> are initialized to indeterminate values (which may be <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">trap representations</a>)</li><li> objects with static and thread-local <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> are initialized as follows</li></ul><dl><dd><ul><li> pointers are initialized to null pointer values of their types</li><li> objects of integral types are initialized to unsigned zero</li><li> objects of floating types are initialized to positive zero</li><li> members of arrays, structs, and unions are initialized as described above, recursively, plus all padding bits are initialized to zero</li></ul></dd><dd>(on platforms where null pointers and floating zeroes have all-bit-zero representations, this form of initialization for statics is normally implemented by allocating them in the .bss section of the program image)</dd></dl></section>	http://en.cppreference.com/w/c/language/initialization
inline function specifier	A										<section class="prog__container"><p>Declares an <a class="extiw" href="http://en.wikipedia.com/wiki/inline_function" title="enwiki:inline function">inline function</a>.</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>inline</code> function_declaration</td><td></td><td> (since C99)</td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>The intent of the <code>inline</code> specifier is to serve as a hint for the compiler to perform optimizations, such as function inlining, which require the definition of a function to be visible at the call site. The compilers can (and usually do) ignore presence or absence of the <code>inline</code> specifier for the purpose of optimization.</p><p>If the compiler performs function inlining, it replaces a call of that function with its body, avoiding the overhead of a function call (placing data on stack and retrieving the result), which may result in a larger executable as the code for the function has to be repeated multiple times. The result is similar to <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace">function-like macros</a>, except that identifiers and macros used in the function refer to the definitions visible at the point of definition, not at the point of call.</p><p>Regardless of whether inlining takes place, the following semantics of inline functions are guaranteed:<br></p><p>Any function with internal linkage may be declared <code>static inline</code> with no other restrictions.</p><p>A non-static inline function cannot define a non-const function-local static and cannot refer to a file-scope static.<br></p><div><div><pre><code>static int x;inline void f(void){    static int n = 1; // error: non-const static in a non-static inline function    int k = x; // error: non-static inline function accesses a static variable}</code></pre></div></div><p>If a non-static function is declared <code>inline</code>, then it must be defined in the same translation unit. The inline definition that does not use <code>extern</code> is not externally visible and does not prevent other translation units from defining the same function. This makes the <code>inline</code> keyword an alternative to <code>static</code> for defining functions inside header files, which may be included in multiple translation units of the same program.</p><p>If a function is declared <code>inline</code> in some translation units, it does not need to be declared inline everywhere: at most one translation unit may also provide a regular, non-inline non-static function, or a function declared <code>extern inline</code>. This one translation unit is said to provide the <i>external definition</i>. One external definition must exist in the program if the name of the function with external linkage is used in an expression, see <a href="http://en.cppreference.com/w/c/language/extern#One_definition_rule" title="c/language/extern">one definition rule</a>. </p><p>If the external definition exists in the program, the address of the function is always the address of the external function, but when this address is used to make a function call, it's unspecified whether the <i>inline definition</i> (if present in the translation unit) or the <i>external definition</i> is called. The static objects defined within an inline definition are distinct from the static objects defined within the external definition:</p><div><div><pre><code>inline const char *saddr(void) // the inline definition for use in this file{    static const char name[] = "saddr";    return name;}int compare_name(void){    return saddr() == saddr(); // unspecified behavior, one call could be external}extern const char *saddr(void); // an external definition is generated, too</code></pre></div></div><p>A valid C program must not depend on whether the inline version or the external version of a function is called.<br></p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/inline" title="c/keyword/inline"><tt>inline</tt></a></p></section>	http://en.cppreference.com/w/c/language/inline
integer constant	A										<section class="prog__container"><p>Allows values of integer type to be used in expressions directly.<br></p><span class="prog__sub"> Syntax</span><p>An integer constant is a <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">non-lvalue</a> expression of the form</p><table><tr><td></td></tr><tr><td> decimal-constant integer-suffix(optional)</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> octal-constant integer-suffix(optional)</td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> hex-constant integer-suffix(optional)</td><td> (3)</td><td></td></tr><tr><td></td></tr></table><p>where<br></p><ul><li> decimal-constant is a non-zero decimal digit (<code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>), followed by zero or more decimal digits (<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>)</li><li> octal-constant is the digit zero (<code>0</code>) followed by zero or more octal digits (<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>)</li><li> hex-constant is the character sequence <code>0x</code> or the character sequence <code>0X</code> followed by one or more hexadecimal digits (<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>, <code>a</code>, <code>A</code>, <code>b</code>, <code>B</code>, <code>c</code>, <code>C</code>, <code>d</code>, <code>D</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>)</li><li> integer-suffix, if provided, may contain one or both of the following (if both are provided, they may appear in any order:</li></ul><dl><dd><ul><li> unsigned-suffix (the character <code>u</code> or the character <code>U</code>)</li><li> long-suffix (the character <code>l</code> or the character <code>L</code>) or the long-long-suffix (the character sequence <code>ll</code> or the character sequence <code>LL</code>) (since C99)</li></ul></dd></dl><span class="prog__sub"> Explanation</span><div>1) Decimal integer constant (base 10, the first digit is the most significant).</div><div>2) Octal integer constant (base 8, the first digit is the most significant).</div><div>3) Hexadecimal integer constant (base 16, the first digit is the most significant, the letters 'a' through 'f' represent the decimal values 10 through 15).</div><p>The following variables are initialized to the same value:<br></p><div><div><pre><code>int d = 42;int o = 052;int x = 0x2a;int X = 0X2A;</code></pre></div></div><span class="prog__sub"> The type of the integer constant</span><p>The type of the integer constant is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</p><table><tr><th colspan="3"> Types allowed for integer constants</th></tr><tr><td> suffix</td><td> decimal bases</td><td> hexadecimal or octal bases</td></tr><tr><td> no suffix</td><td> <code>int</code><p><code>long int</code><br/><code>unsigned long int</code> (until C99)<br/><code>long long int</code> (since C99)</p></td><td> <code>int</code><p><code>unsigned int</code><br/><code>long int</code><br/><code>unsigned long int</code><br/><code>long long int</code>(since C99)<br/><code>unsigned long long int</code>(since C99)</p></td></tr><tr><td> <code>u</code> or <code>U</code></td><td> <code>unsigned int</code><p><code>unsigned long int</code><br/><code>unsigned long long int</code>(since C99)</p></td><td> <code>unsigned int</code><p><code>unsigned long int</code><br/><code>unsigned long long int</code>(since C99)</p></td></tr><tr><td> <code>l</code> or <code>L</code></td><td> <code>long int</code><p><code>unsigned long int</code>(until C99)<br/><code>long long int</code>(since C99)</p></td><td> <code>long int</code><p><code>unsigned long int</code><br/><code>long long int</code>(since C99)<br/><code>unsigned long long int</code>(since C99)</p></td></tr><tr><td> both <code>l</code>/<code>L</code> and <code>u</code>/<code>U</code></td><td> <code>unsigned long int</code><p><code>unsigned long long int</code>(since C99)</p></td><td> <code>unsigned long int</code><p><code>unsigned long long int</code>(since C99)</p></td></tr><tr><td> <code>ll</code> or <code>LL</code></td><td> <code>long long int</code>(since C99)</td><td> <code>long long int</code>(since C99)<p><code>unsigned long long int</code>(since C99)</p></td></tr><tr><td> both <code>ll</code>/<code>LL</code> and <code>u</code>/<code>U</code></td><td> <code>unsigned long long int</code>(since C99)</td><td> <code>unsigned long long int</code>(since C99)</td></tr></table><p>If the value of the integer constant is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as <code>__int128</code>), the constant may be given the extended integer type; otherwise, the program is ill-formed.</p></section>	http://en.cppreference.com/w/c/language/integer_constant
Lifetime	A										<section class="prog__container"><p>Every <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">object</a> in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate), and, for VLA, retains its size (since C99) over a portion of program execution known as this object's <i>lifetime</i>.</p><p>For the objects that are declared with automatic, static, and thread storage duration, lifetime equals their <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> (note the difference between non-VLA and VLA automatic storage duration).</p><p>For the objects with allocated storage duration, the lifetime begins when the allocation function returns (including the return from <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc</a>) and ends when the <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc</a> or deallocation function is called. Note that since allocated objects have no <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">declared type</a>, the type of the lvalue expression first used to access this object becomes its <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">effective type</a>.</p><p>Accessing an object outside of its lifetime is undefined behavior.<br></p><div><div><pre><code>int* foo(void) {    int a = 17; // a has automatic storage duration    return &amp;a;}  // lifetime of a endsint main(void) {    int* p = foo(); // p points to an object past lifetime ("dangling pointer")    int n = *p; // undefined behavior}</code></pre></div></div><p>A pointer to an object (or one past the object) whose lifetime ended has indeterminate value.<br></p><span class="prog__sub"> Temporary lifetime</span><p>Struct and union objects with array members (either direct or members of nested struct/union members) that are designated by <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">non-lvalue expressions</a>, have <i>temporary lifetime</i>. Temporary lifetime begins when the expression that refers to such object is evaluated and ends at the next <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> (until C11)when the containing full expression or full declarator ends (since C11).</p><p>Any attempt to modify an object with temporary lifetime results in undefined behavior.<br></p><div><div><pre><code>struct T { double a[4]; };struct T f(void) { return (struct T){3.15}; }double g1(double* x) { return *x; }void g2(double* x) { *x = 1.0; }int main(void){    double d = g1(f().a); // C99: UB access to a[0] in g1 whose lifetime ended                          //      at the sequence point at the start of g1                          // C11: OK, d is 3.15    g2(f().a); // C99: UB modification of a[0] whose lifetime ended at the sequence point               // C11: UB attempt to modify a temporary object}</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/lifetime
Main function	A										<section class="prog__container"><p>Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function called <code>main</code>, which is the designated start of the program.</p><table><tr><td></td></tr><tr><td> <code>int</code> <code>main</code> <code>(void)</code> <code>{</code> body <code>} </code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>int</code> <code>main</code> <code>(</code><code>int</code> argc<code>,</code> <code>char</code> <code>*</code>argv<code>[]</code><code>)</code> <code>{</code> body <code>} </code></td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>int</code> <code>main</code> <code>(</code><code>int</code> argc<code>,</code> <code>char</code> <code>*</code>argv<code>[]</code> <code>,</code> other_parameters <code>)</code> <code>{</code> body <code>} </code></td><td> (3)</td><td></td></tr><tr><td></td></tr><tr><td> <code>/* another implementation-defined signature */</code></td><td> (4)</td><td></td></tr><tr><td></td></tr></table><p><br/></p><span class="prog__sub"> Parameters</span><table><tr><td>  argc</td><td> -</td><td>  Non-negative value representing the number of arguments passed to the program from the environment in which the program is run.</td></tr><tr><td>  argv</td><td> -</td><td>  Pointer to an array of pointers to null-terminated multibyte strings that represent the arguments passed to the program from the execution environment (<code>argv[0]</code> through <code>argv[argc-1]</code>). The value of <code>argv[argc]</code> is guaranteed to be <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.</td></tr><tr><td>  body</td><td> -</td><td>  The body of the main function</td></tr><tr><td> other_parameters</td><td> -</td><td>  Implementations may allow additional forms of the main function. A very common extension is passing a third argument of type <code>char*[]</code> pointing at <a class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html" rel="nofollow">an array of pointers to the execution environment variables</a>.</td></tr></table><p>The names <code>argc</code> and <code>argv</code> are arbitrary, as well as the representation of the types of the parameters: <code>int main(int ac, char** av)</code> is equally valid.</p><span class="prog__sub"> Return value</span><p>If the return statement is used, the return value is used as the argument to the implicit call to <a href="http://en.cppreference.com/w/c/program/exit" title="c/program/exit">exit()</a> (see below for details). The values zero and <a href="http://en.cppreference.com/w/c/program/EXIT_status" title="c/program/EXIT status">EXIT_SUCCESS</a> indicate successful termination, the value <a href="http://en.cppreference.com/w/c/program/EXIT_status" title="c/program/EXIT status">EXIT_FAILURE</a> indicates unsuccessful termination.</p><span class="prog__sub"> Explanation</span><p>The <code>main</code> function is called at program startup, after all objects with static storage duration are initialized. It is the designated entry point to a program that is executed in <i>hosted</i> environment (that is, with an operating system). The name and type of the entry point to any <i>freestanding</i> program (boot loaders, OS kernels, etc) are implementation-defined.</p><p>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as <i>command line arguments</i>). The pointers <code>argv[1] .. argv[argc-1]</code> point at the first characters in each of these strings. <code>argv[0]</code> is the pointer to the initial character of a null-terminated multibyte strings that represents the name used to invoke the program itself (or, if this is not supported by the execution environment, argv[0][0] is guaranteed to be zero). </p><p>If the execution environment cannot distinguish between uppercase and lowercase letters, the command line arguments are converted to lower case.<br></p><p>The strings are modifiable, and any modifications made persist until program termination, although these modifications do not propagate back to the execution environment: they can be used, for example, with <a href="http://en.cppreference.com/w/c/string/byte/strtok" title="c/string/byte/strtok">strtok</a>.</p><p>The size of the array pointed to by <code>argv</code> is at least <code>argc+1</code>, and the last element, <code>argv[argc]</code>, is guaranteed to be a null pointer.</p><p>The <code>main</code> function has several special properties:</p><div>1) A prototype for this function cannot be supplied by the program</div><div>2) If the return type of the main function is <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> with <code>int</code>, then the return from the initial call to main (but not the return from any subsequent, recursive, call) is equivalent to executing the <a href="http://en.cppreference.com/w/c/program/exit" title="c/program/exit">exit</a> function, with the value that the main function is returning passed as the argument (which then calls the functions registered with <a href="http://en.cppreference.com/w/c/program/atexit" title="c/program/atexit">atexit</a>, flushes and closes all streams, and deletes the files created with <a href="http://en.cppreference.com/w/c/io/tmpfile" title="c/io/tmpfile">tmpfile</a>, and returns control to the execution environment).</div><div>3) If the return type of the main function is not <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> with <code>int</code> (e.g. <code>void main(void)</code>), the value returned to the execution environment is unspecified</div><div>4) The body of the main function does not need to contain the <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return">return statement</a>: if control reaches the end of <code>main</code> without encountering a return statement, the effect is that of executing <code>return 0;</code>.</div><span class="prog__sub"> Example</span><div><p> Demonstrates how to inform a program about where to find its input and where to write its results.<p>Invocation: ./a.out indatafile outdatafile<br></p></p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0int main(int argc, char *argv[]){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("argc =\xc2\xa0%d\n", argc);    int ndx = 0;    while (ndx &lt; argc)    {          <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("argv[%d] --&gt;\xc2\xa0%s\n", ndx,argv[ndx]);          ++ndx;    }    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("argv[argc] =\xc2\xa0%s\n", argv[argc]);    return 0;}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>argc = 3<br>argv[0] --&gt; ./a.out<br>argv[1] --&gt; indatafile<br>argv[2] --&gt; outdatafile<br>argv[argc] = (null)</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/main_function
Memory model	A										<section class="prog__container"><p>Defines the semantics of computer memory storage for the purpose of the C abstract machine.<br></p><p>The data storage (memory) available to a C program is one or more contiguous sequences of <i>bytes</i>. Each byte in memory has a unique <i>address</i>.</p><span class="prog__sub"> Byte</span><p>A <i>byte</i> is the smallest addressable unit of memory. It is defined as a contiguous sequence of bits, large enough to hold any member of the <i>basic execution character set</i> (<a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">the 96 characters</a> that are required to be single-byte). C supports bytes of sizes 8 bits and greater.</p><p>The <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types">types</a> <code>char</code>, <code>unsigned char</code>, and <code>signed char</code> use one byte for both storage and <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">value representation</a>. The number of bits in a byte is accessible as <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">CHAR_BIT</a>.</p><span class="prog__sub"> Memory location</span><p>A <i>memory location</i> is </p><ul><li> an object of <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">scalar type</a> (arithmetic type, pointer type, enumeration type)</li><li> or the largest contiguous sequence of <a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field">bit fields</a> of non-zero length</li></ul><div><div><pre><code>struct S {    char a;     // memory location #1    int b : 5;  // memory location #2    int c : 11, // memory location #2 (continued)          : 0,        d : 8;  // memory location #3    struct {        int ee : 8; // memory location #4    } e;} obj; // The object 'obj' consists of 4 separate memory locations</code></pre></div></div><table><tr><td><span class="prog__sub"> Threads and data races</span><p>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by <a href="http://en.cppreference.com/w/c/thread/thrd_create" title="c/thread/thrd create">thrd_create</a> or other means.</p><p>Any thread can potentially access any object in the program (objects with automatic and thread-local <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> may still be accessed by another thread through a pointer).</p><p>Different threads of execution are always allowed to access (read and modify) different <i>memory locations</i> concurrently, with no interference and no synchronization requirements. (note that it is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (non-zero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be)</p><p>When an <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">evaluation</a> of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to <i>conflict</i>. A program that has two conflicting evaluations has a <i>data race</i> unless either</p><ul><li> both conflicting evaluations are <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic operations</a></li><li> one of the conflicting evaluations <i>happens-before</i> another (see <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order</a>)</li></ul><p>If a data race occurs, the behavior of the program is undefined.<br></p>(in particular, <a href="http://en.cppreference.com/w/c/thread/mtx_unlock" title="c/thread/mtx unlock">mtx_unlock</a> is <i>synchronized-with</i>, and therefore, <i>happens-before</i> <a href="http://en.cppreference.com/w/c/thread/mtx_lock" title="c/thread/mtx lock">mtx_lock</a> of the same mutex by another thread, which makes it possible to use mutex locks to guard against data races) <table><tr><td></td><td>This section is incomplete<br/>Reason: small example or two </td></tr></table><span class="prog__sub"> Memory order</span><p>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order</a> for details on the order in which writes made from threads become visible to other threads.</p></td><td>(since C11)</td></tr></table></section>	http://en.cppreference.com/w/c/language/memory_model
Lookup and name spaces	A										<section class="prog__container"><p>When an <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifier</a> is encountered in a C program, a lookup is performed to locate the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a> that introduced that identifier and that is currently <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">in scope</a>. C allows more than one declaration for the same identifier to be in scope simultaneously if these identifiers belong to different categories, called <i>name spaces</i>:</p><div>1) Label name space: all identifiers declared as <a href="http://en.cppreference.com/w/c/language/statements#Labels" title="c/language/statements">labels</a>.</div><div>2) Tag names: all identifiers declared as names of <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">structs</a>, <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">unions</a> and <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enumerated types</a>. Note that all three kinds of tags share one name space.</div><div>3) Member names: all identifiers declared as members of any one <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a>. Every struct and union introduces its own name space of this kind.</div><div>4) All other identifiers, called <i>ordinary identifiers</i> to distinguish from (1-3) (function names, object names, typedef names, enumeration constants).</div><p>At the point of lookup, the name space of an identifier is determined by the manner in which it is used:<br></p><div>1) identifier appearing as the operand of a <a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto">goto statement</a> is looked up in the label name space.</div><div>2) identifier that follows the keyword <code>struct</code>, <code>union</code>, or <code>enum</code> is looked up in the tag name space.</div><div>3) identifier that follows the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">member access</a> or member access through pointer operator is looked up in the name space of members of the type determined by the left-hand operand of the member access operator.</div><div>4) all other identifiers are looked up in the name space of ordinary identifiers.</div></section>	http://en.cppreference.com/w/c/language/name_space
_Noreturn function specifier	A										<section class="prog__container"><p>Specifies that the function does not return to its point of invocation.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Noreturn</code> function_declaration</td><td></td><td> (since C11)</td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>The <code>_Noreturn</code> keyword appears in a function declaration and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a>). If the function declared <code>_Noreturn</code> returns, the behavior is undefined. A compiler diagnostic is recommended if this can be detected.</p><p>The <code>_Noreturn</code> specifier may appear more than once in the same function declaration, the behavior is the same as if it appeared once.</p><p>This specifier is typically used through the convenience macro <a href="http://en.cppreference.com/w/c/types" title="c/types"><tt>noreturn</tt></a>, which is provided in the header <code>stdnoreturn.h</code></p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/_Noreturn" title="c/keyword/ Noreturn"><tt>_Noreturn</tt></a></p><span class="prog__sub"> Standard library</span><p>The following functions are <code>noreturn</code> in the standard library:</p><ul><li> <a href="http://en.cppreference.com/w/c/program/abort" title="c/program/abort">abort()</a></li><li> <a href="http://en.cppreference.com/w/c/program/exit" title="c/program/exit">exit()</a></li><li> <a href="http://en.cppreference.com/w/c/program/_Exit" title="c/program/ Exit">_Exit()</a></li><li> <a href="http://en.cppreference.com/w/c/program/quick_exit" title="c/program/quick exit">quick_exit()</a></li><li> <a href="http://en.cppreference.com/w/c/thread/thrd_exit" title="c/thread/thrd exit">thrd_exit()</a></li><li> <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp()</a></li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdnoreturn.h&gt;\xc2\xa0// causes undefined behavior if i &lt;= 0// exits if i &gt; 0noreturn void stop_now(int i) // or _Noreturn void stop_now(int i){    if (i &gt; 0) <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(i);}\xc2\xa0int main(void){  <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("Preparing to stop...");  stop_now(2);  <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("This code is never executed.");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Preparing to stop...</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/noreturn
Alternative operators and tokens	A										<section class="prog__container"><p>C source code may be written in any non-ASCII 7-bit character set that includes the <a class="extiw" href="http://en.wikipedia.com/wiki/ISO_646" title="enwiki:ISO 646">ISO 646:1983</a> invariant character set. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: <code>{, }, [, ], #, \\, ^, |, ~</code>. To be able to use character encodings where some or all of these symbols do not exist (such as the German <a class="external text" href="http://de.wikipedia.org/wiki/DIN_66003" rel="nofollow">DIN 66003</a>), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.</p><h2> Operator macros(C95)</h2><p>There are alternative spellings for the operators that use non-ISO646 characters, defined in <code>&lt;iso646.h&gt;</code> as macros:</p><table><tr><td> <div>Defined in header <code>&lt;iso646.h&gt;</code> </div></td></tr><tr><td>  Primary</td><td>  Alternative</td></tr><tr><td> <div><div><code>&amp;&amp;</code></div></div></td><td> <code>and</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>&amp;=</code></div></div></td><td> <code>and_eq</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>&amp;</code></div></div></td><td> <code>bitand</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>|</code></div></div></td><td> <code>bitor</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>~</code></div></div></td><td> <code>compl</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>!</code></div></div></td><td> <code>not</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>!=</code></div></div></td><td> <code>not_eq</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>||</code></div></div></td><td> <code>or</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>|=</code></div></div></td><td> <code>or_eq</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>^</code></div></div></td><td> <code>xor</code> <br/> (macro constant)</td></tr><tr><td> <div><div><code>^=</code></div></div></td><td> <code>xor_eq</code> <br/> (macro constant)</td></tr></table><p>The characters <code>&amp;</code> and <code>!</code> are invariant under ISO-646, but alternatives are provided for the operators that use these characters anyway to accommodate even more restrictive historical charsets.</p><p>There is no alternative spelling (such as <code>eq</code>) for the equality operator <code>==</code> because the character <code>=</code> was present in all supported charsets.</p><h2> Alternative tokens(C95)</h2><p>The following alternative tokens are part of the core language, and, in all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace">stringification operator</a> can make the spelling visible). The two-letter alternative tokens are sometimes called "digraphs"</p><p><br/></p><table><tr><th> Primary</th><th> Alternative</th></tr><tr><td> <code>{</code> </td><td> <code>&lt;%</code></td></tr><tr><td> <code></code>} </td><td> <code>%&gt;</code></td></tr><tr><td> <code>[</code> </td><td> <code>&lt;:</code></td></tr><tr><td> <code>]</code> </td><td> <code>:&gt;</code></td></tr><tr><td> <code>#</code> </td><td> <code>%:</code></td></tr><tr><td> <code>##</code> </td><td> <code>%:%:</code></td></tr></table><h2> Trigraphs</h2><p>The following three-character groups (trigraphs) are <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">parsed before comments and string literals are recognized</a>, and each appearance of a trigraph is replaced by the corresponding primary character:</p><table><tr><th> Primary</th><th> Trigraph</th></tr><tr><td> <code>{</code> </td><td> <code>??&lt;</code></td></tr><tr><td> <code></code>} </td><td> <code>??&gt;</code></td></tr><tr><td> <code>[</code> </td><td> <code>??(</code></td></tr><tr><td> <code>]</code> </td><td> <code>??)</code></td></tr><tr><td> <code>#</code> </td><td> <code>??=</code></td></tr><tr><td> <code>\\</code> </td><td> <code>??/</code></td></tr><tr><td> <code>^</code> </td><td> <code>??'</code></td></tr><tr><td> <code>|</code> </td><td> <code>??!</code></td></tr><tr><td> <code>~</code> </td><td> <code>??-</code></td></tr></table><p>Because trigraphs are processed early, a comment such as <code>// Will the next line be executed?????/</code> will effectively comment out the following line, and the string literal such as <code>"What's going on??!"</code> is parsed as <code>"What's going on|"</code>.</p><span class="prog__sub"> Example</span><div><p> The following example demonstrates alternative operator spellings from the <code>&lt;iso646.h&gt;</code> header as well as use of digraphs and trigraphs.<p>The space character in the first command-line argument, argv[1], requires the quotation marks: ", World!".<br></p></p><div><div>Run this code</div></div><div><div><pre><code>%:include &lt;stdlib.h&gt;%:include &lt;stdio.h&gt;%:include &lt;iso646.h&gt;\xc2\xa0int main(int argc, char** argv)??&lt;    if (argc &gt; 1 and argv&lt;:1:&gt; not_eq <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>)    &lt;%       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Hello%s\n", argv&lt;:1:&gt;);    %&gt;\xc2\xa0    return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_SUCCESS</a>;??&gt;</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>Hello, World!</code></pre></div></div></div><table><tr><td> <div><a href="http://en.cppreference.com/w/cpp/language/operator_alternative" title="cpp/language/operator alternative">C++ documentation</a> for Alternative operator representations</div></td></tr></table></section>	http://en.cppreference.com/w/c/language/operator_alternative
Arithmetic operators	A										<section class="prog__container"><p>Arithmetic operators apply standard mathematical operations to their operands.<br></p><table><tr><td></td><td>This section is incomplete<br/>Reason: consider a more general-purpose ToC for this and other tables that cover multiple topics </td></tr></table><table><tr><th> Operator</th><th> Operator name</th><th> Example</th><th> Result</th></tr><tr><td> <code>+</code></td><td> unary plus</td><td> <code>+a</code></td><td> the value of <b>a</b> after promotions</td></tr><tr><td> <code>-</code></td><td> unary minus</td><td> <code>-a</code></td><td> the negative of <b>a</b></td></tr><tr><td> <code>+</code></td><td> addition</td><td> <code>a + b</code></td><td> the addition of <b>a</b> and <b>b</b></td></tr><tr><td> <code>-</code></td><td> subtraction</td><td> <code>a - b</code></td><td> the subtraction of <b>b</b> from <b>a</b></td></tr><tr><td> <code>*</code></td><td> product</td><td> <code>a * b</code></td><td> the product of <b>a</b> and <b>b</b></td></tr><tr><td> <code>/</code></td><td> division</td><td> <code>a / b</code></td><td> the division of <b>a</b> by <b>b</b></td></tr><tr><td> <code>%</code></td><td> modulo</td><td> <code>a % b</code></td><td> the remainder of <b>a</b> divided by <b>b</b></td></tr><tr><td> <code>~</code></td><td> bitwise NOT</td><td> <code>~a</code></td><td> the bitwise NOT of <b>a</b></td></tr><tr><td> <code>&amp;</code></td><td> bitwise AND</td><td> <code>a &amp; b</code></td><td> the bitwise AND of <b>a</b> and <b>b</b></td></tr><tr><td> <code>|</code></td><td> bitwise OR</td><td> <code>a | b</code></td><td> the bitwise OR of <b>a</b> and <b>b</b></td></tr><tr><td> <code>^</code></td><td> bitwise XOR</td><td> <code>a ^ b</code></td><td> the bitwise XOR of <b>a</b> and <b>b</b></td></tr><tr><td> <code>&lt;&lt;</code></td><td> bitwise left shift</td><td> <code>a &lt;&lt; b</code></td><td> <b>a</b> left shifted by <b>b</b></td></tr><tr><td> <code>&gt;&gt;</code></td><td> bitwise right shift</td><td> <code>a &gt;&gt; b</code></td><td> <b>a</b> right shifted by <b>b</b></td></tr></table><span class="prog__sub"> Overflows</span><p>Unsigned integer arithmetic is always performed modulo 2n<br/> where n is the number of bits in that particular integer. E.g. for <code>unsigned int</code>, adding one to <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">UINT_MAX</a> gives <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, and subtracting one from <code>\xe2\x80\x8b0\xe2\x80\x8b</code> gives <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">UINT_MAX</a>.</p><p>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. <code>-ftrapv</code> in GCC and Clang), or may be completely <a class="external text" href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html" rel="nofollow">optimized out by the compiler</a>.</p><h4> Floating-point environment</h4><p>If <a href="http://en.cppreference.com/w/c/preprocessor/impl" title="c/preprocessor/impl"><tt>#pragma STDC FENV_ACCESS</tt></a> is set to <code>ON</code>, all floating-point arithmetic operators obey the current floating-point <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding direction</a> and report floating-point arithmetic errors as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a> unless part of a <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">static initializer</a> (in which case floating-point exceptions are not raised and the rounding mode is to nearest)</p><h4> Floating-point contraction</h4><p>Unless <a href="http://en.cppreference.com/w/c/preprocessor/impl" title="c/preprocessor/impl"><tt>#pragma STDC FP_CONTRACT</tt></a> is set to <code>OFF</code>, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of <code>(x*y) + z</code> with a single fused multiply-add CPU instruction or optimization of <code>a = x*x*x*x;</code> as <code>tmp = x*x; a = tmp*tmp</code>.</p><p>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></p><span class="prog__sub"> Unary arithmetic</span><p>The unary arithmetic operator expressions have the form <br></p><table><tr><td></td></tr><tr><td> <code>+</code> expression</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>-</code> expression</td><td> (2)</td><td></td></tr><tr><td></td></tr></table><div>1) unary plus (promotion)</div><div>2) unary minus (negation)<p>where <br></p><table><tr><td> expression</td><td> -</td><td>  expression of any <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic type</a></td></tr></table></div><p>Both unary plus and unary minus first apply <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">integral promotions</a> to their operand, and then</p><ul><li> unary plus returns the value after promotion</li><li> unary minus returns the negative of the value after promotion (except that the negative of a NaN is another NaN)</li></ul><p>The type of the expression is the type after promotion, and the <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">value category</a> is non-lvalue.</p></section>	http://en.cppreference.com/w/c/language/operator_arithmetic
Assignment operators	A										<section class="prog__container"><p>Assignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right.<br></p><table><tr><th> Operator</th><th> Operator name</th><th> Example</th><th> Description</th><th> Equivalent of</th></tr><tr><td> <code>=</code></td><td> basic assignment</td><td> <code>a = b</code></td><td> <b>a</b> becomes equal to <b>b</b></td><td> <small>N/A</small></td></tr><tr><td> <code>+=</code></td><td> addition assignment</td><td> <code>a += b</code></td><td> <b>a</b> becomes equal to the addition of <b>a</b> and <b>b</b></td><td> <code>a = a + b</code></td></tr><tr><td> <code>-=</code></td><td> subtraction assignment</td><td> <code>a -= b</code></td><td> <b>a</b> becomes equal to the subtraction of <b>b</b> from <b>a</b></td><td> <code>a = a - b</code></td></tr><tr><td> <code>*=</code></td><td> multiplication assignment</td><td> <code>a *= b</code></td><td> <b>a</b> becomes equal to the product of <b>a</b> and <b>b</b></td><td> <code>a = a * b</code></td></tr><tr><td> <code>/=</code></td><td> division assignment</td><td> <code>a /= b</code></td><td> <b>a</b> becomes equal to the division of <b>a</b> by <b>b</b></td><td> <code>a = a / b</code></td></tr><tr><td> <code>%=</code></td><td> modulo assignment</td><td> <code>a %= b</code></td><td> <b>a</b> becomes equal to the remainder of <b>a</b> divided by <b>b</b></td><td> <code>a = a % b</code></td></tr><tr><td> <code>&amp;=</code></td><td> bitwise AND assignment</td><td> <code>a &amp;= b</code></td><td> <b>a</b> becomes equal to the bitwise AND of <b>a</b> and <b>b</b></td><td> <code>a = a &amp; b</code></td></tr><tr><td> <code>|=</code></td><td> bitwise OR assignment</td><td> <code>a |= b</code></td><td> <b>a</b> becomes equal to the bitwise OR of <b>a</b> and <b>b</b></td><td> <code>a = a | b</code></td></tr><tr><td> <code>^=</code></td><td> bitwise XOR assignment</td><td> <code>a ^= b</code></td><td> <b>a</b> becomes equal to the bitwise XOR of <b>a</b> and <b>b</b></td><td> <code>a = a ^ b</code></td></tr><tr><td> <code>&lt;&lt;=</code></td><td> bitwise left shift assignment</td><td> <code>a &lt;&lt;= b</code></td><td> <b>a</b> becomes equal to <b>a</b> left shifted by <b>b</b></td><td> <code>a = a &lt;&lt; b</code></td></tr><tr><td> <code>&gt;&gt;=</code></td><td> bitwise right shift assignment</td><td> <code>a &gt;&gt;= b</code></td><td> <b>a</b> becomes equal to <b>a</b> right shifted by <b>b</b></td><td> <code>a = a &gt;&gt; b</code></td></tr></table><span class="prog__sub"> Simple assignment</span><p>The simple assignment operator expressions have the form <br></p><table><tr><td></td></tr><tr><td> lhs <code>=</code> rhs</td><td></td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> lhs</td><td> -</td><td> <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">modifiable lvalue</a> expression of any complete object type</td></tr><tr><td> rhs</td><td> -</td><td>  expression of any type <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicitly convertible</a> to lhs or <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> with lhs</td></tr></table><p>Assignment performs <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicit conversion</a> from the value of rhs to the type of rhs and then replaces the value in the object designated by lhs with the converted value of rhs.</p><p>Assignment also returns the same value as what was stored in <code>lhs</code> (so that expressions such as <code>a = b = c</code> are possible). The <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">value category</a> of the assignment operator is non-lvalue (so that expressions such as <code>(a=b)=c</code> are invalid).</p><p>rhs and lhs must satisfy one of the following:</p><ul><li> both lhs and rhs have <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> type, or..</li><li> rhs must be <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicitly convertible</a> to lhs, which implies</li></ul><dl><dd><ul><li> both lhs and rhs have <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>, in which case lhs may be <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>-qualified or <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a></li><li> both lhs and rhs have <a href="http://en.cppreference.com/w/c/language/pointer" title="c/language/pointer">pointer</a> to <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> (ignoring qualifiers) types, or one of the pointers is a pointer to void, and the <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">conversion</a> would not add qualifiers to the pointed-to type. lhs may be <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> or <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a>-qualified or <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a>.</li><li> lhs is a pointer (possibly qualified or atomic) and rhs is a null pointer constant such as <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a></li><li> lhs has type _Bool (possibly qualified or atomic) and rhs is a pointer</li></ul></dd></dl></section>	http://en.cppreference.com/w/c/language/operator_assignment
Comparison operators	A										<section class="prog__container"><p>Comparison operators are binary operators that test a condition and return <b>1</b> if that condition is logically <b>true</b> and <b>0</b> if that condition is <b>false</b>..</p><table><tr><th> Operator</th><th> Operator name</th><th> Example</th><th> Description</th></tr><tr><td> <code>==</code></td><td> equal to</td><td> <code>a == b</code></td><td> <b>a</b> is equal to <b>b</b></td></tr><tr><td> <code>!=</code></td><td> not equal to</td><td> <code>a != b</code></td><td> <b>a</b> is not equal to <b>b</b></td></tr><tr><td> <code>&lt;</code></td><td> less than</td><td> <code>a &lt; b</code></td><td> <b>a</b> is less than <b>b</b></td></tr><tr><td> <code>&gt;</code></td><td> greater than</td><td> <code>a &gt; b</code></td><td> <b>a</b> is greater than <b>b</b></td></tr><tr><td> <code>&lt;=</code></td><td> less than or equal to</td><td> <code>a &lt;= b</code></td><td> <b>a</b> is less than or equal to <b>b</b></td></tr><tr><td> <code>&gt;=</code></td><td> greater than or equal to</td><td> <code>a &gt;= b</code></td><td> <b>a</b> is greater than or equal to <b>b</b></td></tr></table><span class="prog__sub"> Relational operators</span><p>The relational operator expressions have the form <br></p><table><tr><td></td></tr><tr><td> lhs <code>&lt;</code> rhs</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> lhs <code>&gt;</code> rhs</td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> lhs <code>&lt;=</code> rhs</td><td> (3)</td><td></td></tr><tr><td></td></tr><tr><td> lhs <code>&gt;=</code> rhs</td><td> (4)</td><td></td></tr><tr><td></td></tr></table><div>1) less-than expression</div><div>2) greater-than expression</div><div>3) less or equal expression</div><div>4) greater or equal expression<p>where <br></p><table><tr><td> lhs, rhs</td><td> -</td><td>  expressions that both have real type or both have pointer to object type</td></tr></table></div><p>The type of any relational operator expression is <code>int</code>, and its value (which is not an lvalue) is <code>1</code> when the specified relationship holds true and <code>\xe2\x80\x8b0\xe2\x80\x8b</code> when the specified relationship does not hold.</p><p>If lhs and rhs are expressions of any <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types" title="c/language/types">real type</a>, then</p><ul><li> if lhs and rhs have arithmetic type, <a href="http://en.cppreference.com/w/c/language/conversion#Usual_arithmetic_conversions" title="c/language/conversion">usual arithmetic conversions</a> are performed</li><li> the values of the operands after conversion are compared in the usual mathematical sense (except that positive and negative zeroes compare equal and any comparison involving a NaN value returns zero)</li></ul><p>Note that complex and imaginary numbers cannot be compared with these operators.<br></p><p>If lhs and rhs are expressions of pointer type, they must be both pointers to objects of <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types#Compatible_types" title="c/language/types">compatible types</a>, except that qualifications of the pointed-to objects are ignored.</p><ul><li> a pointer to an object that is not an element of an array is treated as if it were pointing to an element of an array with one element</li><li> if two pointers point to the same object, or both point one past the end of the same array, they compare equal</li><li> if two pointers point to different elements of the same array, the one pointing at the element with the larger index compares greater.</li><li> if one pointer points to the element of an array and the other pointer points one past the end of the same array, the one-past-the-end pointer compares greater</li><li> if the two pointers point to members of the same <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a>, the pointer to the member declared later in the struct definition compares greater than then pointer to the member declared earlier.</li><li> pointers to members of the same union compare equal</li><li> all other pointer comparisons invoke undefined behavior</li></ul><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;assert.h&gt;int main(void){    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(1 &lt; 2);    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(2+2 &lt;= 4.0); // int converts to double, two 4.0's compare equal\xc2\xa0    struct { int x,y; } s;    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(&amp;s.x &lt; &amp;s.y); // struct members compare in order of declaration\xc2\xa0    double d = 0.0/0.0; // NaN    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>( !(d &lt; d) );    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>( !(d &gt; d) );    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>( !(d &gt;= d) );    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>( !(d &gt;= d) );\xc2\xa0    float f = 0.1; // f = 0.100000001490116119384765625    double g = 0.1; // g = 0.1000000000000000055511151231257827021181583404541015625    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(f &gt; g); // different values}</code></pre></div></div><p><br/></p></div><span class="prog__sub"> Equality operators</span><p>The equality operator expressions have the form <br></p><table><tr><td></td></tr><tr><td> lhs <code>==</code> rhs</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> lhs <code>!=</code> rhs</td><td> (2)</td><td></td></tr><tr><td></td></tr></table><div>1) equal-to expression</div><div>2) not equal to expression<p>where <br></p><table><tr><td> lhs, rhs</td><td> -</td><td>  expressions that<ul><li> both have any <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic types</a> (including complex and imaginary)</li><li> both are pointers to objects or functions of <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/types#Compatible_types" title="c/language/types">compatible</a> types, ignoring qualifiers of the pointed-to types</li><li> one is a pointer to object and the other is a pointer to (possibly qualified) <code>void</code></li><li> one is a pointer to object or function and the other is a null pointer constant such as <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a></li></ul><p><br/></p></td></tr></table></div><p>The type of any equality operator expression is <code>int</code>, and its value (which is not an lvalue) is <code>1</code> when the specified relationship holds true and <code>\xe2\x80\x8b0\xe2\x80\x8b</code> when the specified relationship does not hold.</p><ul><li> if both operands have arithmetic types, <a href="http://en.cppreference.com/w/c/language/conversion#Usual_arithmetic_conversions" title="c/language/conversion">usual arithmetic conversions</a> are performed and the resulting values are compared in the usual mathematical sense (except that positive and negative zeroes compare equal and any comparison involving a NaN value, including equality with itself, returns zero). In particular, values of complex type are equal if their real parts compare equal and their imaginary parts compare equal.</li><li> if one operand is a pointer and the other is a null pointer constant, the null pointer constant is first <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">converted</a> to the type of the pointer (which gives a null pointer value), and the two pointers are compared as described below</li><li> if one operand is a pointer and the other is a pointer to void, the non-void pointer is <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">converted</a> to the pointer to void and the two pointers are compared as described below</li><li> two pointers compare equal if any of the following is true:</li></ul><dl><dd><ul><li> they are both null pointer values of their type</li><li> they are both pointers to the same object</li><li> one pointer is to a struct/union/array object and the other is to its first member/any member/first element</li><li> they are both pointing one past the last element of the same array</li><li> one is one past the end of an array, and the other is at the start of a different array (of the same type) that follows the first in a larger array or in a struct with no padding</li></ul></dd></dl><p>(as with relational operators, pointers to objects that aren't elements of any array behave as pointers to elements of arrays of size 1)<br></p></section>	http://en.cppreference.com/w/c/language/operator_comparison
Increment/decrement operators	A										<section class="prog__container"><p>Increment/decrement operators are unary operators that increment/decrement the value of a variable by 1. <br></p><p>They can have postfix form:<br></p><table><tr><td></td></tr><tr><td> expr <code>++</code></td><td></td><td></td></tr><tr><td></td></tr><tr><td> expr <code>--</code></td><td></td><td></td></tr><tr><td></td></tr></table><p>As well as the prefix form:<br></p><table><tr><td></td></tr><tr><td> <code>++</code> expr</td><td></td><td></td></tr><tr><td></td></tr><tr><td> <code>--</code> expr</td><td></td><td></td></tr><tr><td></td></tr></table><p>The operand expr of both prefix and postfix increment or decrement must be a <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">modifiable lvalue</a> of <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">integer type</a> (including <code>_Bool</code> and enums), real floating type, or a pointer type. It may be cvr-qualified, unqualified, or <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a>.</p><p>The result of the postfix increment and decrement operators is the value of expr. </p><p>The result of the prefix increment operator is the result of adding the value <code>1</code> to the value of expr: the expression <code>++e</code> is equivalent to <code>e+=1</code>. The result of the prefix decrement operator is the result of subtracting the value <code>1</code> from the value of expr: the expression <code>--e</code> is equivalent to <code>e-=1</code>.</p><p>Increment operators initiate the side-effect of adding the value <code>1</code> of appropriate type to the operand. Decrement operators initiate the side-effect of subtracting the value <code>1</code> of appropriate type from the operand. As with any other side-effects, these operations complete at or before the next <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a>.<code>int a = 1;<br/>int b = a++; // stores 1+a (which is 2) to a<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// returns the value of a (which is 1)<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// After this line, b == 1 and a == 2<br/>a = 1;<br/>int c = ++a; // stores 1+a (which is 2) to a<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// returns 1+a (which is 2)<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0// after this line, c == 2 and a == 2</code></p><table><tr><td><p>Post-increment or post-decrement on any <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic variable</a> is an atomic read-modify-write operation with memory order <a href="http://en.cppreference.com/w/c/atomic/memory_order" title="c/atomic/memory order">memory_order_seq_cst</a>.</p></td><td>(since C11)</td></tr></table><p>See <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> for limitations on pointer arithmetic, as well as for implicit conversions applied to the operands.</p></section>	http://en.cppreference.com/w/c/language/operator_incdec
Logical operators	A										<section class="prog__container"><p>Logical operators apply standard boolean algebra operations to their operands.<br></p><table><tr><th> Operator</th><th> Operator name</th><th> Example</th><th> Result</th></tr><tr><td> <code>!</code></td><td> logical NOT</td><td> <code>!a</code></td><td> the logical negation of <b>a</b></td></tr><tr><td> <code>&amp;&amp;</code></td><td> logical AND</td><td> <code>a &amp;&amp; b</code></td><td> the logical AND of <b>a</b> and <b>b</b></td></tr><tr><td> <code>||</code></td><td> logical OR</td><td> <code>a || b</code></td><td> the logical OR of <b>a</b> and <b>b</b></td></tr></table><span class="prog__sub"> Logical NOT</span><p>The logical NOT expression has the form <br></p><table><tr><td></td></tr><tr><td> <code>!</code> expression</td><td></td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> expression</td><td> -</td><td>  an expression of any <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">scalar type</a></td></tr></table><p>The logical NOT operator has type <code>int</code>. Its value is <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if expression evaluates to a value that compares unequal to zero. Its value is <code>1</code> if expression evaluates to a value that compares equal to zero. (so <code>!E</code> is the same as <code>(0==E)</code>)</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main(void){    bool b = !(2+2 == 4); // not true    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("!(2+2==4) =\xc2\xa0%s\n", b ? "true" : "false");\xc2\xa0    int n = <a href="http://en.cppreference.com/w/c/string/byte/isspace">isspace</a>('a'); // zero if 'a' is a space, nonzero otherwise    int x = !!n; // "bang-bang", common C idiom for mapping integers to [0,1]                 // (all non-zero values become 1)    char *a[2] = {"nonspace", "space"};    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%s\n", a[x]); // now x can be safely used as an index to array of 2 ints}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>!(2+2==4) = false<br>nonspace</code></pre></div></div></div><span class="prog__sub"> Logical AND</span><p>The logical AND expression has the form <br></p><table><tr><td></td></tr><tr><td> lhs <code>&amp;&amp;</code> rhs</td><td></td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> lhs</td><td> -</td><td>  an expression of any scalar type</td></tr><tr><td> rhs</td><td> -</td><td>  an expression of any scalar type, which is only evaluated if lhs does not compare equal to <code>\xe2\x80\x8b0\xe2\x80\x8b</code></td></tr></table><p>The logical-AND operator has type <code>int</code> and the value <code>1</code> if both lhs and rhs compare unequal to zero. It has the value <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise (if either lhs or rhs or both compare equal to zero).</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the evaluation of lhs. If the result of lhs compares equal to zero, then rhs is not evaluated at all (so-called <i>short-circuit evaluation</i>)</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;int main(void){    bool b = 2+2==4 &amp;&amp; 2*2==4; // b == true\xc2\xa0    1 &gt; 2 &amp;&amp; <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("this won't print");\xc2\xa0    char *p = "abc";    if(p &amp;&amp; *p) // common C idiom: if p is not null                // AND if p does not point at the end of the string    {           // (note that thanks to short-circuit evaluation, this                //  will not attempt to dereference a null pointer)    // ...      // ... then do some string processing    }}</code></pre></div></div><p><br/></p></div><span class="prog__sub"> Logical OR</span><p>The logical OR expression has the form <br></p><table><tr><td></td></tr><tr><td> lhs <code>||</code> rhs</td><td></td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> lhs</td><td> -</td><td>  an expression of any scalar type</td></tr><tr><td> rhs</td><td> -</td><td>  an expression of any scalar type, which is only evaluated if lhs compares equal to <code>\xe2\x80\x8b0\xe2\x80\x8b</code></td></tr></table><p>The logical-OR operator has type <code>int</code> and the value <code>1</code> if either lhs or rhs compare unequal to zero. It has value <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise (if both lhs and rhs compare equal to zero).</p><p>There is a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> after the evaluation of lhs. If the result of lhs compares unequal to zero, then rhs is not evaluated at all (so-called <i>short-circuit evaluation</i>)</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;int main(void){    bool b = 2+2 == 4 || 2+2 == 5; // true    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("true or false =\xc2\xa0%s\n", b ? "true" : "false");\xc2\xa0    // logical OR can be used simialar to perl's "or die", as long as rhs has scalar type    <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("test.txt", "r") || <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("could not open test.txt:\xc2\xa0%s\n", <a href="http://en.cppreference.com/w/c/string/byte/strerror">strerror</a>(errno));}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>true or false = true<br>could not open test.txt: No such file or directory</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/operator_logical
Member access operators	A										<section class="prog__container"><p>Member access operators allow access to the members of their operands.<br></p><table><tr><th> Operator</th><th> Operator name</th><th> Example</th><th> Description</th></tr><tr><td> <code>[]</code></td><td> array subscript</td><td> <code>a[b]</code></td><td> access the <b>b</b>th element of array <b>a</b></td></tr><tr><td> <code>*</code></td><td> pointer dereference</td><td> <code>*a</code></td><td> dereference the pointer <b>a</b> to access the object or function it refers to</td></tr><tr><td> <code>&amp;</code></td><td> address of</td><td> <code>&amp;a</code></td><td> create a pointer that refers to the object or function <b>a</b></td></tr><tr><td> <code>.</code></td><td> member access</td><td> <code>a.b</code></td><td> access member <b>b</b> of <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> <b>a</b></td></tr><tr><td> <code>-&gt;</code></td><td> member access through pointer</td><td> <code>a-&gt;b</code></td><td> access member <b>b</b> of <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> pointed to by <b>a</b></td></tr></table><span class="prog__sub"> Subscript</span><p>The array subscrpt expression has the form <br></p><table><tr><td></td></tr><tr><td> pointer-expression <code>[</code> integer-expression <code>]</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> integer-expression <code>[</code> pointer-expression <code>]</code></td><td> (2)</td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> pointer-expression</td><td> -</td><td>  an <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> of type pointer to complete object</td></tr><tr><td> integer-expression</td><td> -</td><td>  an <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> of integer type</td></tr></table><p>The subscript operator expression is is <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue expression</a> whose type is the type of the object pointed to by pointer-expression.</p><p>By definition, the subscript operator <code>E1[E2]</code> is exactly identical to <code>*((E1)+(E2))</code>.  If pointer-expression is an array expression, it undergoes <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">lvalue-to-rvalue conversion</a> and becomes a pointer to the first element of the array.</p><p>Due to the definition of the <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">addition between a pointer and an integer</a>, the result is the element of the array with the index equal to the result of integer-expression (or, if pointer-expression was pointing at ith element of some array, the result is i plus the result of integer-expression)</p><p>Note: see <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array</a> for the details on multidimensional arrays.</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;int main(void){    int a[3] = {1,2,3};    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\xc2\xa0%d\n", a[2],  // n == 3                      2[a]); // same, n == 3    a[2] = 7; // subscripts are lvalues\xc2\xa0    int n[2][3] = {1,2,3,4,5,6};    int (*p)[3] = &amp;n[1]; // elements of n are arrays    int x = n[1][2]; // applying [] again to the array n[1]\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%c\xc2\xa0%c\n", "abc"[2], 2["abc"]); // string literals are arrays too}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>3 3<br>c c</code></pre></div></div></div><span class="prog__sub"> Dereference</span><p>The <i>dereference</i> or <i>indirection</i> expression has the form </p><table><tr><td></td></tr><tr><td> <code>*</code> pointer-expression</td><td></td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> pointer-expression</td><td> -</td><td>  an <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> of any pointer type</td></tr></table><p>If pointer-expression is a pointer to function, the result of the dereference operator is a function designator for that function.</p><p>If pointer-expression is a pointer to object, the result is an <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue expression</a> that designates the pointed-to object.</p><p>Dereferencing a null pointer, a pointer to an object outside of its lifetime (a dangling pointer), a misaligned pointer, or a pointer with indeterminate value is undefined behavior, except when the dereference operator is nullified by applying the address-of operator to its result, as in <code>&amp;*E</code></p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;int main(void){    int n = 1;    int* p = &amp;n;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("*p =\xc2\xa0%d\n", *p); // the value of *p is what's stored in n    *p = 7; // *p is lvalue    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("*p =\xc2\xa0%d\n", *p);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>*p = 1<br>*p = 7</code></pre></div></div></div><span class="prog__sub"> Address of</span><p>The address-of expression has the form <br></p><table><tr><td></td></tr><tr><td> <code>&amp;</code> function</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>&amp;</code> lvalue-expression</td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>&amp;</code> <code>*</code> expression</td><td> (3)</td><td></td></tr><tr><td></td></tr><tr><td> <code>&amp;</code> expression <code>[</code> expression <code>]</code></td><td> (4)</td><td></td></tr><tr><td></td></tr></table><div>1) address of a function</div><div>2) address of an object</div><div>3) special case: &amp; and * cancel each other, neither one is evaluated</div><div>4) special case: &amp; and the * that is implied in [] cancel each other, only the addition implied in [] is evaluated<p>where <br></p><table><tr><td> lvalue-expression</td><td> -</td><td>  an <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue</a> expression of any type that is not a <a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field">bit field</a> and does not have <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">register</a> storage class</td></tr></table></div><p>The address-of operator produces the <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">non-lvalue</a> address of its operand, suitable for initializing a pointer to the type of the operand. If the operand is a function designator ((1)), the result is a pointer to function. If the operand is an object ((2)), the result is a pointer to object.</p><p>If the operand is the dereference operator, no action is taken (so it's okay to apply &amp;* to a null pointer), except that the result is not an lvalue.<br></p><p>If the operand is an array index expression, no action is taken other than the array-to-pointer conversion and the addition, so &amp;a[N] is valid for an array of size N (obtaining a pointer one past the end is okay, dereferencing it is not, but dereference cancels out in this expression).<br></p><div><div><div>Run this code</div></div><div><div><pre><code>int f(char c) { return c;}int main(void){   int n = 1;   int *p = &amp;n; // address of object n   int (*fp)(char) = &amp;f; // address of function f   int a[3] = {1,2,3};   int *beg=a, *end=&amp;a[3]; // same as end = n+3}</code></pre></div></div><p><br/></p></div><span class="prog__sub"> Member access</span><p>The member access expression has the form <br></p><table><tr><td></td></tr><tr><td> expression <code>.</code> member-name</td><td></td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> expression</td><td> -</td><td>  an expression of <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> type</td></tr><tr><td> member-name</td><td> -</td><td>  an <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifier</a> that names a member of the struct or union designated by expression</td></tr></table><p>The member access expression designates the named member of the <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> designated by its left operand. It has the same <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">value category</a> as its left operand. </p><p>If the left operand is <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a> or <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> qualified, the result is also qualified. If the left operand is <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a>, the behavior is undefined.</p><p>Note: besides identifiers that name objects of struct or union type, the following expressions may have struct or union types: <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">assignment</a>, <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call</a>, <a href="http://en.cppreference.com/w/c/language/operator_other" title="c/language/operator other">comma operator</a>, <a href="http://en.cppreference.com/w/c/language/operator_other" title="c/language/operator other">conditional operator</a>, and <a href="http://en.cppreference.com/w/c/language/compound_literal" title="c/language/compound literal">compound literal</a>.</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;struct s {int x;};struct s f(void) { return (struct s){1}; }int main(void){    struct s s;    s.x = 1; // ok, changes the member of s    int n = f().x; // f() is an expression of type struct s//  f().x = 1; // Error: this member access expression is not an lvalue\xc2\xa0    const struct s sc;//  sc.x = 3;  // Error: sc.x is const, can't be assigned\xc2\xa0    union { int x; double d; } u = {1};    u.d = 0.1; // changes the active member of the union}</code></pre></div></div><p><br/></p></div><span class="prog__sub"> Member access through pointer</span><p>The member access expression has the form <br></p><table><tr><td></td></tr><tr><td> expression <code>-&gt;</code> member-name</td><td></td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> expression</td><td> -</td><td>  an expression of type <a href="http://en.cppreference.com/w/c/language/pointer" title="c/language/pointer">pointer</a> to <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a></td></tr><tr><td> member-name</td><td> -</td><td>  an <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifier</a> that names a member of the struct or union pointed by expression</td></tr></table><p>The member access through pointer expression designates the named member of the <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> type pointed to by its left operand. Its value category is always <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">lvalue</a></p><p>If the type pointed to by the left operand is <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a> or <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> qualified, the result is also qualified. If the type pointed to by the left operand is <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a>, the behavior is undefined.</p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;struct s {int x;};int main(void){    struct s s={1}, *p = &amp;s;    p-&gt;x = 7; // changes the value of s.x through the pointer    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", p-&gt;x); // prints 7}</code></pre></div></div><p><br/></p></div></section>	http://en.cppreference.com/w/c/language/operator_member_access
Other operators	A										<section class="prog__container"><p>A collection of operators that do not fit into any of the other major categories.<br></p><table><tr><td></td><td>This section is incomplete<br/>Reason: consider a more general-purpose ToC for this and other tables that cover multiple topics </td></tr></table><table><tr><th> Operator</th><th> Operator name</th><th> Example</th><th> Description</th></tr><tr><td> <code>(...)</code></td><td> <a href="#Function_call">function call</a></td><td> <code>f(...)</code></td><td> call the function <b>f</b>(), with zero or more arguments</td></tr><tr><td> <code>,</code></td><td> <a href="#Comma_operator">comma operator</a></td><td> <code>a, b</code></td><td> evaluate expression <b>a</b>, disregard its return value and complete any side-effects, then evaluate expression <b>b</b>, returning the type and the result of this evaluation</td></tr><tr><td> <code>(type)</code></td><td> <a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast">type cast</a></td><td> <code>(type)a</code></td><td> cast the type of <b>a</b> to <b>type</b></td></tr><tr><td> <code>? :</code></td><td> <a href="#Conditional_operator">conditional operator</a></td><td> <code>a ? b : c</code></td><td> if <b>a</b> is logically true (does not evaluate to zero) then evaluate expression <b>b</b>, otherwise evaluate expression <b>c</b></td></tr><tr><td> <code>sizeof</code></td><td> <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof operator</a></td><td> <code>sizeof a</code></td><td> the size in bytes of <b>a</b></td></tr><tr><td> <code>_Alignof</code> (since C11)</td><td> <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">_Alignof operator</a></td><td> <code>_Alignof(type)</code></td><td> the alignment required of <b>type</b></td></tr></table><span class="prog__sub"> Function call</span><p>The function call expression has the form <br></p><table><tr><td></td></tr><tr><td> expression <code>(</code> argument-list(optional) <code>)</code></td><td></td><td></td></tr><tr><td></td></tr></table><p>where <br></p><table><tr><td> expression</td><td> -</td><td> any expression of pointer-to-function type (after <a href="http://en.cppreference.com/w/c/language/conversion#Lvalue_conversions" title="c/language/conversion">lvalue conversions</a>)</td></tr><tr><td> argument-list</td><td> -</td><td>  comma-separated list of expressions (which cannot be comma operators) of any complete object type. May be omitted when calling functions that take no arguments.</td></tr></table><p>The behavior of the function call expression depends on whether the prototype of the function being called is <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">in scope</a> at the point of call. </p><h4> Call to a function with a prototype</h4><div>1) The number of parameters must equal the number of arguments (unless the ellipsis parameter is used).</div><div>2) The type of each parameter must he a type such that <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicit conversion as if by assignment</a> exists that converts the unqualified type of the corresponding argument to the type of the parameter.</div><table><tr><td><div> Additionally, for every parameter of <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array type</a> that uses the keyword <code>static</code> between <code>[</code> and <code>]</code>, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter.</div></td><td>(since C99)</td></tr></table><div>3) The arguments are evaluated <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">in unspecified order and without sequencing</a>.</div><div>4) <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">Assignment</a> (until C11)<a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">Initialization</a> (since C11) is performed to copy the value of each argument to the corresponding function parameter (note; the function can modify its parameters, and those changes do not affect the arguments; C function calls are only call-by-value).<dl><dd><ul><li> if there is a <a href="http://en.cppreference.com/w/c/language/variadic" title="c/language/variadic">trailing ellipsis</a> parameter,  <a href="http://en.cppreference.com/w/c/language/conversion#Default_argument_promotions" title="c/language/conversion">Default argument promotions</a> are performed on the remaining arguments, which are made available to va_list.</li></ul></dd></dl></div><div>5) Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression)<div><div><pre><code>void f(char* p, int x) {}int main(void){    f("abc", 3.14); // array to pointer and float to int conversions}</code></pre></div></div></div><h4> Call to a function without a prototype</h4><div>1) The arguments are evaluated <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">in unspecified order and without sequencing</a>.</div><div>2) <a href="http://en.cppreference.com/w/c/language/conversion#Default_argument_promotions" title="c/language/conversion">Default argument promotions</a> are performed on every argument expression.</div><div>3) <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">Assignment</a> (until C11)<a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">Initialization</a> (since C11) is performed to copy the value of each argument to the corresponding function parameter.</div><div>4) Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression)<div><div><pre><code>void f(); // no prototypeint main(void){    f(1, 1.0f); // UB unless f is defined to take an int and a double}void f(int a, double c) {}</code></pre></div></div></div><p>The behavior of a function call to a function without a prototype is undefined if<br></p><ul><li> the number of arguments does not match the number of parameters.</li><li> the promoted types of the arguments are not <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> with the promoted types of the parameters except that</li></ul><dl><dd><ul><li> signed and unsigned versions of the same integer type are considered compatible if the value of the argument is representable by both types.</li><li> pointers to void and pointers to (possibly cvr-qualified) character types are considered compatible</li></ul></dd></dl></section>	http://en.cppreference.com/w/c/language/operator_other
C Operator Precedence	A										<section class="prog__container"><p>The following table lists the precedence and associativity of C operators. Operators are listed top to bottom, in descending precedence.<br></p><table><tr><th style="text-align: left"> Precedence</th><th style="text-align: left"> Operator</th><th style="text-align: left"> Description</th><th style="text-align: left"> Associativity</th></tr><tr><th rowspan="6"> 1</th><td> <code>++</code> <code>--</code></td><td> Suffix/postfix increment and decrement</td><td> Left-to-right</td></tr><tr><td> <code>()</code></td><td> Function call</td></tr><tr><td> <code>[]</code></td><td> Array subscripting</td></tr><tr><td> <code>.</code></td><td> Structure and union member access</td></tr><tr><td> <code>-&gt;</code></td><td> Structure and union member access through pointer</td></tr><tr><td> <code>(<i>type</i>){<i>list</i>}</code></td><td> Compound literal(C99)</td></tr><tr><th rowspan="8"> 2</th><td> <code>++</code> <code>--</code></td><td> Prefix increment and decrement</td><td> Right-to-left</td></tr><tr><td> <code>+</code> <code>-</code></td><td> Unary plus and minus</td></tr><tr><td> <code>!</code> <code>~</code></td><td> Logical NOT and bitwise NOT</td></tr><tr><td> <code>(<i>type</i>)</code></td><td> Type cast</td></tr><tr><td> <code>*</code></td><td> Indirection (dereference)</td></tr><tr><td> <code>&amp;</code></td><td> Address-of</td></tr><tr><td> <code>sizeof</code></td><td> Size-of</td></tr><tr><td> <code>_Alignof</code></td><td> Alignment requirement(C11)</td></tr><tr><th> 3</th><td> <code>*</code> <code>/</code> <code>%</code></td><td> Multiplication, division, and remainder</td><td> Left-to-right</td></tr><tr><th> 4</th><td> <code>+</code> <code>-</code></td><td> Addition and subtraction</td></tr><tr><th> 5</th><td> <code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td> Bitwise left shift and right shift</td></tr><tr><th rowspan="2"> 6</th><td> <code>&lt;</code> <code>&lt;=</code></td><td> For relational operators &lt; and \xe2\x89\xa4 respectively</td></tr><tr><td> <code>&gt;</code> <code>&gt;=</code></td><td> For relational operators &gt; and \xe2\x89\xa5 respectively</td></tr><tr><th> 7</th><td> <code>==</code> <code>!=</code></td><td> For relational = and \xe2\x89\xa0 respectively</td></tr><tr><th> 8</th><td> <code>&amp;</code></td><td> Bitwise AND</td></tr><tr><th> 9</th><td> <code>^</code></td><td> Bitwise XOR (exclusive or)</td></tr><tr><th> 10</th><td> <code>|</code></td><td> Bitwise OR (inclusive or)</td></tr><tr><th> 11</th><td> <code>&amp;&amp;</code></td><td> Logical AND</td></tr><tr><th> 12</th><td> <code>||</code></td><td> Logical OR</td></tr><tr><th> 13<sup class="reference" id="cite_ref-1">[note 1]</sup></th><td> <code>?:</code></td><td> Ternary conditional<sup class="reference" id="cite_ref-2">[note 2]</sup></td><td> Right-to-Left</td></tr><tr><th rowspan="5"> 14</th><td> <code>=</code></td><td> Simple assignment</td></tr><tr><td> <code>+=</code> <code>-=</code></td><td> Assignment by sum and difference</td></tr><tr><td> <code>*=</code> <code>/=</code> <code>%=</code></td><td> Assignment by product, quotient, and remainder</td></tr><tr><td> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td> Assignment by bitwise left shift and right shift</td></tr><tr><td> <code>&amp;=</code> <code>^=</code> <code>|=</code></td><td> Assignment by bitwise AND, XOR, and OR</td></tr><tr><th> 15</th><td> <code>,</code></td><td> Comma</td><td> Left-to-right</td></tr></table><ol class="references"><li id="cite_note-1"><a href="#cite_ref-1">\xe2\x86\x91</a> Fictional precedence level, see Notes below</li><li id="cite_note-2"><a href="#cite_ref-2">\xe2\x86\x91</a> The expression in the middle of the conditional operator (between <code>?</code> and <code>:</code>) is parsed as if parenthesized: its precedence relative to <code>?:</code> is ignored.</li></ol><p>When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression <code>*p++</code> is parsed as <code>*(p++)</code>, and not as <code>(*p)++</code>.</p><p>Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression <code>a=b=c</code> is parsed as <code>a=(b=c)</code>, and not as <code>(a=b)=c</code> because of right-to-left associativity.</p></section>	http://en.cppreference.com/w/c/language/operator_precedence
Pointer declaration	A										<section class="prog__container"><p>Pointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers. Pointer may also refer to nothing, which is indicated by the special null pointer value.<br></p><span class="prog__sub"> Syntax</span><p>In the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration grammar</a> of a pointer declaration, the <i>type-specifier</i> sequence designates the pointed-to type (which may be function or object type and may be incomplete), and the <i>declarator</i> has the form:</p><table><tr><td></td></tr><tr><td> <code>*</code> qualifiers(optional) declarator</td><td> (1)</td><td></td></tr><tr><td></td></tr></table><p>where declarator may be the identifier that names the pointer being declared, including another pointer declarator (which would indicate a pointer to a pointer):</p><div><div><pre><code>float *p, **pp; // p is a pointer to float                // pp is a pointer to a pointer to floatint (*fp)(int); // fp is a pointer to function with type int(int)</code></pre></div></div><p>The qualifiers that appear between <code>*</code> and the identifier (or other nested declarator) qualify the type of the pointer that is being declared:</p><div><div><pre><code>int n;const int * pc = &amp;n; // pc is a non-const pointer to a const int// *pc = 2; // Error: n cannot be changed through p without a castpc = <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>; // OK: pc itself can be changed\xc2\xa0int * const cp = &amp;n; // cp is a const pointer to a non-const int*cp = 2; // OK to change n through cp// cp = NULL; // Error: cp itself cannot be changed\xc2\xa0int * const * pcp = &amp;cp; // non-const pointer to const pointer to non-const int</code></pre></div></div><span class="prog__sub"> Explanation</span><p>Pointers are used for indirection, which is a ubiquitous programming technique; they can be used to implement pass-by-reference semantics, to access objects with dynamic <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a>, to implement "optional" types (using the null pointer value), aggregation relationship between structs, callbacks (using pointers to functions), generic interfaces (using pointers to void), and much more.</p><h4> Pointers to objects</h4><p>A pointer to object can be initialized with the result of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">address-of operator</a> applied to an expression of object type (which may be incomplete):</p><div><div><pre><code>int n;int *np = &amp;n; // pointer to intint *const *npp = &amp;np; // non-const pointer to const pointer to non-const int\xc2\xa0int a[2];int (*ap)[2] = &amp;a; // pointer to array of int\xc2\xa0struct S { int n; } s = {1}int* sp = &amp;s.n; // pointer to the int that is a member of s</code></pre></div></div><p>Pointers may appear as operands to the <a href="http://en.cppreference.com/w/c/language/operator_member_access#Dereference" title="c/language/operator member access">indirection operator</a> (unary <code>*</code>), which returns <a href="http://en.cppreference.com/w/c/language/value_category" title="c/language/value category">the lvalue</a> identifying the pointed-to object:</p><div><div><pre><code>int n;int* p = &amp;n;     // pointer p is pointing to n*p = 7;         // stores 7 in n<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", *p); // lvalue-to-rvalue conversion reads the value from n</code></pre></div></div><p>Pointers to objects of <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> and <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> type may also appear as the left-hand operands of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">member access through pointer</a> operator <code>-&gt;</code>.</p><p>Because of the <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array-to-pointer</a> implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</p><div><div><pre><code>int a[2];int *p = a; // pointer to a[0]\xc2\xa0int b[3][3];int (*row)[3] = b; // pointer to b[0]</code></pre></div></div><p>Certain <a href="http://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">addition, subtraction</a>, <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">compound assignment</a>, <a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec">increment, and decrement</a> operators are defined for pointers to elements of arrays.</p><p><a href="http://en.cppreference.com/w/c/language/operator_comparison" title="c/language/operator comparison">Comparison operators</a> are defined for pointers to objects in some situations: two pointers that represent the same address compare equal, two null pointer values compare equal, pointers to elements of the same array compare the same as the array indexes of those elements, and pointers to struct members compare in order of declaration of those members.</p><p>Many implementations also provide <a class="extiw" href="http://en.wikipedia.com/wiki/Total_order#Strict_total_order" title="enwiki:Total order">strict total ordering</a> of pointers of random origin, e.g. if they are implemented as addresses within continuous ("flat") virtual address space. </p><h4> Pointers to functions</h4><p>A pointer to function can be initialized with an address of a function. Because of the <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">function-to-pointer</a> conversion, the address-of operator is optional:</p><div><div><pre><code>void f(int);void (*pf1)(int) = &amp;f;void (*pf2)(int) = f; // same as &amp;f</code></pre></div></div><p>Unlike functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, passed to other functions as arguments, etc.<br></p><p>A pointer to function can be used on the left-hand side of the <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call operator</a>; this invokes the pointed-to function:</p><div><div><pre><code>#include &lt;stdio.h&gt;int f(int n){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", n);    return n*n;}int main(void){    int (*p)(int) = f;    int x = p(7);}</code></pre></div></div><p>Dereferencing a function pointer yields the function designator for the pointed-to function:<br></p><div><div><pre><code>int f();int (*p)() = f;    // pointer p is pointing to f(*p)(); // function f invoked through the function designatorp();    // function f invoked directly through the pointer</code></pre></div></div><p><a href="http://en.cppreference.com/w/c/language/operator_comparison" title="c/language/operator comparison">Equality comparison operators</a> are defined for pointers to functions (they compare equal if pointing to the same function).</p><h4> Pointers to void</h4><p>Pointer to object of any type can be <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">implicitly converted</a> to pointer to <code>void</code> (optionally <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a> or <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>-qualified), and vice versa:</p><div><div><pre><code>int n=1, *p=&amp;n;void* pv = p; // int* to void*int* p2 = pv; // void* to int*<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", *p2); // prints 1</code></pre></div></div><p>Pointers to void are used to pass objects of unknown type, which is common in generic interfaces: <a href="http://en.cppreference.com/w/c/memory/malloc" title="c/memory/malloc">malloc</a> returns <code>void*</code>, <a href="http://en.cppreference.com/w/c/algorithm/qsort" title="c/algorithm/qsort">qsort</a> expects a user-provided callback that accepts two <code>const void*</code> arguments. <a class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html" rel="nofollow">pthread_create</a> expects a user-provided callback that accepts and returns <code>void*</code>. In all cases, it is the caller's responsibility to convert the pointer to the correct type before use.</p><span class="prog__sub"> Null pointers</span><p>Pointers of every type have a special value known as <i>null pointer value</i> of that type. A pointer whose value is null does not point to an object or a function (dereferencing a null pointer is undefined behavior), and compares equal to all pointers of the same type whose value is also <i>null</i>.</p><p>To initialize a pointer to null or to assign the null value to an existing pointer, a null pointer constant (<a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, or any other integer constant with the value zero) may be used. <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">static initialization</a> also initializes pointers to their null values.</p><p>Null pointers can indicate the absence of an object or can be used to indicate other types of error conditions. In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> does nothing when a null pointer is passed).</p></section>	http://en.cppreference.com/w/c/language/pointer
restrict type qualifier	A										<section class="prog__container"><p>Each individual type in the C <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">type system</a> has several <i>qualified</i> versions of that type, corresponding to one, two, or all three of the <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, and, for pointers to object types, <i>restrict</i> qualifiers. This page describes the effects of the <i>restrict</i> qualifier.</p><p>Only pointers to <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">object types</a> may be restrict-qualified (in particular, <code>int restrict *p</code> and <code>float (* restrict f9)(void)</code> are errors).</p><p>restrict semantics apply to lvalue expressions only; for example, a cast to restrict-qualified pointer or a function call returning a restrict-qualified pointer are not lvalues and the qualifier has no effect.<br></p><p>During each execution of a block in which a restricted pointer <code>P</code> is declared (typically each execution of a function body in which <code>P</code> is a function parameter), if some object that is accessible through <code>P</code> (directly or indirectly) is modified, by any means, then all accesses to that object (both reads and writes) in that block must occur through <code>P</code> (directly or indirectly), otherwise the behavior is undefined:</p><div><div><pre><code>void f(int n, int * restrict p, int * restrict q){    while(n-- &gt; 0)        *p++ = *q++; // none of the objects modified through *p is the same                     // as any of the objects read through *q                     // compiler free to optimize, vectorize, page map, etc.}void g(void){    extern int d[100];    f(50, d + 50, d); // OK    f(50, d + 1, d); // Undefined behavior: d[1] is accessed through both p and q in f}</code></pre></div></div><p>If the object is never modified, it may be aliased and accessed through different restrict-qualified pointers (note that if the objects pointed to by aliased restrict-qualified pointers are, in turn, pointers, this aliasing can inhibit optimization).<br></p><p>Assignment from one restricted pointer to another is undefined behavior, except when assigning from a pointer to an object in some outer block to a pointer in some inner block (including using a restricted pointer argument when calling a function with a restricted pointer parameter) or when returning from a function (and otherwise when the block of the from-pointer ended):<br></p><div><div><pre><code>int* restrict p1 = &amp;a;int* restrict p2 = &amp;b;p1 = p2; // undefined behavior</code></pre></div></div><p>Restricted pointers can be assigned to unrestricted pointers freely, the optimization opportunities remain in place as long as the compiler is able to analyze the code:<br></p><div><div><pre><code>void f(int n, float * restrict r, float * restrict s) {   float * p = r, * q = s; // OK   while(n-- &gt; 0) *p++ = *q++; // almost certainly optimized just like *r++ = *s++}</code></pre></div></div><p>If an array type is declared with the restrict type qualifier (through the use of <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>), the array type is not restrict-qualified, but its element type is:</p><div><div><pre><code>typedef int *array_t[10];restrict array_t a; // the type of a is int *restrict[10]</code></pre></div></div><p>In a function declaration, the keyword <code>restrict</code> may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed:</p><div><div><pre><code>void f(int m, int n, float a[restrict m][n], float b[restrict m][n]);void g12(int n, float (*p)[n]) {   f(10, n, p, p+10); // OK   f(20, n, p, p+10); // possibly undefined behavior (depending on what f does)}</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/restrict
return statement	A										<section class="prog__container"><p>Terminates current function and returns specified value to the caller function.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>return</code> expression <code>;</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>return</code> <code>;</code></td><td> (2)</td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><div>1) Evaluates the expression, terminates the current function and returns the result of the expression to the caller (the value returned becomes the value of the function call expression). Only valid if the function return type is not <code>void</code>.</div><div>2) Terminates the current function. Only valid if the function return type is <code>void</code>.</div><p>If the type of the expression is different from the return type of the function, its value is <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">converted</a> as if by assignment to an object whose type is the return type of the function, except that overlap between object representations is permitted:</p><div><div><pre><code>struct s { double i; } f(void); // function returning struct sunion { struct { int f1; struct s f2; } u1;        struct { struct s f3; int f4; } u2; } g;struct s f(void){    return g.u1.f2;}int main(void){// g.u2.f3 = g.u1.f2; // undefined behavior (overlap in assignment)   g.u2.f3 = f();     // well-defined}</code></pre></div></div><p>If the return type is a real floating type, the result may be represented in <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">greater range and precision</a> than implied by the new type.</p><p>Reaching the end of a function other than <code>main</code> is equivalent to <code>return;</code>. Reaching the end of the main function is equivalent to <code>return 0;</code>. Reaching the end of any other value-returning function is undefined behavior, but only if the result of the function is used in an expression.</p><p>Executing the <code>return</code> statement in a <a href="http://en.cppreference.com/w/c/language/_Noreturn" title="c/language/ Noreturn">no-return function</a> is undefined behavior.</p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/return" title="c/keyword/return"><tt>return</tt></a></p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: improve </td></tr></table><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0void fa(int i){    if (i == 2)       return;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("fa():  \xc2\xa0%d\n", i);} // implied return;\xc2\xa0int fb(int i){    if (i &gt; 4)       return 4;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("fb():  \xc2\xa0%d\n", i);    return 2;}\xc2\xa0int main(void){    fa(2);    fa(1);    int i = fb(5);   // the return value 4 used to initializes i    i = fb(i);       // the return value 2 used as rhs of assignment    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("main():\xc2\xa0%d\n", i);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>fa():   1<br>fb():   4<br>main(): 2</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/return
Scalar initialization	A										<section class="prog__container"><p>When <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">initializing</a> an object of <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">scalar type</a>, the initializer must be a single expression</p><p>The initializer for a scalar (an object of integer type including booleans and enumerated types, floating type including complex and imaginary, and pointer type including pointer to function) must be a single expression, optionally enclosed in braces:<br></p><table><tr><td></td></tr><tr><td> <code>=</code> expression</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>=</code> <code>{ </code> expression <code>} </code></td><td> (2)</td><td></td></tr><tr><td></td></tr></table><p>The expression is evaluated, and its value, after <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">conversion as if by assignment</a> to the type of the object, becomes the initial value of the object being initialized.</p></section>	http://en.cppreference.com/w/c/language/scalar_initialization
Scope	A										<section class="prog__container"><p>Each <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifier</a> that appears in a C program is <i>visible</i> (that is, may be used) only in some possibly discontiguous portion of the source code called its <i>scope</i>.</p><p>Within a scope, an identifier may designate more than one entity only if the entities are in different <a href="http://en.cppreference.com/w/c/language/name_space" title="c/language/name space">name spaces</a>.</p><p>C has four kinds of scopes: <br></p><dl><dd><ul><li> block scope</li><li> file scope</li><li> function scope</li><li> function prototype scope</li></ul></dd></dl><span class="prog__sub"> Nested scopes</span><p>If two different entities named by the same identifier are in scope at the same time, and they belong to the same <a href="http://en.cppreference.com/w/c/language/name_space" title="c/language/name space">name space</a>, the scopes are nested (no other form of scope overlap is allowed), and the declaration that appears in the inner scope hides the declaration that appears in the outer scope:</p><div><div><pre><code>// The name space here is ordinary identifiers.\xc2\xa0int a;   // file scope of name a begins here\xc2\xa0void f(void){    int a = 1; // the block scope of the name a begins here; hides file-scope a    {      int a = 2;         // the scope of the inner a begins here, outer a is hidden      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", a); // inner a is in scope, prints 2    }                    // the block scope of the inner a ends here    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", a);   // the outer a is in scope, prints 1}                        // the scope of the outer a ends here\xc2\xa0void g(int a);   // name a has function prototype scope; hides file-scope a</code></pre></div></div><span class="prog__sub"> Block scope</span><p>The scope of any identifier declared inside a <a href="http://en.cppreference.com/w/c/language/statements#Compound_statements" title="c/language/statements">compound statement</a>, including function bodies, or in any expression, declaration, or statement appearing in <a href="http://en.cppreference.com/w/c/language/if" title="c/language/if">if</a>, <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch">switch</a>, <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for</a>, <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while</a>, or <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do">do-while</a> statement (since C99), or within the parameter list of a <a href="http://en.cppreference.com/w/c/language/function_definition" title="c/language/function definition">function definition</a> begins at the point of declaration and ends at the end of the block or statement in which it was declared.</p><div><div><pre><code>void f(int n)  // scope of the function parameter 'n' begins{         // the body of the function begins   ++n;   // 'n' is in scope and refers to the function parameter// int n = 2; // error: cannot redeclare identifier in the same scope   for(int n = 0; n&lt;10; ++n) { // scope of loop-local 'n' begins       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", n); // prints 0 1 2 3 4 5 6 7 8 9   } // scope of the loop-local 'n' ends     // the function parameter 'n' is back in scope   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", n); // prints the value of the parameter} // scope of function parameter 'n' endsint a = n; // Error: name 'n' is not in scope</code></pre></div></div><table><tr><td><p>Until C99, selection and iteration statements did not establish their own block scopes (although if a compound statement was used in the statement, it had its usual block scope):<br></p><div><div><pre><code>enum {a, b};int different(void){    if (sizeof(enum {b, a}) != sizeof(int))        return a; // a == 1    return b; // b == 0 in C89, b == 1 in C99}</code></pre></div></div></td><td>(since C99)</td></tr></table><p>Block-scope variables have <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">no linkage</a> and <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">automatic storage duration</a> by default. Note that storage duration for non-VLA local variables begins when the block is entered, but until the declaration is seen, the variable is not in scope and cannot be accessed.</p><span class="prog__sub"> File scope</span><p>The scope of any identifier declared outside of any block or parameter list begins at the point of declaration and ends at the end of the translation unit.<br></p><div><div><pre><code>int i; // scope of i beginsstatic int g(int a) { return a; } // scope of g begins (note, "a" has block scope)int main(void){    i = g(2); // i and g are in scope}</code></pre></div></div><p>File-scope identifiers have <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">external linkage</a> and <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">static storage duration</a> by default.</p><span class="prog__sub"> Function scope</span><p>A <a href="http://en.cppreference.com/w/c/language/statements#Labels" title="c/language/statements">label (and only a label)</a> declared inside a function is in scope everywhere in that function, in all nested blocks, before and after its own declaration. Note: a label is declared implicitly, by using an otherwise unused identifier before the colon character before any statement.</p><div><div><pre><code>void f(){   {          goto label; // label in scope even though declared laterlabel:;   }   goto label; // label ignores block scope}\xc2\xa0void g(){    goto label; // error: label not in scope in g()}</code></pre></div></div><span class="prog__sub"> Function prototype scope</span><p>The scope of a name introduced in the parameter list of a <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declaration</a> that is not a definition ends at the end of the function <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarator</a>.</p><div><div><pre><code>int f(int n,      int a[n]); // n is in scope and refers to the first parameter</code></pre></div></div><p>Note that if there are multiple or nested declarators in the declaration, the scope ends at the end of the nearest enclosing function declarator:<br></p><div><div><pre><code>void f ( // function name 'f' is at file scope long double f,            // the identifier 'f' is now in scope, file-scope 'f' is hidden char (**a)[10 * sizeof f] // 'f' refers to the first parameter, which is in scope);\xc2\xa0enum{ n = 3 };int (*(*g)(int n))[n]; // the scope of the function parameter 'n'                       // ends at the end of its function declarator                       // in the array declarator, global n is in scope// (this declares a pointer to function returning a pointer to an array of 3 int)</code></pre></div></div><span class="prog__sub"> Point of declaration</span><p>The scope of structure, union, and enumeration tags begins immediately after the appearance of the tag in a type specifier that declares the tag.<br></p><div><div><pre><code>struct Node {   struct Node* next; // Node is in scope and refers to this struct};</code></pre></div></div><p>The scope of enumeration constant begins immediately after the appearance of its defining enumerator in an enumerator list.<br></p><div><div><pre><code>enum { x = 12 };{    enum { x = x + 1, // new x is not in scope until the comma, x is initialized to 13           y = x + 1  // the new enumerator x is now in scope, y is initialized to 14         };}</code></pre></div></div><p>The scope of any other identifier begins just after the end of its declarator and before the initializer, if any:<br></p><div><div><pre><code>int x = 2; // scope of the first 'x' begins{    int x[x]; // scope of the newly declared x begins after the declarator (x[x]).              // Within the declarator, the outer 'x' is still in scope.              // This declares a VLA array of 2 int.}\xc2\xa0unsigned char x = 32; // scope of the outer 'x' begins{    unsigned char x = x;            // scope of the inner 'x' begins before the initializer (= x)            // this does not initialize the inner 'x' with the value 32,             // this initializes the inner 'x' with its own, indeterminate, value}\xc2\xa0unsigned long factorial(unsigned long n)// declarator ends, 'factorial' is in scope from this point{   return n&lt;2 ? 1 : n*factorial(n-1); // recursive call}</code></pre></div></div><p>As a special case, the scope of a <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">type name</a> that is not a declaration of an identifier is considered to begin just after the place within the type name where the identifier would appear were it not omitted.</p></section>	http://en.cppreference.com/w/c/language/scope
sizeof operator	A										<section class="prog__container"><p>Queries size of the object or type<br></p><p>Used when actual size of the object must be known<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>sizeof(</code> type <code>)</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>sizeof</code> expression <code></code></td><td> (2)</td><td></td></tr><tr><td></td></tr></table><p>Both versions return a value of type <a href="http://en.cppreference.com/w/c/types/size_t" title="c/types/size t">size_t</a>. </p><span class="prog__sub"> Explanation</span><div>1) Returns the size, in bytes, of the <a href="http://en.cppreference.com/w/c/language/object#Object_representation" title="c/language/object">object representation</a> of type</div><div>2) Returns the size, in bytes, of the object representation of the type of expression</div></section>	http://en.cppreference.com/w/c/language/sizeof
Statements	A										<section class="prog__container"><p>Statements are fragments of the C program that are executed in sequence. The body of any function is a compound statement, which, in turn is a sequence of statements and declarations:<br></p><div><div><pre><code>int main(void){ // start of a compound statement    int n = 1; // declaration (not a statement)    n = n+1; // expression statement    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("n =\xc2\xa0%d\n", n); // expression statement    return 0; // return statement} // end of compound statement, end of function body</code></pre></div></div><p><br/>There are five types of statements:</p><div>1) compound statements</div><div>2) expression statements</div><div>3) selection statements</div><div>4) iteration statements</div><div>5) jump statements</div><span class="prog__sub"> Labels</span><p>Any statement can be <i>labeled</i>, by providing a name followed by a colon before the statement itself.</p><table><tr><td></td></tr><tr><td> identifier <code>:</code> statement</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>case</code> constant_expression <code>:</code> statement</td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>default</code> <code>:</code> statement</td><td> (3)</td><td></td></tr><tr><td></td></tr></table><div>1) Target for <a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto">goto</a>.</div><div>2) Case label in a <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch">switch</a> statement.</div><div>3) Default label in a <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch">switch</a> statement.</div><p>Any statement (but not a declaration) may be preceded by any number of <i>labels</i>, each of which declares identifier to be a label name, which must be unique within the enclosing function (in other words, label names have <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">function scope</a>).</p><p>Label declaration has no effect on its own, does not alter the flow of control, or modify the behavior of the statement that follows in any way.<br></p><span class="prog__sub"> Compound statements</span><p>A compound statement, or <i>block</i>, is a brace-enclosed sequence of statements and declarations.</p><table><tr><td></td></tr><tr><td> <code>{</code> statement <code>|</code> declaration...(optional) <code>} </code></td><td> (1)</td><td></td></tr><tr><td></td></tr></table><p>The compound statement allows a set of declarations and statements to be grouped into one unit that can be used anywhere a single statement is expected (for example, in an <a href="http://en.cppreference.com/w/c/language/if" title="c/language/if">if</a> statement or an iteration statement):</p><div><div><pre><code>if (expr) // start of if-statement{ // start of block  int n = 1; // declaration  <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", n); // expression statement} // end of block, end of if-statement</code></pre></div></div><p>Each compound statement introduces its own <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">block scope</a>.</p><p>The initializers of the variables with automatic <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> declared inside a block and the VLA declarators are executed when flow of control passes over these declarations in order, as if they were statements:</p><div><div><pre><code>int main(void){ // start of block  { // start of block       <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("hello"); // expression statement       int n = <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("abc\n"); // declaration, prints "abc", stores 4 in n       int a[n*<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1\n")]; // declaration, prints "1", allocates 8*sizeof(int)       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu\n", sizeof(a)); // expression statement  } // end of block, scope of n and a ends  int n = 7; // n can be reused}</code></pre></div></div><span class="prog__sub"> Expression statements</span><p>An expression followed by a semicolon is a statement.<br></p><table><tr><td></td></tr><tr><td> expression(optional) <code>;</code></td><td> (1)</td><td></td></tr><tr><td></td></tr></table><p>Most statements in a typical C program are expression statements, such as assignments or function calls.<br></p><p>An expression statement without an expression is called a <i>null statement</i>. It is often used to provide an empty body to a <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for</a> or <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while</a> loop. It can also be used to carry a label in the end of a compound statement or before a declaration:</p><div><div><pre><code><a href="http://en.cppreference.com/w/c/io/puts">puts</a>("hello"); // expression statementchar *s;while (*s++ != '\x00')    ; // null statement</code></pre></div></div><span class="prog__sub"> Selection statements</span><p>The selection statements choose between one of several statements depending on the value of an expression.<br></p><table><tr><td></td></tr><tr><td> <code>if</code> <code>(</code> expression <code>)</code> statement</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>if</code> <code>(</code> expression <code>)</code> statement <code>else</code> statement</td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>switch</code> <code>(</code> expression <code>)</code> statement</td><td> (3)</td><td></td></tr><tr><td></td></tr></table><div>1) <a href="http://en.cppreference.com/w/c/language/if" title="c/language/if">if</a> statement</div><div>2) <a href="http://en.cppreference.com/w/c/language/if" title="c/language/if">if</a> statement with an else clause</div><div>3) <a href="http://en.cppreference.com/w/c/language/switch" title="c/language/switch">switch</a> statement</div><span class="prog__sub"> Iteration statements</span><p>The iteration statements repeatedly execute a statement.<br></p><table><tr><td></td></tr><tr><td> <code>while</code> <code>(</code> expression <code>)</code> statement</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>do</code> statement <code>while</code> <code>(</code> expression <code>)</code> <code>;</code></td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>for</code> <code>(</code> init_clause <code>;</code> expression(optional) <code>;</code> expression(optional) <code>)</code> statement</td><td> (3)</td><td></td></tr><tr><td></td></tr></table><div>1) <a href="http://en.cppreference.com/w/c/language/while" title="c/language/while">while</a> loop</div><div>2) <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do">do-while</a> loop</div><div>3) <a href="http://en.cppreference.com/w/c/language/for" title="c/language/for">for</a> loop</div><span class="prog__sub"> Jump statements</span><p>The jump statements unconditionally transfer flow control.<br></p><table><tr><td></td></tr><tr><td> <code>break</code> <code>;</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>continue</code> <code>;</code></td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>return</code> expression(optional) <code>;</code></td><td> (3)</td><td></td></tr><tr><td></td></tr><tr><td> <code>goto</code> identifier <code>;</code></td><td> (4)</td><td></td></tr><tr><td></td></tr></table><div>1) <a href="http://en.cppreference.com/w/c/language/break" title="c/language/break">break</a> statement</div><div>2) <a href="http://en.cppreference.com/w/c/language/continue" title="c/language/continue">continue</a> statement</div><div>3) <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return">return</a> statement with an optional expression</div><div>4) <a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto">goto</a> statement</div></section>	http://en.cppreference.com/w/c/language/statements
static assert declaration	A										<section class="prog__container"><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>_Static_assert</code> <code>(</code> expression <code>,</code> message <code>)</code></td><td></td><td> (since C11)</td></tr><tr><td></td></tr></table><table><tr><td> expression</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">integer constant expression</a></td></tr><tr><td> message</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literal</a></td></tr></table><p>This keyword is also available as convenience macro <a href="http://en.cppreference.com/w/c/error/static_assert" title="c/error/static assert"><tt>static_assert</tt></a>, available in the header <code>&lt;assert.h&gt;</code>.</p><span class="prog__sub"> Explanation</span><p>The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message as part of the error message (except that characters not in <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">basic source character set</a> aren't required to be displayed).</p><p>Otherwise, if expression does not equal zero, nothing happens; no code is emitted.</p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/_Static_assert" title="c/keyword/ Static assert"><tt>_Static_assert</tt></a></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;assert.h&gt;int main(void){    // Test if math works.    static_assert(2 + 2 == 4, "Whoa dude!"); // or _Static_assert(...\xc2\xa0    // This will produce an error at compile time.    static_assert(sizeof(int) &lt; sizeof(char),                 "this program requires that int is less than char");}</code></pre></div></div><p><br/></p></div></section>	http://en.cppreference.com/w/c/language/static_assert
Static storage duration	A										<section class="prog__container"><p>An object whose identifier is declared without the storage-class specifier <code>_Thread_local</code>, and either with external or internal linkage or with the storage-class specifier <code>static</code>, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.</p></section>	http://en.cppreference.com/w/c/language/static_storage_duration
Storage-class specifiers	A										<section class="prog__container"><p>Specify <i>storage duration</i> and <i>linkage</i> of objects and functions:</p><dl><dd><ul><li><code>auto</code> - automatic duration and no linkage</li><li><code>register</code> - automatic duration and no linkage; address of this variable cannot be taken</li><li><code>static</code> - static duration and internal linkage (unless at block scope)</li><li><code>extern</code> - static duration and external linkage (unless already declared internal)</li></ul></dd></dl><table><tr><td><dl><dd><ul><li><code>_Thread_local</code> - thread storage duration</li></ul></dd></dl></td><td>(since C11)</td></tr></table><span class="prog__sub"> Explanation</span><p>Storage-class specifiers appear in <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>. At most one specifier may be used, except that <code>_Thread_local</code> may be combined with <code>static</code> or <code>extern</code> to adjust linkage (since C11). The storage-class specifiers determine two independent properties of the names they declare: <i>storage duration</i> and <i>linkage</i>.</p><div>1) The <code>auto</code> specifier is only allowed for objects declared at block scope (except function parameter lists). It indicates automatic storage duration and no linkage, which are the defaults for these kinds of declarations.</div><div>2) The <code>register</code> specifier is only allowed for objects declared at block scope, including function parameter lists. It indicates automatic storage duration and no linkage (which is the default for these kinds of declarations), but additionally hints the optimizer to store the value of this variable in a CPU register if possible. Regardless of whether this optimization takes place or not, variables declared <code>register</code> cannot be used as arguments to the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">address-of operator</a>, cannot use <a href="http://en.cppreference.com/w/c/language/_Alignas" title="c/language/ Alignas">alignas</a> (since C11), and <code>register</code> arrays are not convertible to pointers.</div><div>3) The <code>static</code> specifier specifies both static storage duration (unless combined with <code>_Thread_local</code>) (since C11) and internal linkage (unless used at block scope). It can be used with functions at file scope and with variables at both file and block scope, but not in function parameter lists.</div><div>4) The <code>extern</code> specifier specifies static storage duration (unless combined with <code>_Thread_local</code>) (since C11) and external linkage. It can be used with function and object declarations in both file and block scope (excluding function parameter lists). If <code>extern</code> appears on a redeclaration of an identifier that was already declared with internal linkage, the linkage remains internal. Otherwise (if the prior declaration was external, no-linkage, or is not in scope), the linkage is external.</div><table><tr><td><div>5) <code>_Thread_local</code> indicates <i>thread storage duration</i>. It cannot be used with function declarations. If it is used on a declaration of an object, it must be present on every declaration of the same object. If it is used on a block-scope declaration, it must be combined with either <code>static</code> or <code>extern</code> to decide linkage.</div></td><td>(since C11)</td></tr></table><p>If no storage-class specifier is provided, the defaults are:<br></p><dl><dd> <code>extern</code> for all functions</dd><dd> <code>extern</code> for objects at file scope</dd><dd> <code>auto</code> for objects at block scope</dd></dl><p>For any struct or union declared with a storage-class specifier, the storage duration (but not linkage) applies to their members, recursively.<br></p><p>Function declarations at block scope can use <code>extern</code> or none at all. Function declarations at file scope can use <code>extern</code> or <code>static</code>.</p><p>Function parameters cannot use any storage-class specifiers other than <code>register</code>. Note that <code>static</code> has special meaning in function parameters of array type.</p><span class="prog__sub"> Storage duration</span><p>Every <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">object</a> has a property called <i>storage duration</i>, which limits the object <a href="http://en.cppreference.com/w/c/language/lifetime" title="c/language/lifetime">lifetime</a>. There are four kinds of storage duration in C:</p><dl><dd><ul><li><i><b>automatic</b></i> storage duration. The storage is allocated when the <a href="http://en.cppreference.com/w/c/language/statements#Compound_statements" title="c/language/statements">block</a> in which the object was declared is entered and deallocated when it is exited by any means (<a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto">goto</a>, <a href="http://en.cppreference.com/w/c/language/return" title="c/language/return">return</a>, reaching the end). One exception is the <a href="http://en.cppreference.com/w/c/language/array#Variable-length_arrays" title="c/language/array">VLAs</a>; their storage is allocated when the declaration is executed, not on block entry, and deallocated when the declaration goes out of scope, not than when the block is exited (since C99). If the block is entered recursively, a new allocation is performed for every recursion level. All function parameters and non-<code>static</code> block-scope objects have this storage duration, as well as <a href="http://en.cppreference.com/w/c/language/compound_literal" title="c/language/compound literal">compound literals</a> used at block scope.</li></ul></dd></dl><dl><dd><ul><li><i><b>static</b></i> storage duration. The storage duration is the entire execution of the program, and the value stored in the object is initialized only once, prior to <a href="http://en.cppreference.com/w/c/language/main_function" title="c/language/main function">main function</a>. All objects declared <code>static</code> and all objects with either internal or external linkage that aren't declared <code>_Thread_local</code> (since C11) have this storage duration.</li></ul></dd></dl><table><tr><td><dl><dd><ul><li><i><b>thread</b></i> storage duration. The storage duration is the entire execution of the thread in which it was created, and the value stored in the object is initialized when the thread is started. Each thread has its own, distinct, object. If the thread that executes the expression that accesses this object is not the thread that executed its initialization, the behavior is implementation-defined. All objects declared <code>_Thread_local</code> have this storage duration.</li></ul></dd></dl></td><td>(since C11)</td></tr></table><dl><dd><ul><li><i><b>allocated</b></i> storage duration. The storage is allocated and deallocated on request, using <a href="http://en.cppreference.com/w/c/memory" title="c/memory">dynamic memory allocation</a> functions.</li></ul></dd></dl><h4> Linkage</h4><p>Linkage refers to the ability of an identifier (variable or function) to be referred to in other scopes. If a variable or function with the same identifier is declared in several scopes, but cannot be referred to from all of them, then several instances of the variable are generated. The following linkages are recognized:<br></p><dl><dd><ul><li><i><b>no linkage</b></i>. The identifier can be referred to only from the scope it is in. All function parameters and all non-<code>extern</code> block-scope variables (including the ones declared <code>static</code>) have this linkage.</li></ul></dd></dl><dl><dd><ul><li><i><b>internal linkage</b></i>. The identifier can be referred to from all scopes in the current translation unit. All <code>static</code> identifiers (both functions and variables) have this linkage.</li></ul></dd></dl><dl><dd><ul><li><i><b>external linkage</b></i>. The identifier can be referred to from any other translation units in the entire program. All non-<code>static</code> functions, all <code>extern</code> variables (unless earlier declared <code>static</code>), and all file-scope non-<code>static</code> variables have this linkage.</li></ul></dd></dl><p>If the same identifier appears with both internal and external linkage in the same translation unit, the behavior is undefined. This is possible when <a href="http://en.cppreference.com/w/c/language/extern" title="c/language/extern">tentative definitions</a> are used.</p><h4> Linkage and libraries</h4><table><tr><td></td><td>This section is incomplete<br/>Reason: should this be a separate top-level entry in c/language under Miscellaneous? </td></tr></table><p>Declarations with external linkage are commonly made available in header files so that all  translation units that <a href="http://en.cppreference.com/w/c/preprocessor/include" title="c/preprocessor/include">#include</a> the file may refer to the same identifier that are defined elsewhere.</p><p>Any declaration with internal linkage that appears in a header file results in a separate and distinct object in each translation unit that includes that file.<br></p><p>Library interface:<br></p><div><div><pre><code>// flib.h#ifndef FLIB_H#define FLIB_Hvoid f(void);              // function declaration with external linkageextern int state;          // variable declaration with external linkagestatic const int size = 5; // definition of a read-only variable with internal linkageenum { MAX = 10 };         // constant definitioninline int sum (int a, int b) { return a+b; } // inline function definition#endif // FLIB_H</code></pre></div></div><p>Library implementation:<br></p><div><div><pre><code>// flib.c#include "flib.h"static void local_f(int s) {}  // definition with internal linkage (only used in this file)static int local_state;        // definition with internal linkage (only used in this file)\xc2\xa0int state;                     // definition with external linkage (used by main.c)void f(void) {local_f(state);} // definition with external linkage (used by main.c)</code></pre></div></div><p>Application code:<br></p><div><div><pre><code>// main.c #include "flib.h"int main(void){    int x[MAX] = {size}; // uses the constant and the read-only variable    state = 7;           // modifies state in flib.c    f();                 // calls f() in flib.c}</code></pre></div></div><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/auto" title="c/keyword/auto"><tt>auto</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/register" title="c/keyword/register"><tt>register</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/static" title="c/keyword/static"><tt>static</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/extern" title="c/keyword/extern"><tt>extern</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/_Thread_local" title="c/keyword/ Thread local"><tt>_Thread_local</tt></a></p></section>	http://en.cppreference.com/w/c/language/storage_duration
string literals	A										<section class="prog__container"><p>Constructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>"</code> s-char-sequence <code>"</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>u8</code> <code>"</code> s-char-sequence <code>"</code></td><td> (2)</td><td> (since C11)</td></tr><tr><td></td></tr><tr><td> <code>u</code> <code>"</code> s-char-sequence <code>"</code></td><td> (3)</td><td> (since C11)</td></tr><tr><td></td></tr><tr><td> <code>U</code> <code>"</code> s-char-sequence <code>"</code></td><td> (4)</td><td> (since C11)</td></tr><tr><td></td></tr><tr><td> <code>L</code> <code>"</code> s-char-sequence <code>"</code></td><td> (5)</td><td></td></tr><tr><td></td></tr></table><p>where<br></p><table><tr><td> s-char-sequence</td><td> -</td><td>  zero or more characters, each of which is either a multibyte character from the source character set (excluding (<code>"</code>), <code>\\</code>, and newline), or character escape, hex escape, octal escape, or unified character name (since C99) as defined in <a href="http://en.cppreference.com/w/c/language/escape" title="c/language/escape">escape sequences</a>.<p><br/></p></td></tr></table><div>1) <i>character string literal</i>: The type of the literal is <code>char[]</code>, each character in the array is initialized from the next character in s-char-sequence using the execution character set.</div><div>2) <i>UTF-8 string literal</i>: The type of the literal is <code>char[]</code>, each character in the array is initialized from the next multibyte character in s-char-sequence using UTF-8 encoding.</div><div>3) 16-bit wide string literal: The type of the literal is <code>char16_t[]</code>, each char16_t element in the array is initialized as if by executing <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtoc16" title="c/string/multibyte/mbrtoc16">mbrtoc16</a> in implementation-defined locale.</div><div>4) 32-bit wide string literal: The type of the literal is <code>char32_t[]</code>, each char32_t element in the array is initialized as if by executing <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtoc32" title="c/string/multibyte/mbrtoc32">mbrtoc32</a> in implementation-defined locale.</div><div>5) wide string literal: The type of the literal is <code>wchar_t[]</code>, each wchar_t element in the array is initialized as if by executing <a href="http://en.cppreference.com/w/c/string/multibyte/mbstowcs" title="c/string/multibyte/mbstowcs">mbstowcs</a> in implementation-defined locale.</div><span class="prog__sub"> Explanation</span><p>First, at <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">translation phase 6</a> (after macro expansion), the adjacent string literals (that is, string literals separated by whitespace only) are concatenated.</p><table><tr><td><p>Only two narrow or two wide string literals may be concatenated.<br></p></td><td>(until C99)</td></tr><tr><td><p>If one literal is unprefixed, the resulting string literal has the width/encoding specified by the prefixed literal. If the two string literals have different encoding prefixes, concatenation is implementation-defined. <br></p><div><div><pre><code>L"\xce\x94x =\xc2\xa0%" <a href="http://en.cppreference.com/w/c/types/integer">PRId16</a> // at phase 4, PRId16 expands to "d"                 // at phase 6, L"\xce\x94x =\xc2\xa0%" and "d" form L"\xce\x94x =\xc2\xa0%d"</code></pre></div></div></td><td>(since C99)</td></tr></table><p>Secondly, at <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">translation phase 7</a>, a terminating null character is added to each string literal, and then each literal initializes an unnamed array with static <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> and length just enough to contain the contents of the string literal plus one the null terminator.</p><div><div><pre><code>char* p = "\x12" "3"; // creates a static char[3] array holding {'\x12', '3', '\x00'}                       // sets p to point to the first element of the array</code></pre></div></div><p>String literals are <b>not modifiable</b> (and in fact may be placed in read-only memory such as <code>.rodata</code>). If a program attempts to modify the static array formed by a string literal, the behavior is undefined.</p><div><div><pre><code>char* p = "Hello";p[1] = 'M'; // Undefined behavior</code></pre></div></div><p>It is neither required nor forbidden for identical string literals to refer to the same location in memory. Moreover, overlapping string literals or string literals that are substrings of other string literals may be combined.<br></p><div><div><pre><code>"def" == 3+"abcdef"; // may be 1 or 0, implementation-defined</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/string_literal
Struct declaration	A										<section class="prog__container"><p>A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps).<br></p><p>The <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">type specifier</a> for a struct is identical to the <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union"> <code>union</code></a> type specifier except for the keyword used:</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>struct</code> name(optional) <code>{ </code> struct-declaration-list <code>} </code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>struct</code> name</td><td> (2)</td><td></td></tr><tr><td></td></tr></table><div>1) Struct definition: introduces the new type struct name and defines its meaning</div><div>2) If used on a line of its own, as in <code>struct</code> name <code>;</code>, <i>declares</i> but doesn't define the struct <code>name</code> (see forward declaration below). In other contexts, names the previously-declared struct.</div><table><tr><td> name</td><td> -</td><td>  the name of the struct that's being defined</td></tr><tr><td> struct-declaration-list</td><td> -</td><td>  any number of variable declarations, <a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field">bit field</a> declarations, and <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/static_assert" title="c/language/static assert">static assert</a> declarations. Members of incomplete type and members of function type are not allowed (except for the flexible array member described below)</td></tr></table><span class="prog__sub"> Explanation</span><p>Within a struct object, addresses of its elements (and the addresses of the bit field allocation units) increase in order in which the members were defined. A pointer to a struct can be cast to a pointer to its first member (or, if the member is a bit field, to its allocation unit). Likewise, a pointer to the first member of a struct can be cast to a pointer to the enclosing struct. There may be unnamed padding between any two members of a struct or after the last member, but not before the first member. The size of a struct is at least as large as the sum of the sizes of its members.<br></p><table><tr><td><p>If a struct defines at least one named member, it is allowed to additionally declare its last member with incomplete array type. When an element of the flexible array member is accessed (in an expression that uses operator <code>.</code> or <code>-&gt;</code> with the flexible array member's name as the right-hand-side operand), then the struct behaves as if the array member had the longest size fitting in the memory allocated for this object. If no additional storage was allocated, it behaves as if an array with 1 element, except that the behavior is undefined if that element is accessed or a pointer one past that element is produced. Initialization, <code>sizeof</code>, and the assignment operator ignore the flexible array member. Structures with flexible array members (or unions whose last member is a structure with flexible array member) cannot appear as array elements or as members of other structures.</p><div><div><pre><code>struct s { int n; double d[]; }; // s.d is a flexible array member \xc2\xa0    struct s t1 = { 0 };         // OK, d is as if double d[1], but UB to access    struct s t2 = { 1, { 4.2 } }; // error: initialization ignores flexible array\xc2\xa0    // if sizeof (double) == 8    struct s *s1 = <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(sizeof (struct s) + 64); // as if d was double d[8]    struct s *s2 = <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(sizeof (struct s) + 46); // as if d was double d[5]\xc2\xa0    s1 = <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(sizeof (struct s) + 10); // now as if d was double d[1]    s2 = <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(sizeof (struct s) + 6);  // same, but UB to access    double *dp = &amp;(s1-&gt;d[0]);    //  OK    *dp = 42;                    //  OK    dp = &amp;(s2-&gt;d[0]);            //  OK    *dp = 42;                    //  undefined behavior\xc2\xa0    *s1 = *s2; // only copies s.n, not any element of s.d               // except those caught in sizeof (struct s)</code></pre></div></div></td><td>(since C99)</td></tr></table><table><tr><td><p>Similar to union, an unnamed member of a struct whose type is a struct without name is known as <i>anonymous struct</i>. Every member of an anonymous struct is considered to be a member of the enclosing struct or union. This applies recursively if the enclosing struct or union is also anonymous.</p><div><div><pre><code>struct v {   union { // anonymous union      struct { int i, j; }; // anonymous structure      struct { long k, l; } w;   };   int m;} v1;\xc2\xa0v1.i = 2;   // validv1.k = 3;   // invalid: inner structure is not anonymousv1.w.k = 5; // valid</code></pre></div></div><p>Similar to union, the behavior of the program is undefined if struct is defined without any named members (including those obtained via anonymous nested structs or unions).<br></p></td><td>(since C11)</td></tr></table><span class="prog__sub"> Forward declaration</span><p>A declaration of the following form<br></p><table><tr><td></td></tr><tr><td> <code>struct</code> name <code>;</code></td><td></td><td></td></tr><tr><td></td></tr></table><p>hides any previously declared meaning for the name name in the tag name space and declares name as a new struct name in current scope, which will be defined later. Until the definition appears, this struct name has <a href="http://en.cppreference.com/w/c/language/type#Incomplete_types" title="c/language/type">incomplete type</a>.</p><p>This allows structs that refer to each other:<br></p><div><div><pre><code>struct y;struct x { struct y *p; /* ... */ };struct y { struct x *q; /* ... */ };</code></pre></div></div><p>Note that a new struct name may also be introduced just by using a struct tag within another declaration, but if a previously declared struct with the same name exists in the tag <a href="http://en.cppreference.com/w/c/language/name_space" title="c/language/name space">name space</a>, the tag would refer to that name</p><div><div><pre><code>struct s* p = <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>; // tag naming an unknown struct declares itstruct s { int a; }; // definition for the struct pointed to by pvoid g(void){    struct s; // forward declaration of a new, local struct s              // this hides global struct s until the end of this block    struct s *p;  // pointer to local struct s                  // without the forward declaration above,                  // this would point at the file-scope s    struct s { char* p; }; // definitions of the local struct s}</code></pre></div></div><p><br/></p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/struct" title="c/keyword/struct"><tt>struct</tt></a></p></section>	http://en.cppreference.com/w/c/language/struct
Struct and union initialization	A										<section class="prog__container"><p>When <a href="http://en.cppreference.com/w/c/language/initialization" title="c/language/initialization">initializing</a> an object of <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a> or <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a> type, the initializer must be a non-empty, brace-enclosed, comma-separated list of initializers for the members:</p><table><tr><td></td></tr><tr><td> <code>=</code> <code>{ </code> expression <code>,</code> <code>...</code> <code>} </code></td><td></td><td> (until C99)</td></tr><tr><td></td></tr><tr><td> <code>=</code> <code>{ </code> designator(optional) expression <code>,</code> <code>...</code> <code>} </code></td><td></td><td> (since C99)</td></tr><tr><td></td></tr></table><p>where the designator is a sequence (whitespace-separated or adjacent) of individual member designators of the form <code>.</code> member and <a href="http://en.cppreference.com/w/c/language/array_initialization" title="c/language/array initialization">array designators</a> of the form <code>[</code> index <code>]</code>.</p><p>All members that are not initialized explicitly are <a href="http://en.cppreference.com/w/c/language/initialization#Implicit_initialization" title="c/language/initialization">initialized implicitly</a> the same way as objects that have static storage duration.</p><span class="prog__sub"> Explanation</span><p>When initializing a <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union</a>, the initializer list must have only one member, which initializes the first member of the union unless a designated initializer is used (since C99).</p><div><div><pre><code>union { int x; char c[4]; }  u = {1},           // makes u.x active with value 1 u2 = { .c={'\x01'} }; // makes u2.c active with value {'\x01','\x00','\x00','\x00'}</code></pre></div></div><p>When initializing a <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">struct</a>, the first initializer in the list initializes the first declared member (unless a designator is specified) (since C99), and all subsequent initializers without designators  (since C99)initialize the struct members declared after the one initialized by the previous expression.</p><div><div><pre><code>struct point {double x,y,z;} p = {1.2, 1.3}; // p.x=1.2, p.y=1.3, p.z=0.0div_t answer = {.quot = 2, .rem = -1 };      // order of elements in div_t may vary</code></pre></div></div><table><tr><td><p>A designator causes the following initializer to initialize the struct member described by the designator. Initialization then continues forward in order of declaration, beginning with the next element declared after the one described by the designator.<br></p><div><div><pre><code>struct {int sec,min,hour,day,mon,year;} z   = {.day=31,12,2014,.sec=30,15,17}; // initializes z to {30,15,17,31,12,2014}</code></pre></div></div></td><td>(since C99)</td></tr></table><p>It's an error to provide more initializers than members.<br></p><span class="prog__sub"> Nested initialization</span><p>If the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:<br></p><p>If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new <i>current object</i>. The members of the current object are initialized in their natural order, unless designators are used (since C99): array elements in subscript order, struct members in declaration order, only the first declared member of any union. The subobjects within the current object that aren't explicitly initialized by the closing brace are <a href="http://en.cppreference.com/w/c/language/initialization#Implicit_initialization" title="c/language/initialization">implicitly initialized</a>.</p><div><div><pre><code>struct example {    struct addr_t {       <a href="http://en.cppreference.com/w/c/types/integer">uint32_t</a> port;    } addr;    union {       <a href="http://en.cppreference.com/w/c/types/integer">uint8_t</a> a8[4];       <a href="http://en.cppreference.com/w/c/types/integer">uint16_t</a> a16[2];    } in_u;};struct example ex = { // start of initializer list for struct example                     { // start of initializer list for ex.addr                        80 // initialized struct's only member                     }, // end of initializer list for ex.addr                     { // start of initializer-list for ex.in_u                        {127,0,0,1} // initializes first element of the union                     } };</code></pre></div></div><p>If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:<br></p><div><div><pre><code>struct example ex = {80, 127, 0, 0, 1}; // 80 initializes ex.addr.port                                        // 127 initializes ex.in_u.a8[0]                                        // 0 initializes ex.in_u.a8[1]                                        // 0 initializes ex.in_u.a8[2]                                        // 1 initializes ex.in_u.a8[3]</code></pre></div></div><table><tr><td><p>When designators are nested, the designators for the members follow the designators for the enclosing structs/unions/arrays. Within any nested bracketed initializer list, the outermost designator refers to the <i>current object</i> and selects the subobject to be initialized within the <i>current object</i> only.</p><div><div><pre><code>struct example ex2 = { // current object is ex2, designators are for members of example                       .in_u.a8[0]=127, 0, 0, 1, .addr=80}; struct example ex3 = {80, .in_u={ // changes current object to the union ex.in_u                           127,                           .a8[2]=1 // this designator refers to the member of in_u                      } };</code></pre></div></div><p>If any subobject is explicitly initialized twice (which may happen when designators are used), the initializer that appears later in the list is the one used (the earlier initializer may not be evaluated):<br></p><div><div><pre><code>struct {int n;} s = {<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("a\n"), // this may be printed or skipped                     .n=<a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("b\n")}; // always printed</code></pre></div></div><p>Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list:<br></p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;typedef struct { int k; int l; int a[2]; } T;typedef struct { int i;  T t; } S;T x = {.l = 43, .k = 42, .a[1] = 19, .a[0] = 18 }; // x initialized to {42, 43, {18, 19} }int main(void){    S l = { 1,          // initializes l.i to 1           .t = x,      // initializes l.t to {42, 43, {18, 19} }           .t.l = 41,   // changes l.t to {42, 41, {18, 19} }           .t.a[1] = 17 // changes l.t to {42, 41, {18, 17} }          };    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("l.t.k is\xc2\xa0%d\n", l.t.k); // .t = x sets l.t.k to 42 explicitly                                    // .t.l = 42 would zero out l.t.k implicitly}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>l.t.k is 42</code></pre></div></div></div><p>However, when an initializer begins with a left open brace, its <i>current object</i> is fully re-initialized and any prior explicit initializers for any of its subobjects are ignored:</p><div><div><pre><code>struct fred { char s[4]; int n; };struct fred x[ ] = { { { "abc" }, 1 }, // inits x[0] to { {'a','b','c','\x00'}, 1 }                      [0].s[0] = 'q'   // changes x[0] to { {'q','b','c','\x00'}, 1 }                   };struct fred y[ ] = { { { "abc" }, 1 }, // inits y[0] to { {'a','b','c','\x00'}, 1 }                     [0] = { // current object is now the entire y[0] object                             .s[0] = 'q'                             } // replaces y[0] with { {'q','\x00','\x00','\x00'}, 0 }                    };</code></pre></div></div></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/struct_initialization
switch statement	A										<section class="prog__container"><p>Executes code according to the value of an integral argument.<br></p><p>Used where one or several out of many branches of code need to be executed according to an integral value.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>switch (</code> expression <code>)</code> statement</td><td></td><td></td></tr><tr><td></td></tr></table><table><tr><td> expression</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> of <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">integer type</a> (char, signed or unsigned integer, or enumeration)</td></tr><tr><td> statement</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/statements" title="c/language/statements">statement</a> (typically a compound statement). <code>case:</code> and <code>default:</code> labels are permitted in statement, and <code>break;</code> statement has special meaning.</td></tr></table><table><tr><td></td></tr><tr><td> <code>case</code> constant_expression <code>:</code> statement</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>default</code> <code>:</code> statement</td><td> (2)</td><td></td></tr><tr><td></td></tr></table><table><tr><td> constant_expression</td><td> -</td><td>  any integer <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">constant expression</a></td></tr></table><span class="prog__sub"> Explanation</span><p>The body of a switch statement may have an arbitrary number of <code>case:</code> labels, as long as the values of all constant_expressions are unique (after <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">conversion</a> to the promoted type of expression). At most one <code>default:</code> label may be present (although nested switch statements may use their own <code>default:</code> labels or have <code>case:</code> labels whose constants are identical to the ones used in the enclosing switch).</p><p>If expression evaluates to the value that is equal to the value of one of constant_expressions after conversion to the promoted type of expression, then control is transferred to the statement that is labeled with that constant_expression.</p><p>If expression evaluates to a value that doesn't match any of the <code>case:</code> labels, and the <code>default:</code> label is present, control is transferred to the statement labeled with the <code>default:</code> label.</p><p>If expression evaluates to a value that doesn't match any of the <code>case:</code> labels, and the <code>default:</code> label is not present, none of the switch body is executed.</p><p>The <a href="http://en.cppreference.com/w/c/language/break" title="c/language/break">break</a> statement, when encountered anywhere in statement, exits the switch statement:</p><div><div><pre><code>switch(1) {    case 1 : <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("1"); // prints "1",    case 2 : <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("2"); // then prints "2" ("fall-through")}</code></pre></div></div><div><div><pre><code>switch(1) {    case 1 : <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("1"); // prints "1"             break;     // and exits the switch    case 2 : <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("2");             break;}</code></pre></div></div><table><tr><td><p>As with all other selection and iteration statements, the switch statement establishes <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">block scope</a>: any identifier introduced in the expression goes out of scope after the statement.</p><p>If a VLA or another identifier with variably-modified type has a <code>case:</code> or a <code>default:</code> label within its scope, the entire switch statement must be in its scope (in other words, a VLA must be declared either before the entire switch or after the last label):</p><div><div><pre><code>switch (expr){    int i = 4; // not a VLA; OK to declare here    f(i); // never called//  int a[i]; // error: VLA cannot be declared here  case 0:    i = 17;default:;    int a[i]; // OK to declare VLA here    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", i); // prints 17 if expr == 0, prints indeterminate value otherwise}</code></pre></div></div></td><td>(since C99)</td></tr></table><p><br/></p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/switch" title="c/keyword/switch"><tt>switch</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/case" title="c/keyword/case"><tt>case</tt></a>,<a href="http://en.cppreference.com/w/c/keyword/default" title="c/keyword/default"><tt>default</tt></a></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0void func(int x){   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("func(%d): ", x);   switch(x)   {      case 1: <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("case 1, ");      case 2: <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("case 2, ");      case 3: <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("case 3.\n"); break;      case 4: <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("case 4, ");      case 5: <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("case 5, ");      default: <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("default.\n");   }}\xc2\xa0int main(void){   for(int i = 1; i &lt; 10; ++i) func(i);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>func(1): case 1, case 2, case 3.<br>func(2): case 2, case 3.<br>func(3): case 3.<br>func(4): case 4, case 5, default.<br>func(5): case 5, default.<br>func(6): default.<br>func(7): default.<br>func(8): default.<br>func(9): default.</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/switch
Thread storage duration	A										<section class="prog__container"><p>An object whose identifier is declared with the storage-class specifier <code>_Thread_local</code> (since C11) has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>const double PI = 3.14159;         /* const variable is global to all threads  */_Thread_local unsigned int seed;   /* seed is a thread-specific variable       */\xc2\xa0int main(void){    return 0;}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>(none)</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/thread_storage_duration
Phases of translation	A										<section class="prog__container"><p>The C source file is processed by the compiler <i>as if</i> the following phases take place, in this exact order. Actual implementation may combine these actions or process them differently as long as the behavior is the same.</p><span class="prog__sub"> Phase 1</span><div>1) The individual bytes of the source code file (which is generally a text file in some multibyte encoding such as UTF-8) are mapped, in implementation defined manner, to the characters of the <i>source character set</i>. In particular, OS-dependent end-of-line indicators are replaced by newline characters.<dl><dd>The <i>source character set</i> is a multibyte character set which includes the <i>basic source character set</i> as a single-byte subset, consisting of the following 96 characters:</dd></dl></div><div>a) 5 whitespace characters (space, horizontal tab, vertical tab, form feed, new-line)</div><div>b) 10 digit characters from <code>'0'</code> to <code>'9'</code></div><div>c) 52 letters from <code>'a'</code> to <code>'z'</code> and from <code>'A'</code> to <code>'Z'</code></div><div>d) 29 punctuation characters: <code>_ { } [ ] # ( ) &lt; &gt;\xc2\xa0%\xc2\xa0:\xc2\xa0; .\xc2\xa0? * + - / ^ &amp; | ~\xc2\xa0! = , \\ " \xe2\x80\x99</code></div><div>2) <a href="http://en.cppreference.com/w/c/language/operator_alternative" title="c/language/operator alternative">Trigraph sequences</a> are replaced by corresponding single-character representations.</div><span class="prog__sub"> Phase 2</span><div>1) Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation: a line ending in two backslashes followed by an empty line does not combine three lines into one. </div><div>2) If a non-empty source file does not end with a newline character after this step (whether it had no newline originally, or it ended with a backslash), the behavior is undefined.</div><span class="prog__sub"> Phase 3</span><div>1) The source file is decomposed into <a href="http://en.cppreference.com/w/c/comment" title="c/comment">comments</a>, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and <i>preprocessing tokens</i>, which are the following</div><div>a) header names: <code>&lt;stdio.h&gt;</code> or <code>"myfile.h"</code></div><div>b) <a href="http://en.cppreference.com/w/c/language/identifier" title="c/language/identifier">identifiers</a></div><div>c) numbers</div><div>d) <a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant">character constants</a> and <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literals</a></div><div>e) operators and punctuators (including <a href="http://en.cppreference.com/w/c/language/operator_alternative" title="c/language/operator alternative">alternative tokens</a>), such as <code>+</code>, <code>&lt;&lt;=</code>, <code>&lt;%</code>, <code>##</code>, or <code>and</code>.</div><div>f) individual non-whitespace characters that do not fit in any other category</div><div>2) Each comment is replaced by one space character</div><div>3) Newlines are kept, and it's implementation-defined whether non-newline whitespace sequences may be collapsed into single space characters.</div><span class="prog__sub"> Phase 4</span><div>1) <a href="http://en.cppreference.com/w/c/preprocessor" title="c/preprocessor">Preprocessor</a> is executed.</div><div>2) Each file introduced with the <a href="http://en.cppreference.com/w/cpp/preprocessor/include" title="cpp/preprocessor/include">#include</a> directive goes through phases 1 through 4, recursively.</div><div>3) At the end of this phase, all preprocessor directives are removed from the source.</div><span class="prog__sub"> Phase 5</span><div>1) All characters and <a href="http://en.cppreference.com/w/c/language/escape" title="c/language/escape">escape sequences</a> in <a href="http://en.cppreference.com/w/c/language/character_constant" title="c/language/character constant">character constants</a> and <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literals</a> are converted from <i>source character set</i> to <i>execution character set</i> (which may be a multibyte character set such as UTF-8, as long as all 96 characters from the <i>basic source character set</i> listed in phase 1 have single-byte representations). If the character specified by an escape sequence isn't a member of the execution character set, the result is implementation-defined, but is guaranteed to not be a null (wide) character.</div><p>Note: the conversion performed at this stage can be controlled by command line options in some implementations: gcc and clang use <code>-finput-charset</code> to specify the encoding of the source character set, <code>-fexec-charset</code> and <code>-fwide-exec-charset</code> to specify the encodings of the execution character set in the string and character literals that don't have an encoding prefix (since C11).</p><span class="prog__sub"> Phase 6</span><p>Adjacent <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literals</a> are concatenated.</p><span class="prog__sub"> Phase 7</span><p>Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a translation unit.<br></p><span class="prog__sub"> Phase 8</span><p>Linking takes place: Translation units and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment (the OS).<br></p></section>	http://en.cppreference.com/w/c/language/translation_phases
Type	A										<section class="prog__container"><p><small>(See also <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic types</a> for the details on most built-in types and <a href="http://en.cppreference.com/w/c/types" title="c/types"> the list of type-related utilities</a> that are provided by the C library)</small></p><p><a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">Objects</a>, <a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions">functions</a>, and <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expressions</a> have a property called <i>type</i>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</p><span class="prog__sub"> Type classification</span><p>The C type system consists of the following types:<br></p><ul><li>the type <code>void</code></li><li>basic types</li></ul><dl><dd><ul><li>the type <code>char</code></li><li>signed integer types</li></ul><dl><dd><ul><li>standard: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>  (since C99)</li><li>extended: implementation defined, e.g. <code>__int128</code></li></ul></dd></dl><ul><li>unsigned integer types</li></ul><dl><dd><ul><li>standard: <code>_Bool</code>  (since C99), <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>  (since C99)</li><li>extended: implementation-defined, e.g. <code>__uint128</code></li></ul></dd></dl><ul><li>floating types</li></ul><dl><dd><ul><li>real floating types: <code>float</code>, <code>double</code>, <code>long double</code></li><li>complex types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code></li><li>imaginary types: <code>float _Imaginary</code>, <code>double _Imaginary</code>, <code>long double _Imaginary</code></li></ul></dd></dl></dd></dl><ul><li> <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enumerated types</a></li></ul><ul><li> derived types</li></ul><dl><dd><ul><li> <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array types</a></li><li> <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">structure types</a></li><li> <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union types</a></li><li> <a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions">function types</a></li><li> <a href="http://en.cppreference.com/w/c/language/pointer" title="c/language/pointer">pointer types</a></li><li> <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic types</a></li></ul></dd></dl><p>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, and <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> qualifiers (where allowed by the qualifier's semantics).</p><h4> Type groups</h4><ul><li> <i>object types</i>: all types that aren't function types</li><li> <i>character types</i>: <code>char</code>, <code>signed char</code>, <code>unsigned char</code></li><li> <i>integer types</i>: <code>char</code>, signed integer types, unsigned integer types, enumerated types</li><li> <i>real types</i>: integer types and real floating types </li><li> <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>: integer types and floating types</li><li> <i>scalar types</i>: arithmetic types and pointer types</li><li> <i>aggregate types</i>: array types and structure types</li><li> <i>derived declarator types</i>: array types, function types, and pointer types </li></ul><span class="prog__sub"> Compatible types</span><p>In a C program, the declarations referring to the same object or function in <i>different translation units</i> do not have to use the same type. They only have to use sufficiently similar types, formally known as <i>compatible types</i>. Same applies to function calls and lvalue accesses; argument types must be <i>compatible</i> with parameter types and lvalue expression type must be <i>compatible</i> with the object type that is accessed.</p><p>The types <code>T</code> and <code>U</code> are compatible, if</p><ul><li> they are the same type (same name or aliases introduced by a <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>)</li><li> they are identically cvr-qualified versions of compatible unqualified types</li><li> they are pointer types and are pointing to compatible types</li><li> they are array types, and</li></ul><dl><dd><ul><li> their element types are compatible, and</li><li> if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. VLA is compatible with any array of compatible element type. (since C99)</li></ul></dd></dl><ul><li> they are both structure/union/enumeration types, and</li></ul><dl><dd><ul><li>(C99)if one is declared with a tag, the other must also be declared with the same tag.</li><li> if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.</li><li> additionally, if they are enumerations, corresponding members must also have the same values.</li><li> additionally, if they are structures or unions,</li></ul><dl><dd><ul><li> Corresponding members must be declared in the same order (structures only)</li><li> Corresponding bit fields must have the same widths.</li></ul></dd></dl></dd></dl><ul><li> one is an enumerated type and the other is that enumeration's underlying type</li><li> they are function types, and</li></ul><dl><dd><ul><li> their return types are compatible</li><li> they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, the corresponding parameters have compatible types</li><li> one is an old-style (parameter-less) definition, the other has a parameter list, the parameter list does not use an ellipsis and each parameter is compatible (after function parameter type adjustment) with the corresponding old-style parameter after default argument promotions</li><li> one is an old-style (parameter-less) declaration, the other has a parameter list, the parameter list does not use an ellipsis, and all parameters (after function parameter type adjustment) are unaffected by default argument promotions</li></ul></dd></dl><p>The type <code>char</code> is not compatible with <code>signed char</code> and not compatible with <code>unsigned char</code>.</p><p>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.<br></p><div><div><pre><code>// Translation Unit 1struct S {int a;};extern struct S *x;  // compatible with TU2's x, but not with TU3's x// Translation Unit 2struct S;extern struct S *x; // compatible with both x's// Translation Unit 3struct S {float a;};extern struct S *x; // compatible with TU2's x, but not with TU1's x\xc2\xa0// the behavior is undefined</code></pre></div></div><div><div><pre><code>// Translation Unit 1#include &lt;stdio.h&gt;struct s {int i;}; // compatible with TU3's s, but not TU2'sextern struct s x = {0}; // compatible with TU3's xextern void f(void); // compatible with TU2's fint main(){   f();   return x.i;}// Translation Unit 2struct s {float f;}; // compatible with TU4's s, but not TU1's sextern struct s y = {3.14}; // compatible with TU4's yvoid f() // compatible with TU1's f{   return;}// Translation Unit 3struct s {int i;}; // compatible with TU1's s, but not TU2's sextern struct s x; // compatible with TU1's x// Translation Unit 4struct s {float f;}; // compatible with TU2's s, but not TU1's sextern struct s y; // compatible iwth TU2's y\xc2\xa0// the behavior is well-defined: only multiple declarations// of objects and functions must have compatible types, not the types themselves</code></pre></div></div><p>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.<br></p><span class="prog__sub"> Composite types</span><table><tr><td></td><td>This section is incomplete </td></tr></table><span class="prog__sub"> Incomplete types</span><p>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.<br></p><p>The following types are incomplete:<br></p><ul><li> the type <code>void</code>. This type cannot be completed.</li><li> array type of unknown size. It can be completed by a later declaration that specifies the size.</li><li> structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.</li></ul><span class="prog__sub"> Type names</span><p>A type may have to be named in context other than the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a>. In these situations, <i>type name</i> is used, which is, grammatically, exactly the same as a list of <i>type-specifiers</i> and <i>type-qualifiers</i>, followed by the <i>declarator</i> (see <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>) as would be used to declare a single object or function of this type, except that the identifier is omitted:</p><div><div><pre><code>int n; // declaration of an intsizeof(int); // use of type name\xc2\xa0int *a[3]; // declaration of an array of 3 pointers to intsizeof(int *[3]); // use of type name\xc2\xa0int (*p)[3]; // declaration of a pointer to array of 3 intsizeof(int (*)[3]); // use of type name\xc2\xa0int (*a)[*] // declaration of pointer to VLA (in a function parameter)sizeof(int (*)[*]) // use of type name (in a function parameter)\xc2\xa0int *f(void); // declaration of functionsizeof(int *(void)); // use of type name\xc2\xa0int (*p)(void); // declaration of pointer to functionsizeof(int (*)(void)); // use of type name\xc2\xa0int (*const a[])(unsigned int, ...) = {0}; // array of pointers to functionssizeof(int (*const [])(unsigned int, ...)); // use of type name</code></pre></div></div><p>Except the redundant parentheses around the identifier are meaningful in a type-name and represent "function with no parameter specification":<br></p><div><div><pre><code>int (n); // declares n of type intsizeof(int ()); // uses type "function returning int"</code></pre></div></div><p>Type names are used in the following situations:<br></p><ul><li> <a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast">cast</a></li><li> <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a></li></ul><table><tr><td><ul><li> <a href="http://en.cppreference.com/w/c/language/compound_literal" title="c/language/compound literal">compound literal</a></li></ul></td><td>(since C99)</td></tr><tr><td><ul><li> <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic selection</a></li><li> <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">alignof</a></li><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/alignas" title="c/language/alignas">alignas</a></li><li> <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">_Atomic</a> (when used as a type specifier)</li></ul></td><td>(since C11)</td></tr></table><p><br/>A type name may introduce a new type: </p><div><div><pre><code>void* p = (void*)(struct X {int i;} *)0;// type name "struct X {int i;}*" used in the cast expression// introduces the new type "struct X"struct X x = {1}; // struct X is now in scope</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/type
Typedef declaration	A										<section class="prog__container"><p>The <i>typedef declaration</i> provides a way to declare an identifier as a type alias, to be used to replace a possibly complex <a href="http://en.cppreference.com/w/c/language/type#Type_names" title="c/language/type">type name</a></p><p>The keyword <code>typedef</code> is used in a <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a>, in the grammatical position of a <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage-class specifier</a>, except that it does not affect storage or linkage:</p><div><div><pre><code>typedef int int_t; // declares int_t to be an alias for the type inttypedef char char_t, *char_p, (*fp)(void); // declares char_t to be an alias for char                                           // char_p to be an alias for char*                                           // fp to be an alias for char(*)(void)</code></pre></div></div><span class="prog__sub"> Explanation</span><p>If a <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a> uses <code>typedef</code> as storage-class specifier, every declarator in it defines an identifier as an alias to the type specified. Since only one storage-class specifier is permitted in a declaration, typedef declaration cannot be <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">static or extern</a>.</p><p>typedef declaration does not introduce a distinct type, it only establishes a synonym for an existing type, thus typedef names are <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> with the types they alias. Typedef names share the <a href="http://en.cppreference.com/w/c/language/name_space" title="c/language/name space">name space</a> with ordinary identifiers such as enumerators, variables and function.</p><table><tr><td><p>A typedef for a VLA can only appear at block scope. The length of the array is evaluated each time the flow of control passes over the typedef declaration, as opposed to the declaration of the array itself:<br></p><div><div><pre><code>void copyt(int n){    typedef int B[n]; // B is a VLA, its size is n, evaluated now    n += 1;    B a; // size of a is n from before +=1    int b[n]; // a and b are different sizes    for (int i = 1; i &lt; n; i++)        a[i-1] = b[i];}</code></pre></div></div></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/typedef
Type	A										<section class="prog__container"><p><small>(See also <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic types</a> for the details on most built-in types and <a href="http://en.cppreference.com/w/c/types" title="c/types"> the list of type-related utilities</a> that are provided by the C library)</small></p><p><a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">Objects</a>, <a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions">functions</a>, and <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expressions</a> have a property called <i>type</i>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</p><span class="prog__sub"> Type classification</span><p>The C type system consists of the following types:<br></p><ul><li>the type <code>void</code></li><li>basic types</li></ul><dl><dd><ul><li>the type <code>char</code></li><li>signed integer types</li></ul><dl><dd><ul><li>standard: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>  (since C99)</li><li>extended: implementation defined, e.g. <code>__int128</code></li></ul></dd></dl><ul><li>unsigned integer types</li></ul><dl><dd><ul><li>standard: <code>_Bool</code>  (since C99), <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>  (since C99)</li><li>extended: implementation-defined, e.g. <code>__uint128</code></li></ul></dd></dl><ul><li>floating types</li></ul><dl><dd><ul><li>real floating types: <code>float</code>, <code>double</code>, <code>long double</code></li><li>complex types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code></li><li>imaginary types: <code>float _Imaginary</code>, <code>double _Imaginary</code>, <code>long double _Imaginary</code></li></ul></dd></dl></dd></dl><ul><li> <a href="http://en.cppreference.com/w/c/language/enum" title="c/language/enum">enumerated types</a></li></ul><ul><li> derived types</li></ul><dl><dd><ul><li> <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">array types</a></li><li> <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct">structure types</a></li><li> <a href="http://en.cppreference.com/w/c/language/union" title="c/language/union">union types</a></li><li> <a href="http://en.cppreference.com/w/c/language/functions" title="c/language/functions">function types</a></li><li> <a href="http://en.cppreference.com/w/c/language/pointer" title="c/language/pointer">pointer types</a></li><li> <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic types</a></li></ul></dd></dl><p>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>, and <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> qualifiers (where allowed by the qualifier's semantics).</p><h4> Type groups</h4><ul><li> <i>object types</i>: all types that aren't function types</li><li> <i>character types</i>: <code>char</code>, <code>signed char</code>, <code>unsigned char</code></li><li> <i>integer types</i>: <code>char</code>, signed integer types, unsigned integer types, enumerated types</li><li> <i>real types</i>: integer types and real floating types </li><li> <a href="http://en.cppreference.com/w/c/language/arithmetic_types" title="c/language/arithmetic types">arithmetic types</a>: integer types and floating types</li><li> <i>scalar types</i>: arithmetic types and pointer types</li><li> <i>aggregate types</i>: array types and structure types</li><li> <i>derived declarator types</i>: array types, function types, and pointer types </li></ul><span class="prog__sub"> Compatible types</span><p>In a C program, the declarations referring to the same object or function in <i>different translation units</i> do not have to use the same type. They only have to use sufficiently similar types, formally known as <i>compatible types</i>. Same applies to function calls and lvalue accesses; argument types must be <i>compatible</i> with parameter types and lvalue expression type must be <i>compatible</i> with the object type that is accessed.</p><p>The types <code>T</code> and <code>U</code> are compatible, if</p><ul><li> they are the same type (same name or aliases introduced by a <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>)</li><li> they are identically cvr-qualified versions of compatible unqualified types</li><li> they are pointer types and are pointing to compatible types</li><li> they are array types, and</li></ul><dl><dd><ul><li> their element types are compatible, and</li><li> if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. VLA is compatible with any array of compatible element type. (since C99)</li></ul></dd></dl><ul><li> they are both structure/union/enumeration types, and</li></ul><dl><dd><ul><li>(C99)if one is declared with a tag, the other must also be declared with the same tag.</li><li> if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names.</li><li> additionally, if they are enumerations, corresponding members must also have the same values.</li><li> additionally, if they are structures or unions,</li></ul><dl><dd><ul><li> Corresponding members must be declared in the same order (structures only)</li><li> Corresponding bit fields must have the same widths.</li></ul></dd></dl></dd></dl><ul><li> one is an enumerated type and the other is that enumeration's underlying type</li><li> they are function types, and</li></ul><dl><dd><ul><li> their return types are compatible</li><li> they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, the corresponding parameters have compatible types</li><li> one is an old-style (parameter-less) definition, the other has a parameter list, the parameter list does not use an ellipsis and each parameter is compatible (after function parameter type adjustment) with the corresponding old-style parameter after default argument promotions</li><li> one is an old-style (parameter-less) declaration, the other has a parameter list, the parameter list does not use an ellipsis, and all parameters (after function parameter type adjustment) are unaffected by default argument promotions</li></ul></dd></dl><p>The type <code>char</code> is not compatible with <code>signed char</code> and not compatible with <code>unsigned char</code>.</p><p>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.<br></p><div><div><pre><code>// Translation Unit 1struct S {int a;};extern struct S *x;  // compatible with TU2's x, but not with TU3's x// Translation Unit 2struct S;extern struct S *x; // compatible with both x's// Translation Unit 3struct S {float a;};extern struct S *x; // compatible with TU2's x, but not with TU1's x\xc2\xa0// the behavior is undefined</code></pre></div></div><div><div><pre><code>// Translation Unit 1#include &lt;stdio.h&gt;struct s {int i;}; // compatible with TU3's s, but not TU2'sextern struct s x = {0}; // compatible with TU3's xextern void f(void); // compatible with TU2's fint main(){   f();   return x.i;}// Translation Unit 2struct s {float f;}; // compatible with TU4's s, but not TU1's sextern struct s y = {3.14}; // compatible with TU4's yvoid f() // compatible with TU1's f{   return;}// Translation Unit 3struct s {int i;}; // compatible with TU1's s, but not TU2's sextern struct s x; // compatible with TU1's x// Translation Unit 4struct s {float f;}; // compatible with TU2's s, but not TU1's sextern struct s y; // compatible iwth TU2's y\xc2\xa0// the behavior is well-defined: only multiple declarations// of objects and functions must have compatible types, not the types themselves</code></pre></div></div><p>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.<br></p><span class="prog__sub"> Composite types</span><table><tr><td></td><td>This section is incomplete </td></tr></table><span class="prog__sub"> Incomplete types</span><p>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.<br></p><p>The following types are incomplete:<br></p><ul><li> the type <code>void</code>. This type cannot be completed.</li><li> array type of unknown size. It can be completed by a later declaration that specifies the size.</li><li> structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope.</li></ul><span class="prog__sub"> Type names</span><p>A type may have to be named in context other than the <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declaration</a>. In these situations, <i>type name</i> is used, which is, grammatically, exactly the same as a list of <i>type-specifiers</i> and <i>type-qualifiers</i>, followed by the <i>declarator</i> (see <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">declarations</a>) as would be used to declare a single object or function of this type, except that the identifier is omitted:</p><div><div><pre><code>int n; // declaration of an intsizeof(int); // use of type name\xc2\xa0int *a[3]; // declaration of an array of 3 pointers to intsizeof(int *[3]); // use of type name\xc2\xa0int (*p)[3]; // declaration of a pointer to array of 3 intsizeof(int (*)[3]); // use of type name\xc2\xa0int (*a)[*] // declaration of pointer to VLA (in a function parameter)sizeof(int (*)[*]) // use of type name (in a function parameter)\xc2\xa0int *f(void); // declaration of functionsizeof(int *(void)); // use of type name\xc2\xa0int (*p)(void); // declaration of pointer to functionsizeof(int (*)(void)); // use of type name\xc2\xa0int (*const a[])(unsigned int, ...) = {0}; // array of pointers to functionssizeof(int (*const [])(unsigned int, ...)); // use of type name</code></pre></div></div><p>Except the redundant parentheses around the identifier are meaningful in a type-name and represent "function with no parameter specification":<br></p><div><div><pre><code>int (n); // declares n of type intsizeof(int ()); // uses type "function returning int"</code></pre></div></div><p>Type names are used in the following situations:<br></p><ul><li> <a href="http://en.cppreference.com/w/c/language/cast" title="c/language/cast">cast</a></li><li> <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a></li></ul><table><tr><td><ul><li> <a href="http://en.cppreference.com/w/c/language/compound_literal" title="c/language/compound literal">compound literal</a></li></ul></td><td>(since C99)</td></tr><tr><td><ul><li> <a href="http://en.cppreference.com/w/c/language/generic" title="c/language/generic">generic selection</a></li><li> <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">alignof</a></li><li> <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/alignas" title="c/language/alignas">alignas</a></li><li> <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">_Atomic</a> (when used as a type specifier)</li></ul></td><td>(since C11)</td></tr></table><p><br/>A type name may introduce a new type: </p><div><div><pre><code>void* p = (void*)(struct X {int i;} *)0;// type name "struct X {int i;}*" used in the cast expression// introduces the new type "struct X"struct X x = {1}; // struct X is now in scope</code></pre></div></div></section>	http://en.cppreference.com/w/c/language/types
Union declaration	A										<section class="prog__container"><p>A union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence). The value of at most one of the members can be stored in a union at any one time.<br></p><p>The <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">type specifier</a> for a union is identical to the <a href="http://en.cppreference.com/w/c/language/struct" title="c/language/struct"> <code>struct</code></a> type specifier except for the keyword used:</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>union</code> name(optional) <code>{ </code> struct-declaration-list <code>} </code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>union</code> name</td><td> (2)</td><td></td></tr><tr><td></td></tr></table><table><tr><td> name</td><td> -</td><td>  the name of the union that's being defined</td></tr><tr><td> struct-declaration-list</td><td> -</td><td>  any number of variable declarations, bit field declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed.</td></tr></table><span class="prog__sub"> Explanation</span><p>The union is only as big as necessary to hold its largest member (additional unnamed trailing padding may also be added). The other members are allocated in the same bytes as part of that largest member. <br></p><p>A pointer to a union can be cast to a pointer to each of its members (if a union has bit field members, the pointer to a union can be cast to the pointer to the bit field's underlying type). Likewise, a pointer to any member of a union can be cast to a pointer to the enclosing union. <br></p><p>If the member used to access the contents of a union is not the same as the member last used to store a value, the object representation of the value that was stored is reinterpreted as an object representation of the new type (this is known as <i>type punning</i>). If the size of the new type is larger than the size of the last-written type, the contents of the excess bytes are unspecified (and may be a trap representation) </p><table><tr><td><p>Similar to struct, an unnamed member of a union whose type is a union without name is known as <i>anonymous union</i>. Every member of an anonymous union is considered to be a member of the enclosing struct or union. This applies recursively if the enclosing struct or union is also anonymous.</p><div><div><pre><code>struct v {   union { // anonymous union      struct { int i, j; }; // anonymous structure      struct { long k, l; } w;   };   int m;} v1;\xc2\xa0v1.i = 2;   // validv1.k = 3;   // invalid: inner structure is not anonymousv1.w.k = 5; // valid</code></pre></div></div><p>Similar to struct, the behavior of the program is undefined if union is defined without any named members (including those obtained via anonymous nested structs or unions).<br></p></td><td>(since C11)</td></tr></table><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/c/keyword/union" title="c/keyword/union"><tt>union</tt></a></p></section>	http://en.cppreference.com/w/c/language/union
Value categories	A										<section class="prog__container"><p>Each <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a <a href="http://en.cppreference.com/w/c/language/type#Type" title="c/language/type">type</a> and a <a href="http://en.cppreference.com/w/c/language/expressions#General" title="c/language/expressions">value category</a>.</p><p>Every expression belongs to one of three value categories: lvalue, non-lvalue object (rvalue), and function designator.<br></p><span class="prog__sub"> Lvalue expressions</span><p>Lvalue expression is any expression with <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">object type</a> other than the type <code>void</code>, which potentially designates an <a href="http://en.cppreference.com/w/c/language/object" title="c/language/object">object</a> (the behavior is undefined if an lvalue does not actually designate an object when it is evaluated). In other words, lvalue expression evaluates to the <i>object identity</i>. The name of this value category ("left value") is historic and reflects the use of lvalue expressions as the left-hand operand of the assignment operator in the CPL programming language.</p><p>Lvalue expressions can be used in the following <i>lvalue contexts</i>:</p><ul><li> as the operand of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">address-of operator</a> (except if the lvalue designates a <a href="http://en.cppreference.com/w/c/language/bit_field" title="c/language/bit field">bit field</a> or was declared <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">register</a>).</li><li> as the operand of the pre/post <a href="http://en.cppreference.com/w/c/language/operator_incdec" title="c/language/operator incdec">increment and decrement operators</a>.</li><li> as the left-hand operand of the <a href="http://en.cppreference.com/w/c/language/operator_member_access" title="c/language/operator member access">member access</a> (dot) operator.</li><li> as the left-hand operand of the <a href="http://en.cppreference.com/w/c/language/operator_assignment" title="c/language/operator assignment">assignment and compound assignment</a> operators.</li></ul><p>If an lvalue expression is used in any context other than <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a>, <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">_Alignof</a>, or the operators listed above, non-array lvalues of any complete type undergo <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">lvalue conversion</a>, which models the memory load of the value of the object from its location. Similarly, array lvalues undergo <a href="http://en.cppreference.com/w/c/language/conversion" title="c/language/conversion">array-to-pointer conversion</a> when used in any context other than <code>sizeof</code>, <code>_Alignof</code>, address-of operator, or array initialization from a string literal.</p><p>The semantics of <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>/<a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a>/<a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a>-qualifiers and <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a> types apply to lvalues only (lvalue conversion strips the qualifiers and removes atomicity).</p><p>The following expressions are lvalues:<br></p><ul><li> identifiers, including function parameters, provided they were declared as designating objects (and not functions)</li><li> <a href="http://en.cppreference.com/w/c/language/string_literal" title="c/language/string literal">string literals</a></li><li> (C99) <a href="http://en.cppreference.com/w/c/language/compound_literal" title="c/language/compound literal">compound literals</a></li><li> parenthesized expression if the unparenthesized expression is an lvalue</li><li> the result of a member access (dot) operator if its left-hand argument is lvalue</li><li> the result of a member access through pointer <code>-&gt;</code> operator</li><li> the result of the indirection (unary <code>*</code>) operator applied to a pointer to object</li><li> the result of the subscription operator (<code>[]</code>)</li></ul><h4> Modifiable lvalue expressions</h4><p>A <i>modifiable lvalue</i> is any lvalue expression of complete, non-array type which is not <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>-qualified, and, if it's a struct/union, has no members that are <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>-qualified, recursively.</p><p>Only modifiable lvalue expressions may be used as arguments to increment/decrement, and as left-hand arguments of assignment and compound assignment operators.<br></p><span class="prog__sub"> Non-lvalue object expressions</span><p>Colloquially known as <i>rvalues</i>, non-lvalue object expressions are the expressions of object types that do not designate objects, but rather values that have no object identity or storage location. The address of a non-lvalue object expression cannot be taken.</p><p>The following expressions are non-lvalue object expressions:<br></p><ul><li> integer, character, and floating constants</li><li> all operators not specified to return lvalues, including</li></ul><dl><dd><ul><li> any function call expression</li><li> any cast expression (note that compound literals, which look similar, are lvalues)</li><li> member access operator (dot) applied to a non-lvalue structure/union, <code>f().x</code>, <code>(x,s1).a</code>, <code>s1=s2).m</code></li><li> all arithmetic, relational, logical, and bitwise operators</li><li> increment and decrement operators (note: pre- forms are lvalues in C++)</li><li> assignment and compound assignment operators (note: they are lvalues in C++)</li><li> the conditional operator (note: may be lvalue in C++)</li><li> the comma operator (note: may be lvalue in C++)</li><li> the address-of operator, even it if is neutralized by being applied to the result of the unary <code>*</code> operator</li></ul></dd></dl><p>As a special case, expressions of type <code>void</code> are assumed to be non-lvalue object expressions that yield a value which has no representation and requires no storage.</p><p>Note that a struct/union rvalue that has a member (possibly nested) of array type does in fact designate an object with <a href="http://en.cppreference.com/w/c/language/lifetime" title="c/language/lifetime">temporary lifetime</a>. This object can be accessed through lvalue expressions that form by indexing the array member or by indirection through the pointer obtained by array-to-pointer conversion of the array member.</p><span class="prog__sub"> Function designator expression</span><p>A function designator (the identifier introduced by a <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declaration</a>) is an expression of function type. When used in any context other than the address-of operator, <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof">sizeof</a>, and <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">_Alignof</a> (the last two generate compile errors when applied to functions), the function designator is always converted to a non-lvalue pointer to function. Note that the function-call operator is defined for pointers to functions and not for function designators themselves.</p></section>	http://en.cppreference.com/w/c/language/value_category
Variadic arguments	A										<section class="prog__container"><p>Variadic functions are functions that may be called with different number of arguments. <br></p><p>Only new-style (prototyped)  <a href="http://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">function declarations</a> may be variadic. This is indicated by the parameter of the form <code>...</code> which must appear last in the parameter list and must follow at least one named parameter.</p><div><div><pre><code>//New-style declarationint printx(const char* fmt, ...); // function declared this wayprintx("hello world"); // may be called with oneprintx("a=%d b=%d", a, b); // or more arguments\xc2\xa0// int printy(..., const char* fmt); // Error: ... must be the last// int printz(...); // Error: ... must follow at least one named parameter</code></pre></div></div><p>At the <a href="http://en.cppreference.com/w/c/language/operator_other#Function_call" title="c/language/operator other">function call</a>, each argument that is a part of the variable argument list undergoes special implicit conversions known as <a href="http://en.cppreference.com/w/c/language/conversion#Default_argument_promotions" title="c/language/conversion">default argument promotions</a>.</p><p>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the <a href="http://en.cppreference.com/w/c/variadic" title="c/variadic">&lt;stdarg.h&gt; library facilities</a>:</p><table><tr><td> <div>Defined in header <code>&lt;stdarg.h&gt;</code> </div></td></tr><tr><td> <div><div><a href="http://en.cppreference.com/w/c/variadic/va_start" title="c/variadic/va start"> va_start</a></div></div></td><td>   enables access to variadic function arguments <br/> (function macro) </td></tr><tr><td> <div><div><a href="http://en.cppreference.com/w/c/variadic/va_arg" title="c/variadic/va arg"> va_arg</a></div></div></td><td>   accesses the next variadic function argument <br/> (function macro) </td></tr><tr><td> <div><div><a href="http://en.cppreference.com/w/c/variadic/va_copy" title="c/variadic/va copy"> va_copy</a></div><div>(C99)</div></div></td><td>   makes a copy of the variadic function arguments  <br/> (function macro) </td></tr><tr><td> <div><div><a href="http://en.cppreference.com/w/c/variadic/va_end" title="c/variadic/va end"> va_end</a></div></div></td><td>   ends traversal of the variadic function arguments <br/> (function macro) </td></tr><tr><td> <div><div><a href="http://en.cppreference.com/w/c/variadic/va_list" title="c/variadic/va list"> va_list</a></div></div></td><td>   holds the information needed by va_start, va_arg, va_end, and va_copy <br/> (typedef) </td></tr></table></section>	http://en.cppreference.com/w/c/language/variadic
volatile type qualifier	A										<section class="prog__container"><p>Each individual type in the C <a href="http://en.cppreference.com/w/c/language/type" title="c/language/type">type system</a> has several <i>qualified</i> versions of that type, corresponding to one, two, or all three of the <a href="http://en.cppreference.com/w/c/language/const" title="c/language/const">const</a>, <i>volatile</i>, and, for pointers to object types, <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict">restrict</a> qualifiers. This page describes the effects of the <i>volatile</i> qualifier.</p><p>Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a <a href="http://en.cppreference.com/w/c/language/eval_order" title="c/language/eval order">sequence point</a> from the volatile access.</p><p>A cast of a non-volatile value to a volatile type has no effect. To access a non-volatile object using volatile semantics, its address must be cast to a pointer-to-volatile and then the access must be made through that pointer.<br></p><p>Any attempt to read or write to an object whose type is volatile-qualified through a non-volatile lvalue results in undefined behavior:<br></p><div><div><pre><code>volatile int n = 1; // object of volatile-qualified typeint* p = (int*)&amp;n;int val = *p; // undefined behavior</code></pre></div></div><p>A member of a volatile-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the <code>.</code> operator or the <code>-&gt;</code> operator):</p><div><div><pre><code>struct s { int i; const int ci; } s;// the type of s.i is int, the type of s.ci is const intvolatile struct s vs;// the types of vs.i and vs.ci are volatile int and const volatile int</code></pre></div></div><p>If an array type is declared with the volatile type qualifier (through the use of <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>), the array type is not volatile-qualified, but its element type is. If a function type is declared with the volatile type qualified (through the use of <a href="http://en.cppreference.com/w/c/language/typedef" title="c/language/typedef">typedef</a>), the behavior is undefined.</p><div><div><pre><code>typedef int A[2][3];volatile A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of volatile intint* pi = a[0]; // Error: a[0] has type volatile int*</code></pre></div></div><table><tr><td><p>In a function declaration, the keyword <code>volatile</code> may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.</p><p>The following two declarations declare the same function:<br></p><div><div><pre><code>void f(double x[volatile], const double y[volatile]);void f(double * volatile x, const double * volatile y);</code></pre></div></div></td><td>(since C99)</td></tr></table><p>A pointer to a non-volatile type can be implicitly converted to a pointer to the volatile-qualified version of the same or <a class="mw-redirect" href="http://en.cppreference.com/w/c/language/compatible_type" title="c/language/compatible type">compatible type</a>. The reverse conversion can be performed with a cast expression.</p><div><div><pre><code>int* p = 0;volatile int* vp = p; // OK: adds qualifiers (int to volatile int)p = vp; // Error: discards qualifiers (volatile int to int)p = (int*)vp; // OK: cast</code></pre></div></div><p>Note that pointer to pointer to <code>T</code> is not convertible to pointer to pointer to <code>volatile T</code>; for two types to be compatible, their qualifications must be identical:</p><div><div><pre><code>char *p = 0;volatile char **vpp = &amp;p; // Error: char* and volatile char* are not compatible typeschar * volatile *pvp = &amp;p; // OK, adds qualifiers (char* to char*volatile)</code></pre></div></div><span class="prog__sub"> Uses of volatile</span><div>1) <a href="http://en.cppreference.com/w/c/language/static_storage_duration" title="c/language/static storage duration">static</a> <code>volatile</code> objects model memory-mapped I/O ports, and <code>static</code> <code>const</code> <code>volatile</code> objects model memory-mapped input ports, such as a real-time clock:<div><div><pre><code>volatile short *ttyport = (volatile short*)TTYPORT_ADDR;for(int i = 0; i &lt; N; ++i)    *ttyport = a[i]; // *ttyport is an lvalue of type volatile short</code></pre></div></div></div><div>2) <code>static</code> <code>volatile</code> objects of type <a href="http://en.cppreference.com/w/c/program/sig_atomic_t" title="c/program/sig atomic t">sig_atomic_t</a> are used for communication with <a href="http://en.cppreference.com/w/c/program/signal" title="c/program/signal">signal</a> handlers.</div><div>3) <code>volatile</code> variables that are local to a function that contains an invocation of the <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a> macro are the only local variables guaranteed to retain their values after <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a> returns.</div><div>4) In addition, volatile variables can be used to disable certain forms of optimization, e.g. to disable dead store elimination or constant folding for microbenchmarks.</div><p>Note that volatile variables are not suitable for communication between threads; they do not offer atomicity, synchronization, or memory ordering. A read from a volatile variable that is modified by another thread without synchronization or concurrent modification from two unsynchronized threads is undefined behavior due to a data race.<br></p><span class="prog__sub"> Keywords</span><p><a href="http://en.cppreference.com/w/cpp/keyword/volatile" title="cpp/keyword/volatile"><tt>volatile</tt></a></p><span class="prog__sub"> Example</span><div><p> demonstrates the use of volatile to disable optimizations<br> </p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;time.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/chrono/clock_t">clock_t</a> t = <a href="http://en.cppreference.com/w/c/chrono/clock">clock</a>();    double d;    for (int n=0; n&lt;10000; ++n)       for (int m=0; m&lt;10000; ++m)           d += d*n*m; // reads and writes to a non-volatile     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Modified a non-volatile variable 100m times. "           "Time used:\xc2\xa0%.2f seconds\n",           (double)(<a href="http://en.cppreference.com/w/c/chrono/clock">clock</a>() - t)/<a href="http://en.cppreference.com/w/c/chrono/CLOCKS_PER_SEC">CLOCKS_PER_SEC</a>);\xc2\xa0    t = <a href="http://en.cppreference.com/w/c/chrono/clock">clock</a>();    volatile double vd;    for (int n=0; n&lt;10000; ++n)       for (int m=0; m&lt;10000; ++m)           vd += vd*n*m; // reads and writes to a volatile     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Modified a volatile variable 100m times. "           "Time used:\xc2\xa0%.2f seconds\n",           (double)(<a href="http://en.cppreference.com/w/c/chrono/clock">clock</a>() - t)/<a href="http://en.cppreference.com/w/c/chrono/CLOCKS_PER_SEC">CLOCKS_PER_SEC</a>);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>Modified a non-volatile variable 100m times. Time used: 0.00 seconds<br>Modified a volatile variable 100m times. Time used: 0.79 seconds</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/language/volatile
while loop	A										<section class="prog__container"><p>Executes a statement repeatedly, until the value of expression becomes equal to zero. The test takes place before each iteration.</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>while (</code> expression <code>)</code> statement</td><td></td><td></td></tr><tr><td></td></tr></table><table><tr><td> expression</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/expressions" title="c/language/expressions">expression</a> of <a href="http://en.cppreference.com/w/c/language/type#Type_groups" title="c/language/type">scalar type</a>. This expression is evaluated before each iteration, and if it compares equal to zero, the loop is exited.</td></tr><tr><td> statement</td><td> -</td><td>  any <a href="http://en.cppreference.com/w/c/language/statements" title="c/language/statements">statement</a>, typically a compound statement, which serves as the body of the loop</td></tr></table><span class="prog__sub"> Explanation</span><p>A <code>while</code> statement causes the statement (also called <i>the loop body</i>) to be executed repeatedly until the expression (also called <i>controlling expression</i>) compares equal to zero. The repetition occurs regardless of whether the loop body is entered normally or by a <a href="http://en.cppreference.com/w/c/language/goto" title="c/language/goto">goto</a> into the middle of statement.</p><p>The evaluation of expression takes place before each execution of statement (unless entered by a goto). If the controlling expression needs to be evaluated after the loop body, the <a href="http://en.cppreference.com/w/c/language/do" title="c/language/do">do-while loop</a> may be used.</p><p>If the execution of the loop needs to be terminated at some point, <a href="http://en.cppreference.com/w/c/language/break" title="c/language/break"> break statement</a> can be used as a terminating statement. </p><p>If the execution of the loop needs to be continued at the end of the loop body, <a href="http://en.cppreference.com/w/c/language/continue" title="c/language/continue"> continue statement</a> can be used as a shortcut.</p><p>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; <code>while(true)</code> is always an endless loop.</p><table><tr><td><p>As with all other selection and iteration statements, the while statement establishes <a href="http://en.cppreference.com/w/c/language/scope" title="c/language/scope">block scope</a>: any identifier introduced in the expression goes out of scope after the statement.</p></td><td>(since C99)</td></tr></table></section>	http://en.cppreference.com/w/c/language/while
A list of open source C libraries	A										<section class="prog__container"><div><p>The objective of this page is to build a comprehensible list of open source C libraries, so that when one needs an implementation of particular functionality, one need not waste time searching on Google.<br></p><p>If you know a library that might be useful to others, please add a link to it here. There are no restrictions on what can be included except that it must be possible to download the source of the library.<br></p><p>The page is provided 'as is' - with the hope of being useful, but without any warranties. Outdated, misleading or wrong links might appear here. If you've noticed one of these, it would be great if you fixed the error.<br></p></div><h2> Operating system</h2><dl><dt> Access control</dt></dl><ul><li><a class="external text" href="http://savannah.nongnu.org/projects/acl/" rel="nofollow">acl</a></li><li><a class="external text" href="http://apparmor.net/" rel="nofollow">apparmor</a></li></ul><dl><dt> Extended attributes</dt></dl><ul><li><a class="external text" href="http://savannah.nongnu.org/projects/attr/" rel="nofollow">attr</a></li></ul><h2> Graphic user interface</h2><ul><li><a class="external text" href="http://www.tecgraf.puc-rio.br/iup/" rel="nofollow">IUP</a></li><li><a class="external text" href="http://tinyfiledialogs.sourceforge.net" rel="nofollow">tiny file dialogs</a>\xc2\xa0-\xc2\xa0 a single C cross-platform file (no init, no main loop, 6 modal function calls)</li></ul><h2> Gtk+ widgets</h2><ul><li><a class="external text" href="http://www.gtk.org/" rel="nofollow">gtk+</a></li><li><a class="external text" href="http://www.gnome.org/projects/evolution/" rel="nofollow">gtkhtml</a></li><li><a class="external text" href="https://launchpad.net/appmenu-gtk" rel="nofollow">appmenu-gtk</a></li><li><a class="external text" href="http://live.gnome.org/Ghex" rel="nofollow">ghex</a></li><li><a class="external text" href="http://gtkspell.sourceforge.net/" rel="nofollow">gtkspell</a></li><li><a class="external text" href="http://projects.gnome.org/gtksourceview/" rel="nofollow">gtksourceview</a></li><li><a class="external text" href="https://launchpad.net/gtkhotkey" rel="nofollow">gtkhotkey</a></li><li><a class="external text" href="http://live.gnome.org/Gucharmap" rel="nofollow">gucharmap</a></li><li><a class="external text" href="http://live.gnome.org/GooCanvas" rel="nofollow">goocanvas</a></li></ul><h2> Audio</h2><dl><dt> Codecs</dt></dl><ul><li><a class="external text" href="http://aften.sourceforge.net/" rel="nofollow">aften</a></li><li><a class="external text" href="http://www.audiocoding.com/" rel="nofollow">faad2</a></li><li><a class="external text" href="http://www.wavpack.com" rel="nofollow">wavpack</a></li></ul><dl><dt> Infrastructure</dt></dl><ul><li><a class="external text" href="http://www.alsa-project.org/" rel="nofollow">alsa-lib</a></li></ul><dl><dt> CD</dt></dl><ul><li><a class="external text" href="http://www.xiph.org/paranoia/" rel="nofollow">cdparanoia</a></li></ul><dl><dt>Speech synthesis</dt></dl><ul><li><a class="external text" href="http://espeak.sourceforge.net/" rel="nofollow">espeak</a>--</li><li><a class="external text" href="http://www.speech.cs.cmu.edu/flite" rel="nofollow">flite</a> --</li></ul><h2> Video</h2><dl><dt> Codecs</dt></dl><ul><li><a class="external text" href="https://slackbuilds.org/repository/14.1/multimedia/schroedinger/" rel="nofollow">schroedinger</a>--</li><li><a class="external text" href="http://linuxtv.org/downloads/v4l-utils/" rel="nofollow">video4linux</a>--</li></ul><h2> Files</h2><ul><li><a class="external text" href="http://spruce.sourceforge.net/gmime/" rel="nofollow">gmime</a></li><li><a class="external text" href="http://matteodelseppia.github.io/libcaos/" rel="nofollow">caos</a></li></ul><h2> Maths</h2><ul><li><a class="external text" href="http://www.gnu.org/software/gsl" rel="nofollow">gsl</a></li></ul><dl><dt> Integer Multi-Dimensional Interpolation</dt></dl><ul><li><a class="external text" href="http://www.argyllcms.com/" rel="nofollow">argyll</a></li></ul><dl><dt> Linear algebra</dt></dl><ul><li><a class="external text" href="http://math-atlas.sourceforge.net/" rel="nofollow">atlas</a></li><li><a class="external text" href="http://www.netlib.org/blas/" rel="nofollow">blas</a></li><li><a class="external text" href="http://eigen.tuxfamily.org/index.php" rel="nofollow">eigen</a></li></ul><dl><dt> Finance</dt></dl><ul><li><a class="external text" href="http://sourceforge.net/projects/ta-lib/" rel="nofollow">ta-lib</a></li></ul><dl><dt> FFT</dt></dl><ul><li><a class="external text" href="http://fftw.org" rel="nofollow">fftw3</a></li></ul><dl><dt> Multiprecision</dt></dl><ul><li><a class="external text" href="http://gmplib.org/" rel="nofollow">gmp</a></li></ul><dl><dt> Signal Processing</dt></dl><ul><li><a class="external text" href="http://liquidsdr.org/" rel="nofollow">liquid-dsp</a></li><li><a class="external text" href="http://www.omg.org/hot-topics/vsipl.htm/" rel="nofollow">vsipl</a></li><li><a class="external text" href="http://www.omg.org/hot-topics/vsipl.htm/" rel="nofollow">vsipl++</a></li></ul><h2> Graphics</h2><ul><li><a class="external text" href="http://cairographics.org/" rel="nofollow">cairo</a></li><li><a class="external text" href="http://gegl.org/babl/" rel="nofollow">babl</a></li><li><a class="external text" href="http://www.libsigil.com/" rel="nofollow">SIGIL (Sound, Input, and Graphics Integration Library)</a>\xc2\xa0-\xc2\xa0 extremely easy-to-use, cross-platform library for 2D graphics, input, and audio</li></ul><h2> Interprocess</h2><ul><li><a class="external text" href="http://www.freedesktop.org/wiki/Software/DBusBindings" rel="nofollow">dbus-glib</a></li><li><a class="external text" href="http://dbus.freedesktop.org/" rel="nofollow">dbus</a></li><li><a class="external text" href="https://launchpad.net/dee" rel="nofollow">dee</a></li></ul><h2> Databases</h2><ul><li><a class="external text" href="http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/overview/index.html" rel="nofollow">berkeley db</a></li><li><a class="external text" href="http://symas.com/mdb/" rel="nofollow">lmdb</a></li></ul><h2> Communications</h2><ul><li><a class="external text" href="http://curl.haxx.se/libcurl/" rel="nofollow">libcurl</a></li><li><a class="external text" href="http://zeromq.org/" rel="nofollow">zeromq</a></li><li><a class="external text" href="http://cpp-netlib.org/" rel="nofollow">cpp-netlib</a></li></ul><h2> Compression</h2><ul><li><a class="external text" href="http://www.bzip.org/" rel="nofollow">bzip2</a></li><li><a class="external text" href="http://zlib.net/" rel="nofollow">zlib</a></li></ul><h2> libc</h2><ul><li><a class="external text" href="http://bstring.sourceforge.net/" rel="nofollow">bstrlib</a></li><li><a class="external text" href="http://www.eglibc.org" rel="nofollow">eglibc</a></li></ul><h2> XML</h2><ul><li><a class="external text" href="http://expat.sourceforge.net" rel="nofollow">expat</a></li></ul><h2> Javascript</h2><ul><li><a class="external text" href="http://live.gnome.org/Gjs" rel="nofollow">gjs</a></li></ul><h2> Metrics</h2><ul><li><a class="external text" href="http://github.com/martinsos/edlib" rel="nofollow">edlib</a></li></ul></section>	http://en.cppreference.com/w/c/links/libs
LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;locale.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define LC_ALL \xc2\xa0 \xc2\xa0 \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define LC_COLLATE \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define LC_CTYPE \xc2\xa0 \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define LC_MONETARY /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define LC_NUMERIC \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define LC_TIME \xc2\xa0 \xc2\xa0 /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of <a href="http://en.cppreference.com/w/c/locale/setlocale" title="c/locale/setlocale">setlocale</a>.</p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>LC_ALL</code></td><td>  selects the entire C locale</td></tr><tr><td> <code>LC_COLLATE</code></td><td>  selects the collation category of the C locale</td></tr><tr><td> <code>LC_CTYPE</code></td><td>  selects the character classification category of the C locale</td></tr><tr><td> <code>LC_MONETARY</code></td><td>  selects the monetary formatting category of the C locale</td></tr><tr><td> <code>LC_NUMERIC</code></td><td>  selects the numeric formatting category of the C locale</td></tr><tr><td> <code>LC_TIME</code></td><td>  selects the time formatting category of the C locale</td></tr></table><p>Additional macro constants, with names that begin with <code>LC_</code> followed by at least one uppercase letter, may be defined in <code>locale.h</code>. For example, the POSIX specification requires LC_MESSAGES (which controls, among other things, <a href="http://en.cppreference.com/w/c/io/perror" title="c/io/perror">perror</a> and <a href="http://en.cppreference.com/w/c/string/byte/strerror" title="c/string/byte/strerror">strerror</a>), and the GNU C library additionally defines LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT, and LC_IDENTIFICATION.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;time.h&gt;#include &lt;wchar.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(LC_ALL, "en_US.UTF-8"); // the C locale will be the UTF-8 enabled English    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(LC_NUMERIC, "de_DE");   // decimal dot will be German    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(LC_TIME, "ja_JP");      // date/time formatting will be Japanese    wchar_t str[100];    <a href="http://en.cppreference.com/w/c/chrono/time_t">time_t</a> t = <a href="http://en.cppreference.com/w/c/chrono/time">time</a>(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>);    <a href="http://en.cppreference.com/w/c/chrono/wcsftime">wcsftime</a>(str, 100, L"%A\xc2\xa0%c", <a href="http://en.cppreference.com/w/c/chrono/localtime">localtime</a>(&amp;t));    <a href="http://en.cppreference.com/w/c/io/fwprintf">wprintf</a>(L"Number:\xc2\xa0%.2f\nDate:\xc2\xa0%Ls\n", 3.14, str);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Number: 3,14<br>Date: \xe6\x9c\x88\xe6\x9b\x9c\xe6\x97\xa5 2011\xe5\xb9\xb412\xe6\x9c\x8819\xe6\x97\xa5 18\xe6\x99\x8204\xe5\x88\x8640\xe7\xa7\x92</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/locale/LC_categories
lconv	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;locale.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>struct lconv;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The struct <code>lconv</code> contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with <a href="http://en.cppreference.com/w/c/locale/localeconv" title="c/locale/localeconv">localeconv</a>. The members of <code>lconv</code> are values of type <code>char</code> and of type <code>char*</code>. Each <code>char*</code> member except <code>decimal_point</code> may be pointing at a null character (that is, at an empty C-string). The members of type <code>char</code> are all non-negative numbers, any of which may be <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">CHAR_MAX</a> if the corresponding value is not available in the current C locale.</p><span class="prog__sub"> Member objects</span><h4> Non-monetary numeric formatting parameters</h4><table><tr><td> <div><div>char* decimal_point</div></div></td><td>   the character used as the decimal point <br/> (public member object)</td></tr><tr><td> <div><div>char* thousands_sep</div></div></td><td>   the character used to separate groups of digits before the decimal point <br/> (public member object)</td></tr><tr><td> <div><div>char* grouping</div></div></td><td>   a string whose elements indicate the sizes of digit groups <br/> (public member object)</td></tr></table><h4> Monetary numeric formatting parameters</h4><table><tr><td> <div><div>char* mon_decimal_point</div></div></td><td>   the character used as the decimal point <br/> (public member object)</td></tr><tr><td> <div><div>char* mon_thousands_sep</div></div></td><td>   the character used to separate groups of digits before the decimal point <br/> (public member object)</td></tr><tr><td> <div><div>char* mon_grouping</div></div></td><td>   a string whose elements indicate the sizes of digit groups <br/> (public member object)</td></tr><tr><td> <div><div>char* positive_sign</div></div></td><td>   a string used to indicate non-negative monetary quantity <br/> (public member object)</td></tr><tr><td> <div><div>char* negative_sign</div></div></td><td>   a string used to indicate negative monetary quantity <br/> (public member object)</td></tr></table><h4> Local monetary numeric formatting parameters</h4><table><tr><td> <div><div>char* currency_symbol</div></div></td><td>   the symbol used for currency in the current C locale <br/> (public member object)</td></tr><tr><td> <div><div>char frac_digits</div></div></td><td>   the number of digits after the decimal point to display in a monetary quantity <br/> (public member object)</td></tr><tr><td> <div><div>char p_cs_precedes</div></div></td><td> <code>1</code> if currency_symbol is placed before non-negative value, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if after <br/> (public member object)</td></tr><tr><td> <div><div>char n_cs_precedes</div></div></td><td> <code>1</code> if currency_symbol is placed before negative value, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if after <br/> (public member object)</td></tr><tr><td> <div><div>char p_sep_by_space</div></div></td><td>   indicates the separation of <code>currency_symbol</code>, <code>positive_sign</code>, and the non-negative monetary value <br/> (public member object)</td></tr><tr><td> <div><div>char n_sep_by_space</div></div></td><td>   indicates the separation of <code>currency_symbol</code>, <code>negative_sign</code>, and the negative monetary value <br/> (public member object)</td></tr><tr><td> <div><div>char p_sign_posn</div></div></td><td>   indicates the position of <code>positive_sign</code> in a non-negative monetary value <br/> (public member object)</td></tr><tr><td> <div><div>char n_sign_posn</div></div></td><td>   indicates the position of <code>negative_sign</code> in a negative monetary value <br/> (public member object)</td></tr></table><h4> International monetary numeric formatting parameters</h4><table><tr><td> <div><div>char* int_curr_symbol</div></div></td><td>   the string used as international currency name in the current C locale  <br/> (public member object)</td></tr><tr><td> <div><div>char int_frac_digits</div></div></td><td>   the number of digits after the decimal point to display in an international monetary quantity <br/> (public member object)</td></tr><tr><td> <div><div>char int_p_cs_precedes</div><div>(C99)</div></div></td><td> <code>1</code> if currency_symbol is placed before non-negative international monetary value, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if after <br/> (public member object)</td></tr><tr><td> <div><div>char int_n_cs_precedes</div><div>(C99)</div></div></td><td> <code>1</code> if currency_symbol is placed before negative international monetary value, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if after <br/> (public member object)</td></tr><tr><td> <div><div>char int_p_sep_by_space</div><div>(C99)</div></div></td><td>   indicates the separation of <code>currency_symbol</code>, <code>positive_sign</code>, and the non-negative international monetary value <br/> (public member object)</td></tr><tr><td> <div><div>char int_n_sep_by_space</div><div>(C99)</div></div></td><td>   indicates the separation of <code>currency_symbol</code>, <code>negative_sign</code>, and the negative international monetary value <br/> (public member object)</td></tr><tr><td> <div><div>char int_p_sign_posn</div><div>(C99)</div></div></td><td>   indicates the position of <code>positive_sign</code> in a non-negative international monetary value <br/> (public member object)</td></tr><tr><td> <div><div>char int_n_sign_posn</div><div>(C99)</div></div></td><td>   indicates the position of <code>negative_sign</code> in a negative international monetary value <br/> (public member object)</td></tr></table><p><br/>The characters of the C-strings pointed to by <code>grouping</code> and <code>mon_grouping</code> are interpreted according to their numeric values. When the terminating <code>'\x00'</code> is encountered, the last value seen is assumed to repeat for the remainder of digits. If <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">CHAR_MAX</a> is encountered, no further digits are grouped. the typical grouping of three digits at a time is <code>"\x03"</code>.</p><p>The values of <code>p_sep_by_space</code>, <code>n_sep_by_space</code>, <code>int_p_sep_by_space</code>, <code>int_n_sep_by_space</code> are interpreted as follows:</p><table><tr><td> 0</td><td> no space separates the currency symbol and the value</td></tr><tr><td> 1</td><td> sign sticks to the currency symbol, value is separated by a space</td></tr><tr><td> 2</td><td> sign sticks to the value. Currency symbol is separated by a space</td></tr></table><p>The values of <code>p_sign_posn</code>, <code>n_sign_posn</code>, <code>int_p_sign_posn</code>, <code>int_n_sign_posn</code> are interpreted as follows:</p><table><tr><td> 0</td><td> parentheses around the value and the currency symbol are used to represent the sign</td></tr><tr><td> 1</td><td> sign before the value and the currency symbol</td></tr><tr><td> 2</td><td> sign after the value and the currency symbol</td></tr><tr><td> 3</td><td> sign before the currency symbol</td></tr><tr><td> 4</td><td> sign after the currency symbol</td></tr></table><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;locale.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "ja_JP.UTF-8");    struct lconv *lc = <a href="http://en.cppreference.com/w/c/locale/localeconv">localeconv</a>();    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Japanese currency symbol:\xc2\xa0%s(%s)\n", lc-&gt;currency_symbol, lc-&gt;int_curr_symbol);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>Japanese currency symbol: \xef\xbf\xa5(JPY )</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/locale/lconv
localeconv	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;locale.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/locale/lconv">lconv</a>* localeconv();</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>localeconv</code> function obtains a pointer to a static object of type <a href="http://en.cppreference.com/w/c/locale/lconv" title="c/locale/lconv">lconv</a>, which represents numeric and monetary formatting rules of the current C locale.</p><span class="prog__sub"> Parameters</span><p>(none)<br></p><span class="prog__sub"> Return value</span><p>pointer to the current <a href="http://en.cppreference.com/w/c/locale/lconv" title="c/locale/lconv">lconv</a> object. </p></section>	http://en.cppreference.com/w/c/locale/localeconv
setlocale	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;locale.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char* setlocale( int category, const char* locale);</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>setlocale</code> function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to <code>setlocale</code>. If <code>locale</code> is a null pointer, <code>setlocale</code> queries the current C locale without modifying it.</p><span class="prog__sub"> Parameters</span><table><tr><td>  category</td><td> -</td><td>  locale category identifier, one of the <a href="http://en.cppreference.com/w/c/locale/LC_categories" title="c/locale/LC categories">LC_xxx</a> macros. May be null.</td></tr><tr><td>  locale</td><td> -</td><td>  system-specific locale identifier. Can be <code>""</code> for the user-preferred locale or <code>"C"</code> for the minimal locale</td></tr></table><span class="prog__sub"> Return value</span><p>pointer to a narrow null-terminated string identifying the C locale after applying the changes, if any, or null pointer on failure.<br></p><p>A copy of the returned string along with the category used in this call to <code>setlocale</code> may be used later in the program to restore the locale back to the state at the end of this call.</p></section>	http://en.cppreference.com/w/c/locale/setlocale
aligned_alloc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void *aligned_alloc( <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> alignment, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Allocate <code>size</code> bytes of uninitialized storage whose alignment is specified by <code>alignment</code>. The <code>size</code> parameter must be an integral multiple of <code>alignment</code>.</p><p><code>aligned_alloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A previous call to <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> or <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc</a> that deallocates a region of memory <i>synchronizes-with</i> a call to aligned_alloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>aligned_alloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p><span class="prog__sub">  Parameters </span><table><tr><td>  alignment</td><td> -</td><td>  specifies the alignment.  Must be a valid alignment supported by the implementation.</td></tr><tr><td>  size</td><td> -</td><td>  number of bytes to allocate.  An integral multiple of <code>alignment</code></td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns the pointer to the beginning of newly allocated memory. The returned pointer must be deallocated with <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free()</a> or <code>realloc()</code>.</p><p>On failure, returns a null pointer.<br></p></section>	http://en.cppreference.com/w/c/memory/aligned_alloc
calloc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void* calloc( <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> num, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Allocates memory for an array of <code>num</code> objects of size <code>size</code> and initializes all bytes in the allocated storage to zero. </p><p>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.<br></p><p>If <code>size</code> is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage)</p><table><tr><td><p><code>calloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A previous call to <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> or <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc</a> that deallocates a region of memory <i>synchronizes-with</i> a call to <strong class="selflink">calloc</strong> that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>calloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p></td><td>(since C11)</td></tr></table><span class="prog__sub"> Parameters</span><table><tr><td>  num</td><td> -</td><td>  number of objects</td></tr><tr><td>  size</td><td> -</td><td>  size of each object</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns the pointer to the beginning of newly allocated memory. The returned pointer must be deallocated with <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free()</a> or <code>realloc()</code>.</p><p>On failure, returns a null pointer.<br></p></section>	http://en.cppreference.com/w/c/memory/calloc
free	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void free( void* ptr );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Deallocates the space previously allocated by <a href="http://en.cppreference.com/w/c/memory/malloc" title="c/memory/malloc">malloc()</a>, <a href="http://en.cppreference.com/w/c/memory/calloc" title="c/memory/calloc">calloc()</a>, aligned_alloc, (since C11) or <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc()</a>.</p><p>If <code>ptr</code> is a null pointer, the function does nothing.</p><p>The behavior is undefined if the value of <code>ptr</code> does not equal a value returned earlier by <a href="http://en.cppreference.com/w/c/memory/malloc" title="c/memory/malloc">malloc()</a>, <a href="http://en.cppreference.com/w/c/memory/calloc" title="c/memory/calloc">calloc()</a>, <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc()</a>, or aligned_alloc() (since C11).</p><p>The behavior is undefined if the memory area referred to by <code>ptr</code> has already been deallocated, that is, <code>free()</code> or <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc()</a> has already been called with <code>ptr</code> as the argument and no calls to <a href="http://en.cppreference.com/w/c/memory/malloc" title="c/memory/malloc">malloc()</a>, <a href="http://en.cppreference.com/w/c/memory/calloc" title="c/memory/calloc">calloc()</a> or <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc()</a> resulted in a pointer equal to <code>ptr</code> afterwards.</p><p>The behavior is undefined if after <code>free()</code> returns, an access is made through the pointer <code>ptr</code> (unless another allocation function happened to result in a pointer value equal to <code>ptr</code>)</p><table><tr><td><p><code>free</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A call to <strong class="selflink">free</strong> that deallocates a region of memory <i>synchronizes-with</i> a call to any subsequent allocation function that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by the allocation function. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p></td><td>(since C11)</td></tr></table><span class="prog__sub"> Parameters</span><table><tr><td>  ptr</td><td> -</td><td>  pointer to the memory to deallocate</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/memory/free
malloc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void* malloc( <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> size );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Allocates <code>size</code> bytes of uninitialized storage.</p><p>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.<br></p><p>If <code>size</code> is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</p><table><tr><td><p><code>malloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A previous call to <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> or <a href="http://en.cppreference.com/w/c/memory/realloc" title="c/memory/realloc">realloc</a> that deallocates a region of memory <i>synchronizes-with</i> a call to <strong class="selflink">malloc</strong> that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>malloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p></td><td>(since C11)</td></tr></table><span class="prog__sub"> Parameters</span><table><tr><td>  size</td><td> -</td><td>  number of bytes to allocate</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns the pointer to the beginning of newly allocated memory. The returned pointer must be deallocated with <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free()</a> or <code>realloc()</code>.</p><p>On failure, returns a null pointer.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;   #include &lt;stdlib.h&gt; \xc2\xa0int main(void) {    int *p1 = malloc(4*sizeof(int));  // allocates enough for an array of 4 int    int *p2 = malloc(sizeof(int[4])); // same, naming the type directly    int *p3 = malloc(4*sizeof *p3);   // same, without repeating the type name\xc2\xa0    if(p1) {        for(int n=0; n&lt;4; ++n) // populate the array            p1[n] = n*n;        for(int n=0; n&lt;4; ++n) // print it back out            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("p1[%d] ==\xc2\xa0%d\n", n, p1[n]);    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/memory/free">free</a>(p1);    <a href="http://en.cppreference.com/w/c/memory/free">free</a>(p2);    <a href="http://en.cppreference.com/w/c/memory/free">free</a>(p3);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>p1[0] == 0<br>p1[1] == 1<br>p1[2] == 4<br>p1[3] == 9</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/memory/malloc
realloc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void *realloc( void *ptr, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> new_size );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Reallocates the given area of memory. It must be previously allocated by <a href="http://en.cppreference.com/w/c/memory/malloc" title="c/memory/malloc">malloc()</a>, <a href="http://en.cppreference.com/w/c/memory/calloc" title="c/memory/calloc">calloc()</a> or <code>realloc()</code> and not yet freed with a call to <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> or <code>realloc</code>. Otherwise, the results are undefined.</p><p>The reallocation is done by either:<br></p><div>a) expanding or contracting the existing area pointed to by <code>ptr</code>, if possible. The contents of the area remain unchanged up to the lesser of the new and old sizes. If the area is expanded, the contents of the new part of the array are undefined. </div><div>b) allocating a new memory block of size <code>new_size</code> bytes, copying memory area with size equal the lesser of the new and the old sizes, and freeing the old block.</div><p>If there is not enough memory, the old memory block is not freed and null pointer is returned.<br></p><p>If <code>ptr</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, the behavior is the same as calling <a href="http://en.cppreference.com/w/c/memory/malloc" title="c/memory/malloc">malloc</a>(<code>new_size</code>).</p><p>If <code>new_size</code> is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage).</p><table><tr><td><p><code>realloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p><p>A previous call to <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free</a> or <code>realloc</code> that deallocates a region of memory <i>synchronizes-with</i> a call to any allocation function, including <code>realloc</code> that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>realloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p></td><td>(since C11)</td></tr></table><span class="prog__sub"> Parameters</span><table><tr><td>  ptr</td><td> -</td><td>  pointer to the memory area to be reallocated</td></tr><tr><td>  new_size</td><td> -</td><td>  new size of the array</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns the pointer to the beginning of newly allocated memory. The returned pointer must be deallocated with <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free()</a> or <code>realloc()</code>. The original pointer <code>ptr</code> is invalidated and any access to it is undefined behavior (even if reallocation was in-place).</p><p>On failure, returns a null pointer. The original pointer <code>ptr</code> remains valid and may need to be deallocated with <a href="http://en.cppreference.com/w/c/memory/free" title="c/memory/free">free()</a> or <code>realloc()</code>.</p></section>	http://en.cppreference.com/w/c/memory/realloc
Type-generic math	A										<section class="prog__container"><p>The header <code>&lt;tgmath.h&gt;</code> includes the headers <code>&lt;math.h&gt;</code> and <code>&lt;complex.h&gt;</code> and defines several type-generic macros that determine which real or, when applicable, complex function to call based on the types of the arguments.</p><p>For each macro, the parameters whose corresponding real type in the unsuffixed math.h function is <code>double</code> are known as <i>generic parameters</i> (for example, both parameters of <a href="http://en.cppreference.com/w/c/numeric/math/pow" title="c/numeric/math/pow">pow</a> are generic parameters, but only the first parameter of <a href="http://en.cppreference.com/w/c/numeric/math/scalbn" title="c/numeric/math/scalbn">scalbn</a> is a generic parameter)</p><p>When a <code>&lt;tgmath.h&gt;</code> macro is used the types of the arguments passed to the generic parameters determine which function is selected by the macro as described below. If the types of the arguments are not <a href="http://en.cppreference.com/w/c/language/type#Compatible_types" title="c/language/type">compatible</a> with the parameter types of the selected function, the behavior is undefined (e.g. if a complex argument is passed into a real-only tgmath macro: <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> fc; <a href="http://en.cppreference.com/w/c/numeric/math/ceil">ceil</a>(fc)</code> or <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> dc; double d; <a href="http://en.cppreference.com/w/c/numeric/math/fmax">fmax</a>(dc, d)</code> are examples of undefined behavior)</p><p>Note: type-generic macros were implemented in implementation-defined manner in C99, but C11 keyword <a href="http://en.cppreference.com/w/c/keyword/_Generic" title="c/keyword/ Generic">_Generic</a> makes it possible to implement these macros in portable manner.</p><span class="prog__sub"> Complex/real type-generic macros</span><p>For all functions that have both real and complex counterparts, a type-generic macro <code>XXX</code> exists, which calls either of:</p><ul><li> real function:</li></ul><dl><dd><ul><li> <code>float</code> variant <code>XXXf</code></li><li> <code>double</code> variant <code>XXX</code></li><li> <code>long double</code> variant <code>XXXl</code></li></ul></dd></dl><ul><li> complex function:</li></ul><dl><dd><ul><li> <code>float</code> variant <code>cXXXf</code></li><li> <code>double</code> variant <code>cXXX</code></li><li> <code>long double</code> variant <code>cXXXl</code></li></ul></dd></dl><p>An exception to the above rule is the <code>fabs</code> macro (see the table below).</p><p>The function to call is determined as follows:<br></p><ul><li> If any of the arguments for the generic parameters is imaginary, the behavior is specified on each function reference page individually (in particular, sin, cos, tag, cosh, sinh, tanh, asin, atan, asinh, and atanh call <i>real</i> functions, the return types of sin, tan, sinh, tanh, asin, atan, asinh, and atanh are imaginary, and the return types of cos and cosh are real)</li><li> If any of the arguments for the generic parameters is complex, then the complex function is called, otherwise the real function is called.</li><li> If any of the arguments for the generic parameters is <code>long double</code>, then the <code>long double</code> variant is called. Otherwise, if any of the parameters is <code>double</code> or integer, then the <code>double</code> variant is called. Otherwise, <code>float</code> variant is called.</li></ul><p>The type-generic macros are as follows:<br></p><table><tr><th> Type-generic macro</th><th colspan="3"> Real function <br/> variants</th><th colspan="3"> Complex function <br/> variants</th></tr><tr><th style="height: 8em;"> \xc2\xa0</th><th> <div><div><code>float</code></div></div></th><th> <div><div><code>double</code></div></div></th><th> <div><div><code>long double</code></div></div></th><th> <div><div><code>float</code></div></div></th><th> <div><div><code>double</code></div></div></th><th> <div><div><code>long double</code></div></div></th></tr><tr><th> fabs</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/fabs" title="c/numeric/math/fabs"><tt>fabsf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fabs" title="c/numeric/math/fabs"><tt>fabs</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fabs" title="c/numeric/math/fabs"><tt>fabsl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cabs" title="c/numeric/complex/cabs"><tt>cabsf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cabs" title="c/numeric/complex/cabs"><tt>cabs</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cabs" title="c/numeric/complex/cabs"><tt>cabsl</tt></a></td></tr><tr><th> exp</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/exp" title="c/numeric/math/exp"><tt>expf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/exp" title="c/numeric/math/exp"><tt>exp</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/exp" title="c/numeric/math/exp"><tt>expl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cexp" title="c/numeric/complex/cexp"><tt>cexpf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cexp" title="c/numeric/complex/cexp"><tt>cexp</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cexp" title="c/numeric/complex/cexp"><tt>cexpl</tt></a></td></tr><tr><th> log</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/log" title="c/numeric/math/log"><tt>logf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/log" title="c/numeric/math/log"><tt>log</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/log" title="c/numeric/math/log"><tt>logl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/clog" title="c/numeric/complex/clog"><tt>clogf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/clog" title="c/numeric/complex/clog"><tt>clog</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/clog" title="c/numeric/complex/clog"><tt>clogl</tt></a></td></tr><tr><th> pow</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/pow" title="c/numeric/math/pow"><tt>powf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/pow" title="c/numeric/math/pow"><tt>pow</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/pow" title="c/numeric/math/pow"><tt>powl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cpow" title="c/numeric/complex/cpow"><tt>cpowf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cpow" title="c/numeric/complex/cpow"><tt>cpow</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cpow" title="c/numeric/complex/cpow"><tt>cpowl</tt></a></td></tr><tr><th> sqrt</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/sqrt" title="c/numeric/math/sqrt"><tt>sqrtf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/sqrt" title="c/numeric/math/sqrt"><tt>sqrt</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/sqrt" title="c/numeric/math/sqrt"><tt>sqrtl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csqrt" title="c/numeric/complex/csqrt"><tt>csqrtf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csqrt" title="c/numeric/complex/csqrt"><tt>csqrt</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csqrt" title="c/numeric/complex/csqrt"><tt>csqrtl</tt></a></td></tr><tr><th> sin</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/sin" title="c/numeric/math/sin"><tt>sinf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/sin" title="c/numeric/math/sin"><tt>sin</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/sin" title="c/numeric/math/sin"><tt>sinl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csin" title="c/numeric/complex/csin"><tt>csinf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csin" title="c/numeric/complex/csin"><tt>csin</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csin" title="c/numeric/complex/csin"><tt>csinl</tt></a></td></tr><tr><th> cos</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/cos" title="c/numeric/math/cos"><tt>cosf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/cos" title="c/numeric/math/cos"><tt>cos</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/cos" title="c/numeric/math/cos"><tt>cosl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ccos" title="c/numeric/complex/ccos"><tt>ccosf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ccos" title="c/numeric/complex/ccos"><tt>ccos</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ccos" title="c/numeric/complex/ccos"><tt>ccosl</tt></a></td></tr><tr><th> tan</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/tan" title="c/numeric/math/tan"><tt>tanf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/tan" title="c/numeric/math/tan"><tt>tan</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/tan" title="c/numeric/math/tan"><tt>tanl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ctan" title="c/numeric/complex/ctan"><tt>ctanf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ctan" title="c/numeric/complex/ctan"><tt>ctan</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ctan" title="c/numeric/complex/ctan"><tt>ctanl</tt></a></td></tr><tr><th> asin</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/asin" title="c/numeric/math/asin"><tt>asinf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/asin" title="c/numeric/math/asin"><tt>asin</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/asin" title="c/numeric/math/asin"><tt>asinl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/casin" title="c/numeric/complex/casin"><tt>casinf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/casin" title="c/numeric/complex/casin"><tt>casin</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/casin" title="c/numeric/complex/casin"><tt>casinl</tt></a></td></tr><tr><th> acos</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/acos" title="c/numeric/math/acos"><tt>acosf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/acos" title="c/numeric/math/acos"><tt>acos</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/acos" title="c/numeric/math/acos"><tt>acosl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cacos" title="c/numeric/complex/cacos"><tt>cacosf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cacos" title="c/numeric/complex/cacos"><tt>cacos</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cacos" title="c/numeric/complex/cacos"><tt>cacosl</tt></a></td></tr><tr><th> atan</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/atan" title="c/numeric/math/atan"><tt>atanf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/atan" title="c/numeric/math/atan"><tt>atan</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/atan" title="c/numeric/math/atan"><tt>atanl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/catan" title="c/numeric/complex/catan"><tt>catanf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/catan" title="c/numeric/complex/catan"><tt>catan</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/catan" title="c/numeric/complex/catan"><tt>catanl</tt></a></td></tr><tr><th> sinh</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/sinh" title="c/numeric/math/sinh"><tt>sinhf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/sinh" title="c/numeric/math/sinh"><tt>sinh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/sinh" title="c/numeric/math/sinh"><tt>sinhl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csinh" title="c/numeric/complex/csinh"><tt>csinhf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csinh" title="c/numeric/complex/csinh"><tt>csinh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/csinh" title="c/numeric/complex/csinh"><tt>csinhl</tt></a></td></tr><tr><th> cosh</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/cosh" title="c/numeric/math/cosh"><tt>coshf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/cosh" title="c/numeric/math/cosh"><tt>cosh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/cosh" title="c/numeric/math/cosh"><tt>coshl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ccosh" title="c/numeric/complex/ccosh"><tt>ccoshf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ccosh" title="c/numeric/complex/ccosh"><tt>ccosh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ccosh" title="c/numeric/complex/ccosh"><tt>ccoshl</tt></a></td></tr><tr><th> tanh</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/tanh" title="c/numeric/math/tanh"><tt>tanhf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/tanh" title="c/numeric/math/tanh"><tt>tanh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/tanh" title="c/numeric/math/tanh"><tt>tanhl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ctanh" title="c/numeric/complex/ctanh"><tt>ctanhf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ctanh" title="c/numeric/complex/ctanh"><tt>ctanh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/ctanh" title="c/numeric/complex/ctanh"><tt>ctanhl</tt></a></td></tr><tr><th> asinh</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/asinh" title="c/numeric/math/asinh"><tt>asinhf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/asinh" title="c/numeric/math/asinh"><tt>asinh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/asinh" title="c/numeric/math/asinh"><tt>asinhl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/casinh" title="c/numeric/complex/casinh"><tt>casinhf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/casinh" title="c/numeric/complex/casinh"><tt>casinh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/casinh" title="c/numeric/complex/casinh"><tt>casinhl</tt></a></td></tr><tr><th> acosh</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/acosh" title="c/numeric/math/acosh"><tt>acoshf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/acosh" title="c/numeric/math/acosh"><tt>acosh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/acosh" title="c/numeric/math/acosh"><tt>acoshl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cacosh" title="c/numeric/complex/cacosh"><tt>cacoshf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cacosh" title="c/numeric/complex/cacosh"><tt>cacosh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cacosh" title="c/numeric/complex/cacosh"><tt>cacoshl</tt></a></td></tr><tr><th> atanh</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/atanh" title="c/numeric/math/atanh"><tt>atanhf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/atanh" title="c/numeric/math/atanh"><tt>atanh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/atanh" title="c/numeric/math/atanh"><tt>atanhl</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/catanh" title="c/numeric/complex/catanh"><tt>catanhf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/catanh" title="c/numeric/complex/catanh"><tt>catanh</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/catanh" title="c/numeric/complex/catanh"><tt>catanhl</tt></a></td></tr></table><span class="prog__sub"> Real-only functions</span><p>For all functions that do not have complex counterparts, with the exception of <code>modf</code>, a type-generic macro <code>XXX</code> exists, which calls either of the variants of a real function:</p><ul><li> <code>float</code> variant <code>XXXf</code></li><li> <code>double</code> variant <code>XXX</code></li><li> <code>long double</code> variant <code>XXXl</code></li></ul><p>The function to call is determined as follows:<br></p><ul><li> If any of the arguments for the generic parameters is <code>long double</code>, then the <code>long double</code> variant is called. Otherwise, if any of the arguments for the generic parameters is <code>double</code>, then the <code>double</code> variant is called. Otherwise, <code>float</code> variant is called.</li></ul><table><tr><th> Type-generic macro</th><th colspan="3"> Real function <br/> variants</th></tr><tr><th style="height: 8em;"> \xc2\xa0</th><th> <div><div><code>float</code></div></div></th><th> <div><div><code>double</code></div></div></th><th> <div><div><code>long double</code></div></div></th></tr><tr><th> atan2</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/atan2" title="c/numeric/math/atan2"><tt>atan2f</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/atan2" title="c/numeric/math/atan2"><tt>atan2</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/atan2" title="c/numeric/math/atan2"><tt>atan2l</tt></a></td></tr><tr><th> cbrt</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/cbrt" title="c/numeric/math/cbrt"><tt>cbrtf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/cbrt" title="c/numeric/math/cbrt"><tt>cbrt</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/cbrt" title="c/numeric/math/cbrt"><tt>cbrtl</tt></a></td></tr><tr><th> ceil</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/ceil" title="c/numeric/math/ceil"><tt>ceilf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/ceil" title="c/numeric/math/ceil"><tt>ceil</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/ceil" title="c/numeric/math/ceil"><tt>ceill</tt></a></td></tr><tr><th> copysign</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/copysign" title="c/numeric/math/copysign"><tt>copysignf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/copysign" title="c/numeric/math/copysign"><tt>copysign</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/copysign" title="c/numeric/math/copysign"><tt>copysignl</tt></a></td></tr><tr><th> erf</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/erf" title="c/numeric/math/erf"><tt>erff</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/erf" title="c/numeric/math/erf"><tt>erf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/erf" title="c/numeric/math/erf"><tt>erfl</tt></a></td></tr><tr><th> erfc</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/erfc" title="c/numeric/math/erfc"><tt>erfcf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/erfc" title="c/numeric/math/erfc"><tt>erfc</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/erfc" title="c/numeric/math/erfc"><tt>erfcl</tt></a></td></tr><tr><th> exp2</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/exp2" title="c/numeric/math/exp2"><tt>exp2f</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/exp2" title="c/numeric/math/exp2"><tt>exp2</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/exp2" title="c/numeric/math/exp2"><tt>exp2l</tt></a></td></tr><tr><th> expm1</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/expm1" title="c/numeric/math/expm1"><tt>expm1f</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/expm1" title="c/numeric/math/expm1"><tt>expm1</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/expm1" title="c/numeric/math/expm1"><tt>expm1l</tt></a></td></tr><tr><th> fdim</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/fdim" title="c/numeric/math/fdim"><tt>fdimf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fdim" title="c/numeric/math/fdim"><tt>fdim</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fdim" title="c/numeric/math/fdim"><tt>fdiml</tt></a></td></tr><tr><th> floor</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/floor" title="c/numeric/math/floor"><tt>floorf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/floor" title="c/numeric/math/floor"><tt>floor</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/floor" title="c/numeric/math/floor"><tt>floorl</tt></a></td></tr><tr><th> fma</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/fma" title="c/numeric/math/fma"><tt>fmaf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fma" title="c/numeric/math/fma"><tt>fma</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fma" title="c/numeric/math/fma"><tt>fmal</tt></a></td></tr><tr><th> fmax</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmax" title="c/numeric/math/fmax"><tt>fmaxf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmax" title="c/numeric/math/fmax"><tt>fmax</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmax" title="c/numeric/math/fmax"><tt>fmaxl</tt></a></td></tr><tr><th> fmin</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmin" title="c/numeric/math/fmin"><tt>fminf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmin" title="c/numeric/math/fmin"><tt>fmin</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmin" title="c/numeric/math/fmin"><tt>fminl</tt></a></td></tr><tr><th> fmod</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmod" title="c/numeric/math/fmod"><tt>fmodf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmod" title="c/numeric/math/fmod"><tt>fmod</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/fmod" title="c/numeric/math/fmod"><tt>fmodl</tt></a></td></tr><tr><th> frexp</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/frexp" title="c/numeric/math/frexp"><tt>frexpf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/frexp" title="c/numeric/math/frexp"><tt>frexp</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/frexp" title="c/numeric/math/frexp"><tt>frexpl</tt></a></td></tr><tr><th> hypot</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/hypot" title="c/numeric/math/hypot"><tt>hypotf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/hypot" title="c/numeric/math/hypot"><tt>hypot</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/hypot" title="c/numeric/math/hypot"><tt>hypotl</tt></a></td></tr><tr><th> ilogb</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/ilogb" title="c/numeric/math/ilogb"><tt>ilogbf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/ilogb" title="c/numeric/math/ilogb"><tt>ilogb</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/ilogb" title="c/numeric/math/ilogb"><tt>ilogbl</tt></a></td></tr><tr><th> ldexp</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/ldexp" title="c/numeric/math/ldexp"><tt>ldexpf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/ldexp" title="c/numeric/math/ldexp"><tt>ldexp</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/ldexp" title="c/numeric/math/ldexp"><tt>ldexpl</tt></a></td></tr><tr><th> lgamma</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/lgamma" title="c/numeric/math/lgamma"><tt>lgammaf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/lgamma" title="c/numeric/math/lgamma"><tt>lgamma</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/lgamma" title="c/numeric/math/lgamma"><tt>lgammal</tt></a></td></tr><tr><th> llrint</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>llrintf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>llrint</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>llrintl</tt></a></td></tr><tr><th> llround</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>llroundf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>llround</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>llroundl</tt></a></td></tr><tr><th> log10</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/log10" title="c/numeric/math/log10"><tt>log10f</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/log10" title="c/numeric/math/log10"><tt>log10</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/log10" title="c/numeric/math/log10"><tt>log10l</tt></a></td></tr><tr><th> log1p</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/log1p" title="c/numeric/math/log1p"><tt>log1pf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/log1p" title="c/numeric/math/log1p"><tt>log1p</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/log1p" title="c/numeric/math/log1p"><tt>log1pl</tt></a></td></tr><tr><th> log2</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/log2" title="c/numeric/math/log2"><tt>log2f</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/log2" title="c/numeric/math/log2"><tt>log2</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/log2" title="c/numeric/math/log2"><tt>log2l</tt></a></td></tr><tr><th> logb</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/logb" title="c/numeric/math/logb"><tt>logbf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/logb" title="c/numeric/math/logb"><tt>logb</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/logb" title="c/numeric/math/logb"><tt>logbl</tt></a></td></tr><tr><th> lrint</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>lrintf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>lrint</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>lrintl</tt></a></td></tr><tr><th> lround</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>lroundf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>lround</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>lroundl</tt></a></td></tr><tr><th> nearbyint</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/nearbyint" title="c/numeric/math/nearbyint"><tt>nearbyintf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/nearbyint" title="c/numeric/math/nearbyint"><tt>nearbyint</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/nearbyint" title="c/numeric/math/nearbyint"><tt>nearbyintl</tt></a></td></tr><tr><th> nextafter</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/nextafter" title="c/numeric/math/nextafter"><tt>nextafterf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/nextafter" title="c/numeric/math/nextafter"><tt>nextafter</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/nextafter" title="c/numeric/math/nextafter"><tt>nextafterl</tt></a></td></tr><tr><th> nexttoward</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/nextafter" title="c/numeric/math/nextafter"><tt>nexttowardf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/nextafter" title="c/numeric/math/nextafter"><tt>nexttoward</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/nextafter" title="c/numeric/math/nextafter"><tt>nexttowardl</tt></a></td></tr><tr><th> remainder</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/remainder" title="c/numeric/math/remainder"><tt>remainderf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/remainder" title="c/numeric/math/remainder"><tt>remainder</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/remainder" title="c/numeric/math/remainder"><tt>remainderl</tt></a></td></tr><tr><th> remquo</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/remquo" title="c/numeric/math/remquo"><tt>remquof</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/remquo" title="c/numeric/math/remquo"><tt>remquo</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/remquo" title="c/numeric/math/remquo"><tt>remquol</tt></a></td></tr><tr><th> rint</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>rintf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>rint</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint"><tt>rintl</tt></a></td></tr><tr><th> round</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>roundf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>round</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round"><tt>roundl</tt></a></td></tr><tr><th> scalbln</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/scalbn" title="c/numeric/math/scalbn"><tt>scalblnf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/scalbn" title="c/numeric/math/scalbn"><tt>scalbln</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/scalbn" title="c/numeric/math/scalbn"><tt>scalblnl</tt></a></td></tr><tr><th> scalbn</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/scalbn" title="c/numeric/math/scalbn"><tt>scalbnf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/scalbn" title="c/numeric/math/scalbn"><tt>scalbn</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/scalbn" title="c/numeric/math/scalbn"><tt>scalbnl</tt></a></td></tr><tr><th> tgamma</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/tgamma" title="c/numeric/math/tgamma"><tt>tgammaf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/tgamma" title="c/numeric/math/tgamma"><tt>tgamma</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/tgamma" title="c/numeric/math/tgamma"><tt>tgammal</tt></a></td></tr><tr><th> trunc</th><td> <a href="http://en.cppreference.com/w/c/numeric/math/trunc" title="c/numeric/math/trunc"><tt>truncf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/trunc" title="c/numeric/math/trunc"><tt>trunc</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/math/trunc" title="c/numeric/math/trunc"><tt>truncl</tt></a></td></tr></table><span class="prog__sub"> Complex-only functions</span><p>For all complex number functions that do not have real counterparts, a type-generic macro <code>cXXX</code> exists, which calls either of the variants of a complex function:</p><ul><li> <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> variant <code>cXXXf</code></li><li> <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> variant <code>cXXX</code></li><li> <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> variant <code>cXXXl</code></li></ul><p>The function to call is determined as follows:<br></p><ul><li> If any of the arguments for the generic parameters is real, complex, or imaginary, then the appropriate complex function is called.</li></ul><table><tr><th> Type-generic macro</th><th colspan="3"> Complex function <br/> variants</th></tr><tr><th style="height: 8em;"> \xc2\xa0</th><th> <div><div><code>float</code></div></div></th><th> <div><div><code>double</code></div></div></th><th> <div><div><code>long double</code></div></div></th></tr><tr><th> carg</th><td> <a href="http://en.cppreference.com/w/c/numeric/complex/carg" title="c/numeric/complex/carg"><tt>cargf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/carg" title="c/numeric/complex/carg"><tt>carg</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/carg" title="c/numeric/complex/carg"><tt>cargl</tt></a></td></tr><tr><th> conj</th><td> <a href="http://en.cppreference.com/w/c/numeric/complex/conj" title="c/numeric/complex/conj"><tt>conjf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/conj" title="c/numeric/complex/conj"><tt>conj</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/conj" title="c/numeric/complex/conj"><tt>conjl</tt></a></td></tr><tr><th> creal</th><td> <a href="http://en.cppreference.com/w/c/numeric/complex/creal" title="c/numeric/complex/creal"><tt>crealf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/creal" title="c/numeric/complex/creal"><tt>creal</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/creal" title="c/numeric/complex/creal"><tt>creall</tt></a></td></tr><tr><th> cimag</th><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cimag" title="c/numeric/complex/cimag"><tt>cimagf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cimag" title="c/numeric/complex/cimag"><tt>cimag</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cimag" title="c/numeric/complex/cimag"><tt>cimagl</tt></a></td></tr><tr><th> cproj</th><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cproj" title="c/numeric/complex/cproj"><tt>cprojf</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cproj" title="c/numeric/complex/cproj"><tt>cproj</tt></a></td><td> <a href="http://en.cppreference.com/w/c/numeric/complex/cproj" title="c/numeric/complex/cproj"><tt>cprojl</tt></a></td></tr></table><span class="prog__sub">  Example </span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;tgmath.h&gt;\xc2\xa0int main(void){    int i = 2;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("sqrt(2) =\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(i)); // argument type is int, calls sqrt\xc2\xa0    float f = 0.5;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("sin(0.5f) =\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/numeric/math/sin">sin</a>(f));   // argument type is float, calls sinf\xc2\xa0    float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> dc = 1 + 0.5*I;    float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z = <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(dc);      // argument type is float complex, calls csqrtf    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("sqrt(1 + 0.5i) =\xc2\xa0%f+%fi\n",           <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z),  // argument type is float complex, calls crealf           <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z)); // argument type is float complex, calls cimagf}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>sqrt(2) = 1.414214<br>sin(0.5f) = 0.479426<br>sqrt(1 + 0.5i) = 1.029086+0.242934i</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/tgmath
cabsf, cabs, cabsl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 cabsf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0cabs( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double cabsl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define fabs( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex absolute value (also known as norm, modulus, or magnitude) of <code>z</code>.</div><div>4) Type-generic macro: if <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> or <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>cabsl</code> is called. If <code>z</code>  has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> or <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>cabsf</code> is called. If <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code> or <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>cabs</code> is called. For real and integer types, the corresponding version of <a href="http://en.cppreference.com/w/c/numeric/math/fabs" title="c/numeric/math/fabs">fabs</a> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, returns the absolute value (norm, magnitude) of <code>z</code>.</p><p>Errors and special cases are handled as if the function is implemented as <code><a href="http://en.cppreference.com/w/c/numeric/math/hypot">hypot</a>(<a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z))</code></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;complex.h&gt;\xc2\xa0int main(void){    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z = 1.0 + 1.0*I;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%.1f%+.1fi cartesian is rho=%f theta=%f polar\n",           <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z), cabs(z), <a href="http://en.cppreference.com/w/c/numeric/complex/carg">carg</a>(z));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>1.0+1.0i cartesian is rho=1.414214 theta=0.785398 polar</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/complex/cabs
cacosf, cacos, cacosl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 cacosf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0cacos( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> cacosl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define acos( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex arc cosine of <code>z</code> with branch cuts outside the interval [\xe2\x88\x921,+1] along the real axis.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cacosl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cacos</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cacosf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>acosf</code>, <code>acos</code>, <code>acosl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding complex number version.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, complex arc cosine of <code>z</code> is returned, in the range [0\xc2\xa0; \xe2\x88\x9e) along the real axis and in the range [\xe2\x88\x92<i>i</i>\xcf\x80\xc2\xa0; <i>i</i>\xcf\x80] along the imaginary axis.</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>cacos(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(cacos(z))</code></li><li> If <code>z</code> is <code>\xc2\xb10+0i</code>, the result is <code>\xcf\x80/2-0i</code></li><li> If <code>z</code> is <code>\xc2\xb10+NaNi</code>, the result is <code>\xcf\x80/2+NaNi</code></li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code> (for any finite x), the result is <code>\xcf\x80/2-\xe2\x88\x9ei</code></li><li> If <code>z</code> is <code>x+NaNi</code> (for any nonzero finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised.</li><li> If <code>z</code> is <code>-\xe2\x88\x9e+yi</code> (for any positive finite y), the result is <code>\xcf\x80-\xe2\x88\x9ei</code></li><li> If <code>z</code> is <code>-\xe2\x88\x9e+yi</code> (for any positive finite y), the result is <code>+0-\xe2\x88\x9ei</code></li><li> If <code>z</code> is <code>-\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>3\xcf\x80/4-\xe2\x88\x9ei</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>\xcf\x80/4-\xe2\x88\x9ei</code></li><li> If <code>z</code> is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code>, the result is <code>NaN\xc2\xb1\xe2\x88\x9ei</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+\xe2\x88\x9ei</code>, the result is <code>NaN-\xe2\x88\x9ei</code></li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul></section>	http://en.cppreference.com/w/c/numeric/complex/cacos
cacoshf, cacosh, cacoshl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 cacoshf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0cacosh( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> cacoshl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define acosh( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes complex arc hyperbolic sine of a complex value <code>z</code> with branch cut at values less than 1 along the real axis.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cacoshl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cacosh</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cacoshf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>acoshf</code>, <code>acosh</code>, <code>acoshl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding complex number version and the return type is complex.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>The complex arc hyperbolic cosine of <code>z</code> in the interval [0; \xe2\x88\x9e) along the real axis and in the interval [\xe2\x88\x92i\xcf\x80; +i\xcf\x80] along the imaginary axis.</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>cacosh(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(cacosh(z))</code></li><li> If <code>z</code> is <code>\xc2\xb10+0i</code>, the result is <code>+0+i\xcf\x80/2</code></li><li> If <code>z</code> is <code>+x+\xe2\x88\x9ei</code> (for any finite x), the result is <code>+\xe2\x88\x9e+i\xcf\x80/2</code></li><li> If <code>z</code> is <code>+x+NaNi</code> (for any<sup class="reference" id="cite_ref-1">[1]</sup> finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised.</li><li> If <code>z</code> is <code>-\xe2\x88\x9e+yi</code> (for any positive finite y), the result is <code>+\xe2\x88\x9e+i\xcf\x80</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code> (for any positive finite y), the result is <code>+\xe2\x88\x9e+0i</code></li><li> If <code>z</code> is <code>-\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>+\xe2\x88\x9e+3i\xcf\x80/4</code></li><li> If <code>z</code> is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code>, the result is <code>+\xe2\x88\x9e+NaNi</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised.</li><li> If <code>z</code> is <code>NaN+\xe2\x88\x9ei</code>, the result is <code>+\xe2\x88\x9e+NaNi</code></li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><ol class="references"><li id="cite_note-1"><a href="#cite_ref-1">\xe2\x86\x91</a> per <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471" rel="nofollow">DR471</a>, this holds for non-zero x only. If <code>z</code> is <code>0+NaNi</code>, the result should be <code>NaN+i\xcf\x80/2</code></li></ol></section>	http://en.cppreference.com/w/c/numeric/complex/cacosh
cargf, carg, cargl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 cargf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0carg( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double cargl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define carg( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the argument (also called phase angle) of <code>z</code>, with a branch cut along the negative real axis.</div><div>4) Type-generic macro: if <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>long double</code>, <code>cargl</code> is called. If <code>z</code>  has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>float</code>, <code>cargf</code> is called. If <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>double</code>, or any integer type, <code>carg</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, returns the phase angle of <code>z</code> in the interval (\xe2\x88\x92\xcf\x80; \xcf\x80).</p><p>Errors and special cases are handled as if the function is implemented as <code><a href="http://en.cppreference.com/w/c/numeric/math/atan2">atan2</a>(<a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z), <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z))</code></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;complex.h&gt;\xc2\xa0int main(void) {    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z1 = 1.0+0.0*I;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("phase angle of\xc2\xa0%.1f%+.1fi is\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z1), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z1), carg(z1));\xc2\xa0    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z2 = 0.0+1.0*I;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("phase angle of\xc2\xa0%.1f%+.1fi is\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z2), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z2), carg(z2));\xc2\xa0    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z3 = -1.0+0.0*I;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("phase angle of\xc2\xa0%.1f%+.1fi is\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z3), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z3), carg(z3));\xc2\xa0    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z4 = <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z3); // or CMPLX(-1, -0.0)    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("phase angle of\xc2\xa0%.1f%+.1fi (the other side of the cut) is\xc2\xa0%f\n",             <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z4), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z4), carg(z4));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>phase angle of 1.0+0.0i is 0.000000<br>phase angle of 0.0+1.0i is 1.570796<br>phase angle of -1.0+0.0i is 3.141593<br>phase angle of -1.0-0.0i (the other side of the cut) is -3.141593</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/complex/carg
casinf, casin, casinl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 casinf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0casin( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> casinl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define asin( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex arc sine of <code>z</code> with branch cuts outside the interval [\xe2\x88\x921,+1] along the real axis.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>casinl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>casin</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>casinf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>asinf</code>, <code>asin</code>, <code>asinl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/asinh" title="c/numeric/math/asinh">asinh</a>, implementing the formula asin(iy) = i asinh(y), and the return type of the macro is imaginary.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, complex arc sine of <code>z</code> is returned, in the range of a strip unbounded along the imaginary axis and in the interval [\xe2\x88\x92\xcf\x80/2; +\xcf\x80/2] along the real axis.</p><p>Errors and special cases are handled as if the operation is implemented by <code>-I * <a href="http://en.cppreference.com/w/c/numeric/complex/casinh">casinh</a>(I*z)</code></p></section>	http://en.cppreference.com/w/c/numeric/complex/casin
casinhf, casinh, casinhl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 casinhf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0casinh( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> casinhl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define asinh( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex arc hyperbolic sine of <code>z</code> with branch cuts outside the interval [\xe2\x88\x92i; +i] along the imaginary axis.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>casinhl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>casinh</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>casinhf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>asinhf</code>, <code>asinh</code>, <code>asinhl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/asin" title="c/numeric/math/asin">asin</a>, implementing the formula asinh(iy) = i asin(y), and the return type is imaginary.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the complex arc hyperbolic sine of <code>z</code> is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [\xe2\x88\x92i\xcf\x80/2; +i\xcf\x80/2] along the imaginary axis.</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>casinh(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(casinh(z))</code></li><li> <code>casinh(-z) == -casinh(z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code> (for any positive finite x), the result is <code>+\xe2\x88\x9e+\xcf\x80/2</code></li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code> (for any positive finite y), the result is <code>+\xe2\x88\x9e+0i</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>+\xe2\x88\x9e+i\xcf\x80/4</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+NaNi</code>, the result is <code>+\xe2\x88\x9e+NaNi</code></li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN+0i</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite nonzero y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+\xe2\x88\x9ei</code>, the result is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code> (the sign of the real part is unspecified)</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul></section>	http://en.cppreference.com/w/c/numeric/complex/casinh
catanf, catan, catanl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 catanf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0catan( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> catanl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define atan( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex arc tangent of <code>z</code> with branch cuts outside the interval [\xe2\x88\x92i,+i] along the imaginary axis.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>catanl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>catan</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>catanf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>atanf</code>, <code>atan</code>, <code>atanl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/atanh" title="c/numeric/math/atanh">atanh</a>, implementing the formula atan(iy) = i atanh(y), and the return type of the macro is imaginary.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, complex arc tangent of <code>z</code> is returned, in the range of a strip unbounded along the imaginary axis and in the interval [\xe2\x88\x92\xcf\x80/2; +\xcf\x80/2] along the real axis.</p><p>Errors and special cases are handled as if the operation is implemented by <code>-I * <a href="http://en.cppreference.com/w/c/numeric/complex/catanh">catanh</a>(I*z)</code>.</p></section>	http://en.cppreference.com/w/c/numeric/complex/catan
catanhf, catanh, catanhl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 catanhf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0catanh( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> catanhl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define atanh( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex arc hyperbolic tangent of <code>z</code> with branch cuts outside the interval [\xe2\x88\x921; +1] along the real axis.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>catanhl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>catanh</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>catanhf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>atanhf</code>, <code>atanh</code>, <code>atanhl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of <code>atan</code>, implementing the formula atanh(iy) = i atan(y), and the return type is imaginary.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the complex arc hyperbolic tangent of <code>z</code> is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [\xe2\x88\x92i\xcf\x80/2; +i\xcf\x80/2] along the imaginary axis.</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>catanh(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(catanh(z))</code></li><li> <code>catanh(-z) == -catanh(z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>+0+NaNi</code>, the result is <code>+0+NaNi</code></li><li> If <code>z</code> is <code>+1+0i</code>, the result is <code>+\xe2\x88\x9e+0i</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised</li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code> (for any finite positive x), the result is <code>+0+i\xcf\x80/2</code></li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite nonzero x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code> (for any finite positive y), the result is <code>+0+i\xcf\x80/2</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>+0+i\xcf\x80/2</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+NaNi</code>, the result is <code>+0+NaNi</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+\xe2\x88\x9ei</code>, the result is <code>\xc2\xb10+i\xcf\x80/2</code> (the sign of the real part is unspecified)</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul></section>	http://en.cppreference.com/w/c/numeric/complex/catanh
ccosf, ccos, ccosl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 ccosf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0ccos( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> ccosl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define cos( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex cosine of <code>z</code>.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ccosl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ccos</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ccosf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>cosf</code>, <code>cos</code>, <code>cosl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/cosh" title="c/numeric/math/cosh">cosh</a>, implementing the formula cos(iy) = cosh(y), and the return type is real.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the complex cosine of <code>z</code> is returned.</p><p>Errors and special cases are handled as if the operation is implemented by <code><a href="http://en.cppreference.com/w/c/numeric/complex/ccosh">ccosh</a>(I*z)</code>.</p></section>	http://en.cppreference.com/w/c/numeric/complex/ccos
ccoshf, ccosh, ccoshl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 ccoshf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0ccosh( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> ccoshl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define cosh( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex hyperbolic cosine of <code>z</code>.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ccoshl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ccosh</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ccoshf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>coshf</code>, <code>cosh</code>, <code>coshl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/cos" title="c/numeric/math/cos">cos</a>, implementing the formula cosh(iy) = cos(y), and the return type is real.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, complex hyperbolic cosine of <code>z</code> is returned</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>ccosh(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(ccosh(z))</code></li><li> <code>ccosh(z) == ccosh(-z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>1+0i</code></li><li> If <code>z</code> is <code>+0+\xe2\x88\x9ei</code>, the result is <code>NaN\xc2\xb10i</code> (the sign of the imaginary part is unspecified) and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>z</code> is <code>+0+NaNi</code>, the result is <code>NaN\xc2\xb10i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code> (for any finite non-zero x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite non-zero x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+0i</code>, the result is <code>+\xe2\x88\x9e+0i</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code> (for any finite non-zero y), the result is <code>+\xe2\x88\x9e+cis(y)</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code> (the sign of the real part is unspecified) and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+NaN</code>, the result is <code>+\xe2\x88\x9e+NaN</code></li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN\xc2\xb10i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite non-zero y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><p>where cis(y) is cos(y) + i sin(y)</p></section>	http://en.cppreference.com/w/c/numeric/complex/ccosh
cexpf, cexp, cexpl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 cexpf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0cexp( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> cexpl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define exp( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex base-<i>e</i> exponential of <code>z</code>.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cexpl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cexp</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cexpf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>expf</code>, <code>exp</code>, <code>expl</code>). If <code>z</code> is imaginary, the corresponding complex argument version is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, <i>e</i> raised to the power of <code>z</code>, ez<br/> is returned.</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>cexp(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(cexp(z))</code></li><li> If <code>z</code> is <code>\xc2\xb10+0i</code>, the result is <code>1+0i</code></li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code> (for any finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised.</li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised.</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+0i</code>, the result is <code>+\xe2\x88\x9e+0i</code></li><li> If <code>z</code> is <code>-\xe2\x88\x9e+yi</code> (for any finite y), the result is <code>+0+cis(y)</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code> (for any finite nonzero y), the result is <code>+\xe2\x88\x9e+cis(y)</code></li><li> If <code>z</code> is <code>-\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>\xc2\xb10\xc2\xb10i</code> (signs are unspecified)</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised (the sign of the real part is unspecified)</li><li> If <code>z</code> is <code>-\xe2\x88\x9e+NaNi</code>, the result is <code>\xc2\xb10\xc2\xb10i</code> (signs are unspecified)</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+NaNi</code>, the result is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code> (the sign of the real part is unspecified)</li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN+0i</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any nonzero y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><p>where cis(y) is cos(y) + i sin(y)</p></section>	http://en.cppreference.com/w/c/numeric/complex/cexp
cimagf, cimag, cimagl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 cimagf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0cimag( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double cimagl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define cimag( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Returns the imaginary part of <code>z</code>.</div><div>4) Type-generic macro: if <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>long double</code>, <code>cimagl</code> is called. If <code>z</code>  has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>float</code>, <code>cimagf</code> is called. If <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>double</code>, or any integer type, <code>cimag</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>The imaginary part of <code>z</code>.</p><p>This function is fully specified for all possible inputs and is not subject to any errors described in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p></section>	http://en.cppreference.com/w/c/numeric/complex/cimag
clogf, clog, clogl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 clogf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0clog( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> clogl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define log( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex natural (base-<i>e</i>) logarithm of <code>z</code> with branch cut along the negative real axis.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>clogl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>clog</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>clogf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>logf</code>, <code>log</code>, <code>logl</code>). If <code>z</code> is imaginary, the corresponding complex number version is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the complex natural logarithm of <code>z</code> is returned, in the range of a strip in the interval [\xe2\x88\x92i\xcf\x80, +i\xcf\x80] along the imaginary axis and mathematically unbounded along the real axis.</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> The function is continuous onto the branch cut taking into account the sign of imaginary part</li><li> <code>clog(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(clog(z))</code></li><li> If <code>z</code> is <code>-0+0i</code>, the result is <code>-\xe2\x88\x9e+\xcf\x80i</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised</li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>-\xe2\x88\x9e+0i</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised</li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code> (for any finite x), the result is <code>+\xe2\x88\x9e+\xcf\x80i/2</code></li><li> If <code>z</code> is <code>x+NaNi</code> (for any finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>-\xe2\x88\x9e+yi</code> (for any finite positive y), the result is <code>-\xe2\x88\x9e+\xcf\x80i</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code> (for any finite positive y), the result is <code>-\xe2\x88\x9e+0i</code></li><li> If <code>z</code> is <code>-\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>+\xe2\x88\x9e+3\xcf\x80i/4</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>+\xe2\x88\x9e+\xcf\x80i/4</code></li><li> If <code>z</code> is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code>, the result is <code>+\xe2\x88\x9e+NaNi</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+\xe2\x88\x9ei</code>, the result is <code>+\xe2\x88\x9e+NaNi</code></li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul></section>	http://en.cppreference.com/w/c/numeric/complex/clog
CMPLXF, CMPLX, CMPLXL	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 CMPLXF( float real, float imag );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0CMPLX( double real, double imag );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> CMPLXL( long double real, long double imag );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of <code>real</code> (converted to the specified argument type) and the imaginary part having the value of <code>imag</code> (converted to the specified argument type)</p><p>The expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions <code>real</code> and <code>imag</code> are also suitable.</p><span class="prog__sub"> Parameters</span><table><tr><td>  real</td><td> -</td><td>  the real part of the complex number to return</td></tr><tr><td>  imag</td><td> -</td><td>  the imaginary part of the complex number to return</td></tr></table><span class="prog__sub"> Return value</span><p>A complex number composed of <code>real</code> and <code>imag</code> as the real and imaginary parts.</p></section>	http://en.cppreference.com/w/c/numeric/complex/CMPLX
complex	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define complex _Complex</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>This macro expands to a type specifier used to identify <a href="http://en.cppreference.com/w/c/language/arithmetic_types#Complex_floating_types" title="c/language/arithmetic types">complex types</a>.</p><p>A program may undefine and perhaps then redefine the <strong class="selflink">complex</strong> macro.</p></section>	http://en.cppreference.com/w/c/numeric/complex/complex
_Complex_I	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define _Complex_I /* unspecified */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>_Complex_I</code> macro expands to a value of type <code>const float _Complex</code> with the value of the imaginary unit.</p></section>	http://en.cppreference.com/w/c/numeric/complex/Complex_I
conjf, conj, conjl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 conjf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0conj( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> conjl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define conj( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the <a class="extiw" href="http://en.wikipedia.com/wiki/Complex_conjugate" title="enwiki:Complex conjugate">complex conjugate</a> of <code>z</code> by reversing the sign of the imaginary part.</div><div>4) Type-generic macro: if <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>long double</code>, <code>conjl</code> is called. If <code>z</code>  has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>float</code>, <code>conjf</code> is called. If <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>double</code>, or any integer type, <code>conj</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>The complex conjugate of <code>z</code>.</p></section>	http://en.cppreference.com/w/c/numeric/complex/conj
cpowf, cpow, cpowl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 cpowf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> x, float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> y );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0cpow( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> x, double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> y );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> cpowl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> x, long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define pow( x, y )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex power function xy<br/>, with branch cut for the first parameter along the negative real axis.</div><div>4) Type-generic macro: If any argument has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cpowl</code> is called. if any argument has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cpow</code> is called, if any argument has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>cpowf</code> is called. If the arguments are real or integer, then the macro invokes the corresponding real function (<code>powf</code>, <code>pow</code>, <code>powl</code>). If any argument is imaginary, the corresponding complex number version is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the complex power xy<br/>, is returned.</p><p>Errors and special cases are handled as if the operation is implemented by <code><a href="http://en.cppreference.com/w/c/numeric/complex/cexp">cexp</a>(y*<a href="http://en.cppreference.com/w/c/numeric/complex/clog">clog</a>(x))</code>, except that the implementation is allowed to treat special cases more carefully.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;complex.h&gt;\xc2\xa0int main(void){        double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z = cpow(1.0+2.0*I, 2);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("(1+2i)^2 =\xc2\xa0%.1f%+.1fi\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z));\xc2\xa0    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z2 = cpow(-1, 0.5);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("(-1+0i)^0.5 =\xc2\xa0%.1f%+.1fi\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z2), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z2));\xc2\xa0    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z3 = cpow(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(-1), 0.5); // other side of the cut    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("(-1-0i)^0.5 =\xc2\xa0%.1f%+.1fi\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z3), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z3));\xc2\xa0    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z4 = cpow(I, I); // i^i = exp(-pi/2)    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("i^i =\xc2\xa0%f%+fi\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z4), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z4));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>(1+2i)^2 = -3.0+4.0i<br>(-1+0i)^0.5 = 0.0+1.0i<br>(-1-0i)^0.5 = 0.0-1.0i<br>i^i = 0.207880+0.000000i</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/complex/cpow
cprojf, cproj, cprojl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 cprojf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0cproj( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double cprojl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define cproj( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the projection of <code>z</code> on the Riemann sphere.</div><div>4) Type-generic macro: if <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>long double</code>, <code>cprojl</code> is called. If <code>z</code>  has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>float</code>, <code>cprojf</code> is called. If <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>double</code>, or any integer type, <code>cproj</code> is called.</div><p>For most <code>z</code>, <code>cproj(z)==z</code>, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, <code>INFINITY+0.0*I</code> or <code>INFINITY-0.0*I</code>. The sign of the imaginary (zero) component is the sign of <code><a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z)</code>. </p><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>The projection of <code>z</code> on the Riemann sphere.</p><p>This function is fully specified for all possible inputs and is not subject to any errors described in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p></section>	http://en.cppreference.com/w/c/numeric/complex/cproj
crealf, creal, creall	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 crealf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0creal( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double creall( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define creal( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Returns the real part of <code>z</code>.</div><div>4) Type-generic macro: if <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>long double</code>, <code>creall</code> is called. If <code>z</code>  has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, or <code>float</code>, <code>crealf</code> is called. If <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/imaginary">imaginary</a></code>, <code>double</code>, or any integer type, <code>creal</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>The real part of <code>z</code>.</p><p>This function is fully specified for all possible inputs and is not subject to any errors described in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p></section>	http://en.cppreference.com/w/c/numeric/complex/creal
csinf, csin, csinl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 csinf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0csin( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> csinl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define sin( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex sine of <code>z</code>.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csinl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csin</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csinf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>sinf</code>, <code>sin</code>, <code>sinl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/sinh" title="c/numeric/math/sinh">sinh</a>, implementing the formula sin(iy) = i sinh(y), and the return type of the macro is imaginary.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the complex sine of <code>z</code>.</p><p>Errors and special cases are handled as if the operation is implemented by <code>-I * <a href="http://en.cppreference.com/w/c/numeric/complex/csinh">csinh</a>(I*z)</code></p></section>	http://en.cppreference.com/w/c/numeric/complex/csin
csinhf, csinh, csinhl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 csinhf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0csinh( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> csinhl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define sinh( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex hyperbolic sine of <code>z</code>.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csinhl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csinh</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csinhf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>sinhf</code>, <code>sinh</code>, <code>sinhl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/sin" title="c/numeric/math/sin">sin</a>, implementing the formula sinh(iy) = i sin(y), and the return type is imaginary.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, complex hyperbolic sine of <code>z</code> is returned</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>csinh(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(csinh(z))</code></li><li> <code>csinh(z) == -csinh(-z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>+0+\xe2\x88\x9ei</code>, the result is <code>\xc2\xb10+NaNi</code> (the sign of the real part is unspecified) and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>z</code> is <code>+0+NaNi</code>, the result is <code>\xc2\xb10+NaNi</code></li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code> (for any positive finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>z</code> is <code>x+NaNi</code> (for any positive finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+0i</code>, the result is <code>+\xe2\x88\x9e+0i</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code> (for any positive finite y), the result is <code>+\xe2\x88\x9e+cis(y)</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code> (the sign of the real part is  unspecified) and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+NaNi</code>, the result is <code>\xc2\xb1\xe2\x88\x9e+NaNi</code> (the sign of the real part is  unspecified)</li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN+0i</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any finite nonzero y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><p>where cis(y) is cos(y) + i sin(y)</p></section>	http://en.cppreference.com/w/c/numeric/complex/csinh
csqrtf, csqrt, csqrtl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 csqrtf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0csqrt( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> csqrtl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define sqrt( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex square root of <code>z</code> with branch cut along the negative real axis.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csqrtl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csqrt</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>csqrtf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>sqrtf</code>, <code>sqrt</code>, <code>sqrtl</code>). If <code>z</code> is imaginary, the corresponding complex number version is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, returns the square root of <code>z</code>, in the range of the right half-plane, including the imaginary axis ([0; +\xe2\x88\x9e) along the real axis and (\xe2\x88\x92\xe2\x88\x9e; +\xe2\x88\x9e) along the imaginary axis.)</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> The function is continuous onto the branch cut taking into account the sign of imaginary part</li><li> <code>csqrt(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(csqrt(z))</code></li><li> If <code>z</code> is <code>\xc2\xb10+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code>, the result is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code> even if x is NaN</li><li> If <code>z</code> is <code>x+NaNi</code>, the result is <code>NaN+NaNi</code> (unless x is \xc2\xb1\xe2\x88\x9e) and  <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>-\xe2\x88\x9e+yi</code>, the result is <code>+0+\xe2\x88\x9ei</code> for finite positive y</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code>, the result is <code>+\xe2\x88\x9e+0i)</code> for finite positive y</li><li> If <code>z</code> is <code>-\xe2\x88\x9e+NaNi</code>, the result is <code>NaN\xc2\xb1\xe2\x88\x9e</code> (sign of imaginary part unspecified)</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+NaNi</code>, the result is <code>+\xe2\x88\x9e+NaNi</code></li><li> If <code>z</code> is <code>NaN+yi</code>, the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;complex.h&gt;\xc2\xa0int main(void){    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z1 = csqrt(-4);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Square root of -4 is\xc2\xa0%.1f%+.1fi\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z1), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z1));\xc2\xa0    double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z2 = csqrt(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(-4)); // or, in C11, CMPLX(-4, -0.0)    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Square root of -4-0i, the other side of the cut, is "           "%.1f%+.1fi\n", <a href="http://en.cppreference.com/w/c/numeric/complex/creal">creal</a>(z2), <a href="http://en.cppreference.com/w/c/numeric/complex/cimag">cimag</a>(z2));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Square root of -4 is 0.0+2.0i<br>Square root of -4-0i, the other side of the cut, is 0.0-2.0i</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/complex/csqrt
ctanf, ctan, ctanl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 ctanf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0ctan( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> ctanl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define tan( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex tangent of <code>z</code>.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ctanl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ctan</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ctanf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>tanf</code>, <code>tan</code>, <code>tanl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/tanh" title="c/numeric/math/tanh">tanh</a>, implementing the formula tan(iy) = i tanh(y), and the return type is imaginary.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the complex tangent of <code>z</code> is returned.</p><p>Errors and special cases are handled as if the operation is implemented by <code>-i * <a href="http://en.cppreference.com/w/c/numeric/complex/ctanh">ctanh</a>(i*z)</code>, where <code>i</code> is the imaginary unit.</p></section>	http://en.cppreference.com/w/c/numeric/complex/ctan
ctanhf, ctanh, ctanhl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0 ctanhf( float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> \xc2\xa0 \xc2\xa0 \xc2\xa0ctanh( double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> ctanhl( long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a> z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define tanh( z )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the complex hyperbolic tangent of <code>z</code>.</div><div>4) Type-generic macro: If <code>z</code> has type <code>long double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ctanhl</code> is called. if <code>z</code> has type <code>double <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ctanh</code> is called, if <code>z</code> has type <code>float <a href="http://en.cppreference.com/w/c/numeric/complex/complex">complex</a></code>, <code>ctanhf</code> is called. If <code>z</code> is real or integer, then the macro invokes the corresponding real function (<code>tanhf</code>, <code>tanh</code>, <code>tanhl</code>). If <code>z</code> is imaginary, then the macro invokes the corresponding real version of the function <a href="http://en.cppreference.com/w/c/numeric/math/tan" title="c/numeric/math/tan">tan</a>, implementing the formula tanh(iy) = i tan(y), and the return type is imaginary.</div><span class="prog__sub"> Parameters</span><table><tr><td>  z</td><td> -</td><td>  complex argument</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, complex hyperbolic tangent of <code>z</code> is returned</p><span class="prog__sub"> Error handling and special values</span><p>Errors are reported consistent with <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a></p><p>If the implementation supports IEEE floating-point arithmetic,<br></p><ul><li> <code>ctanh(<a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(z)) == <a href="http://en.cppreference.com/w/c/numeric/complex/conj">conj</a>(ctanh(z))</code></li><li> <code>ctanh(-z) == -ctanh(z)</code></li><li> If <code>z</code> is <code>+0+0i</code>, the result is <code>+0+0i</code></li><li> If <code>z</code> is <code>x+\xe2\x88\x9ei</code> (for any<sup class="reference" id="cite_ref-1">[1]</sup> finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>z</code> is <code>x+NaN</code> (for any<sup class="reference" id="cite_ref-2">[2]</sup> finite x), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+yi</code> (for any finite positive y), the result is <code>1+0i</code></li><li> If <code>z</code> is <code>+\xe2\x88\x9e+\xe2\x88\x9ei</code>, the result is <code>1\xc2\xb10i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>+\xe2\x88\x9e+NaNi</code>, the result is <code>1\xc2\xb10i</code> (the sign of the imaginary part is unspecified)</li><li> If <code>z</code> is <code>NaN+0i</code>, the result is <code>NaN+0i</code></li><li> If <code>z</code> is <code>NaN+yi</code> (for any non-zero y), the result is <code>NaN+NaNi</code> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If <code>z</code> is <code>NaN+NaNi</code>, the result is <code>NaN+NaNi</code></li></ul><ol class="references"><li id="cite_note-1"><a href="#cite_ref-1">\xe2\x86\x91</a> per <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471" rel="nofollow">DR471</a>, this only holds for non-zero x. If <code>z</code> is <code>0+\xe2\x88\x9ei</code>, the result should be <code>0+NaNi</code></li><li id="cite_note-2"><a href="#cite_ref-2">\xe2\x86\x91</a> per <a class="external text" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471" rel="nofollow">DR471</a>, this only holds for non-zero x. If <code>z</code> is <code>0+NaNi</code>, the result should be <code>0+NaNi</code></li></ol></section>	http://en.cppreference.com/w/c/numeric/complex/ctanh
imaginary	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define imaginary _Imaginary</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>This macro expands to the keyword <a href="http://en.cppreference.com/w/c/keyword/_Imaginary" title="c/keyword/ Imaginary">_Imaginary</a>.</p><p>This is a convenience macro that makes it possible to use <code>float imaginary</code>, <code>double imaginary</code>, and <code>long double imaginary</code> as an alternative way to write the three pure imaginary C types <code>float _Imaginary</code>, <code>double _Imaginary</code>, and <code>long double _Imaginary</code></p><p>As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.<br></p><table><tr><td><p>A compiler that defines <code>__STDC_IEC_559_COMPLEX__</code> is not required to support imaginary numbers. POSIX recommends checking if the macro <code>_Imaginary_I</code> is defined to identify imaginary number support.</p></td><td>(since C99)<br/>(until C11)</td></tr><tr><td><p>Imaginary numbers are supported if <code>__STDC_IEC_559_COMPLEX__</code> is defined.</p></td><td>(since C11)</td></tr></table></section>	http://en.cppreference.com/w/c/numeric/complex/imaginary
_Imaginary_I	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;complex.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define _Imaginary_I /* unspecified */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>_Imaginary_I</code> macro expands to a value of type <code>const float _Imaginary</code> with the value of the imaginary unit.</p><p>As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.<br></p><table><tr><td><p>A compiler that defines <code>__STDC_IEC_559_COMPLEX__</code> is not required to support imaginary numbers. POSIX recommends checking if the macro <code>_Imaginary_I</code> is defined to identify imaginary number support.</p></td><td>(since C99)<br/>(until C11)</td></tr><tr><td><p>Imaginary numbers are supported if <code>__STDC_IEC_559_COMPLEX__</code> is defined.</p></td><td>(since C11)</td></tr></table></section>	http://en.cppreference.com/w/c/numeric/complex/Imaginary_I
FE_DFL_ENV	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define FE_DFL_ENV \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The macro constant <strong class="selflink">FE_DFL_ENV</strong> expands to an expression of type <code>const fenv_t*</code>, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</p><p>Additional macros that begin with <code>FE_</code> followed by uppercase letters, and have the type <code>const fenv_t*</code>, may be supported by an implementation.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;fenv.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ON\xc2\xa0void show_fe_exceptions(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current exceptions raised: ");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_DIVBYZERO");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INEXACT");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INVALID");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a>))      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_OVERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_UNDERFLOW</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_UNDERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>)==0) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" none");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0void show_fe_rounding_method(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current rounding method:    ");    switch (<a href="http://en.cppreference.com/w/c/numeric/fenv/feround">fegetround</a>()) {           case <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_TONEAREST</a>:  <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("FE_TONEAREST");  break;           case <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_DOWNWARD</a>:   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("FE_DOWNWARD");   break;           case <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_UPWARD</a>:     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("FE_UPWARD");     break;           case <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_TOWARDZERO</a>: <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("FE_TOWARDZERO"); break;           default:            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("unknown");    };    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0void show_fe_environment(void){    show_fe_exceptions();    show_fe_rounding_method();} \xc2\xa0int main(){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("On startup:\n");    show_fe_environment();\xc2\xa0    // Change environment    <a href="http://en.cppreference.com/w/c/numeric/fenv/feround">fesetround</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_DOWNWARD</a>);     // change rounding mode    <a href="http://en.cppreference.com/w/c/numeric/fenv/feraiseexcept">feraiseexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>);   // raise exception    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\nBefore restoration:\n");    show_fe_environment();\xc2\xa0    <a href="http://en.cppreference.com/w/c/numeric/fenv/feenv">fesetenv</a>(FE_DFL_ENV);    // restore    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\nAfter restoring default environment:\n");    show_fe_environment();}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>On startup:<br>current exceptions raised:  none<br>current rounding method:    FE_TONEAREST<br>\xc2\xa0<br>Before restoration:<br>current exceptions raised:  FE_INVALID<br>current rounding method:    FE_DOWNWARD<br>\xc2\xa0<br>After restoring default environment:<br>current exceptions raised:  none<br>current rounding method:    FE_TONEAREST</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/FE_DFL_ENV
FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define FE_DIVBYZERO \xc2\xa0 \xc2\xa0/*implementation defined power of 2*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FE_INEXACT \xc2\xa0 \xc2\xa0 \xc2\xa0/*implementation defined power of 2*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FE_INVALID \xc2\xa0 \xc2\xa0 \xc2\xa0/*implementation defined power of 2*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FE_OVERFLOW \xc2\xa0 \xc2\xa0 /*implementation defined power of 2*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FE_UNDERFLOW \xc2\xa0 \xc2\xa0/*implementation defined power of 2*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FE_ALL_EXCEPT \xc2\xa0FE_DIVBYZERO | FE_INEXACT | \\<br/><p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0FE_INVALID | FE_OVERFLOW | \xc2\xa0\\<br/></p>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0FE_UNDERFLOW</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>All these macro constants (except <strong class="selflink">FE_ALL_EXCEPT</strong>) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported. </p><p>The macro constant <strong class="selflink">FE_ALL_EXCEPT</strong>, which expands to the bitwise OR of all other <code>FE_*</code>, is always defined and is zero if floating-point exceptions are not supported by the implementation.</p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>FE_DIVBYZERO</code></td><td>  pole error occurred in an earlier floating-point operation</td></tr><tr><td> <code>FE_INEXACT</code></td><td>  inexact result: rounding was necessary to store the result of an earlier floating-point operation</td></tr><tr><td> <code>FE_INVALID</code></td><td>  domain error occurred in an earlier floating-point operation</td></tr><tr><td> <code>FE_OVERFLOW</code></td><td>  the result of an earlier floating-point operation was too large to be representable</td></tr><tr><td> <code>FE_UNDERFLOW</code></td><td>  the result of an earlier floating-point operation was subnormal with a loss of precision</td></tr><tr><td> <code>FE_ALL_EXCEPT</code></td><td>  bitwise OR of all supported floating-point exceptions</td></tr></table><p>The implementation may define additional macro constants in <code>&lt;fenv.h&gt;</code> to identify additional floating-point exceptions. All such constants begin with <code>FE_</code> followed by at least one uppercase letter.</p><p>See <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a> for further details.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;#include &lt;fenv.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ONvoid show_fe_exceptions(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("exceptions raised:");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(FE_DIVBYZERO)) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_DIVBYZERO");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(FE_INEXACT))   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INEXACT");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(FE_INVALID))   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INVALID");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(FE_OVERFLOW))  <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_OVERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(FE_UNDERFLOW)) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_UNDERFLOW");    <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(FE_ALL_EXCEPT);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("MATH_ERREXCEPT is\xc2\xa0%s\n",           math_errhandling &amp; MATH_ERREXCEPT ? "set" : "not set");\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("0.0/0.0 =\xc2\xa0%f\n", 0.0/0.0);    show_fe_exceptions();\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0/0.0 =\xc2\xa0%f\n", 1.0/0.0);    show_fe_exceptions();\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0/10.0 =\xc2\xa0%f\n", 1.0/10.0);    show_fe_exceptions();\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("sqrt(-1) =\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(-1));    show_fe_exceptions();\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("DBL_MAX*2.0 =\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a>*2.0);    show_fe_exceptions();\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("nextafter(DBL_MIN/pow(2.0,52),0.0) =\xc2\xa0%.1f\n",                      <a href="http://en.cppreference.com/w/c/numeric/math/nextafter">nextafter</a>(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MIN</a>/<a href="http://en.cppreference.com/w/c/numeric/math/pow">pow</a>(2.0,52),0.0));    show_fe_exceptions();}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>MATH_ERREXCEPT is set<br>0.0/0.0 = nan<br>exceptions raised: FE_INVALID<br>1.0/0.0 = inf<br>exceptions raised: FE_DIVBYZERO<br>1.0/10.0 = 0.100000<br>exceptions raised: FE_INEXACT<br>sqrt(-1) = -nan<br>exceptions raised: FE_INVALID<br>DBL_MAX*2.0 = inf<br>exceptions raised: FE_INEXACT FE_OVERFLOW<br>nextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0<br>exceptions raised: FE_INEXACT FE_UNDERFLOW</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions
FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define FE_DOWNWARD \xc2\xa0 \xc2\xa0 /*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FE_TONEAREST \xc2\xa0 \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FE_TOWARDZERO \xc2\xa0 /*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FE_UPWARD \xc2\xa0 \xc2\xa0 \xc2\xa0 /*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Each of these macro constants expands to a nonnegative integer constant expression, which can be used with <a href="http://en.cppreference.com/w/c/numeric/fenv/feround" title="c/numeric/fenv/feround">fesetround</a> and <a href="http://en.cppreference.com/w/c/numeric/fenv/feround" title="c/numeric/fenv/feround">fegetround</a> to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in <code>&lt;fenv.h&gt;</code>, which should all begin with <code>FE_</code> followed by at least one uppercase letter. Each macro is only defined if it is supported.</p><p>On most implementations, these macro constants expand to the values equal to the values of <a href="http://en.cppreference.com/w/c/types/limits/FLT_ROUNDS" title="c/types/limits/FLT ROUNDS">FLT_ROUNDS</a> and <code>float_round_style</code></p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>FE_DOWNWARD</code></td><td>  rounding towards negative infinity</td></tr><tr><td> <code>FE_TONEAREST</code></td><td>  rounding towards nearest integer</td></tr><tr><td> <code>FE_TOWARDZERO</code></td><td>  rounding towards zero</td></tr><tr><td> <code>FE_UPWARD</code></td><td>  rounding towards positive infinity</td></tr></table><p>Additional rounding modes may be supported by an implementation.<br></p><p>The current rounding mode affects the following:<br></p><ul><li> results of floating-point arithmetic operators outside of constant expressions</li></ul><div><div><pre><code>double x = 1;x/10; // 0.09999999999999999167332731531132594682276248931884765625   // or 0.1000000000000000055511151231257827021181583404541015625</code></pre></div></div><ul><li> results of standard library <a href="http://en.cppreference.com/w/c/numeric/math" title="c/numeric/math">mathematical functions</a></li></ul><div><div><pre><code><a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(2); // 1.41421356237309492343001693370752036571502685546875      // or 1.4142135623730951454746218587388284504413604736328125</code></pre></div></div><ul><li> floating-point to floating-point implicit conversion and casts</li></ul><div><div><pre><code>double d = 1 + <a href="http://en.cppreference.com/w/c/types/limits">DBL_EPSILON</a>;float f = d; //  1.00000000000000000000000           // or 1.00000011920928955078125</code></pre></div></div><ul><li> string conversions such as <a href="http://en.cppreference.com/w/c/string/byte/strtof" title="c/string/byte/strtof">strtod</a> or <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">printf</a></li></ul><div><div><pre><code><a href="http://en.cppreference.com/w/c/string/byte/strtof">strtof</a>("0.1", <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>); // 0.0999999940395355224609375                  // or 0.100000001490116119384765625</code></pre></div></div><ul><li> the library rounding functions <a href="http://en.cppreference.com/w/c/numeric/math/nearbyint" title="c/numeric/math/nearbyint">nearbyint</a>, <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint">rint</a>, <a href="http://en.cppreference.com/w/c/numeric/math/rint" title="c/numeric/math/rint">lrint</a></li></ul><div><div><pre><code><a href="http://en.cppreference.com/w/c/numeric/math/rint">lrint</a>(2.1); // 2 or 3</code></pre></div></div><p>The current rounding mode does NOT affect the following:<br></p><ul><li> floating-point to integer implicit conversion and casts (always towards zero)</li><li> results of floating-point arithmetic operators in constant expressions (always to nearest)</li><li> the library functions <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round">round</a>, <a href="http://en.cppreference.com/w/c/numeric/math/round" title="c/numeric/math/round">lround</a>, <a href="http://en.cppreference.com/w/c/numeric/math/ceil" title="c/numeric/math/ceil">ceil</a>, <a href="http://en.cppreference.com/w/c/numeric/math/floor" title="c/numeric/math/floor">floor</a>, <a href="http://en.cppreference.com/w/c/numeric/math/trunc" title="c/numeric/math/trunc">trunc</a></li></ul><p>As with any <a href="http://en.cppreference.com/w/c/numeric/fenv" title="c/numeric/fenv">floating-point environment</a> functionality, rounding is only guaranteed if <code>#pragma STDC FENV_ACCESS ON</code> is set.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fenv.h&gt;#include &lt;math.h&gt;int main(){#pragma STDC FENV_ACCESS ON    <a href="http://en.cppreference.com/w/c/numeric/fenv/feround">fesetround</a>(FE_DOWNWARD);    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("rounding down: ");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("           pi =\xc2\xa0%.22f\n", acosf(-1));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("strtof("1.1") =\xc2\xa0%.22f\n", <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtof</a>("1.1", <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("    rint(2.1) =\xc2\xa0%.22f\n\n", rintf(2.1));    <a href="http://en.cppreference.com/w/c/numeric/fenv/feround">fesetround</a>(FE_UPWARD);    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("rounding up: ");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("           pi =\xc2\xa0%.22f\n", acosf(-1));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("strtof("1.1") =\xc2\xa0%.22f\n", <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtof</a>("1.1", <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("    rint(2.1) =\xc2\xa0%.22f\n", rintf(2.1));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>rounding down: <br>           pi = 3.1415925025939941406250<br>strtof("1.1") = 1.0999999046325683593750<br>    rint(2.1) = 2.0000000000000000000000<br>\xc2\xa0<br>rounding up: <br>           pi = 3.1415927410125732421875<br>strtof("1.1") = 1.1000000238418579101563<br>    rint(2.1) = 3.0000000000000000000000</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/FE_round
feclearexcept	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int feclearexcept( int excepts );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Attempts to clear the floating-point exceptions that are listed in the bitmask argument <code>excepts</code>, which is a bitwise OR of the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">floating point exception macros</a>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  excepts</td><td> -</td><td>  bitmask listing the exception flags to clear</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if all indicated exceptions were successfully cleared or if <code>excepts</code> is zero. Returns a non-zero value on error.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;fenv.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;\xc2\xa0/* * A possible implementation of hypot which makes use of many advanced * floating point features. */double hypot_demo(double a, double b) {  const int range_problem = <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a> | <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_UNDERFLOW</a>;  feclearexcept(range_problem);  // try a fast algorithm  double result = <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(a * a + b * b);  if (!<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(range_problem))  // no overflow or underflow    return result;                   // return the fast result  // do a more complicated calculation to avoid overflow or underflow  int a_exponent,b_exponent;  <a href="http://en.cppreference.com/w/c/numeric/math/frexp">frexp</a>(a, &amp;a_exponent);  <a href="http://en.cppreference.com/w/c/numeric/math/frexp">frexp</a>(b, &amp;b_exponent);\xc2\xa0  if (a_exponent - b_exponent &gt; <a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX_EXP</a>)    return <a href="http://en.cppreference.com/w/c/numeric/math/fabs">fabs</a>(a) + <a href="http://en.cppreference.com/w/c/numeric/math/fabs">fabs</a>(b);        // we can ignore the smaller value  // scale so that fabs(a) is near 1  double a_scaled = <a href="http://en.cppreference.com/w/c/numeric/math/scalbn">scalbn</a>(a, -a_exponent);  double b_scaled = <a href="http://en.cppreference.com/w/c/numeric/math/scalbn">scalbn</a>(b, -a_exponent);  // overflow and underflow is now impossible   result = <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(a_scaled * a_scaled + b_scaled * b_scaled);  // undo scaling  return <a href="http://en.cppreference.com/w/c/numeric/math/scalbn">scalbn</a>(result, a_exponent);}\xc2\xa0int main(void){  // Normal case takes the fast route  <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("hypot(%f,\xc2\xa0%f) =\xc2\xa0%f\n", 3.0, 4.0, hypot_demo(3.0, 4.0));  // Extreme case takes the slow but more accurate route  <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("hypot(%e,\xc2\xa0%e) =\xc2\xa0%e\n", <a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a> / 2.0,                                 <a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a> / 2.0,                                 hypot_demo(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a> / 2.0, <a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a> / 2.0));\xc2\xa0  return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>hypot(3.000000, 4.000000) = 5.000000<br>hypot(8.988466e+307, 8.988466e+307) = 1.271161e+308</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/feclearexcept
fegetenv, fesetenv	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fegetenv( fenv_t* envp );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>int fesetenv( const fenv_t* envp );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>1) Attempts to store the status of the floating-point environment in the object pointed to by <code>envp</code>.</p><p>2) Attempts to establish the floating-point environment from the object pointed to by <code>envp</code>. The value of that object must be previously obtained by a call to <a href="http://en.cppreference.com/w/c/numeric/fenv/feholdexcept" title="c/numeric/fenv/feholdexcept">feholdexcept</a> or <code>fegetenv</code> or be a floating-point macro constant. If any of the floating-point status flags are set in <code>envp</code>, they become set in the environment (and are then testable with <a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept" title="c/numeric/fenv/fetestexcept">fetestexcept</a>), but the corresponding floating-point exceptions are not raised (execution continues uninterrupted)</p><span class="prog__sub"> Parameters</span><table><tr><td>  envp</td><td> -</td><td>  pointer to the object of type <code>fenv_t</code> which holds the status of the floating-point environment</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> on success, non-zero otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;fenv.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ON\xc2\xa0void show_fe_exceptions(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current exceptions raised: ");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_DIVBYZERO");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INEXACT");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INVALID");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a>))      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_OVERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_UNDERFLOW</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_UNDERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>)==0) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" none");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0void show_fe_rounding_method(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current rounding method:    ");    switch (<a href="http://en.cppreference.com/w/c/numeric/fenv/feround">fegetround</a>()) {           case <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_TONEAREST</a>:  <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("FE_TONEAREST");  break;           case <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_DOWNWARD</a>:   <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("FE_DOWNWARD");   break;           case <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_UPWARD</a>:     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("FE_UPWARD");     break;           case <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_TOWARDZERO</a>: <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("FE_TOWARDZERO"); break;           default:            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("unknown");    };    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0void show_fe_environment(void){    show_fe_exceptions();    show_fe_rounding_method();}    \xc2\xa0int main(void){    fenv_t curr_env;    int rtn;\xc2\xa0    /* Show default environment. */    show_fe_environment();    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");\xc2\xa0    /* Perform some computation under default environment. */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("+11.5 -&gt;\xc2\xa0%+4.1f\n", <a href="http://en.cppreference.com/w/c/numeric/math/rint">rint</a>(+11.5)); /* midway between two integers */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("+12.5 -&gt;\xc2\xa0%+4.1f\n", <a href="http://en.cppreference.com/w/c/numeric/math/rint">rint</a>(+12.5)); /* midway between two integers */    show_fe_environment();    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");\xc2\xa0    /* Save current environment. */    rtn = fegetenv(&amp;curr_env);\xc2\xa0    /* Perform some computation with new rounding method. */    <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/numeric/fenv/feround">fesetround</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round">FE_DOWNWARD</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0/0.0 =\xc2\xa0%f\n", 1.0/0.0);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("+11.5 -&gt;\xc2\xa0%+4.1f\n", <a href="http://en.cppreference.com/w/c/numeric/math/rint">rint</a>(+11.5));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("+12.5 -&gt;\xc2\xa0%+4.1f\n", <a href="http://en.cppreference.com/w/c/numeric/math/rint">rint</a>(+12.5));    show_fe_environment();    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");\xc2\xa0    /* Restore previous environment. */    rtn = fesetenv(&amp;curr_env);    show_fe_environment();\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>current exceptions raised: none<br>current rounding method:   FE_TONEAREST<br>\xc2\xa0<br>+11.5 -&gt; +12.0<br>+12.5 -&gt; +12.0<br>current exceptions raised: FE_INEXACT<br>current rounding method:   FE_TONEAREST<br>\xc2\xa0<br>1.0/0.0 = inf<br>+11.5 -&gt; +11.0<br>+12.5 -&gt; +12.0<br>current exceptions raised: FE_DIVBYZERO FE_INEXACT<br>current rounding method:   FE_DOWNWARD<br>\xc2\xa0<br>current exceptions raised: FE_INEXACT<br>current rounding method:   FE_TONEAREST</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/feenv
fegetexceptflag, fesetexceptflag	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fegetexceptflag( fexcept_t* flagp, int excepts );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>int fesetexceptflag( const fexcept_t* flagp, int excepts );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument <code>excepts</code>, which is a bitwise OR of the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">floating point exception macros</a>. </p><p>2) Attempts to copy the full contents of the floating-point exception flags that are listed in <code>excepts</code> from <code>flagp</code> into the floating-point environment. Does not raise any exceptions, only modifies the flags.</p><p>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in <code>flagp</code> in implementation-defined format.</p><span class="prog__sub"> Parameters</span><table><tr><td>  flagp</td><td> -</td><td>  pointer to an <code>fexcept_t</code> object where the flags will be stored or read from</td></tr><tr><td>  excepts</td><td> -</td><td>  bitmask listing the exception flags to get/set</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> on success, non-zero otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;fenv.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ON\xc2\xa0void show_fe_exceptions(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current exceptions raised: ");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_DIVBYZERO");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INEXACT");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INVALID");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a>))      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_OVERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_UNDERFLOW</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_UNDERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>)==0) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" none");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0int main(void){    fexcept_t excepts;\xc2\xa0    /* Setup a "current" set of exception flags. */    <a href="http://en.cppreference.com/w/c/numeric/fenv/feraiseexcept">feraiseexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>);    show_fe_exceptions();\xc2\xa0    /* Save current exception flags. */    fegetexceptflag(&amp;excepts,<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);\xc2\xa0    /* Temporarily raise two other exceptions. */    <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/numeric/fenv/feraiseexcept">feraiseexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a> | <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>);    show_fe_exceptions();\xc2\xa0    /* Restore previous exception flags. */    fesetexceptflag(&amp;excepts,<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    show_fe_exceptions();\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>current exceptions raised: FE_INVALID<br>current exceptions raised: FE_INEXACT FE_OVERFLOW<br>current exceptions raised: FE_INVALID</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/feexceptflag
feholdexcept	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int feholdexcept( fenv_t* envp );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>First, saves the current floating-point environment to the object pointed to by <code>envp</code> (similar to <a href="http://en.cppreference.com/w/c/numeric/fenv/feenv" title="c/numeric/fenv/feenv">fegetenv</a>), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by <a href="http://en.cppreference.com/w/c/numeric/fenv/feupdateenv" title="c/numeric/fenv/feupdateenv">feupdateenv</a> or <a href="http://en.cppreference.com/w/c/numeric/fenv/feenv" title="c/numeric/fenv/feenv">fesetenv</a>.</p><p>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to <a href="http://en.cppreference.com/w/c/numeric/fenv/feupdateenv" title="c/numeric/fenv/feupdateenv">feupdateenv</a> after clearing the unwanted exceptions.</p><span class="prog__sub"> Parameters</span><table><tr><td>  envp</td><td> -</td><td>  pointer to the object of type <code>fenv_t</code> where the floating-point environment will be stored</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> on success, non-zero otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;fenv.h&gt;#include &lt;float.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ON\xc2\xa0void show_fe_exceptions(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current exceptions raised: ");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_DIVBYZERO");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INEXACT");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INVALID");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a>))      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_OVERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_UNDERFLOW</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_UNDERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>)==0) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" none");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0double x2 (double x)   /* times two */{    fenv_t curr_excepts;\xc2\xa0    /* Save and clear current f-p environment. */    feholdexcept(&amp;curr_excepts);\xc2\xa0    /* Raise inexact and overflow exceptions. */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In x2():  x =\xc2\xa0%f\n", x=x*2.0);    show_fe_exceptions();    <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>);   /* hide inexact exception from caller */\xc2\xa0    /* Merge caller's exceptions (FE_INVALID)        */    /* with remaining x2's exceptions (FE_OVERFLOW). */    <a href="http://en.cppreference.com/w/c/numeric/fenv/feupdateenv">feupdateenv</a>(&amp;curr_excepts);    return x;}\xc2\xa0int main(void){        <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/numeric/fenv/feraiseexcept">feraiseexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>);   /* some computation with invalid argument */    show_fe_exceptions();    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("x2(DBL_MAX) =\xc2\xa0%f\n", x2(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a>));    show_fe_exceptions();\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>current exceptions raised:  FE_INVALID<br>In x2():  x = inf<br>current exceptions raised:  FE_INEXACT FE_OVERFLOW<br>x2(DBL_MAX) = inf<br>current exceptions raised:  FE_INVALID FE_OVERFLOW</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/feholdexcept
feraiseexcept	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int feraiseexcept( int excepts );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Attempts to raise all floating point exceptions listed in <code>excepts</code> (a bitwise OR of the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">floating point exception macros</a>). If one of the exceptions is <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_OVERFLOW</a> or <code>FE_UNDERFLOW</code>, this function may additionally raise <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a>. The order in which the exceptions are raised is unspecified, except that <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_OVERFLOW</a> and <code>FE_UNDERFLOW</code> are always raised before <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  excepts</td><td> -</td><td>  bitmask listing the exception flags to raise</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if all listed exceptions were raised, non-zero value otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;fenv.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ON\xc2\xa0void show_fe_exceptions(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current exceptions raised: ");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_DIVBYZERO");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INEXACT");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INVALID");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a>))      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_OVERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_UNDERFLOW</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_UNDERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>)==0) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" none");    <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0double some_computation(void){    /* Computation reaches a state that causes overflow. */    int r = feraiseexcept(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a> | <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("feraiseexcept()\xc2\xa0%s\n", (r?"fails":"succeeds"));    return 0.0;}\xc2\xa0int main(void){    some_computation();    show_fe_exceptions();\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>feraiseexcept() succeeds<br>current exceptions raised:  FE_INEXACT FE_OVERFLOW</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/feraiseexcept
fegetround, fesetround	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fesetround( int <a href="http://en.cppreference.com/w/c/numeric/math/round">round</a> );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>int fegetround();</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>1) Attempts to establish the floating-point rounding direction equal to the argument argument <code>round</code>, which is expected to be one of the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">floating point rounding macros</a>. </p><p>2) Returns the value of the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">floating point rounding macro</a> that corresponds to the current rounding direction. </p><span class="prog__sub"> Parameters</span><table><tr><td>  round</td><td> -</td><td>  rounding direction, one of <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">floating point rounding macros</a></td></tr></table><span class="prog__sub"> Return value</span><p>1) <code>\xe2\x80\x8b0\xe2\x80\x8b</code> on success, non-zero otherwise.</p><p>2) the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">floating point rounding macro</a> describing the current rounding direction or a negative value if the direction cannot be determined.</p></section>	http://en.cppreference.com/w/c/numeric/fenv/feround
fetestexcept	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int fetestexcept( int excepts );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines which of the specified subset of the floating point exceptions are currently set. The argument <code>excepts</code> is a bitwise OR of the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">floating point exception macros</a>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  excepts</td><td> -</td><td>  bitmask listing the exception flags to test</td></tr></table><span class="prog__sub"> Return value</span><p>Bitwise OR of the floating-point exception macros that are both included in <code>excepts</code> and correspond to floating-point exceptions currently set.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;fenv.h&gt;#include &lt;float.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ON\xc2\xa0void show_fe_exceptions(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current exceptions raised: ");    if(fetestexcept(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_DIVBYZERO");    if(fetestexcept(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INEXACT");    if(fetestexcept(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INVALID");    if(fetestexcept(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a>))      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_OVERFLOW");    if(fetestexcept(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_UNDERFLOW</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_UNDERFLOW");    if(fetestexcept(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>)==0) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" none");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0int main(void){    /* Show default set of exception flags. */    show_fe_exceptions();\xc2\xa0    /* Perform some computations which raise exceptions. */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0/0.0     =\xc2\xa0%f\n", 1.0/0.0);        /* FE_DIVBYZERO            */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0/10.0    =\xc2\xa0%f\n", 1.0/10.0);       /* FE_INEXACT              */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("sqrt(-1)    =\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(-1));       /* FE_INVALID              */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("DBL_MAX*2.0 =\xc2\xa0%f\n", <a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a>*2.0);    /* FE_INEXACT FE_OVERFLOW  */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("nextafter(DBL_MIN/pow(2.0,52),0.0) =\xc2\xa0%.1f\n",           <a href="http://en.cppreference.com/w/c/numeric/math/nextafter">nextafter</a>(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MIN</a>/<a href="http://en.cppreference.com/w/c/numeric/math/pow">pow</a>(2.0,52),0.0));   /* FE_INEXACT FE_UNDERFLOW */    show_fe_exceptions();\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>current exceptions raised:  none<br>1.0/0.0     = inf<br>1.0/10.0    = 0.100000<br>sqrt(-1)    = -nan<br>DBL_MAX*2.0 = inf<br>nextafter(DBL_MIN/pow(2.0,52),0.0) = 0.0<br>current exceptions raised:  FE_DIVBYZERO FE_INEXACT FE_INVALID FE_OVERFLOW FE_UNDERFLOW</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/fetestexcept
feupdateenv	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;fenv.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int feupdateenv( const fenv_t* envp );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by <code>envp</code> (similar to <a href="http://en.cppreference.com/w/c/numeric/fenv/feenv" title="c/numeric/fenv/feenv">fesetenv</a>), then raises the floating-point exceptions that were saved.</p><p>This function may be used to end the non-stop mode established by an earlier call to <a href="http://en.cppreference.com/w/c/numeric/fenv/feholdexcept" title="c/numeric/fenv/feholdexcept">feholdexcept</a>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  envp</td><td> -</td><td>  pointer to the object of type <code>fenv_t</code> set by an earlier call to <a href="http://en.cppreference.com/w/c/numeric/fenv/feholdexcept" title="c/numeric/fenv/feholdexcept">feholdexcept</a> or <code>fegetenv</code> or equal to <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_DFL_ENV" title="c/numeric/fenv/FE DFL ENV">FE_DFL_ENV</a></td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> on success, non-zero otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;fenv.h&gt;#include &lt;float.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ON\xc2\xa0void show_fe_exceptions(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("current exceptions raised: ");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_DIVBYZERO");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INEXACT");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>))       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_INVALID");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a>))      <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_OVERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_UNDERFLOW</a>))     <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" FE_UNDERFLOW");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>)==0) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" none");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n");}\xc2\xa0double x2 (double x)   /* times two */{    fenv_t curr_excepts;\xc2\xa0    /* Save and clear current f-p environment. */    <a href="http://en.cppreference.com/w/c/numeric/fenv/feholdexcept">feholdexcept</a>(&amp;curr_excepts);\xc2\xa0    /* Raise inexact and overflow exceptions. */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In x2():  x =\xc2\xa0%f\n", x=x*2.0);    show_fe_exceptions();    <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INEXACT</a>);   /* hide inexact exception from caller */\xc2\xa0    /* Merge caller's exceptions (FE_INVALID)        */    /* with remaining x2's exceptions (FE_OVERFLOW). */    feupdateenv(&amp;curr_excepts);    return x;}\xc2\xa0int main(void){        <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/numeric/fenv/feraiseexcept">feraiseexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>);   /* some computation with invalid argument */    show_fe_exceptions();    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("x2(DBL_MAX) =\xc2\xa0%f\n", x2(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a>));    show_fe_exceptions();\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>current exceptions raised:  FE_INVALID<br>In x2():  x = inf<br>current exceptions raised:  FE_INEXACT FE_OVERFLOW<br>x2(DBL_MAX) = inf<br>current exceptions raised:  FE_INVALID FE_OVERFLOW</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/fenv/feupdateenv
abs, labs, llabs, imaxabs	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0abs( int n );</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>long \xc2\xa0 \xc2\xa0 \xc2\xa0 labs( long n );</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>long long llabs( long long n );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;inttypes.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> imaxabs( <a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> n );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Computes the absolute value of an integer number.  The behavior is undefined if the result cannot be represented by the return type.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  n</td><td> -</td><td>  integer value</td></tr></table><span class="prog__sub"> Return value</span><p>The absolute value of <code>n</code> (i.e. <code>|n|</code>), if it is representable.</p></section>	http://en.cppreference.com/w/c/numeric/math/abs
acos, acosf, acosl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 acosf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0acos( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double acosl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define acos( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the principal value of the arc cosine of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>acosl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>acos</code> is called. Otherwise, <code>acosf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>cacosf</code>, <code>cacos</code>, <code>cacosl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the arc cosine of <code>arg</code> (arccos(arg)) in the range [0\xc2\xa0; \xcf\x80], is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error occurs if <code>arg</code> is outside the range <code>[-1.0; 1.0]</code>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is +1, the value <code>+0</code> is returned.</li><li> If |arg| &gt; 1, a domain error occurs and NaN is returned.</li><li> if the argument is NaN, NaN is returned</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;errno.h&gt;#include &lt;fenv.h&gt;#include &lt;string.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ONint main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("acos(-1) =\xc2\xa0%f\n", acos(-1));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("acos(0.0) =\xc2\xa0%f 2*acos(0.0) =\xc2\xa0%f\n", acos(0), 2*acos(0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("acos(0.5) =\xc2\xa0%f 3*acos(0.5) =\xc2\xa0%f\n", acos(0.5), 3*acos(0.5));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("acos(1) =\xc2\xa0%f\n", acos(1));    // error handling     errno = 0; <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("acos(1.1) =\xc2\xa0%f\n", acos(1.1));    if(errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">EDOM</a>) <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("    errno == EDOM");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>)) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("    FE_INVALID raised");}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>acos(-1) = 3.141593<br>acos(0.0) = 1.570796 2*acos(0.0) = 3.141593<br>acos(0.5) = 1.047198 3*acos(0.5) = 3.141593<br>acos(1) = 0.000000<br>acos(1.1) = nan<br>    errno == EDOM: Numerical argument out of domain<br>    FE_INVALID raised</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/acos
acosh, acoshf, acoshl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 acoshf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0acosh( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double acoshl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define acosh( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the inverse hyperbolic cosine of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>acoshl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>acosh</code> is called. Otherwise, <code>acoshf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>cacoshf</code>, <code>cacosh</code>, <code>cacoshl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing the area of a hyperbolic sector</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the inverse hyperbolic cosine of <code>arg</code> (cosh-1<br/>(arg), or arcosh(arg)) on the interval [0, +\xe2\x88\x9e], is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the argument is less than 1, a domain error occurs.<br></p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is less than 1, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised an NaN is returned</li><li> if the argument is 1, +0 is returned</li><li> if the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/acosh
asin, asinf, asinl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 asinf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0asin( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double asinl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define asin( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the principal values of the arc sine of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>asinl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>asin</code> is called. Otherwise, <code>asinf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>casinf</code>, <code>casin</code>, <code>casinl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><code>arg</code><table><tr><td>\xcf\x80</td></tr><tr><td>2</td></tr></table><table><tr><td>\xcf\x80</td></tr><tr><td>2</td></tr></table><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error occurs if <code>arg</code> is outside the range <code>[-1.0; 1.0]</code>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, it is returned unmodified</li><li> If |arg| &gt; 1, a domain error occurs and NaN is returned.</li><li> if the argument is NaN, NaN is returned</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;fenv.h&gt;#include &lt;string.h&gt;\xc2\xa0#pragma STDC FENV_ACCESS ONint main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("asin( 1.0) =\xc2\xa0%+f, 2*asin( 1.0)=%+f\n", asin(1), 2*asin(1));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("asin(-0.5) =\xc2\xa0%+f, 6*asin(-0.5)=%+f\n", asin(-0.5), 6*asin(-0.5));    // special values    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("asin(0.0) =\xc2\xa0%1f, asin(-0.0)=%f\n", asin(+0.0), asin(-0.0));    // error handling     errno = 0; <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("asin(1.1) =\xc2\xa0%f\n", asin(1.1));    if(errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">EDOM</a>) <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("    errno == EDOM");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_INVALID</a>)) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("    FE_INVALID raised");}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>asin( 1.0) = +1.570796, 2*asin( 1.0)=+3.141593<br>asin(-0.5) = -0.523599, 6*asin(-0.5)=-3.141593<br>asin(0.0) = 0.000000, asin(-0.0)=-0.000000<br>asin(1.1) = nan<br>    errno == EDOM: Numerical argument out of domain<br>    FE_INVALID raised</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/asin
asinh, asinhf, asinhl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 asinhf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0asinh( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double asinhl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define asinh( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the inverse hyperbolic sine of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>asinhl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>asinh</code> is called. Otherwise, <code>asinhf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>casinhf</code>, <code>casinh</code>, <code>casinhl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing the area of a hyperbolic sector</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the inverse hyperbolic sine of <code>arg</code> (sinh-1<br/>(arg), or arsinh(arg)), is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10 or \xc2\xb1\xe2\x88\x9e, it is returned unmodified</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/asinh
atan, atanf, atanl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 atanf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0atan( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double atanl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define atan( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the principal value of the arc tangent of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>atanl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>atan</code> is called. Otherwise, <code>atanf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>catanf</code>, <code>catan</code>, <code>catanl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><code>arg</code><table><tr><td>\xcf\x80</td></tr><tr><td>2</td></tr></table><table><tr><td>\xcf\x80</td></tr><tr><td>2</td></tr></table><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, it is returned unmodified</li><li> If the argument is +\xe2\x88\x9e, +\xcf\x80/2 is returned</li><li> If the argument is -\xe2\x88\x9e, -\xcf\x80/2 is returned</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/atan
atan2, atan2f, atan2l	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 atan2f( float y, float x );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0atan2( double y, double x );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double atan2l( long double y, long double x );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define atan2( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the arc tangent of <code>y/x</code> using the signs of arguments to determine the correct quadrant.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>atan2l</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>atan2</code> is called. Otherwise, <code>atan2f</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><code>y/x</code><table><tr><td>y</td></tr><tr><td>x</td></tr></table><div><div>Y argument</div><div>Return value</div><div><a class="image" href="http://en.cppreference.com/w/File:math-atan2.png"></a></div><div>X argument</div></div><p>If a domain error occurs, an implementation-defined value is returned.<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error may occur if <code>x</code> and <code>y</code> are both zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>x</code> and <code>y</code> are both zero, domain error <i>does not</i> occur</li><li> If <code>x</code> and <code>y</code> are both zero, range error does not occur either</li><li> If <code>y</code> is zero, pole error does not occur</li><li> If <code>y</code> is <code>\xc2\xb10</code> and <code>x</code> is negative or <code>-0</code>, <code>\xc2\xb1\xcf\x80</code> is returned</li><li> If <code>y</code> is <code>\xc2\xb10</code> and <code>x</code> is positive or <code>+0</code>, <code>\xc2\xb10</code> is returned</li><li> If <code>y</code> is <code>\xc2\xb1\xe2\x88\x9e</code> and <code>x</code> is finite, <code>\xc2\xb1\xcf\x80/2</code> is returned</li><li> If <code>y</code> is <code>\xc2\xb1\xe2\x88\x9e</code> and <code>x</code> is <code>-\xe2\x88\x9e</code>, <code>\xc2\xb13\xcf\x80/4</code> is returned</li><li> If <code>y</code> is <code>\xc2\xb1\xe2\x88\x9e</code> and <code>x</code> is <code>+\xe2\x88\x9e</code>, <code>\xc2\xb1\xcf\x80/4</code> is returned</li><li> If <code>x</code> is <code>\xc2\xb10</code> and <code>y</code> is negative, <code>-\xcf\x80/2</code> is returned</li><li> If <code>x</code> is <code>\xc2\xb10</code> and <code>y</code> is positive, <code>+\xcf\x80/2</code> is returned</li><li> If <code>x</code> is <code>-\xe2\x88\x9e</code> and <code>y</code> is finite and positive, <code>+\xcf\x80</code> is returned</li><li> If <code>x</code> is <code>-\xe2\x88\x9e</code> and <code>y</code> is finite and negative, <code>-\xcf\x80</code> is returned</li><li> If <code>x</code> is <code>+\xe2\x88\x9e</code> and <code>y</code> is finite and positive, <code>+0</code> is returned</li><li> If <code>x</code> is <code>+\xe2\x88\x9e</code> and <code>y</code> is finite and negative, <code>-0</code> is returned</li><li> If either <code>x</code> is NaN or <code>y</code> is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/atan2
atanh, atanhf, atanhl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 atanhf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0atanh( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double atanhl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define atanh( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the inverse hyperbolic tangent of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>atanhl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>atanh</code> is called. Otherwise, <code>atanhf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>catanhf</code>, <code>catanh</code>, <code>catanhl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing the area of a hyperbolic sector</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the inverse hyperbolic tangent of <code>arg</code> (tanh-1<br/>(arg), or artanh(arg)), is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned (with the correct sign).</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the argument is not on the interval [-1, +1], a range error occurs.</p><p>If the argument is \xc2\xb11, a pole error occurs.<br></p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10, it is returned unmodified</li><li> if the argument is \xc2\xb11, \xc2\xb1\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised.</li><li> if |arg|&gt;1, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised.</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/atanh
cbrt, cbrtf, cbrtl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 cbrtf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0cbrt( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double cbrtl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define cbrt( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the cubic root of <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>cbrtl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>cbrt</code> is called. Otherwise, <code>cbrtf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the cubic root of <code>arg</code> (3\xe2\x88\x9aarg), is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10 or \xc2\xb1\xe2\x88\x9e, it is returned, unchanged</li><li> if the argument is NaN, NaN is returned.</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/cbrt
ceil, ceilf, ceill	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 ceilf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0ceil( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double ceill( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define ceil( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the smallest integer value not less than <code>arg</code>. </div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>ceill</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>ceil</code> is called. Otherwise, <code>ceilf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the smallest integer value not less than <code>arg</code>, that is \xe2\x8c\x88arg\xe2\x8c\x89, is returned.</p><div><div>Return value</div><div>Argument</div></div><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding mode</a> has no effect.</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, unmodified</li><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified</li><li> If arg is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/ceil
copysign, copysignf, copysignl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 copysignf( float x, float y );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0copysign( double x, double y );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double copysignl( long double x, long double y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define copysign(from, to)</code></div></td><td> (7) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Composes a floating point value with the magnitude of <code>x</code> and the sign of <code>y</code>. </div><div>4) Type-generic macro: If any argument has type <code>long double</code>, <code>copysignl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>copysign</code> is called. Otherwise, <code>copysignf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the floating point value with the magnitude of <code>x</code> and the sign of <code>y</code> is returned.</p><p>If <code>x</code> is NaN, then NaN with the sign of <code>y</code> is returned.</p><p>If <code>y</code> is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</p><span class="prog__sub"> Error handling</span><p>This function is not subject to any errors specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The returned value is exact (<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised) and independent of the current <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding mode</a>.</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/copysign
cos, cosf, cosl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 cosf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0cos( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double cosl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define cos( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the cosine of <code>arg</code> (measured in radians).</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>cosl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>cos</code> is called. Otherwise, <code>cosf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>ccosf</code>, <code>ccos</code>, <code>ccosl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing angle in radians</td></tr></table><span class="prog__sub"> Return value</span><span class="prog__sub"> Return value</span><p>If no errors occur, the cosine of <code>arg</code> (cos(arg)) in the range [-1\xc2\xa0; +1], is returned.</p><table><tr><td><p>The result may have little or no significance if the magnitude of <code>arg</code> is large.</p></td><td>(until C++11)</td></tr></table><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10, the result is 1.0</li><li> if the argument is \xc2\xb1\xe2\x88\x9e, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/cos
cosh, coshf, coshl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 coshf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0cosh( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double coshl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define cosh( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the hyperbolic cosine of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>coshl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>cosh</code> is called. Otherwise, <code>coshf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>ccoshf</code>, <code>ccosh</code>, <code>ccoshl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing a hyperbolic angle</td></tr></table><span class="prog__sub"> Return value</span><code>arg</code><table><tr><td>earg<br/>+e-arg<br/></td></tr><tr><td>2</td></tr></table><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10, 1 is returned</li><li> If the argument is \xc2\xb1\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/cosh
div, ldiv, lldiv, imaxdiv	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>div_t \xc2\xa0 \xc2\xa0 div( int x, int y );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>ldiv_t \xc2\xa0 \xc2\xa0ldiv( long x, long y );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>lldiv_t \xc2\xa0 lldiv( long long x, long long y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;inttypes.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>imaxdiv_t imaxdiv( <a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> x, <a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> y );</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Computes both the quotient and the remainder of the division of the numerator <code>x</code> by the denominator <code>y</code>.</p><table><tr><td><p>Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that <code>quot * y + rem == x</code>.</p></td><td>(until C99)</td></tr><tr><td><p>Computes the quotient (the result of the expression <code>x/y</code>) and remainder (the result of the expression <code>x%y</code>) simultaneously.</p></td><td>(since C99)</td></tr></table><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  integer values</td></tr></table><span class="prog__sub"> Return value</span><p>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, imaxdiv_t, respectively), returns both as an object of type <code>div_t</code>, <code>ldiv_t</code>, <code>lldiv_t</code>, <code>imaxdiv_t</code> defined as follows:</p><div><h2>  div_t </h2><div><div><pre><code>struct div_t { int quot; int rem; };</code></pre></div></div><p>or<br></p><div><div><pre><code>struct div_t { int rem; int quot; };</code></pre></div></div></div><div><h2>  ldiv_t </h2><div><div><pre><code>struct ldiv_t { long quot; long rem; };</code></pre></div></div><p>or<br></p><div><div><pre><code>struct ldiv_t { long rem; long quot; };</code></pre></div></div></div><div><h2>  lldiv_t </h2><div><div><pre><code>struct lldiv_t { long long quot; long long rem; };</code></pre></div></div><p>or<br></p><div><div><pre><code>struct lldiv_t { long long rem; long long quot; };</code></pre></div></div></div><div><h2>  imaxdiv_t </h2><div><div><pre><code>struct imaxdiv_t { <a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> quot; <a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> rem; };</code></pre></div></div><p>or<br></p><div><div><pre><code>struct imaxdiv_t { <a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> rem; <a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> quot; };</code></pre></div></div></div><p><br/>If either the remainder or the quotient cannot be represented, the behavior is undefined.</p><p><br/></p></section>	http://en.cppreference.com/w/c/numeric/math/div
erf, erff, erfl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 erff( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0erf( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double erfl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define erf( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the <a class="extiw" href="http://en.wikipedia.com/wiki/Error_function" title="enwiki:Error function">error function</a> of <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>erfl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>erf</code> is called. Otherwise, <code>erff</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><code>arg</code><table><tr><td>2</td></tr><tr><td>\xe2\x88\x9a\xcf\x80</td></tr></table><br/><i>e</i><sup>-t2<br/></sup><i>t</i><table><tr><td>2*arg</td></tr><tr><td>\xe2\x88\x9a\xcf\x80</td></tr></table><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, \xc2\xb10 is returned</li><li> If the argument is \xc2\xb1\xe2\x88\x9e, \xc2\xb11 is returned</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/erf
erfc, erfcf, erfcl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 erfcf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0erfc( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double erfcl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define erfc( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the <a class="extiw" href="http://en.wikipedia.com/wiki/Complementary_error_function" title="enwiki:Complementary error function">complementary error function</a> of <code>arg</code>, that is <code>1.0-erf(arg)</code>, but without loss of precision for large <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>erfcl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>erfc</code> is called. Otherwise, <code>erfcf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><code>arg</code><table><tr><td>2</td></tr><tr><td>\xe2\x88\x9a\xcf\x80</td></tr></table><br/><i>e</i><sup>-t2<br/></sup><i>t</i><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is +\xe2\x88\x9e, +0 is returned</li><li> If the argument is -\xe2\x88\x9e, 2 is returned</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/erfc
exp, expf, expl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 expf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0exp( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double expl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define exp( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the <i>e</i> (Euler's number, <code>2.7182818</code>) raised to the given power <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>expl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>exp</code> is called. Otherwise, <code>expf</code> is called. If <code>arg</code> is complex or imaginary, then the macro invokes the corresponding complex function (<code>cexpf</code>, <code>cexp</code>, <code>cexpl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the base-<i>e</i> exponential of <code>arg</code> (earg<br/>) is returned.</p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, 1 is returned</li><li> If the argument is -\xe2\x88\x9e, +0 is returned</li><li> If the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/exp
exp2, exp2f, exp2l	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 exp2f( float n );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0exp2( double n );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double exp2l( long double n );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define exp2( n )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes 2 raised to the given power <code>n</code>.</div><div>4) Type-generic macro: If <code>n</code> has type <code>long double</code>, <code>exp2l</code> is called. Otherwise, if <code>n</code> has integer type or the type <code>double</code>, <code>exp2</code> is called. Otherwise, <code>exp2f</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  n</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the base-<i>2</i> exponential of <code>n</code> (2n<br/>) is returned.</p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, 1 is returned</li><li> If the argument is -\xe2\x88\x9e, +0 is returned</li><li> If the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If the argument is NaN, NaN is returned</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;#include &lt;errno.h&gt;#include &lt;fenv.h&gt;#pragma STDC FENV_ACCESS ONint main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("exp2(5) =\xc2\xa0%f\n", exp2(5));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("exp2(0.5) =\xc2\xa0%f\n", exp2(0.5));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("exp2(-4) =\xc2\xa0%f\n", exp2(-4));    // special values    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("exp2(-9) =\xc2\xa0%f\n", exp2(-0.9));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("exp2(-Inf) =\xc2\xa0%f\n", exp2(-INFINITY));    //error handling    errno = 0; <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("exp2(1024) =\xc2\xa0%f\n", exp2(1024));    if(errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>) <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("    errno == ERANGE");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_OVERFLOW</a>)) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("    FE_OVERFLOW raised");}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>exp2(5) = 32.000000<br>exp2(0.5) = 1.414214<br>exp2(-4) = 0.062500<br>exp2(-9) = 0.535887<br>exp2(-Inf) = 0.000000<br>exp2(1024) = Inf<br>    errno == ERANGE: Result too large<br>    FE_OVERFLOW raised</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/exp2
expm1, expm1f, expm1l	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 expm1f( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0expm1( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double expm1l( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define expm1( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the <i>e</i> (Euler's number, <code>2.7182818</code>) raised to the given power <code>arg</code>, minus <code>1.0</code>. This function is more accurate than the expression <code>std::<a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a>(arg)-1.0</code> if <code>arg</code> is close to zero.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>expm1l</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>expm1</code> is called. Otherwise, <code>expm1f</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur earg<br/>-1 is returned.</p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, it is returned, unmodified</li><li> If the argument is -\xe2\x88\x9e, -1 is returned</li><li> If the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/expm1
fabs, fabsf, fabsl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 fabsf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0fabs( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double fabsl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define fabs( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the absolute value of a floating point value <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>fabsl</code> is called. Otherwise, if the argument has integer type or has type <code>double</code>, <code>fabs</code> is called. Otherwise, <code>fabsf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>cabsf</code>, <code>cabs</code>, <code>cabsl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If successful, returns the absolute value of <code>arg</code> (<code>|arg|</code>). The value returned is exact and does not depend on any rounding modes.</p><span class="prog__sub"> Error handling</span><p>This function is not subject to any of the error conditions specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, +0 is returned</li><li> If the argument is \xc2\xb1\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If the argument is NaN, NaN is returned</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;\xc2\xa0/* This numerical integration assumes all area is positive. */#define PI 3.14159double num_int (double a, double b,                double f(double),                unsigned n) {    if (a == b) return 0.0;    if (n == 0) n=1;   /* avoid division by zero */    double h = (b-a)/n;    double sum = 0.0;    for (unsigned k=0; k &lt; n; ++k)        sum += h*fabs(f(a+k*h));    return sum;}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("fabs(+3) =\xc2\xa0%f\n", fabs(+3.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("fabs(-3) =\xc2\xa0%f\n", fabs(-3.0));    // special values    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("fabs(-0) =\xc2\xa0%f\n", fabs(-0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("fabs(-Inf) =\xc2\xa0%f\n", fabs(-INFINITY));\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f\n", num_int(0.0,2*PI,<a href="http://en.cppreference.com/w/c/numeric/math/sin">sin</a>,100000));\xc2\xa0}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>fabs(+3) = 3.000000<br>fabs(-3) = 3.000000<br>fabs(-0) = 0.000000<br>fabs(-Inf) = inf<br>4.000000</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/fabs
fdim	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 fdimf( float x, float y );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0fdim( double x, double y );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double fdiml( long double x, long double y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define fdim( x, y )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Returns the positive difference between <code>x</code> and <code>y</code>, that is, if <code>x&gt;y</code>, returns <code>x-y</code>, otherwise (if <code>x\xe2\x89\xa4y</code>), returns +0.</div><div>4) Type-generic macro: If any argument has type <code>long double</code>, <code>fdiml</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fdim</code> is called. Otherwise, <code>fdimf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If successful, returns the positive difference between x and y.<br></p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct value (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If either argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/fdim
float_t, double_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>typedef /*implementation defined*/ float_t</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>typedef /*implementation defined*/ double_t</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The types <code>float_t</code> and <code>double_t</code> are floating types at least as wide as <code>float</code> and <code>double</code>, respectively, and such that <code>double_t</code> is at least as wide as <code>float_t</code>. The value of <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a> determines the types of <code>float_t</code> and <code>double_t</code>.</p><table><tr><td>  FLT_EVAL_METHOD</td><td>  Explanation</td></tr><tr><td> <code>0</code></td><td> <code>float_t</code> and <code>double_t</code> are equivalent to <code>float</code> and <code>double</code>, respectively</td></tr><tr><td> <code>1</code></td><td>  both <code>float_t</code> and <code>double_t</code> are equivalent to <code>double</code></td></tr><tr><td> <code>2</code></td><td>  both <code>float_t</code> and <code>double_t</code> are equivalent to <code>long double</code></td></tr><tr><td> <code>other</code></td><td>  both <code>float_t</code> and <code>double_t</code> are implementation defined</td></tr></table><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;float.h&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", <a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD">FLT_EVAL_METHOD</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu \xc2\xa0%zu\n", sizeof(float),sizeof(float_t));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu \xc2\xa0%zu\n", sizeof(double),sizeof(double_t));    return 0;}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>0<br>4  4<br>8  8</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/float_t
floor, floorf, floorl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 floorf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0floor( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double floorl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define floor( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the largest integer value not greater than <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>floorl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>floor</code> is called. Otherwise, <code>floorf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the largest integer value not greater than <code>arg</code>, that is \xe2\x8c\x8aarg\xe2\x8c\x8b, is returned.</p><div><div>Return value</div><div>Argument</div></div><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding mode</a> has no effect.</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, unmodified</li><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified</li><li> If arg is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/floor
fma, fmaf, fmal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 fmaf( float x, float y, float z );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0fma( double x, double y, double z );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double fmal( long double x, long double y, long double z );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div><code>#define FP_FAST_FMA \xc2\xa0/* implementation-defined */</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td> <div><code>#define FP_FAST_FMAF /* implementation-defined */</code></div></td><td> (5) </td><td> (since C99) </td></tr><tr><td> <div><code>#define FP_FAST_FMAL /* implementation-defined */</code></div></td><td> (6) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define fma( x, y, z )</code></div></td><td> (7) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes <code>(x*y) + z</code> as if to infinite precision and rounded only once to fit the result type.</div><div>4-6) If the macro constants <code>FP_FAST_FMAF</code>, <code>FP_FAST_FMA</code>, or <code>FP_FAST_FMAL</code> are defined, the corresponding function <code>fmaf</code>, <code>fma</code>, or <code>fmal</code> evaluates faster (in addition to being more precise) than the expression <code>x*y+z</code> for <code>float</code>, <code>double</code>, and <code>long double</code> arguments, respectively. If defined, these macros evaluate to integer <code>1</code>.</div><div>7) Type-generic macro: If any argument has type <code>long double</code>, <code>fmal</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fma</code> is called. Otherwise, <code>fmaf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  x, y, z</td><td> -</td><td>  floating point values</td></tr></table><span class="prog__sub"> Return value</span><p>If successful, returns the value of <code>(x*y) + z</code> as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</p><p>If a range error due to overflow occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct value (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/cpp/numeric/math/math_errhandling" title="cpp/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> may be raised</li><li> If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If x or y are NaN, NaN is returned</li><li> If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/fma
fmax, fmaxf, fmaxl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 fmaxf( float x, float y );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0fmax( double x, double y );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double fmaxl( long double x, long double y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define fmax( x, y )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).</div><div>4) Type-generic macro: If any argument has type <code>long double</code>, <code>fmaxl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fmax</code> is called. Otherwise, <code>fmaxf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><span class="prog__sub"> Return value</span><p>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.<br></p><span class="prog__sub"> Error handling</span><p>This function is not subject to any of the error conditions specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If one of the two arguments is NaN, the value of the other argument is returned</li><li> Only if both arguments are NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/fmax
fmin, fminf, fminl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 fminf( float x, float y );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0fmin( double x, double y );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double fminl( long double x, long double y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define fmin( x, y )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen).</div><div>4) Type-generic macro: If any argument has type <code>long double</code>, <code>fminl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fmin</code> is called. Otherwise, <code>fminf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><span class="prog__sub"> Return value</span><p>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.<br></p><span class="prog__sub"> Error handling</span><p>This function is not subject to any of the error conditions specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If one of the two arguments is NaN, the value of the other argument is returned</li><li> Only if both arguments are NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/fmin
fmod, fmodf, fmodl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 fmodf( float x, float y );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0fmod( double x, double y );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double fmodl( long double x, long double y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define fmod( x, y )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the floating-point remainder of the division operation <code>x/y</code>.</div><div>4) Type-generic macro: If any argument has type <code>long double</code>, <code>fmodl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>fmod</code> is called. Otherwise, <code>fmodf</code> is called.</div><p>The floating-point remainder of the division operation <code>x/y</code> calculated by this function is exactly the value <code>x - n*y</code>, where <code>n</code> is <code>x/y</code> with its fractional part truncated.</p><p>The returned value has the same sign as <code>x</code> and is less or equal to <code>y</code> in magnitude.</p><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><span class="prog__sub"> Return value</span><p>If successful, returns the floating-point remainder of the division <code>x/y</code> as defined above.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error may occur if <code>y</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>x</code> is \xc2\xb10 and <code>y</code> is not zero, \xc2\xb10 is returned</li><li> If <code>x</code> is \xc2\xb1\xe2\x88\x9e and <code>y</code> is not NaN, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>y</code> is \xc2\xb10 and <code>x</code> is not NaN, NaN is returned  and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>y</code> is \xc2\xb1\xe2\x88\x9e and <code>x</code> is finite, <code>x</code> is returned. </li><li> If either argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/fmod
FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define FP_NORMAL \xc2\xa0 \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FP_SUBNORMAL /*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FP_ZERO \xc2\xa0 \xc2\xa0 \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FP_INFINITE \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define FP_NAN \xc2\xa0 \xc2\xa0 \xc2\xa0 /*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>FP_NORMAL</code>, <code>FP_SUBNORMAL</code>, <code>FP_ZERO</code>, <code>FP_INFINITE</code>, <code>FP_NAN</code> macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.</p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>FP_NORMAL</code></td><td>  indicates that the value is <i>normal</i>, i.e. not an infinity, subnormal, not-a-number or zero</td></tr><tr><td> <code>FP_SUBNORMAL</code></td><td>  indicates that the value is <i>subnormal</i></td></tr><tr><td> <code>FP_ZERO</code></td><td>  indicates that the value is positive or negative zero</td></tr><tr><td> <code>FP_INFINITE</code></td><td>  indicates that the value is not representable by the underlying type (positive or negative infinity)</td></tr><tr><td> <code>FP_NAN</code></td><td>  indicates that the value is not-a-number (NaN)</td></tr></table><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;\xc2\xa0const char *show_classification(double x) {    switch(<a href="http://en.cppreference.com/w/c/numeric/math/fpclassify">fpclassify</a>(x)) {        case FP_INFINITE:  return "Inf";        case FP_NAN:       return "NaN";        case FP_NORMAL:    return "normal";        case FP_SUBNORMAL: return "subnormal";        case FP_ZERO:      return "zero";        default:           return "unknown";    }}int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0/0.0 is\xc2\xa0%s\n", show_classification(1/0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("0.0/0.0 is\xc2\xa0%s\n", show_classification(0.0/0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("DBL_MIN/2 is\xc2\xa0%s\n", show_classification(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MIN</a>/2));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("-0.0 is\xc2\xa0%s\n", show_classification(-0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(" 1.0 is\xc2\xa0%s\n", show_classification(1.0));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>1.0/0.0 is Inf<br>0.0/0.0 is NaN<br>DBL_MIN/2 is subnormal<br>-0.0 is zero<br> 1.0 is normal</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/FP_categories
fpclassify	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define fpclassify(arg) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Categorizes floating point value <code>arg</code> into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category. The macro returns an integral value.</p><p><a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that: a normal long double value might become subnormal when converted to double and zero when converted to float.</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>One of <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories" title="c/numeric/math/FP categories">FP_INFINITE</a>, <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories" title="c/numeric/math/FP categories">FP_NAN</a>, <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories" title="c/numeric/math/FP categories">FP_NORMAL</a>, <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories" title="c/numeric/math/FP categories">FP_SUBNORMAL</a>, <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories" title="c/numeric/math/FP categories">FP_ZERO</a> or implementation-defined type, specifying the category of <code>arg</code>.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;\xc2\xa0const char *show_classification(double x) {    switch(fpclassify(x)) {        case <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories">FP_INFINITE</a>:  return "Inf";        case <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories">FP_NAN</a>:       return "NaN";        case <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories">FP_NORMAL</a>:    return "normal";        case <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories">FP_SUBNORMAL</a>: return "subnormal";        case <a href="http://en.cppreference.com/w/c/numeric/math/FP_categories">FP_ZERO</a>:      return "zero";        default:           return "unknown";    }}int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0/0.0 is\xc2\xa0%s\n", show_classification(1/0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("0.0/0.0 is\xc2\xa0%s\n", show_classification(0.0/0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("DBL_MIN/2 is\xc2\xa0%s\n", show_classification(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MIN</a>/2));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("-0.0 is\xc2\xa0%s\n", show_classification(-0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0 is\xc2\xa0%s\n", show_classification(1.0));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>1.0/0.0 is Inf<br>0.0/0.0 is NaN<br>DBL_MIN/2 is subnormal<br>-0.0 is zero<br>1.0 is normal</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/fpclassify
frexp, frexpf, frexpl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 frexpf( float arg, int* <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0frexp( double arg, int* <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double frexpl( long double arg, int* <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define frexp( arg, exp )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Decomposes given floating point value <code>x</code> into a normalized fraction and an integral power of two.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>frexpl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>frexp</code> is called. Otherwise, <code>frexpf</code> is called, respectively.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr><tr><td>  exp</td><td> -</td><td>  pointer to integer value to store the exponent to</td></tr></table><span class="prog__sub"> Return value</span><p>If <code>arg</code> is zero, returns zero and stores zero in <code>*exp</code>.</p><p>Otherwise (if <code>arg</code> is not zero), if no errors occur, returns the value <code>x</code> in the range  <code>(-1;-0.5], [0.5; 1)</code> and stores an integer value in <code>*<a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a></code> such that x\xc3\x972(*exp)<br/>=arg.</p><p>If the value to be stored in <code>*exp</code> is outside the range of <code>int</code>, the behavior is unspecified.</p><p>If <code>arg</code> is not a floating-point number, the behavior is unspecified.</p><span class="prog__sub"> Error handling</span><p>This function is not subject to any errors specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified, and <code>0</code> is stored in <code>*<a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a></code>.</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, and an unspecified value is stored in <code>*<a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a></code>.</li><li> If <code>arg</code> is NaN, NaN is returned, and an unspecified value is stored in <code>*<a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a></code>.</li><li> No floating-point exceptions are raised.</li><li> If <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">FLT_RADIX</a> is 2 (or a power of 2), the returned value is exact, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">the current rounding mode</a> is ignored</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/frexp
HUGE_VALF, HUGE_VAL, HUGE_VALL	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define HUGE_VALF /*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define HUGE_VAL \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define HUGE_VALL /*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>HUGE_VALF</code>, <code>HUGE_VAL</code> and <code>HUGE_VALL</code> macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>).</p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>HUGE_VALF</code></td><td>  Expands to positive <code>float</code> expression that indicates overflow</td></tr><tr><td> <code>HUGE_VAL</code></td><td>  Expands to positive <code>double</code> expression that indicates overflow, not necessarily representable as a <code>float</code></td></tr><tr><td> <code>HUGE_VALL</code></td><td>  Expands to positive <code>long double</code> expression that indicates overflow, not necessarily representable as a <code>float</code> or <code>double</code></td></tr></table><p>On implementations that support floating-point infinities, these macros always expand to the positive infinities of <code>float</code>, <code>double</code>, and <code>long double</code>, respectively.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;math.h&gt;#include &lt;stdio.h&gt;int main(void){    double result = 1.0/0.0;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1.0/0.0 =\xc2\xa0%f\n", result);    if (result == HUGE_VAL)        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("1.0/0.0 == HUGE_VAL\n");}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>1.0/0.0 = inf<br>1.0/0.0 == HUGE_VAL</code></pre></div></div></div><div><ul><li> C11 standard (ISO/IEC 9899:2011): </li></ul><dl><dd><ul><li> 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 231)</li></ul></dd></dl><dl><dd><ul><li> F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 517)</li></ul></dd></dl><div><ul><li> C99 standard (ISO/IEC 9899:1999): </li></ul><dl><dd><ul><li> 7.12/3 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 212)</li></ul></dd></dl><dl><dd><ul><li> F.9/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 454)</li></ul></dd></dl><div><ul><li> C89/C90 standard (ISO/IEC 9899:1990): </li></ul><dl><dd><ul><li> 4.5 HUGE_VAL </li></ul></dd></dl></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/HUGE_VAL
hypot, hypotf, hypotl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 hypotf( float x, float y );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0hypot( double x, double y );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double hypotl( long double x, long double y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define hypot( x, y )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the square root of the sum of the squares of <code>x</code> and <code>y</code>, without undue overflow or underflow at intermediate stages of the computation.</div><div>4) Type-generic macro: If any argument has type <code>long double</code>, the long double version of the function is called. Otherwise, if any argument has integer type or has type <code>double</code>, the double version of the function is called. Otherwise, the <code>float</code> version of the function is called.</div><p>The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length <code>x</code> and <code>y</code>, or the distance of the point <code>(x,y)</code> from the origin <code>(0,0)</code>, or the magnitude of a complex number <code>x+<i>i</i>y</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  x</td><td> -</td><td>  floating point value</td></tr><tr><td>  y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the hypotenuse of a right-angled triangle, \xe2\x88\x9ax2<br/>+y2<br/>, is returned.</p><p>If a range error due to overflow occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> <code>hypot(x, y)</code>, <code>hypot(y, x)</code>, and <code>hypot(x, -y)</code> are equivalent</li><li> if one of the arguments is \xc2\xb10, <code>hypot</code> is equivalent to <code>fabs</code> called with the non-zero argument</li><li> if one of the arguments is \xc2\xb1\xe2\x88\x9e, <code>hypot</code> returns +\xe2\x88\x9e even if the other argument is NaN</li><li> otherwise, if any of the arguments is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/hypot
ilogb, ilogbf, ilogbl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int ilogbf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>int ilogb( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>int ilogbl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define ilogb( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define FP_ILOGB0 /*implementation-defined*/</code></div></td><td> (5) </td><td> (since C99) </td></tr><tr><td> <div><code>#define FP_ILOGBNAN /*implementation-defined*/</code></div></td><td> (6) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Extracts the value of the unbiased exponent from the floating-point argument <code>arg</code>, and returns it as a signed integer value. </div><div>4) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>ilogbl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>ilogb</code> is called. Otherwise, <code>ilogbf</code> is called.</div><div>5) Expands to integer constant expression whose value is either <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MIN</a> or <code>-<a href="http://en.cppreference.com/w/c/types/limits">INT_MAX</a></code>.</div><div>6) Expands to integer constant expression whose value is either <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MIN</a> or <code>+<a href="http://en.cppreference.com/w/c/types/limits">INT_MAX</a></code>.</div><p>Formally, the unbiased exponent is the integral part of log<br/>r|arg| as a signed integral value, for non-zero arg, where <code>r</code> is <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">FLT_RADIX</a>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the unbiased exponent of <code>arg</code> is returned as a signed int value.</p><p>If <code>arg</code> is zero, FP_ILOGB0 is returned.</p><p>If <code>arg</code> is infinite, <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MAX</a> is returned.</p><p>If <code>arg</code> is a NaN, FP_ILOGBNAN is returned.</p><p>If the correct result is greater than <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MAX</a> or smaller than <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MIN</a>, the return value is unspecified and a domain error or range error may occur </p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>A domain error or range error may occur if <code>arg</code> is zero, infinite, or NaN.</p><p>If the correct result is greater than <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MAX</a> or smaller than <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MIN</a>, a domain error or a range error may occur </p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the correct result is greater than <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MAX</a> or smaller than <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">INT_MIN</a>, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised.</li><li> If <code>arg</code> is \xc2\xb10, \xc2\xb1\xe2\x88\x9e, or NaN, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised.</li><li> In all other cases, the result is exact (<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised) and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">the current rounding mode</a> is ignored</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/ilogb
INFINITY	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define INFINITY /*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>If the implementation supports floating-point infinities, the macro <code>INFINITY</code> expands to constant expression of type <code>float</code> which evaluates to positive or unsigned infinity.</p><p>If the implementation does not support floating-point infinities, the macro <code>INFINITY</code> expands to a positive value that is guaranteed to overflow a <code>float</code> at compile time, and the use of this macro generates a compiler warning.</p><p>The style used to print an infinity is implementation defined.<br></p><span class="prog__sub"> Example</span><p>Show style used to print an infinity and IEEE format.<br></p><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdint.h&gt;#include &lt;inttypes.h&gt;#include &lt;string.h&gt;\xc2\xa0int main(void){    double f = INFINITY;    <a href="http://en.cppreference.com/w/c/types/integer">uint64_t</a> fn; <a href="http://en.cppreference.com/w/c/string/byte/memcpy">memcpy</a>(&amp;fn, &amp;f, sizeof f);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("INFINITY:  \xc2\xa0%f\xc2\xa0%" <a href="http://en.cppreference.com/w/c/types/integer">PRIx64</a> "\n", f, fn);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>INFINITY:   inf 7ff0000000000000</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/INFINITY
isfinite	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define isfinite(arg) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. The macro returns an integral value.</p><p><a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>arg</code> has finite value, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isfinite(NAN)         =\xc2\xa0%d\n", isfinite(NAN));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isfinite(INFINITY)    =\xc2\xa0%d\n", isfinite(INFINITY));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isfinite(0.0)         =\xc2\xa0%d\n", isfinite(0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isfinite(DBL_MIN/2.0) =\xc2\xa0%d\n", isfinite(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MIN</a>/2.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isfinite(1.0)         =\xc2\xa0%d\n", isfinite(1.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isfinite(exp(800))    =\xc2\xa0%d\n", isfinite(<a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a>(800)));}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>isfinite(NAN)         = 0<br>isfinite(INFINITY)    = 0<br>isfinite(0.0)         = 1<br>isfinite(DBL_MIN/2.0) = 1<br>isfinite(1.0)         = 1<br>isfinite(exp(800))    = 0</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/isfinite
isgreater	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define isgreater(x, y) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is greater than the floating-point number (<code>y</code>), without setting floating-point exceptions. </p><span class="prog__sub"> Parameters</span><table><tr><td>  x</td><td> -</td><td>  floating point value</td></tr><tr><td>  y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>x &gt; y</code>, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p></section>	http://en.cppreference.com/w/c/numeric/math/isgreater
isgreaterequal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define isgreaterequal(x, y) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is greater than or equal to the floating-point number <code>y</code>, without setting floating-point exceptions.</p><span class="prog__sub"> Parameters</span><table><tr><td>  x</td><td> -</td><td>  floating point value</td></tr><tr><td>  y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>x &gt;= y</code>, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p></section>	http://en.cppreference.com/w/c/numeric/math/isgreaterequal
isinf	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define isinf(arg) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> is positive or negative infinity. The macro returns an integral value.</p><p><a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>arg</code> has an infinite value, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isinf(NAN)         =\xc2\xa0%d\n", isinf(NAN));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isinf(INFINITY)    =\xc2\xa0%d\n", isinf(INFINITY));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isinf(0.0)         =\xc2\xa0%d\n", isinf(0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isinf(DBL_MIN/2.0) =\xc2\xa0%d\n", isinf(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MIN</a>/2.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isinf(1.0)         =\xc2\xa0%d\n", isinf(1.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isinf(exp(800))    =\xc2\xa0%d\n", isinf(<a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a>(800)));}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>isinf(NAN)         = 0<br>isinf(INFINITY)    = 1<br>isinf(0.0)         = 0<br>isinf(DBL_MIN/2.0) = 0<br>isinf(1.0)         = 0<br>isinf(exp(800))    = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/isinf
isless	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define isless(x, y) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is less than the floating-point number <code>y</code>, without setting floating-point exceptions.</p><span class="prog__sub"> Parameters</span><table><tr><td>  x</td><td> -</td><td>  floating point value</td></tr><tr><td>  y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>x &lt; y</code>, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p></section>	http://en.cppreference.com/w/c/numeric/math/isless
islessequal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define islessequal(x, y) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is less than or equal to the floating-point number <code>y</code>, without setting floating-point exceptions. </p><span class="prog__sub"> Parameters</span><table><tr><td>  x</td><td> -</td><td>  floating point value</td></tr><tr><td>  y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>x &lt;= y</code>, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p></section>	http://en.cppreference.com/w/c/numeric/math/islessequal
islessgreater	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define islessgreater(x, y) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point number <code>x</code> is less than or greater than the floating-point number <code>y</code>, without setting floating-point exceptions. </p><span class="prog__sub"> Parameters</span><table><tr><td>  x</td><td> -</td><td>  floating point value</td></tr><tr><td>  y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>x &lt; y || x &gt; y</code>, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p></section>	http://en.cppreference.com/w/c/numeric/math/islessgreater
isnan	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define isnan(arg) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> is a not-a-number (NaN) value. The macro returns an integral value.</p><p><a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that (this matters if the evaluation type supports NaNs, while the semantic type does not).</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>arg</code> is a NaN, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p></section>	http://en.cppreference.com/w/c/numeric/math/isnan
isnormal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define isnormal(arg) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> is normal, i.e. is neither zero, subnormal, infinite, nor <code>NaN</code>. The macro returns an integral value.</p><p><a href="http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a> is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>arg</code> is normal, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isnormal(NAN)         =\xc2\xa0%d\n", isnormal(NAN));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isnormal(INFINITY)    =\xc2\xa0%d\n", isnormal(INFINITY));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isnormal(0.0)         =\xc2\xa0%d\n", isnormal(0.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isnormal(DBL_MIN/2.0) =\xc2\xa0%d\n", isnormal(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MIN</a>/2.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isnormal(1.0)         =\xc2\xa0%d\n", isnormal(1.0));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>isnormal(NAN)         = 0<br>isnormal(INFINITY)    = 0<br>isnormal(0.0)         = 0<br>isnormal(DBL_MIN/2.0) = 0<br>isnormal(1.0)         = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/isnormal
isunordered	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define isunordered(x, y) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the floating point numbers <code>x</code> and <code>y</code> are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.</p><span class="prog__sub"> Parameters</span><table><tr><td>  x</td><td> -</td><td>  floating point value</td></tr><tr><td>  y</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if either <code>x</code> or <code>y</code> is NaN, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p><p><br/></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isunordered(NAN,1.0) =\xc2\xa0%d\n", isunordered(NAN,1.0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isunordered(1.0,NAN) =\xc2\xa0%d\n", isunordered(1.0,NAN));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isunordered(NAN,NAN) =\xc2\xa0%d\n", isunordered(NAN,NAN));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isunordered(1.0,0.0) =\xc2\xa0%d\n", isunordered(1.0,0.0));\xc2\xa0    return 0;}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>isunordered(NAN,1.0) = 1<br>isunordered(1.0,NAN) = 1<br>isunordered(NAN,NAN) = 1<br>isunordered(1.0,0.0) = 0</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/isunordered
ldexp, ldexpf, ldexpl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 ldexpf( float arg, int <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0ldexp( double arg, int <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double ldexpl( long double arg, int <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define ldexp( arg, exp )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Multiplies a floating point value <code>arg</code> by the number 2 raised to the <code>exp</code> power.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>ldexpl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>ldexp</code> is called. Otherwise, <code>ldexpf</code> is called, respectively.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr><tr><td>  exp</td><td> -</td><td>  integer value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, <code>arg</code> multiplied by 2 to the power of <code>exp</code> (arg\xc3\x972exp<br/>) is returned.</p><p>If a range error due to overflow occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> Unless a range error occurs, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised (the result is exact)</li><li> Unless a range error occurs, the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">current rounding mode</a> is ignored</li><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, unmodified</li><li> If <code>exp</code> is 0, then <code>arg</code> is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/ldexp
lgamma, lgammaf, lgammal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 lgammaf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0lgamma( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double lgammal( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define lgamma( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the natural logarithm of the absolute value of the <a class="extiw" href="http://en.wikipedia.com/wiki/Gamma_function" title="enwiki:Gamma function">gamma function</a> of <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>lgammal</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>lgamma</code> is called. Otherwise, <code>lgammaf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the value of the logarithm of the gamma function of <code>arg</code>, that is log<br/>e|\xe2\x88\xab\xe2\x88\x9e<br/>0<i>t</i>arg-1<br/> <i>e</i><sup>-t</sup> d<i>t</i>|, is returned.</p><p>If a pole error occurs, <code>+HUGE_VAL</code>, <code>+HUGE_VALF</code>, or <code>+HUGE_VALL</code> is returned.</p><p>If a range error due to overflow occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If <code>arg</code> is zero or is an integer less than zero, a pole error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is 1, +0 is returned</li><li> If the argument is 2, +0 is returned</li><li> If the argument is \xc2\xb10, +\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised</li><li> If the argument is a negative integer, +\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised</li><li> If the argument is \xc2\xb1\xe2\x88\x9e, +\xe2\x88\x9e is returned.</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/lgamma
log, logf, logl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 logf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0log( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double logl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define log( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the natural (base <i>e</i>) logarithm of <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>logl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>log</code> is called. Otherwise, <code>logf</code> is called. If <code>arg</code> is complex or imaginary, then the macro invokes the corresponding complex function (<code>clogf</code>, <code>clog</code>, <code>clogl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the natural (base-<i>e</i>) logarithm of <code>arg</code> (ln(arg) or log<br/>e(arg)) is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error occurs if <code>arg</code> is less than zero.</p><p>Pole error may occur if <code>arg</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, -\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised.</li><li> If the argument is 1, +0 is returned</li><li> If the argument is negative, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised.</li><li> If the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If the argument is NaN, NaN is returned</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;#include &lt;errno.h&gt;#include &lt;fenv.h&gt;#pragma STDC FENV_ACCESS ONint main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log(1) =\xc2\xa0%f\n", log(1));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("base-5 logarithm of 125 =\xc2\xa0%f\n", log(125)/log(5));    // special values    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log(1) =\xc2\xa0%f\n", log(1));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log(+Inf) =\xc2\xa0%f\n", log(INFINITY));    //error handling    errno = 0; <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log(0) =\xc2\xa0%f\n", log(0));    if(errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>) <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("    errno == ERANGE");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>)) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("    FE_DIVBYZERO raised");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>log(1) = 0.000000<br>base-5 logarithm of 125 = 3.000000<br>log(1) = 0.000000<br>log(+Inf) = inf<br>log(0) = -inf<br>    errno == ERANGE: Numerical result out of range<br>    FE_DIVBYZERO raised</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/log
log10, log10f, log10l	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 log10f( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0log10( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double log10l( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define log10( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the common (base-<i>10</i>) logarithm of <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>log10l</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>log10</code> is called. Otherwise, <code>log10f</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the common (base-<i>10</i>) logarithm of <code>arg</code> (log<br/>10(arg) or lg(arg)) is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error occurs if <code>arg</code> is less than zero.</p><p>Pole error may occur if <code>arg</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, -\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised.</li><li> If the argument is 1, +0 is returned</li><li> If the argument is negative, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised.</li><li> If the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If the argument is NaN, NaN is returned</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;float.h&gt;#include &lt;errno.h&gt;#include &lt;fenv.h&gt;#pragma STDC FENV_ACCESS ONint main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log10(1000) =\xc2\xa0%f\n", log10(1000));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log10(0.001) =\xc2\xa0%f\n", log10(0.001));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("base-5 logarithm of 125 =\xc2\xa0%f\n", log10(125)/log10(5));    // special values    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log10(1) =\xc2\xa0%f\n", log10(1));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log10(+Inf) =\xc2\xa0%f\n", log10(INFINITY));    //error handling    errno = 0; <a href="http://en.cppreference.com/w/c/numeric/fenv/feclearexcept">feclearexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_ALL_EXCEPT</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("log10(0) =\xc2\xa0%f\n", log10(0));    if(errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>) <a href="http://en.cppreference.com/w/c/io/perror">perror</a>("    errno == ERANGE");    if(<a href="http://en.cppreference.com/w/c/numeric/fenv/fetestexcept">fetestexcept</a>(<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions">FE_DIVBYZERO</a>)) <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("    FE_DIVBYZERO raised");}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>log10(1000) = 3.000000<br>log10(0.001) = -3.000000<br>base-5 logarithm of 125 = 3.000000<br>log10(1) = 0.000000<br>log10(+Inf) = inf<br>log10(0) = -inf<br>    errno == ERANGE: Numerical result out of range<br>    FE_DIVBYZERO raised</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/log10
log1p, log1pf, log1pl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 log1pf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0log1p( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double log1pl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define log1p( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the natural (base <code>e</code>) logarithm of <code>1+arg</code>. This function is more precise than the expression <code><a href="http://en.cppreference.com/w/c/numeric/math/log">log</a>(1+arg)</code> if <code>arg</code> is close to zero.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>log1pl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>log1p</code> is called. Otherwise, <code>log1pf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur ln(1+arg) is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error occurs if <code>arg</code> is less than -1.</p><p>Pole error may occur if <code>arg</code> is -1.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, it is returned unmodified</li><li> If the argument is -1, -\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised.</li><li> If the argument is less than -1, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised.</li><li> If the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/log1p
log2, log2f, log2l	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 log2f( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0log2( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double log2l( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define log2( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the base <code>2</code> logarithm of <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>log2l</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>log2</code> is called. Otherwise, <code>log2f</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the base-<i>2</i> logarithm of <code>arg</code> (log<br/>2(arg) or lb(arg)) is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error occurs if <code>arg</code> is less than zero.</p><p>Pole error may occur if <code>arg</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, -\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised.</li><li> If the argument is 1, +0 is returned</li><li> If the argument is negative, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised.</li><li> If the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/log2
logb, logbf, logbl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 logbf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0logb( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double logbl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define logb( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Extracts the value of the unbiased radix-independent exponent from the floating-point argument <code>arg</code>, and returns it as a floating-point value. </div><div>4) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>logbl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>logb</code> is called. Otherwise, <code>logbf</code> is called.</div><p>Formally, the unbiased exponent is the signed integral part of log<br/>r|arg| (returned by this function as a floating-point value), for non-zero arg, where <code>r</code> is <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">FLT_RADIX</a>. If <code>arg</code> is subnormal, it is treated as though it was normalized.</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the unbiased exponent of <code>arg</code> is returned as a signed floating-point value.</p><p>If a domain error occurs, an implementation-defined value is returned<br></p><p>If a pole error occurs, <code>-HUGE_VAL</code>, <code>-HUGE_VALF</code>, or <code>-HUGE_VALL</code> is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain or range error may occur if <code>arg</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>arg</code> is \xc2\xb10, -\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised.</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, +\xe2\x88\x9e is returned</li><li> If <code>arg</code> is NaN, NaN is returned.</li><li> In all other cases, the result is exact (<a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised) and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">the current rounding mode</a> is ignored</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/logb
MATH_ERRNO, MATH_ERREXCEPT, math_errhandling	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define MATH_ERRNO \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa01</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define MATH_ERREXCEPT \xc2\xa0 \xc2\xa02</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>#define math_errhandling \xc2\xa0/*implementation defined*/</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The macro constant <code>math_errhandling</code> expands to an expression of type <code>int</code> that is either equal to <code>MATH_ERRNO</code>, or equal to <code>MATH_ERREXCEPT</code>, or equal to their bitwise OR (<code>MATH_ERRNO | MATH_ERREXCEPT</code>).</p><p>The value of <code>math_errhandling</code> indicates the type of error handling that is performed by the floating-point operators and <a href="http://en.cppreference.com/w/c/numeric/math" title="c/numeric/math">functions</a>:</p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>MATH_ERREXCEPT</code></td><td>  indicates that floating-point exceptions are used: at least <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a>, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a>, and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_OVERFLOW</a> are defined in <code>&lt;fenv.h&gt;</code>.</td></tr><tr><td> <code>MATH_ERRNO</code></td><td>  indicates that floating-point operations use the variable <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> to report errors.</td></tr></table><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559), <code>math_errhandling &amp; MATH_ERREXCEPT</code> is required to be non-zero.</p><p>The following floating-point error conditions are recognized:<br></p><table><tr><th>Condition</th><th>Explanation</th><th>errno</th><th>floating-point exception</th><th>Example</th></tr><tr><td>Domain error</td><td>the argument is outside the range in which the operation is mathematically defined (the description of <a href="http://en.cppreference.com/w/c/numeric/math" title="c/numeric/math">each function</a> lists the required domain errors)</td><td><a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EDOM</a></td><td><a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a></td><td><code><a href="http://en.cppreference.com/w/c/numeric/math/acos">acos</a>(2)</code></td></tr><tr><td>Pole error</td><td>the mathematical result of the function is exactly infinite or undefined</td><td><a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">ERANGE</a></td><td><a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a></td><td><code><a href="http://en.cppreference.com/w/c/numeric/math/log">log</a>(0.0)</code>, <code>1.0/0.0</code></td></tr><tr><td>Range error due to overflow</td><td>the mathematical result is finite, but becomes infinite after rounding, or becomes the largest representable finite value after rounding down</td><td><a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">ERANGE</a></td><td><a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_OVERFLOW</a></td><td><code><a href="http://en.cppreference.com/w/c/numeric/math/pow">pow</a>(<a href="http://en.cppreference.com/w/c/types/limits">DBL_MAX</a>,2)</code></td></tr><tr><td>Range error due to underflow</td><td>the result is non-zero, but becomes zero after rounding, or becomes subnormal with a loss of precision</td><td><a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">ERANGE</a> or unchanged (implementation-defined)</td><td><a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_UNDERFLOW</a> or nothing (implementation-defined)</td><td><code><a href="http://en.cppreference.com/w/c/types/limits">DBL_MIN</a>/2</code></td></tr><tr><td>Inexact result</td><td>the result has to be rounded to fit in the destination type</td><td>unchanged</td><td><a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> or nothing (unspecified)</td><td><code><a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(2)</code>, <code>1.0/10.0</code></td></tr></table></section>	http://en.cppreference.com/w/c/numeric/math/math_errhandling
modf, modff, modfl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 modff( float arg, float* iptr );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0modf( double arg, double* iptr );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double modfl( long double arg, long double* iptr );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Decomposes given floating point value <code>arg</code> into integral and fractional parts, each having the same type and sign as <code>arg</code>. The integral part (in floating-point format) is stored in the object pointed to by <code>iptr</code>.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr><tr><td>  iptr</td><td> -</td><td>  pointer to floating point value to store the integral part to</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, returns the fractional part of <code>x</code> with the same sign as <code>x</code>. The integral part is put into the value pointed to by <code>iptr</code>.</p><p>The sum of the returned value and the value stored in <code>*iptr</code> gives <code>arg</code> (allowing for rounding).</p><span class="prog__sub"> Error handling</span><p>This function is not subject to any errors specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If <code>arg</code> is \xc2\xb10, \xc2\xb10 is returned, and \xc2\xb10 is stored in <code>*iptr</code>.</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, \xc2\xb10 is returned, and \xc2\xb1\xe2\x88\x9e is stored in <code>*iptr</code>.</li><li> If <code>arg</code> is NaN, NaN is returned, and NaN is stored in <code>*iptr</code>.</li><li> The returned value is exact, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">the current rounding mode</a> is ignored</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/modf
nan, nanf, nanl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 nanf( const char* arg );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0nan( const char* arg );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>long double nanl( const char* arg );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts the implementation-defined character string <code>arg</code> into the corresponding quiet NaN value, as if by calling <a href="http://en.cppreference.com/w/c/string/byte/strtof" title="c/string/byte/strtof">strtof</a>, <a href="http://en.cppreference.com/w/c/string/byte/strtof" title="c/string/byte/strtof">strtod</a>, or <a href="http://en.cppreference.com/w/c/string/byte/strtof" title="c/string/byte/strtof">strtold</a>, respectively, as follows:</p><p>The call <code>nan("string")</code> is equivalent to the call <code><a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a>("NAN(string)", (char**)<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>);</code>.</p><p>The call <code>nan("")</code> is equivalent to the call <code><a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a>("NAN()", (char**)<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>);</code>.</p><p>The call <code>nan(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>)</code> is equivalent to the call <code><a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a>("NAN", (char**)<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>);</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  narrow character string identifying the contents of a NaN</td></tr></table><span class="prog__sub"> Return value</span><p>The quiet NaN value that corresponds to the identifying string <code>arg</code> or zero if the implementation does not support quiet NaNs. </p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdint.h&gt;#include &lt;inttypes.h&gt;#include &lt;string.h&gt;\xc2\xa0int main(void){    double f1 = nan("1");    <a href="http://en.cppreference.com/w/c/types/integer">uint64_t</a> f1n; <a href="http://en.cppreference.com/w/c/string/byte/memcpy">memcpy</a>(&amp;f1n, &amp;f1, sizeof f1);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("nan("1")   =\xc2\xa0%f (%" <a href="http://en.cppreference.com/w/c/types/integer">PRIx64</a> ")\n", f1, f1n);\xc2\xa0    double f2 = nan("2");    <a href="http://en.cppreference.com/w/c/types/integer">uint64_t</a> f2n; <a href="http://en.cppreference.com/w/c/string/byte/memcpy">memcpy</a>(&amp;f2n, &amp;f2, sizeof f2);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("nan("2")   =\xc2\xa0%f (%" <a href="http://en.cppreference.com/w/c/types/integer">PRIx64</a> ")\n", f2, f2n);\xc2\xa0    double f3 = nan("0xF");    <a href="http://en.cppreference.com/w/c/types/integer">uint64_t</a> f3n; <a href="http://en.cppreference.com/w/c/string/byte/memcpy">memcpy</a>(&amp;f3n, &amp;f3, sizeof f3);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("nan("0xF") =\xc2\xa0%f (%" <a href="http://en.cppreference.com/w/c/types/integer">PRIx64</a> ")\n", f3, f3n);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>nan("1")   = nan (7ff8000000000001)<br>nan("2")   = nan (7ff8000000000002)<br>nan("0xF") = nan (7ff800000000000f)</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/numeric/math/nan
nearbyint, nearbyintf, nearbyintl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 nearbyintf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0nearbyint( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double nearbyintl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define nearbyint( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Rounds the floating-point argument <code>arg</code> to an integer value in floating-point format, using the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">current rounding mode</a>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>nearbyintl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>nearbyint</code> is called. Otherwise, <code>nearbyintf</code> is called, respectively.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>The nearest integer value to <code>arg</code>, according to the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">current rounding mode</a>, is returned.</p><span class="prog__sub"> Error handling</span><p>This function is not subject to any of the errors specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, unmodified</li><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/nearbyint
nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 nextafterf( float from, float to );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0nextafter( double from, double to );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double nextafterl( long double from, long double to );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 nexttowardf( float from, long double to );</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0nexttoward( double from, long double to );</code></div></td><td> (5) </td><td> (since C99) </td></tr><tr><td> <div><code>long double nexttowardl( long double from, long double to );</code></div></td><td> (6) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define nextafter(from, to)</code></div></td><td> (7) </td><td> (since C99) </td></tr><tr><td> <div><code>#define nexttoward(from, to)</code></div></td><td> (8) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) First, converts both arguments to the type of the function, then returns the next representable value of <code>from</code> in the direction of <code>to</code>. If <code>from</code> equals to <code>to</code>, <code>to</code> is returned.</div><div>4-6) First, converts the first argument to the type of the function, then returns the next representable value of <code>from</code> in the direction of <code>to</code>. If <code>from</code> equals to <code>to</code>, <code>to</code> is returned, converted from <code>long double</code> to the return type of the function without loss of range or precision.</div><div>7) Type-generic macro: If any argument has type <code>long double</code>, <code>nextafterl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>nextafter</code> is called. Otherwise, <code>nextafterf</code> is called.</div><div>8) Type-generic macro: If the argument <code>from</code> has type <code>long double</code>, <code>nexttowardl</code> is called. Otherwise, if <code>from</code> has integer type or the type <code>double</code>, <code>nexttoward</code> is called. Otherwise, <code>nexttowardf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  from, to</td><td> -</td><td>  floating point values</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the next representable value of <code>from</code> in the direction of <code>to</code>. is returned. If <code>from</code> equals <code>to</code>, then <code>to</code> is returned, converted to the type of the function.</p><p>If a range error due to overflow occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned (with the same sign as <code>from</code>).</p><p>If a range error occurs due to underflow, the correct result is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if <code>from</code> is finite, but the expected result is an infinity, raises <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_OVERFLOW</a></li><li> if <code>from</code> does not equal <code>to</code> and the result is subnormal or zero, raises <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_UNDERFLOW</a></li><li> in any case, the returned value is independent of the current rounding mode</li><li> if either <code>from</code> or <code>to</code> is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/nextafter
pow, powf, powl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float powf( float base, float exponent );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double pow( double base, double exponent );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double powl( long double base, long double exponent );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define pow( base, exponent )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the value of <code>base</code> raised to the power <code>exponent</code>.</div><div>4) Type-generic macro: If any argument has type <code>long double</code>, <code>powl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>pow</code> is called. Otherwise, <code>powf</code> is called. If at least one argument is complex or imaginary, then the macro invokes the corresponding complex function (<code>cpowf</code>, <code>cpow</code>, <code>cpowl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  base</td><td> -</td><td>  base as floating point value</td></tr><tr><td>  exponent</td><td> -</td><td>  exponent as floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, <code>base</code> raised to the power of <code>exponent</code> (baseexponent<br/>) is returned. </p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a pole error or a range error due to overflow occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If <code>base</code> is finite and negative and <code>exponent</code> is finite and non-integer, a domain error occurs and a range error may occur.</p><p>If <code>base</code> is zero and <code>exponent</code> is zero, a domain error may occur.</p><p>If <code>base</code> is zero and <code>exponent</code> is negative, a domain error or a pole error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> <code>pow(+0, exponent)</code>, where <code>exponent</code> is a negative odd integer, returns <code>+\xe2\x88\x9e</code> and raises <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a></li><li> <code>pow(-0, exponent)</code>, where <code>exponent</code> is a negative odd integer, returns <code>-\xe2\x88\x9e</code> and raises <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a></li><li> <code>pow(\xc2\xb10, exponent)</code>, where <code>exponent</code> is negative, finite, and is an even integer or a non-integer, returns +\xe2\x88\x9e and raises <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a></li><li> <code>pow(\xc2\xb10, -\xe2\x88\x9e)</code> returns +\xe2\x88\x9e and may raise <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a></li><li> <code>pow(+0, exponent)</code>, where <code>exponent</code> is a positive odd integer, returns +0</li><li> <code>pow(-0, exponent)</code>, where <code>exponent</code> is a positive odd integer, returns -0</li><li> <code>pow(\xc2\xb10, exponent)</code>, where <code>exponent</code> is positive non-integer or a positive even integer, returns +0</li><li> <code>pow(-1, \xc2\xb1\xe2\x88\x9e)</code> returns <code>1</code></li><li> <code>pow(+1, exponent)</code> returns <code>1</code> for any <code>exponent</code>, even when <code>exponent</code> is <code>NaN</code></li><li> <code>pow(base, \xc2\xb10)</code> returns <code>1</code> for any <code>base</code>, even when <code>base</code> is <code>NaN</code></li><li> <code>pow(base, exponent)</code> returns <code>NaN</code> and raises <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> if <code>base</code> is finite and negative and <code>exponent</code> is finite and non-integer.</li><li> <code>pow(base, -\xe2\x88\x9e)</code> returns +\xe2\x88\x9e for any <code>|base|&lt;1</code></li><li> <code>pow(base, -\xe2\x88\x9e)</code> returns +0 for any <code>|base|&gt;1</code></li><li> <code>pow(base, +\xe2\x88\x9e)</code> returns +0 for any <code>|base|&lt;1</code></li><li> <code>pow(base, +\xe2\x88\x9e)</code> returns +\xe2\x88\x9e for any <code>|base|&gt;1</code></li><li> <code>pow(-\xe2\x88\x9e, exponent)</code> returns -0 if <code>exponent</code> is a negative odd integer</li><li> <code>pow(-\xe2\x88\x9e, exponent)</code> returns +0 if <code>exponent</code> is a negative non-integer or even integer</li><li> <code>pow(-\xe2\x88\x9e, exponent)</code> returns -\xe2\x88\x9e if <code>exponent</code> is a positive odd integer</li><li> <code>pow(-\xe2\x88\x9e, exponent)</code> returns +\xe2\x88\x9e if <code>exponent</code> is a positive non-integer or even integer</li><li> <code>pow(+\xe2\x88\x9e, exponent)</code> returns +0 for any negative <code>exponent</code></li><li> <code>pow(+\xe2\x88\x9e, exponent)</code> returns +\xe2\x88\x9e for any positive <code>exponent</code></li><li> except where specified above, if any argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/pow
remainder, remainderf, remainderl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 remainderf( float x, float y );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0remainder( double x, double y );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double remainderl( long double x, long double y );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define remainder( x, y )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the IEEE remainder of the floating point division operation <code>x/y</code>.</div><div>4) Type-generic macro: If any argument has type <code>long double</code>, <code>remainderl</code> is called. Otherwise, if any argument has integer type or has type <code>double</code>, <code>remainder</code> is called. Otherwise, <code>remainderf</code> is called.</div><p>The IEEE floating-point remainder of the division operation <code>x/y</code> calculated by this function is exactly the value <code>x - n*y</code>, where the value <code>n</code> is the integral value nearest the exact value <code>x/y</code>. When |n-x/y| = \xc2\xbd, the value <code>n</code> is chosen to be even.</p><p>In contrast to <a href="http://en.cppreference.com/w/c/numeric/math/fmod" title="c/numeric/math/fmod">fmod()</a>, the returned value is not guaranteed to have the same sign as <code>x</code>.</p><p>If the returned value is <code>0</code>, it will have the same sign as <code>x</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  floating point values</td></tr></table><span class="prog__sub"> Return value</span><p>If successful, returns the IEEE floating-point remainder of the division <code>x/y</code> as defined above.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result is returned.<br></p><p>If <code>y</code> is zero, but the domain error does not occur, zero is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error may occur if <code>y</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current <a href="http://en.cppreference.com/w/cpp/numeric/fenv/FE_round" title="cpp/numeric/fenv/FE round">rounding mode</a> has no effect.</li><li> <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised, the result is always exact.</li><li> If <code>x</code> is \xc2\xb1\xe2\x88\x9e and <code>y</code> is not NaN, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>y</code> is \xc2\xb10 and <code>x</code> is not NaN, NaN is returned  and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If either argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/remainder
remquo, remquof, remquol	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 remquof( float x, float y, int *quo );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0remquo( double x, double y, int *quo );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double remquol( long double x, long double y, int *quo );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define remquo( x, y, quo )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the floating-point remainder of the division operation <code>x/y</code> as the <a href="http://en.cppreference.com/w/c/numeric/math/remainder" title="c/numeric/math/remainder">remainder()</a> function does.  Additionally, the sign and at least the three of the last bits of <code>x/y</code> will be stored in <code>quo</code>, sufficient to determine the octant of the result within a period.</div><div>4) Type-generic macro: If any non-pointer argument has type <code>long double</code>, <code>remquol</code> is called. Otherwise, if any non-pointer argument has integer type or has type <code>double</code>, <code>remquo</code> is called. Otherwise, <code>remquof</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  x, y</td><td> -</td><td>  floating point values</td></tr><tr><td>  quo</td><td> -</td><td>  pointer to an integer value to store the sign and some bits of <code>x/y</code></td></tr></table><span class="prog__sub"> Return value</span><p>If successful, returns the floating-point remainder of the division <code>x/y</code> as defined in <a href="http://en.cppreference.com/w/c/numeric/math/remainder" title="c/numeric/math/remainder">remainder</a>, and stores, in <code>*quo</code>, the sign and at least three of the least significant bits of <code>x/y</code> (formally, stores a value whose sign is the sign of <code>x/y</code> and whose magnitude is congruent modulo 2n<br/> to the magnitude of the integral quotient of <code>x/y</code>, where n is an implementation-defined integer greater than or equal to 3).</p><p>If <code>y</code> is zero, the value stored in <code>*quo</code> is unspecified.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.<br></p><p>If <code>y</code> is zero, but the domain error does not occur, zero is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error may occur if <code>y</code> is zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding mode</a> has no effect.</li><li> <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised</li><li> If <code>x</code> is \xc2\xb1\xe2\x88\x9e and <code>y</code> is not NaN, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If <code>y</code> is \xc2\xb10 and <code>x</code> is not NaN, NaN is returned  and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If either <code>x</code> or <code>y</code> is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/remquo
rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float rintf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double rint( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double rintl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define rint( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>long lrintf( float arg );</code></div></td><td> (5) </td><td> (since C99) </td></tr><tr><td> <div><code>long lrint( double arg );</code></div></td><td> (6) </td><td> (since C99) </td></tr><tr><td> <div><code>long lrintl( long double arg );</code></div></td><td> (7) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define lrint( arg )</code></div></td><td> (8) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>long long llrintf( float arg );</code></div></td><td> (9) </td><td> (since C99) </td></tr><tr><td> <div><code>long long llrint( double arg );</code></div></td><td> (10) </td><td> (since C99) </td></tr><tr><td> <div><code>long long llrintl( long double arg );</code></div></td><td> (11) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define llrint( arg )</code></div></td><td> (12) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Rounds the floating-point argument <code>arg</code> to an integer value in floating-point format, using the current rounding mode.</div><div>5-7, 9-11) Rounds the floating-point argument <code>arg</code> to an integer value in integer format, using the current rounding mode.</div><div>4,8,12) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>rintl</code>, <code>lrintl</code>, <code>llrintl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>rint</code>, <code>lrint</code>, <code>llrint</code> is called. Otherwise, <code>rintf</code>, <code>lrintf</code>, <code>llrintf</code> is called, respectively.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the nearest integer value to <code>arg</code>, according to the <a href="http://en.cppreference.com/w/cpp/numeric/fenv/FE_round" title="cpp/numeric/fenv/FE round">current rounding mode</a>, is returned.</p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the result of <code>lrint</code> or <code>llrint</code> is outside the range representable by the return type, a domain error or a range error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><dl><dd> For the <code>rint</code> function:</dd></dl><ul><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, unmodified</li><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul><dl><dd> For <code>lrint</code> and <code>llrint</code> functions:</dd></dl><ul><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised and an implementation-defined value is returned</li><li> If the result of the rounding is outside the range of the return type, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised and an implementation-defined value is returned</li><li> If <code>arg</code> is NaN, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised and an implementation-defined value is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/rint
round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 roundf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0round( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double roundl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define round( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>long \xc2\xa0 \xc2\xa0 \xc2\xa0lroundf( float arg );</code></div></td><td> (5) </td><td> (since C99) </td></tr><tr><td> <div><code>long \xc2\xa0 \xc2\xa0 \xc2\xa0lround( double arg );</code></div></td><td> (6) </td><td> (since C99) </td></tr><tr><td> <div><code>long \xc2\xa0 \xc2\xa0 \xc2\xa0lroundl( long double arg );</code></div></td><td> (7) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define lround( arg )</code></div></td><td> (8) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>long long llroundf( float arg );</code></div></td><td> (9) </td><td> (since C99) </td></tr><tr><td> <div><code>long long llround( double arg );</code></div></td><td> (10) </td><td> (since C99) </td></tr><tr><td> <div><code>long long llroundl( long double arg );</code></div></td><td> (11) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define llround( arg )</code></div></td><td> (12) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the nearest integer value to <code>arg</code> (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.</div><div>5-7, 9-11) Computes the nearest integer value to <code>arg</code> (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode.</div><div>4,8,12) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>roundl</code>, <code>lroundl</code>, <code>llroundl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>round</code>, <code>lround</code>, <code>llround</code> is called. Otherwise, <code>roundf</code>, <code>lroundf</code>, <code>llroundf</code> is called, respectively.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the nearest integer value to <code>arg</code>, rounding halfway cases away from zero, is returned.</p><div><div>Return value</div><div>Argument</div></div><p>If a domain error occurs, an implementation-defined value is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the result of <code>lround</code> or <code>llround</code> is outside the range representable by the return type, a domain error or a range error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><dl><dd> For the <code>round</code>, <code>roundf</code>, and <code>roundl</code> function:</dd></dl><ul><li> The current <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding mode</a> has no effect.</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, unmodified</li><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul><dl><dd> For <code>lround</code> and <code>llround</code> families of functions:</dd></dl><ul><li> <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised</li><li> The current <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding mode</a> has no effect.</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised and an implementation-defined value is returned</li><li> If the result of the rounding is outside the range of the return type, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised and an implementation-defined value is returned</li><li> If <code>arg</code> is NaN, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised and an implementation-defined value is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/round
scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 scalbnf( float arg, int <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0scalbn( double arg, int <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double scalbnl( long double arg, int <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define scalbn( arg, exp )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 scalblnf( float arg, long <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (5) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0scalbln( double arg, long <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (6) </td><td> (since C99) </td></tr><tr><td> <div><code>long double scalblnl( long double arg, long <a href="http://en.cppreference.com/w/c/numeric/math/exp">exp</a> );</code></div></td><td> (7) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define scalbln( arg, exp )</code></div></td><td> (8) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3,5-7) Multiplies a floating point value <code>arg</code> by <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">FLT_RADIX</a> raised to power <code>exp</code>.</div><div>4,8) Type-generic macros: If <code>arg</code> has type <code>long double</code>, <code>scalbnl</code> or <code>scalblnl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>scalbn</code> or <code>scalbln</code> is called. Otherwise, <code>scalbnf</code> or <code>scalblnf</code> is called, respectively.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr><tr><td>  exp</td><td> -</td><td>  integer value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, <code>arg</code> multiplied by <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">FLT_RADIX</a> to the power of <code>exp</code> (arg\xc3\x97FLT_RADIXexp<br/>) is returned.</p><p>If a range error due to overflow occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> Unless a range error occurs, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a> is never raised (the result is exact)</li><li> Unless a range error occurs, the <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">current rounding mode</a> is ignored</li><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, unmodified</li><li> If <code>exp</code> is 0, then <code>arg</code> is returned, unmodified</li><li> If <code>arg</code> is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/scalbn
signbit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define signbit(arg) /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines if the given floating point number <code>arg</code> is negative. The macro returns an integral value.</p><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>Nonzero integral value if <code>arg</code> is negative, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p></section>	http://en.cppreference.com/w/c/numeric/math/signbit
sin, sinf, sinl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 sinf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0sin( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double sinl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define sin( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the sine of <code>arg</code> (measured in radians).</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>sinl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>sin</code> is called. Otherwise, <code>sinf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>csinf</code>, <code>csin</code>, <code>csinl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing an angle in radians</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the sine of <code>arg</code> (sin(arg)) in the range [-1\xc2\xa0; +1], is returned.</p><table><tr><td><p>The result may have little or no significance if the magnitude of <code>arg</code> is large.</p></td><td>(until C99)</td></tr></table><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10, it is returned unmodified</li><li> if the argument is \xc2\xb1\xe2\x88\x9e, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/sin
sinh, sinhf, sinhl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 sinhf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0sinh( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double sinhl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define sinh( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes hyperbolic sine of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>sinhl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>sinh</code> is called. Otherwise, <code>sinhf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>csinhf</code>, <code>csinh</code>, <code>csinhl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing a hyperbolic angle</td></tr></table><span class="prog__sub"> Return value</span><code>arg</code><table><tr><td>earg<br/>-e-arg<br/></td></tr><tr><td>2</td></tr></table><p>If a range error due to overflow occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned.</p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10 or \xc2\xb1\xe2\x88\x9e, it is returned unmodified</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/sinh
sqrt, sqrtf, sqrtl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 sqrtf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0sqrt( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double sqrtl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define sqrt( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes square root of <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>sqrtl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>sqrt</code> is called. Otherwise, <code>sqrtf</code> is called. If <code>arg</code> is complex or imaginary, then the macro invokes the corresponding complex function (<code>csqrtf</code>, <code>csqrt</code>, <code>csqrtl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, square root of <code>arg</code> (\xe2\x88\x9aarg), is returned.</p><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>Domain error occurs if <code>arg</code> is less than zero.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is less than -0, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised and NaN is returned.</li><li> If the argument is +\xe2\x88\x9e or \xc2\xb10, it is returned, unmodified.</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/sqrt
tan, tanf, tanl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 tanf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0tan( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double tanl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define tan( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the tangent of <code>arg</code>  (measured in radians).</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>tanl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>tan</code> is called. Otherwise, <code>tanf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>ctanf</code>, <code>ctan</code>, <code>ctanl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing angle in radians</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the tangent of <code>arg</code> (tan(arg)) is returned.</p><table><tr><td><p>The result may have little or no significance if the magnitude of <code>arg</code> is large.</p></td><td>(until C99)</td></tr></table><p>If a domain error occurs, an implementation-defined value is returned (NaN where supported).<br></p><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10, it is returned unmodified</li><li> if the argument is \xc2\xb1\xe2\x88\x9e, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/tan
tanh, tanhf, tanhl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 tanhf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0tanh( double arg );</code></div></td><td> (2) </td><td> </td></tr><tr><td> <div><code>long double tanhl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define tanh( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the hyperbolic tangent of <code>arg</code>.</div><div>4) Type-generic macro: If the argument has type <code>long double</code>, <code>tanhl</code> is called. Otherwise, if the argument has integer type or the type <code>double</code>, <code>tanh</code> is called. Otherwise, <code>tanhf</code> is called. If the argument is complex, then the macro invokes the corresponding complex function (<code>ctanhf</code>, <code>ctanh</code>, <code>ctanhl</code>).</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value representing a hyperbolic angle</td></tr></table><span class="prog__sub"> Return value</span><code>arg</code><table><tr><td>earg<br/>-e-arg<br/></td></tr><tr><td>earg<br/>+e-arg<br/></td></tr></table><p>If a range error occurs due to underflow, the correct result (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> if the argument is \xc2\xb10, \xc2\xb10 is returned</li><li> If the argument is \xc2\xb1\xe2\x88\x9e, \xc2\xb11 is returned</li><li> if the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/tanh
tgamma, tgammaf, tgammal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 tgammaf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0tgamma( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double tgammal( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define tgamma( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the <a class="extiw" href="http://en.wikipedia.com/wiki/Gamma_function" title="enwiki:Gamma function">gamma function</a> of <code>arg</code>.</div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>tgammal</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>tgamma</code> is called. Otherwise, <code>tgammaf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the value of the gamma function of <code>arg</code>, that is \xe2\x88\xab\xe2\x88\x9e<br/>0<i>t</i>arg-1<br/> <i>e</i><sup>-t</sup> d<i>t</i>, is returned.</p><p>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.<br></p><p>If a pole error occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned.</p><p>If a range error due to overflow occurs, <code>\xc2\xb1HUGE_VAL</code>, <code>\xc2\xb1HUGE_VALF</code>, or <code>\xc2\xb1HUGE_VALL</code> is returned.</p><p>If a range error due to underflow occurs, the correct value (after rounding) is returned.<br></p><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If <code>arg</code> is zero or is an integer less than zero, a pole error or a domain error may occur.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> If the argument is \xc2\xb10, \xc2\xb1\xe2\x88\x9e is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_DIVBYZERO</a> is raised</li><li> If the argument is a negative integer, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If the argument is -\xe2\x88\x9e, NaN is returned and <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_exceptions" title="c/numeric/fenv/FE exceptions">FE_INVALID</a> is raised</li><li> If the argument is +\xe2\x88\x9e, +\xe2\x88\x9e is returned.</li><li> If the argument is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/tgamma
trunc, truncf, truncl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;math.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 truncf( float arg );</code></div></td><td> (1) </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0trunc( double arg );</code></div></td><td> (2) </td><td> (since C99) </td></tr><tr><td> <div><code>long double truncl( long double arg );</code></div></td><td> (3) </td><td> (since C99) </td></tr><tr><td> <div>Defined in header <code>&lt;tgmath.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define trunc( arg )</code></div></td><td> (4) </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1-3) Computes the nearest integer not greater in magnitude than <code>arg</code>. </div><div>4) Type-generic macro: If <code>arg</code> has type <code>long double</code>, <code>truncl</code> is called. Otherwise, if <code>arg</code> has integer type or the type <code>double</code>, <code>trunc</code> is called. Otherwise, <code>truncf</code> is called.</div><span class="prog__sub"> Parameters</span><table><tr><td>  arg</td><td> -</td><td>  floating point value</td></tr></table><span class="prog__sub"> Return value</span><p>If no errors occur, the nearest integer value not greater in magnitude than <code>arg</code> (in other words, <code>arg</code> rounded towards zero), is returned.</p><div><div>Return value</div><div>Argument</div></div><span class="prog__sub"> Error handling</span><p>Errors are reported as specified in <a href="http://en.cppreference.com/w/c/numeric/math/math_errhandling" title="c/numeric/math/math errhandling">math_errhandling</a>.</p><p>If the implementation supports IEEE floating-point arithmetic (IEC 60559),<br></p><ul><li> The current <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">rounding mode</a> has no effect.</li><li> If <code>arg</code> is \xc2\xb1\xe2\x88\x9e, it is returned, unmodified</li><li> If <code>arg</code> is \xc2\xb10, it is returned, unmodified</li><li> If arg is NaN, NaN is returned</li></ul></section>	http://en.cppreference.com/w/c/numeric/math/trunc
rand	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int rand();</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns a pseudo-random integer value between <code>\xe2\x80\x8b0\xe2\x80\x8b</code> and <a href="http://en.cppreference.com/w/c/numeric/random/RAND_MAX" title="c/numeric/random/RAND MAX">RAND_MAX</a> (0 and <code>RAND_MAX</code> included).</p><p><a href="http://en.cppreference.com/w/c/numeric/random/srand" title="c/numeric/random/srand">srand()</a> seeds the pseudo-random number generator used by <code>rand()</code>.If <code>rand()</code> is used before any calls to <code>srand()</code>, <code>rand()</code> behaves as if it was seeded with <code>srand(1)</code>.Each time <code>rand()</code> is seeded with <code>srand()</code>, it must produce the same sequence of values.</p><p><code>rand()</code> is not guaranteed to be thread-safe.</p><span class="prog__sub"> Parameters</span><p>(none)<br></p><span class="prog__sub"> Return value</span><p>Pseudo-random integer value between <code>\xe2\x80\x8b0\xe2\x80\x8b</code> and <a href="http://en.cppreference.com/w/c/numeric/random/RAND_MAX" title="c/numeric/random/RAND MAX">RAND_MAX</a>, inclusive.</p></section>	http://en.cppreference.com/w/c/numeric/random/rand
RAND_MAX	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define RAND_MAX /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Expands to an integer constant expression equal to the maximum value returned by the function <a href="http://en.cppreference.com/w/c/numeric/random/rand" title="c/numeric/random/rand">rand()</a>. This value is implementation dependent. It's guaranteed that this value is at least <code>32767</code>.</p></section>	http://en.cppreference.com/w/c/numeric/random/RAND_MAX
srand	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void srand( unsigned seed );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Seeds the pseudo-random number generator used by <a href="http://en.cppreference.com/w/c/numeric/random/rand" title="c/numeric/random/rand">rand()</a> with the value <code>seed</code>.</p><p>If <code>rand()</code> is used before any calls to <code>srand()</code>, <code>rand()</code> behaves as if it was seeded with <code>srand(1)</code>.</p><p>Each time <code>rand()</code> is seeded with the same <code>seed</code>, it must produce the same sequence of values.</p><p><code>srand()</code> is not guaranteed to be thread-safe.</p><span class="prog__sub"> Parameters</span><table><tr><td>  seed</td><td> -</td><td>  the seed value</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/numeric/random/srand
Conditional inclusion	A										<section class="prog__container"><p>The preprocessor supports conditional compilation of parts of a source file. This behavior is controlled by <code>#if</code>, <code>#else</code>, <code>#elif</code>, <code>#ifdef</code>, <code>#ifndef</code> and <code>#endif</code> directives.</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>#if</code> expression</td><td></td><td></td></tr><tr><td></td></tr><tr><td> <code>#ifdef</code> expression</td><td></td><td></td></tr><tr><td></td></tr><tr><td> <code>#ifndef</code> expression</td><td></td><td></td></tr><tr><td></td></tr><tr><td> <code>#elif</code> expression</td><td></td><td></td></tr><tr><td></td></tr><tr><td> <code>#else</code></td><td></td><td></td></tr><tr><td></td></tr><tr><td> <code>#endif</code></td><td></td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>The conditional preprocessing block starts with <code>#if</code>, <code>#ifdef</code> or <code>#ifndef</code> directive, then optionally includes any number of <code>#elif</code> directives, then optionally includes at most one <code>#else</code> directive and is terminated with the <code>#endif</code> directive. Any inner conditional preprocessing blocks are processed separately.</p><p>Each of <code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#ifdef</code> and <code>#ifndef</code> directives control a code block until the first <code>#elif</code>, <code>#else</code>, <code>#endif</code> directive not belonging to any inner conditional preprocessing blocks. </p><p><code>#if</code>, <code>#ifdef</code> and <code>#ifndef</code>  directives test the specified condition (see below), and if it evaluates to true, compiles the controlled code block. In that case subsequent <code>#else</code> and <code>#elif</code> directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent <code>#else</code> or <code>#elif</code> directive (if any) is processed. In the former case, the code block controlled by the <code>#else</code> directive is unconditionally compiled. In the latter case, the <code>#elif</code> directive acts as if it were a <code>#if</code> directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent <code>#elif</code> and <code>#else</code> directives. The conditional preprocessing block is terminated by the <code>#endif</code> directive.</p><span class="prog__sub"> Conditional evaluation</span><h4> <code>#if, #elif</code></h4><p>The expression is a constant expression, using only <a href="http://en.cppreference.com/w/cpp/language#Literals" title="cpp/language">literals</a> and identifiers, defined using <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace"><tt>#define</tt></a> directive. Any identifier, which is not literal, non defined using <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace"><tt>#define</tt></a> directive, evaluates to <i>0</i>. </p><p>The expression may contain unary operators in form <code>defined</code>\xc2\xa0identifier or  <code>defined (</code>identifier<code>)</code> which return <code>1</code> if the identifier was defined using <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace"><tt>#define</tt></a> directive and <i>0</i> otherwise. If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with <code>\xe2\x80\x8b0\xe2\x80\x8b</code>.</p><table><tr><td>Note: <code>#if cond1</code> ... <code>#elif cond2</code> is different from <code>#if cond1</code> ... <code>#else</code> followed by <code>#if cond3</code> because if <code>cond1</code> is true, the second <code>#if</code> is skipped and <code>cond3</code> does not need to be well-formed, while #elif's <code>cond2</code> must be a valid expression.</td><td>(until C11)</td></tr></table><h4> <code>#ifdef, #ifndef</code></h4><p>Checks if the identifier was defined using <a href="http://en.cppreference.com/w/c/preprocessor/replace" title="c/preprocessor/replace"><tt>#define</tt></a> directive. </p><p><code>#ifdef</code>\xc2\xa0identifier is essentially equivalent to <code>#if defined(</code>\xc2\xa0identifier<code>)</code>.</p><p><code>#ifndef</code>\xc2\xa0identifier is essentially equivalent to <code>#if\xc2\xa0!defined(</code>\xc2\xa0identifier<code>)</code>.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#define ABCD 2#include &lt;stdio.h&gt;\xc2\xa0int main(void){\xc2\xa0#ifdef ABCD    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1: yes\n");#else    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("1: no\n");#endif\xc2\xa0#ifndef ABCD    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("2: no1\n");#elif ABCD == 2    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("2: yes\n");#else    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("2: no2\n");#endif\xc2\xa0#if\xc2\xa0!defined(DCBA) &amp;&amp; (ABCD &lt; 2*4-3)    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("3: yes\n");#endif}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>1: yes<br>2: yes<br>3: yes</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/preprocessor/conditional
Error directive	A										<section class="prog__container"><p>Shows the given error message and renders the program ill-formed.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>#error</code> error_message</td><td></td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>After encountering the <code>#error</code> directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops). </p><p><i>error_message</i> can consist of several words not necessarily in quotes.</p></section>	http://en.cppreference.com/w/c/preprocessor/error
Implementation defined behavior control	A										<section class="prog__container"><p>Implementation defined behavior is controlled by <code>#pragma</code> directive.</p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>#pragma</code> pragma_params</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>_Pragma</code> <code>(</code> string-literal <code>)</code></td><td> (2)</td><td> (since C99)</td></tr><tr><td></td></tr></table><div>1) Behaves in an implementation-defined manner (unless pragma_params is one of the standard pragmas shown below.</div><div>2) Removes the encoding prefix (if any), the outer quotes, and leading/trailing whitespace from string-literal, replaces each <code>"</code> with <code>"</code> and each <code>\\</code> with <code>\\</code>, then tokenizes the result (as in <a href="http://en.cppreference.com/w/c/language/translation_phases" title="c/language/translation phases">translation stage 3</a>), and then uses the result as if the input to <code>#pragma</code> in (1).</div><span class="prog__sub"> Explanation</span><p>The pragma directive controls implementation-specific behavior of the compiler, such as disabling compiler warnings or changing alignment requirements. Any pragma that is not recognized is ignored.<br></p><span class="prog__sub"> Standard pragmas</span><p>The following three pragmas are defined by the language standard:<br></p><table><tr><td></td></tr><tr><td> <code>#pragma STDC FENV_ACCESS </code>arg</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>#pragma STDC FP_CONTRACT </code>arg</td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>#pragma STDC CX_LIMITED_RANGE </code>arg</td><td> (3)</td><td></td></tr><tr><td></td></tr></table><p>where arg is either <code>ON</code> or <code>OFF</code> or <code>DEFAULT</code>. </p><div>1) If set to <code>ON</code>, informs the compiler that the program will access or modify <a href="http://en.cppreference.com/w/c/numeric/fenv" title="c/numeric/fenv">floating-point environment</a>, which means that optimizations that could subvert flag tests and mode changes (e.g., global common subexpression elimination, code motion, and constant folding) are prohibited. The default value is implementation-defined, usually <code>OFF</code>.</div><div>2) Allows <i>contracting</i> of floating-point expressions, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of <code>(x*y) + z</code> with a single fused multiply-add CPU instruction. The default value is implementation-defined, usually <code>ON</code>.</div><div>3) Informs the compiler that multiplication, division, and absolute value of complex numbers may use simplified mathematical formulas (x+iy)\xc3\x97(u+iv) = (xu-yv)+i(yu+xv), (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u2<br/>+v2<br/>), and |x+iy| = \xe2\x88\x9ax2<br/>+y2<br/>, despite the possibility of intermediate overflow. In other words, the programmer guarantees that the range of the values that will be passed to those function is limited. The default value is <code>OFF</code></div><span class="prog__sub"> Non-standard pragmas</span><h4> #pragma once</h4><p><code>#pragma once</code> is a non-standard pragma that is supported by the <a class="extiw" href="http://en.wikipedia.com/wiki/Pragma_once#Portability" title="enwiki:Pragma once">vast majority of modern compilers</a>. If it appears in a header file, it indicates that it is only to be parsed once, even if it is (directly or indirectly) included multiple times in the same source file.</p><p>Standard approach to preventing multiple inclusion of the same header is by using <a class="extiw" href="http://en.wikipedia.com/wiki/Include_guard" title="enwiki:Include guard">include guards</a>:</p><div><div><pre><code>#ifndef FILENAME_H#define FILENAME_H// contents of the header#endif /* FILENAME_H */</code></pre></div></div><p>So that all but the first inclusion of the header in any translation unit are excluded from compilation.<br></p><p>With <code>#pragma once</code>, the same header appears as</p><div><div><pre><code>#pragma once// contents of the header</code></pre></div></div><p>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with <code>#pragma once</code> files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</p><h4> #pragma pack</h4><table><tr><td></td><td>This section is incomplete </td></tr></table></section>	http://en.cppreference.com/w/c/preprocessor/impl
Source file inclusion	A										<section class="prog__container"><p>Includes another source file into the current source file at the line immediately after the directive.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>#include &lt;</code>filename<code>&gt;</code></td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>#include "</code>filename<code>"</code></td><td> (2)</td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><p>Includes source file, identified by filename, into the current source file at the line immediately after the directive.</p><p>The first version of the directive searches only standard include directories. The standard C++ library, as well as standard C library, is implicitly included in standard include directories. The standard include directories can be controlled by the user through compiler options. <br></p><p>Version (2) first searches the directory where the current file resides and, only if the file is not found, searches the standard include directories.<br></p><p>In the case the file is not found, the program is ill-formed.<br></p></section>	http://en.cppreference.com/w/c/preprocessor/include
Filename and line information	A										<section class="prog__container"><p>Changes the current line number and file name in the preprocessor.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>#line</code> lineno</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>#line</code> lineno <code>"</code>filename<code>"</code></td><td> (2)</td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><div>1) Changes the current preprocessor line number to lineno. Occurrences of the macro <code>__LINE__</code> beyond this point will expand to lineno plus the number of actual source code lines encountered since.</div><div>2) Also changes the current preprocessor file name to filename. Occurrences of the macro <code>__FILE__</code> beyond this point will produce filename.</div><p>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to <code>#line</code> as long as they expand to a valid decimal integer optionally following a valid character string.</p></section>	http://en.cppreference.com/w/c/preprocessor/line
Replacing text macros	A										<section class="prog__container"><p>The preprocessor supports text macro replacement and function-like text macro replacement.<br></p><span class="prog__sub"> Syntax</span><table><tr><td></td></tr><tr><td> <code>#define</code> identifier replacement-list(optional)</td><td> (1)</td><td></td></tr><tr><td></td></tr><tr><td> <code>#define</code> identifier<code>(</code> parameters <code>)</code> replacement-list</td><td> (2)</td><td></td></tr><tr><td></td></tr><tr><td> <code>#define</code> identifier<code>(</code> parameters<code>, ... )</code> replacement-list</td><td> (3)</td><td> (since C99)</td></tr><tr><td></td></tr><tr><td> <code>#define</code> identifier<code>( ... )</code> replacement-list</td><td> (4)</td><td> (since C99)</td></tr><tr><td></td></tr><tr><td> <code>#undef </code> identifier</td><td> (5)</td><td></td></tr><tr><td></td></tr></table><span class="prog__sub"> Explanation</span><h4> <code>#define</code> directives</h4><p>The <code>#define</code> directives define the identifier as a macro, that is they instruct the compiler to replace all successive occurrences of identifier with replacement-list, which can be optionally additionally processed. If the identifier is already defined as any type of macro, the program is ill-formed unless the definitions are identical. </p><h5> Object-like macros</h5><p>Object-like macros replace every occurrence of a defined identifier with replacement-list. Version (1) of the <code>#define</code> directive behaves exactly like that.</p><h5> Function-like macros</h5><p>Function-like macros replace each occurrence of a defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list. </p><p>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a ( as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching ) token, skipping intervening matched pairs of left and right parentheses.<br></p><p>The number of arguments must be the same as the number of arguments in the macro definition (parameters) or the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</p><p>Version (2) of the <code>#define</code> directive defines a simple function-like macro.</p><p>Version (3) of the <code>#define</code> directive defines a function-like macro with variable number of arguments. The additional arguments can be accessed using <code>__VA_ARGS__</code> identifier, which is then replaced with arguments, supplied with the identifier to be replaced.</p><p>Version (4) of the <code>#define</code> directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments can be accessed only with <code>__VA_ARGS__</code> identifier, which is then replaced with arguments, supplied with identifier to be replaced.</p><p>Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (such as <code>macro(array[x = y, x + 1])</code>), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.</p><h4> <code>#</code> and <code>##</code> operators</h4><p>In function-like macros, a <code>#</code> operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called "stringification". If the result of stringification is not a valid string literal, the behavior is undefined.</p><table><tr><td><p>When <code>#</code> appears before <code>__VA_ARGS__</code>, the entire expanded __VA_ARGS__ is enclosed in quotes:</p><div><div><pre><code>#define showlist(...) puts(#__VA_ARGS__)showlist();            // expands to puts("")showlist(1, "x", int); // expands to puts("1, "x", int")</code></pre></div></div></td><td>(since C99)</td></tr></table><p>A <code>##</code> operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers and then concatenates the result. This operation is called "concatenation" or "token pasting". Only tokens that form a valid token together may be pasted: identifiers that form a longer identifier, digits that form a number, or operators <code>+</code> and <code>=</code> that form a <code>+=</code>. A comment cannot be created by pasting <code>/</code> and <code>*</code> because comments are removed from text before macro substitution is considered. If the result of concatenation is not a valid token, the behavior is undefined.</p><p>Note: some compilers offer an extension that allows ## to appear after a comma and before __VA_ARGS__, in which case the ## does nothing when __VA_ARGS__ is non-empty, but removes the comma when __VA_ARGS__ is empty: this makes it possible to define macros such as <code>fprintf (stderr, format, ##__VA_ARGS__)</code></p><h4> <code>#undef</code> directive</h4><p>The <code>#undef</code> directive undefines the identifier, that is it cancels the previous definition of the identifier by <code>#define</code> directive. If the identifier does not have an associated macro, the directive is ignored.</p><span class="prog__sub"> Predefined macros</span><p>The following macro names are predefined in any translation unit:<br></p><table><tr><td> <div><div>__STDC__</div></div></td><td>   expands to the integer constant <code>1</code>. This macro is intended to indicate a conforming implementation <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_VERSION__</div><div>(C95)</div></div></td><td>   expands to an integer constant of type <code>long</code> whose value increases with each version of the C standard:<ul><li> <code>199409L</code> (C95)</li><li> <code>199901L</code> (C99)</li><li> <code>201112L</code> (C11) <br/> (macro constant)</li></ul></td></tr><tr><td> <div><div>__STDC_HOSTED__</div><div>(C99)</div></div></td><td>   expands to the integer constant <code>1</code> if the implementation is hosted (runs under an OS), <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if freestanding (runs without an OS)  <br/> (macro constant)</td></tr><tr><td> <div><div>__FILE__</div></div></td><td>   expands to the name of the current file, as a character string literal, can be changed by the <a href="http://en.cppreference.com/w/c/preprocessor/line" title="c/preprocessor/line">#line</a> directive <br/> (macro constant)</td></tr><tr><td> <div><div>__LINE__</div></div></td><td>   expands to the source file line number, an integer constant, can be changed by the <a href="http://en.cppreference.com/w/c/preprocessor/line" title="c/preprocessor/line">#line</a> directive <br/> (macro constant)</td></tr><tr><td> <div><div>__DATE__</div></div></td><td>   expands to the date of translation, a character string literal of the form "Mmm dd yyyy". The name of the month is as if generated by <code><a href="http://en.cppreference.com/w/c/chrono/asctime">asctime</a>()</code> <br/> (macro constant)</td></tr><tr><td> <div><div>__TIME__</div></div></td><td>   expands to the time of translation, a character string literal of the form "hh:mm:ss", as in the time generated by <code><a href="http://en.cppreference.com/w/c/chrono/asctime">asctime</a>()</code> <br/> (macro constant)</td></tr></table><p>The following additional macro names may be predefined by an implementation:<br></p><table><tr><td> <div><div>__STDC_ISO_10646__</div><div>(C99)</div></div></td><td>   expands to an integer constant of the form <code>yyyymmL</code>, if <code>wchar_t</code> uses Unicode, the date indicates the latest revision of Unicode supported <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_IEC_559__</div><div>(C99)</div></div></td><td>   expands to <code>1</code> if IEC 60559 is supported  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_IEC_559_COMPLEX__</div><div>(C99)</div></div></td><td>   expands to <code>1</code> if IEC 60559 complex arithmetic is supported  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_UTF_16__</div><div>(C11)</div></div></td><td>   expands to <code>1</code> if <code>char16_t</code> use UTF-16 encoding  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_UTF_32__</div><div>(C11)</div></div></td><td>   expands to <code>1</code> if <code>char32_t</code> use UTF-32 encoding  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_MB_MIGHT_NEQ_WC__</div><div>(C99)</div></div></td><td>   expands to <code>1</code> if wide character encoding of the basic character set may not equal their narrow encoding, such as on EBCDIC-based systems that use Unicode for wchar_t  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_ANALYZABLE__</div><div>(C11)</div></div></td><td>   expands to <code>1</code> if <a href="http://en.cppreference.com/w/c/language/analyzability" title="c/language/analyzability">analyzability</a> is supported  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_LIB_EXT1__</div><div>(C11)</div></div></td><td>   expands to an integer constant <code>201112L</code> if <a href="http://en.cppreference.com/w/c/error" title="c/error">bounds-checking interfaces</a> are supported  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_NO_ATOMICS__</div><div>(C11)</div></div></td><td>   expands to <code>1</code> if <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a> types and <a href="http://en.cppreference.com/w/c/atomic" title="c/atomic">atomic operations library</a> are not supported  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_NO_COMPLEX__</div><div>(C11)</div></div></td><td>   expands to <code>1</code> if <a href="http://en.cppreference.com/w/c/language/arithmetic_types#Complex_floating_types" title="c/language/arithmetic types">complex types</a> and <a href="http://en.cppreference.com/w/c/numeric/complex" title="c/numeric/complex">complex math library</a> are not supported  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_NO_THREADS__</div><div>(C11)</div></div></td><td>   expands to <code>1</code> if  <a href="http://en.cppreference.com/w/c/thread" title="c/thread">multithreading</a> is not supported  <br/> (macro constant)</td></tr><tr><td> <div><div>__STDC_NO_VLA__</div><div>(C11)</div></div></td><td>   expands to <code>1</code> if <a href="http://en.cppreference.com/w/c/language/array#Variable-length_arrays" title="c/language/array">variable-length arrays</a> are not supported  <br/> (macro constant)</td></tr></table><p>The values of these macros (except for <code>__FILE__</code> and <code>__LINE__</code>) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</p><table><tr><td><p>The predefined variable <code>__func__</code> (see <a href="http://en.cppreference.com/w/c/language/function_definition#func" title="c/language/function definition">function definition</a> for details) is not a preprocessor macro, even though it is sometimes used together with <code>__FILE__</code> and <code>__LINE__</code>, e.g. by <a href="http://en.cppreference.com/w/c/error/assert" title="c/error/assert">assert</a>.</p></td><td>(since C99)</td></tr></table><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;\xc2\xa0//make function factory and use it#define FUNCTION(name, a) int fun_##name(int x) { return (a)*x;}\xc2\xa0FUNCTION(quadruple, 4)FUNCTION(double, 2)\xc2\xa0#undef FUNCTION#define FUNCTION 34#define OUTPUT(a) puts( #a )\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("quadruple(13):\xc2\xa0%d\n", fun_quadruple(13) );    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("double(21):\xc2\xa0%d\n", fun_double(21) );    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", FUNCTION);    OUTPUT(million);               //note the lack of quotes}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>quadruple(13): 52<br>double(21): 42<br>34<br>million</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/preprocessor/replace
_Exit	A										<section class="prog__container"><table><tbody><tr><td> <div><code>void _Exit( int exit_code );</code></div></td><td> </td><td> (since C99) <br/>(until C11) </td></tr><tr><td> <div><code>_Noreturn void _Exit( int exit_code );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Causes normal program termination to occur without completely cleaning the resources.<br></p><p>Destructors of variables with automatic, thread local and static storage durations are not called. Functions passed to <a href="http://en.cppreference.com/w/c/program/at_quick_exit" title="c/program/at quick exit">at_quick_exit()</a> or <a href="http://en.cppreference.com/w/c/program/atexit" title="c/program/atexit">atexit()</a> are not called. Whether open resources such as files are closed is implementation defined. If <code>exit_code</code> is <a href="http://en.cppreference.com/w/c/program/EXIT_status" title="c/program/EXIT status">EXIT_FAILURE</a>, an implementation-defined status, indicating <i>unsuccessful</i> termination, is returned. In other cases implementation-defined status value is returned. </p><span class="prog__sub"> Parameters</span><table><tr><td>  exit_code</td><td> -</td><td>  exit status of the program</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;\xc2\xa0/* _Exit does not call functions registered with atexit. */void f1(void){    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("pushed first");}\xc2\xa0void f2(void){    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("pushed second");}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Enter main()\n");    <a href="http://en.cppreference.com/w/c/program/atexit">atexit</a>(f1);    <a href="http://en.cppreference.com/w/c/program/atexit">atexit</a>(f2);    <a href="http://en.cppreference.com/w/c/io/fflush">fflush</a>(<a href="http://en.cppreference.com/w/c/io">stdout</a>);   /* _Exit does not flush unwritten buffered data */    _Exit(0);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Enter main()</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/_Exit
abort	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void abort(void);</code></div></td><td> </td><td> (until C11) </td></tr><tr><td> <div><code>_Noreturn void abort(void);</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Causes abnormal program termination unless <a href="http://en.cppreference.com/w/c/program/SIG_types" title="c/program/SIG types">SIGABRT</a> is being caught by a signal handler passed to signal and the handler does not return.</p><p>Functions passed to <a href="http://en.cppreference.com/w/c/program/atexit" title="c/program/atexit">atexit()</a> are not called. Whether open resources such as files are closed is implementation defined. Implementation defined status is returned to the host environment that indicates unsuccessful execution. </p><span class="prog__sub"> Parameters</span><p>(none)<br></p><span class="prog__sub"> Return value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void) {    <a href="http://en.cppreference.com/w/c/io">FILE</a> *fp = <a href="http://en.cppreference.com/w/c/io/fopen">fopen</a>("data.txt","r");    if (fp == <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>) {       <a href="http://en.cppreference.com/w/c/io/fprintf">fprintf</a>(<a href="http://en.cppreference.com/w/c/io">stderr</a>, "error opening file data.txt in function main()\n");       abort();    }\xc2\xa0    /* Normal processing continues here. */    <a href="http://en.cppreference.com/w/c/io/fclose">fclose</a>(fp);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Normal Return\n");    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>error opening file data.txt in function main()</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/abort
at_quick_exit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int at_quick_exit( void (*func)(void) );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Registers the function pointed to by <code>func</code> to be called on quick program termination (via <a href="http://en.cppreference.com/w/c/program/quick_exit" title="c/program/quick exit">quick_exit</a>).</p><p>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least <code>32</code> functions.</p><span class="prog__sub"> Parameters</span><table><tr><td>  func</td><td> -</td><td>  pointer to a function to be called on normal program termination</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if the registration succeeds, nonzero value otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;\xc2\xa0void f1(void){    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("pushed first");    <a href="http://en.cppreference.com/w/c/io/fflush">fflush</a>(<a href="http://en.cppreference.com/w/c/io">stdout</a>);}\xc2\xa0void f2(void){    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("pushed second");}\xc2\xa0int main(void){    at_quick_exit(f1);    at_quick_exit(f2);    <a href="http://en.cppreference.com/w/c/program/quick_exit">quick_exit</a>(0);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>pushed second<br>pushed first</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/at_quick_exit
atexit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int atexit( void (*func)(void) );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Registers the function pointed to by <code>func</code> to be called on normal program termination (via <a href="http://en.cppreference.com/w/c/program/exit" title="c/program/exit">exit()</a> or returning from <code>main()</code>). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.</p><p>The same function may be registered more than once.<br></p><p><code>atexit</code> is thread-safe: calling the function from several threads does not induce a data race. </p><p>The implementation is guaranteed to support the registration of at least <code>32</code> functions. The exact limit is implementation-defined.</p><span class="prog__sub"> Parameters</span><table><tr><td>  func</td><td> -</td><td>  pointer to a function to be called on normal program termination</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if the registration succeeds, nonzero value otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;\xc2\xa0void f1(void){    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("pushed first");}\xc2\xa0void f2(void){    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("pushed second");}\xc2\xa0int main(void){    atexit(f1);    atexit(f2);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>pushed second<br>pushed first</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/atexit
exit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void exit( int exit_code );</code></div></td><td> </td><td> (until C11) </td></tr><tr><td> <div><code>_Noreturn void exit( int exit_code );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Causes normal program termination to occur.<br></p><p>Several cleanup steps are performed:<br></p><ul><li> functions passed to <a href="http://en.cppreference.com/w/c/program/atexit" title="c/program/atexit">atexit</a> are called, in reverse order of registration</li><li> all C streams are flushed and closed</li><li> files created by <a href="http://en.cppreference.com/w/c/io/tmpfile" title="c/io/tmpfile">tmpfile</a> are removed</li><li> control is returned to the host environment. If <code>exit_code</code> is zero or <a href="http://en.cppreference.com/w/c/program/EXIT_status" title="c/program/EXIT status">EXIT_SUCCESS</a>, an implementation-defined status, indicating successful termination is returned. If <code>exit_code</code> is <a href="http://en.cppreference.com/w/c/program/EXIT_status" title="c/program/EXIT status">EXIT_FAILURE</a>, an implementation-defined status, indicating unsuccessful termination is returned. In other cases implementation-defined status value is returned.</li></ul></section>	http://en.cppreference.com/w/c/program/exit
EXIT_SUCCESS, EXIT_FAILURE	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define EXIT_SUCCESS /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define EXIT_FAILURE /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> macros expand into integral expressions that can be used as arguments to the <a href="http://en.cppreference.com/w/c/program/exit" title="c/program/exit">exit</a> function (and, therefore, as the values to return from the <a href="http://en.cppreference.com/w/c/language/main_function" title="c/language/main function">main function</a>), and indicate program execution status.</p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>EXIT_SUCCESS</code></td><td>  successful execution of a program</td></tr><tr><td> <code>EXIT_FAILURE</code></td><td>  unsuccessful execution of a program</td></tr></table></section>	http://en.cppreference.com/w/c/program/EXIT_status
getenv, getenv_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char *getenv( const char *name );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t getenv_s( <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> *restrict len, char *restrict value,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 rsize_t valuesz, const char *restrict name );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Searches for an environmental variable with name <code>name</code> in the host-specified environment list and returns a pointer to the string that is associated with the matched environment variable. The set of environmental variables and methods of altering it are implementation-defined. </div><div> This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions <a class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html" rel="nofollow">setenv()</a>, <a class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html" rel="nofollow">unsetenv()</a>, and <a class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html" rel="nofollow">putenv()</a> may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</div><div> Modifying the string returned by <code>getenv</code> invokes undefined behavior.</div><div>2) Same as (1), except that the values of the environment variable is written to the user-provided buffer <code>value</code> (unless null) and the number of bytes written is stored in the user-provided location <code>*len</code> (unless null). If the environment variable is not set in the environment, zero is written to <code>*len</code> (unless null) and <code>'\x00'</code> is written to <code>value[0]</code> (unless null). In addition, the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>name</code> is a null pointer</li><li> <code>valuesz</code> is greater than RSIZE_MAX</li><li> <code>value</code> is a null pointer and <code>valuesz</code> is not zero</li></ul></dd><dd>As all bounds-checked functions, <code>getenv_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  name</td><td> -</td><td>  null-terminated character string identifying the name of the environmental variable to look for</td></tr><tr><td>  len</td><td> -</td><td>  pointer to a user-provided location where getenv_s will store the length of the environment variable</td></tr><tr><td>  value</td><td> -</td><td>  pointer to a user-provided character array where getenv_s will store the contents of the environment variable</td></tr><tr><td>  valuesz</td><td> -</td><td>  maximum number of characters that getenv_s is allowed to write to dest (size of the buffer)</td></tr></table><span class="prog__sub"> Return value</span><div>1) character string identifying the value of the environmental variable or null pointer if such variable is not found.</div><div>2) zero if the environment variable was found, non-zero if it was not found of if a runtime constrant violation occurred. On any error, writes zero to <code>*len</code> (unless <code>len</code> is a null pointer).</div></section>	http://en.cppreference.com/w/c/program/getenv
jmp_buf	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;setjmp.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>typedef /* unspecified */ jmp_buf;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>jmp_buf</code> type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type <code>jmp_buf</code>.</p></section>	http://en.cppreference.com/w/c/program/jmp_buf
longjmp	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;setjmp.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>void longjmp( <a href="http://en.cppreference.com/w/c/program/jmp_buf">jmp_buf</a> env, int status );</code></div></td><td> </td><td> (until C11) </td></tr><tr><td> <div><code>_Noreturn void longjmp( <a href="http://en.cppreference.com/w/c/program/jmp_buf">jmp_buf</a> env, int status );</code></div></td><td> </td><td> (since C11) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Loads the execution context <code>env</code> saved by a previous call to <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a>. This function does not return. Control is transferred to the call site of the macro <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a> that set up <code>env</code>. That <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a> then returns the value, passed as the <code>status</code>.</p><p>If the function that called <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a> has exited (whether by return or by a different <code>longjmp</code> higher up the stack), the behavior is undefined. In other words, only long jumps up the call stack are allowed.</p><table><tr><td><p>Jumping across threads (if the function that called <code>setjmp</code>  was executed by another thread) is also undefined behavior.</p></td><td>(since C11)</td></tr></table><table><tr><td><p>If when <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a> was called, a <a href="http://en.cppreference.com/w/c/language/array" title="c/language/array">VLA</a> or another <a href="http://en.cppreference.com/w/c/language/declarations" title="c/language/declarations">variably-modified type</a> variable was in scope and control left that scope, <code>longjmp</code> to that <code>setjmp</code> invokes undefined behavior even if control remained within the function.</p><p>On the way up the stack, <code>longjmp</code> does not deallocate any VLAs, memory leaks may occur if their lifetimes are terminated in this way:</p><div><div><pre><code>void g(int n){    int a[n]; // a may remain allocated    h(n); // does not return}void h(int n){    int b[n]; // b may remain allocated    longjmp(buf, 2); // might cause a memory leak for h's b and g's a}</code></pre></div></div></td><td>(since C99)</td></tr></table><span class="prog__sub"> Parameters</span><table><tr><td>  env</td><td> -</td><td>  variable referring to the execution state of the program saved by <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a></td></tr><tr><td>  status</td><td> -</td><td>  the value to return from <a href="http://en.cppreference.com/w/c/program/setjmp" title="c/program/setjmp">setjmp</a>. If it is equal to <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, <code>1</code> is used instead</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/program/longjmp
quick_exit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>_Noreturn void quick_exit( int exit_code );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Causes normal program termination to occur without completely cleaning the resources.<br></p><p>Functions passed to <a href="http://en.cppreference.com/w/c/program/at_quick_exit" title="c/program/at quick exit">at_quick_exit</a> are called in reverse order of their registration. After calling the registered functions, calls <code><a href="http://en.cppreference.com/w/c/program/_Exit">_Exit</a>(exit_code)</code></p><span class="prog__sub"> Parameters</span><table><tr><td>  exit_code</td><td> -</td><td>  exit status of the program</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;\xc2\xa0void f1(void){    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("pushed first");    <a href="http://en.cppreference.com/w/c/io/fflush">fflush</a>(<a href="http://en.cppreference.com/w/c/io">stdout</a>);}\xc2\xa0void f2(void){    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("pushed second");}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/program/at_quick_exit">at_quick_exit</a>(f1);    <a href="http://en.cppreference.com/w/c/program/at_quick_exit">at_quick_exit</a>(f2);    quick_exit(0);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>pushed second<br>pushed first</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/quick_exit
raise	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;signal.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int raise( int sig );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Sends signal sig to the program. The signal handler, specified using <a href="http://en.cppreference.com/w/c/program/signal" title="c/program/signal">signal()</a>, is invoked.</p><p>If the user-defined signal handling strategy is not set using <a href="http://en.cppreference.com/w/c/program/signal" title="c/program/signal">signal()</a> yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked. </p><span class="prog__sub"> Parameters</span><table><tr><td>  sig</td><td> -</td><td>  the signal to be sent. It can be an implementation-defined value or one of the following values:<table><tr><td> <div><div><a href="http://en.cppreference.com/w/c/program/SIG_types" title="c/program/SIG types"> SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM</a></div></div></td><td>   defines signal types <br/> (macro constant) </td></tr></table><p><br/></p></td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> upon success, non-zero value on failure.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;signal.h&gt;#include &lt;stdio.h&gt;\xc2\xa0void signal_handler(int <a href="http://en.cppreference.com/w/c/program/signal">signal</a>){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Received signal\xc2\xa0%d\n", <a href="http://en.cppreference.com/w/c/program/signal">signal</a>);}\xc2\xa0int main(void){    // Install a signal handler.    <a href="http://en.cppreference.com/w/c/program/signal">signal</a>(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>, signal_handler);\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Sending signal\xc2\xa0%d\n", <a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>);    raise(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Exit main()\n");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Sending signal 15<br>Received signal 15<br>Exit main()</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/raise
setjmp	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;setjmp.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define setjmp(env) /* implementation-defined */</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Saves the current execution context into a variable <code>env</code> of type <a href="http://en.cppreference.com/w/c/program/jmp_buf" title="c/program/jmp buf">jmp_buf</a>. This variable can later be used to restore the current execution context by <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a> function. That is, when a call to <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a> function is made, the execution continues at the particular call site that constructed the <a href="http://en.cppreference.com/w/c/program/jmp_buf" title="c/program/jmp buf">jmp_buf</a> variable passed to <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a>. In that case <strong class="selflink">setjmp</strong> returns the value passed to <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a>.</p><p>The invocation of <code>setjmp</code> must appear only in one of the following contexts:</p><ul><li> the entire controlling expression of a selection or iteration statement (if, switch, for, while, do-while)</li></ul><div><div><pre><code>switch(setjmp(env)) { ..</code></pre></div></div><ul><li> one operand of a relational or equality operator with the other operand an integer constant expression, with the resulting expression being the entire controlling expression of a selection or iteration statement</li></ul><div><div><pre><code>if(setjmp(env) &gt; 10) { ...</code></pre></div></div><ul><li> the operand of a unary\xc2\xa0! operator with the resulting expression being the entire controlling expression of a selection or iteration statement</li></ul><div><div><pre><code>while(!setjmp(env)) { ...</code></pre></div></div><ul><li> the entire expression of an expression statement (possibly cast to <code>void</code>).</li></ul><div><div><pre><code>setjmp(env);</code></pre></div></div><p>If <code>setjmp</code> appears in any other context, the behavior is undefined.</p><p>Upon return to the scope of setjmp, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when longjmp was executed, except for the non-<a href="http://en.cppreference.com/w/c/language/volatile" title="c/language/volatile">volatile</a> local variables in setjmp's scope, whose values are indeterminate if they have been changed since the setjmp invocation.</p><span class="prog__sub"> Parameters</span><table><tr><td>  env</td><td> -</td><td>  variable to save the execution state of the program to.</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if the macro was called by the original code and the execution context was saved to <code>env</code>.</p><p>Non-zero value if a non-local jump was just performed. The return value in the same as passed to <a href="http://en.cppreference.com/w/c/program/longjmp" title="c/program/longjmp">longjmp</a>.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;setjmp.h&gt;#include &lt;stdnoreturn.h&gt;\xc2\xa0<a href="http://en.cppreference.com/w/c/program/jmp_buf">jmp_buf</a> jump_buffer;\xc2\xa0noreturn void a(int count) {    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("a(%d) called\n", count);    <a href="http://en.cppreference.com/w/c/program/longjmp">longjmp</a>(jump_buffer, count+1); // will return count+1 out of setjmp}\xc2\xa0int main(void){    volatile int count = 0; // modified local vars in setjmp scope must be volatile    if (setjmp(jump_buffer) != 9) // compare against constant in an if        a(++count);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>a(1) called<br>a(2) called<br>a(3) called<br>a(4) called<br>a(5) called<br>a(6) called<br>a(7) called<br>a(8) called</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/setjmp
sig_atomic_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;signal.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>typedef /* unspecified */ sig_atomic_t;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;signal.h&gt;#include &lt;stdio.h&gt;\xc2\xa0volatile sig_atomic_t gSignalStatus = 0;\xc2\xa0void signal_handler(int <a href="http://en.cppreference.com/w/c/program/signal">signal</a>){    gSignalStatus = <a href="http://en.cppreference.com/w/c/program/signal">signal</a>;}\xc2\xa0int main(void){    /* Install a signal handler. */    <a href="http://en.cppreference.com/w/c/program/signal">signal</a>(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGINT</a>, signal_handler);\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("SignalValue:  \xc2\xa0%d\n", gSignalStatus);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Sending signal\xc2\xa0%d\n", <a href="http://en.cppreference.com/w/c/program/SIG_types">SIGINT</a>);    <a href="http://en.cppreference.com/w/c/program/raise">raise</a>(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGINT</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("SignalValue:  \xc2\xa0%d\n", gSignalStatus);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>SignalValue:   0<br>Sending signal 2<br>SignalValue:   2</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/sig_atomic_t
SIG_ERR	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;signal.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define SIG_ERR /* implementation defined */</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>A value of type <code>void (*)(int)</code>. When returned by <a href="http://en.cppreference.com/w/c/program/signal" title="c/program/signal">signal</a>, indicates that an error has occurred.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;\xc2\xa0void signal_handler(int <a href="http://en.cppreference.com/w/c/program/signal">signal</a>){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Received signal\xc2\xa0%d\n", <a href="http://en.cppreference.com/w/c/program/signal">signal</a>);}\xc2\xa0int main(void){    /* Install a signal handler. */    if (<a href="http://en.cppreference.com/w/c/program/signal">signal</a>(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>, signal_handler) == SIG_ERR)    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Error while installing a signal handler.\n");        <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(<a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>);    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Sending signal\xc2\xa0%d\n", <a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>);    if (<a href="http://en.cppreference.com/w/c/program/raise">raise</a>(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>) != 0)    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Error while raising the SIGTERM signal.\n");        <a href="http://en.cppreference.com/w/c/program/exit">exit</a>(<a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a>);    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Exit main()\n");    return <a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_SUCCESS</a>;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Sending signal 15<br>Received signal 15<br>Exit main()</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/SIG_ERR
SIG_DFL, SIG_IGN	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;signal.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define SIG_DFL /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define SIG_IGN /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <strong class="selflink">SIG_DFL</strong> and <strong class="selflink">SIG_IGN</strong> macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for <code><a href="http://en.cppreference.com/w/c/program/signal">signal</a>()</code> function.</p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>SIG_DFL</code></td><td>  default signal handling</td></tr><tr><td> <code>SIG_IGN</code></td><td>  signal is ignored</td></tr></table><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;signal.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    /* using the default signal handler */    <a href="http://en.cppreference.com/w/c/program/raise">raise</a>(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Exit main()\n");   /* never reached */}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>(none)</code></pre></div></div></div><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;signal.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    /* ignoring the signal */    <a href="http://en.cppreference.com/w/c/program/signal">signal</a>(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>, SIG_IGN);    <a href="http://en.cppreference.com/w/c/program/raise">raise</a>(<a href="http://en.cppreference.com/w/c/program/SIG_types">SIGTERM</a>);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Exit main()\n");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Exit main()</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/program/SIG_strategies
SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;signal.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define SIGTERM /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define SIGSEGV /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define SIGINT /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define SIGILL /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define SIGABRT /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>#define SIGFPE /*implementation defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.<br></p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>SIGTERM</code></td><td>  termination request, sent to the program</td></tr><tr><td> <code>SIGSEGV</code></td><td>  invalid memory access (segmentation fault)</td></tr><tr><td> <code>SIGINT</code></td><td>  external interrupt, usually initiated by the user</td></tr><tr><td> <code>SIGILL</code></td><td>  invalid program image, such as invalid instruction</td></tr><tr><td> <code>SIGABRT</code></td><td>  abnormal termination condition, as is e.g. initiated by <a href="http://en.cppreference.com/w/c/program/abort" title="c/program/abort">abort()</a></td></tr><tr><td> <code>SIGFPE</code></td><td>  erroneous arithmetic operation such as divide by zero</td></tr></table></section>	http://en.cppreference.com/w/c/program/SIG_types
signal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;signal.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void (*signal( int sig, void (*handler) (int))) (int);</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Sets the error handler for signal <code>sig</code>. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.</p><p>When signal handler is set to a function and a signal occurs, it is implementation defined whether <code>signal(sig, <a href="http://en.cppreference.com/w/c/program/SIG_strategies">SIG_DFL</a>)</code> will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</p><span class="prog__sub"> Parameters</span><table><tr><td>  sig</td><td> -</td><td>  the signal to set the signal handler to. It can be an implementation-defined value or one of the following values:<table><tr><td> <div><div><a href="http://en.cppreference.com/w/c/program/SIG_types" title="c/program/SIG types"> SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM</a></div></div></td><td>   defines signal types <br/> (macro constant) </td></tr></table><p><br/></p></td></tr><tr><td>  handler</td><td> -</td><td>  the signal handler. This must be one of the following:<ul><li><a href="http://en.cppreference.com/w/c/program/SIG_strategies" title="c/program/SIG strategies">SIG_DFL</a> macro. The signal handler is set to default signal handler.</li><li><a href="http://en.cppreference.com/w/c/program/SIG_strategies" title="c/program/SIG strategies">SIG_IGN</a> macro. The signal is ignored.</li><li>pointer to a function. The signature of the function must be equivalent to the following:</li></ul><table><tbody><tr><td> <div><code>void fun(int sig);</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table></td></tr></table><span class="prog__sub"> Return value</span><p>Previous signal handler on success or <a href="http://en.cppreference.com/w/c/program/SIG_ERR" title="c/program/SIG ERR">SIG_ERR</a> on failure (setting a signal handler can be disabled on some implementations).</p><span class="prog__sub"> Signal handler</span><p>The following limitations are imposed on the user-defined function that is installed as a signal handler.<br></p><p>If the user defined function returns when handling <a href="http://en.cppreference.com/w/c/program/SIG_types" title="c/program/SIG types">SIGFPE</a>, <a href="http://en.cppreference.com/w/c/program/SIG_types" title="c/program/SIG types">SIGILL</a> or <a href="http://en.cppreference.com/w/c/program/SIG_types" title="c/program/SIG types">SIGSEGV</a>, the behavior is undefined.</p><p>If the signal handler is called as a result of <a href="http://en.cppreference.com/w/c/program/abort" title="c/program/abort">abort</a> or <a href="http://en.cppreference.com/w/c/program/raise" title="c/program/raise">raise</a>, the behavior is undefined if the signal handler calls <a href="http://en.cppreference.com/w/c/program/raise" title="c/program/raise">raise</a>.</p><p>If the signal handler is called NOT as a result of <a href="http://en.cppreference.com/w/c/program/abort" title="c/program/abort">abort</a> or <a href="http://en.cppreference.com/w/c/program/raise" title="c/program/raise">raise</a> (in other words, the signal handler is <i>asynchronous</i>), the behavior is undefined if</p><ul><li> the signal handler calls any function within the standard library, except</li></ul><dl><dd><ul><li> <a href="http://en.cppreference.com/w/c/program/abort" title="c/program/abort">abort</a></li><li> <a href="http://en.cppreference.com/w/c/program/_Exit" title="c/program/ Exit">_Exit</a></li><li> <a href="http://en.cppreference.com/w/c/program/quick_exit" title="c/program/quick exit">quick_exit</a></li><li> <code>signal</code> with the first argument being the number of the signal currently handled (async handler can re-register itself, but not other signals). </li><li> atomic functions from <a href="http://en.cppreference.com/w/c/atomic" title="c/atomic">stdatomic.h</a> if the atomic arguments are lock-free</li><li> <a href="http://en.cppreference.com/w/c/atomic/atomic_is_lock_free" title="c/atomic/atomic is lock free">atomic_is_lock_free</a> (with any kind of atomic arguments)</li></ul></dd></dl><ul><li> the signal handler refers to any object with static or thread-local (since C11) <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">storage duration</a> that is not a lock-free <a href="http://en.cppreference.com/w/c/language/atomic" title="c/language/atomic">atomic</a> (since C11) other than by assigning to a static <code>volatile std::<a href="http://en.cppreference.com/w/c/program/sig_atomic_t">sig_atomic_t</a></code>.</li></ul><p>On entry to the signal handler, the state of the floating-point environment and the values of all objects is unspecified, except for<br></p><ul><li> objects of type <code>volatile <a href="http://en.cppreference.com/w/c/program/sig_atomic_t">sig_atomic_t</a></code></li><li> objects of lock-free atomic types (since C11)</li><li> side effects made visible through <a href="http://en.cppreference.com/w/c/atomic/atomic_signal_fence" title="c/atomic/atomic signal fence">atomic_signal_fence</a> (since C11)</li></ul><p>On return from a signal handler, the value of any object modified by the signal handler that is not <code>volatile <a href="http://en.cppreference.com/w/c/program/sig_atomic_t">sig_atomic_t</a></code> or lock-free atomic(since C11) is undefined.</p><p>The behavior is undefined if <code>signal</code> is used in a multithreaded program. It is not required to be thread-safe.</p></section>	http://en.cppreference.com/w/c/program/signal
system	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int system( const char *command );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Calls the host environment's command processor with command parameter. Returns implementation-defined value (usually the value that the invoked program returns).<br></p><p>If command is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> pointer, checks if host environment has a command processor and returns nonzero value only if the command processor exists.</p><span class="prog__sub"> Parameters</span><table><tr><td>  command</td><td> -</td><td>  character string identifying the command to be run in the command processor. If NULL pointer is given, command processor is checked for existence</td></tr></table><span class="prog__sub"> Return value</span><p>Implementation-defined value. If <code>command</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, returns nonzero value only if command processor exists.</p></section>	http://en.cppreference.com/w/c/program/system
atof	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>double atof( const char* str );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets a floating-point value in a byte string pointed to by <code>str</code>.</p><p>Function discards any whitespace characters (as determined by <code>std::<a href="http://en.cppreference.com/w/c/string/byte/isspace">isspace</a>()</code>) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</p><ul><li>decimal floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C locale) (defines significand)</li><li> (optional) <code>e</code> or <code>E</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li>binary floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>0x</code> or <code>0X</code></li><li> nonempty sequence of hexadecimal digits optionally containing a decimal-point character (as determined by the current C locale) (defines significand)</li><li> (optional) <code>p</code> or <code>P</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li> infinity expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>INF</code> or <code>INFINITY</code> ignoring case</li></ul></dd></dl><ul><li> not-a-number expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>NAN</code> or <code>NAN(</code><i>char_sequence</i><code>)</code> ignoring case of the <code>NAN</code> part. <i>char_sequence</i> can only contain alphanumeric characters. The result is a quiet NaN floating-point value.</li></ul></dd></dl><ul><li> any other expression that may be accepted by the currently installed C locale</li></ul><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr></table><span class="prog__sub"> Return value</span><p><code>double</code> value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of the return type, the return value is undefined. If no conversion can be performed, <code>0.0</code> is returned.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("  -0.0000000123junk"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("0.012"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("15e16"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("-0x1afp-2"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("inF"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("Nan"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("1.0e+309"));   // UB: out of range of double    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("0.0"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%g\n", atof("junk"));       // no conversion can be performed}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>-1.23e-08<br>0.012<br>1.5e+17<br>-107.75<br>inf<br>nan<br>inf<br>0<br>0</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/atof
atoi, atol, atoll	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int \xc2\xa0 \xc2\xa0 \xc2\xa0 atoi( const char *str );</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>long \xc2\xa0 \xc2\xa0 \xc2\xa0atol( const char *str );</code></div></td><td> </td><td> </td></tr><tr><td> <div><code>long long atoll( const char *str );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets an integer value in a byte string pointed to by <code>str</code>.</p><p>Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:<br></p><ul><li> (optional) plus or minus sign</li><li> numeric digits</li></ul><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr></table><span class="prog__sub"> Return value</span><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%i\n", atoi(" -123junk"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%i\n", atoi("0"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%i\n", atoi("junk"));         // no conversion can be performed    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%i\n", atoi("2147483648"));   // UB: out of range of int}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>-123<br>0<br>0<br>-2147483648</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/atoi
isalnum	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isalnum( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:<br></p><ul><li> digits (<code>0123456789</code>)</li><li> uppercase letters (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>)</li><li> lowercase letters (<code>abcdefghijklmnopqrstuvwxyz</code>)</li></ul><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is an alphanumeric character, <code>0</code> otherwise.</p><span class="prog__sub"> Example</span><div><p> Demonstrates the use of isalnum() with different locales (OS-specific).<br> </p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    unsigned char c = '\xdf'; // German letter \xc3\x9f in ISO-8859-1\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isalnum('\\xdf') in default C locale returned\xc2\xa0%d\n", !!isalnum(c));\xc2\xa0    if(<a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_CTYPE</a>, "de_DE.iso88591"))        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isalnum('\\xdf') in ISO-8859-1 locale returned\xc2\xa0%d\n", !!isalnum(c));}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>isalnum('\xdf') in default C locale returned 0<br>isalnum('\xdf') in ISO-8859-1 locale returned 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/isalnum
isalpha	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isalpha( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is an alphabetic character, i.e. either an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), or a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>).</p><p>In locales other than <code>"C"</code>, an alphabetic character is a character for which <a href="http://en.cppreference.com/w/c/string/byte/isupper" title="c/string/byte/isupper">isupper()</a> or <a href="http://en.cppreference.com/w/c/string/byte/islower" title="c/string/byte/islower">islower()</a> returns <code>true</code> or any other character considered alphabetic by the locale. In any case, <a href="http://en.cppreference.com/w/c/string/byte/iscntrl" title="c/string/byte/iscntrl">iscntrl()</a>, <a href="http://en.cppreference.com/w/c/string/byte/isdigit" title="c/string/byte/isdigit">isdigit()</a>, <a href="http://en.cppreference.com/w/c/string/byte/ispunct" title="c/string/byte/ispunct">ispunct()</a> and <a href="http://en.cppreference.com/w/c/string/byte/isspace" title="c/string/byte/isspace">isspace()</a> will return <code>false</code> for this character.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is an alphabetic character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><p> Demonstrates the use of isalpha() with different locales (OS-specific). <br> </p><div><div>Run this code</div></div><div><div><pre><code>#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    unsigned char c = '\xdf'; // German letter \xc3\x9f in ISO-8859-1\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isalpha('\\xdf') in default C locale returned\xc2\xa0%d\n", !!isalpha(c));\xc2\xa0    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_CTYPE</a>, "de_DE.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("isalpha('\\xdf') in ISO-8859-1 locale returned\xc2\xa0%d\n", !!isalpha(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>isalpha('\xdf') in default C locale returned 0<br>isalpha('\xdf') in ISO-8859-1 locale returned 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/isalpha
isblank	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isblank( int ch );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a blank character in the current C locale. In the default C locale, only space (<code>0x20</code>) and horizontal tab (<code>0x09</code>) are classified as blank.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is a blank character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;limits.h&gt;\xc2\xa0int main(void){    for (int ndx=0; ndx&lt;=<a href="http://en.cppreference.com/w/c/types/limits">UCHAR_MAX</a>; ndx++)        if (isblank(ndx)) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("0x%02x\n", ndx);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>0x09<br>0x20</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/isblank
iscntrl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iscntrl( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a control character, i.e. codes <code>0x00-0x1F</code> and <code>0x7F</code>.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is a control character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    unsigned char c = '\x94'; // the control code CCH in ISO-8859-1    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In the default C locale, \\x94 is\xc2\xa0%sa control character\n",           iscntrl(c) ? "" : "not " );    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_GB.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In ISO-8859-1 locale, \\x94 is\xc2\xa0%sa control character\n",           iscntrl(c) ? "" : "not " );}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>In the default C locale, \x94 is not a control character<br>In ISO-8859-1 locale, \x94 is a control character</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/iscntrl
isdigit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isdigit( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a numeric character (<code>0123456789</code>).</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is a numeric character, zero otherwise.<br></p></section>	http://en.cppreference.com/w/c/string/byte/isdigit
isgraph	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isgraph( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character has a graphical representation, i.e. it is either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>), or a punctuation character(<code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</code>), or any graphical character specific to the current C locale.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character has a graphical representation character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    unsigned char c = '\xb6'; // the character \xc2\xb6 in ISO-8859-1    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In the default C locale, \\xb6 is\xc2\xa0%sgraphical\n",           isgraph(c) ? "" : "not " );    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_GB.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In ISO-8859-1 locale, \\xb6 is\xc2\xa0%sgraphical\n",           isgraph(c) ? "" : "not " );}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>In the default C locale, \xb6 is not graphical<br>In ISO-8859-1 locale, \xb6 is graphical</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/isgraph
islower	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int islower( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is classified as a lowercase character according to the current C locale. In the default "C" locale, <code>islower</code> returns true only for the lowercase letters (<code>abcdefghijklmnopqrstuvwxyz</code>).</p><p>If <code>islower</code> returns <code>true</code>, it is guaranteed that <a href="http://en.cppreference.com/w/c/string/byte/iscntrl" title="c/string/byte/iscntrl">iscntrl</a>, <a href="http://en.cppreference.com/w/c/string/byte/isdigit" title="c/string/byte/isdigit">isdigit</a>, <a href="http://en.cppreference.com/w/c/string/byte/ispunct" title="c/string/byte/ispunct">ispunct</a>, and <a href="http://en.cppreference.com/w/c/string/byte/isspace" title="c/string/byte/isspace">isspace</a> return <code>false</code> for the same character in the same C locale.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is a lowercase letter, zero otherwise.<br></p><p><br/></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    unsigned char c = '\xe5'; // letter \xc3\xa5 in ISO-8859-1    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In the default C locale, \\xe5 is\xc2\xa0%slowercase\n",           islower(c) ? "" : "not " );    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_GB.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In ISO-8859-1 locale, \\xe5 is\xc2\xa0%slowercase\n",           islower(c) ? "" : "not " );}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>In the default C locale, \xe5 is not lowercase<br>In ISO-8859-1 locale, \xe5 is lowercase</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/islower
isprint	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;cctype&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isprint( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character can be printed, i.e. it is either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>), a punctuation character(<code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</code>), or space, or any character classified as printable by the current C locale.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character can be printed, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    unsigned char c = '\xa0'; // the non-breaking space in ISO-8859-1    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In the default C locale, \\xa0 is\xc2\xa0%sprintable\n", isprint(c)?"":"not ");    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_GB.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In ISO-8859-1 locale, \\xa0 is\xc2\xa0%sprintable\n", isprint(c)?"":"not ");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>In the default C locale, \xa0 is not printable<br>In ISO-8859-1 locale, \xa0 is printable</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/isprint
ispunct	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int ispunct( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a punctuation character in the current C locale. The default C locale classifies the characters <code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</code> as punctuation.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is a punctuation character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    unsigned char c = '\xd7'; // the character \xc3\x97 (multiplication sign) in ISO-8859-1    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In the default C locale, \\xd7 is\xc2\xa0%spunctuation\n",           ispunct(c) ? "" : "not " );    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_GB.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In ISO-8859-1 locale, \\xd7 is\xc2\xa0%spunctuation\n",           ispunct(c) ? "" : "not " );}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>In the default C locale, \xd7 is not punctuation<br>In ISO-8859-1 locale, \xd7 is punctuation</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/ispunct
isspace	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isspace( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a whitespace character, i.e. either space (<code>0x20</code>), form feed (<code>0x0c</code>), line feed (<code>0x0a</code>), carriage return (<code>0x0d</code>), horizontal tab (<code>0x09</code>) or vertical tab (<code>0x0b</code>).</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is a whitespace character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;limits.h&gt;\xc2\xa0int main(void){    for (int ndx=0; ndx&lt;=<a href="http://en.cppreference.com/w/c/types/limits">UCHAR_MAX</a>; ndx++)        if (isspace(ndx)) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("0x%02x\n", ndx);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>0x09<br>0x0a<br>0x0b<br>0x0c<br>0x0d<br>0x20</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/isspace
isupper	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isupper( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is an uppercase character according to the current C locale. In the default "C" locale, <code>isupper</code> returns true only for the uppercase letters (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>).</p><p>If <code>isupper</code> returns <code>true</code>, it is guaranteed that <a href="http://en.cppreference.com/w/c/string/byte/iscntrl" title="c/string/byte/iscntrl">iscntrl</a>, <a href="http://en.cppreference.com/w/c/string/byte/isdigit" title="c/string/byte/isdigit">isdigit</a>, <a href="http://en.cppreference.com/w/c/string/byte/ispunct" title="c/string/byte/ispunct">ispunct</a>, and <a href="http://en.cppreference.com/w/c/string/byte/isspace" title="c/string/byte/isspace">isspace</a> return <code>false</code> for the same character in the same C locale.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is an uppercase letter, zero otherwise.<br></p><p><br/></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    unsigned char c = '\xc6'; // letter \xc3\x86 in ISO-8859-1    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In the default C locale, \\xc6 is\xc2\xa0%suppercase\n",           isupper(c) ? "" : "not " );    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_GB.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In ISO-8859-1 locale, \\xc6 is\xc2\xa0%suppercase\n",           isupper(c) ? "" : "not " );}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>In the default C locale, \xc6 is not uppercase<br>In ISO-8859-1 locale, \xc6 is uppercase</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/isupper
isxdigit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int isxdigit( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given character is a hexadecimal numeric character (<code>0123456789abcdefABCDEF</code>) or is classified as a hexadecimal character.</p><p>The behavior is undefined if the value of <code>ch</code> is not representable as <code>unsigned char</code> and is not equal to <code>EOF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to classify</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the character is an hexadecimal numeric character, zero otherwise.<br></p></section>	http://en.cppreference.com/w/c/string/byte/isxdigit
memchr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void* memchr( const void* ptr, int ch, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of <code>ch</code> (after conversion to <code>unsigned char</code> as if by <code>(unsigned char)ch</code>) in the initial <code>count</code> characters (each interpreted as <code>unsigned char</code>) of the object pointed to by <code>ptr</code>.</p><p>The behavior is undefined if access occurs beyond the end of the array searched. The behavior is undefined if <code>ptr</code> is a null pointer.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ptr</td><td> -</td><td>  pointer to the object to be examined</td></tr><tr><td>  ch</td><td> -</td><td>  character to search for</td></tr><tr><td>  count</td><td> -</td><td>  number of characters to examine</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the location of the character, or <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> if no such character is found.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;\xc2\xa0int main(void){    char str[] = "ABCDEFG";    char *ps = memchr(str,'D',<a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(str));    if (ps != <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>)       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("search character found: \xc2\xa0%s\n", ps);    else       <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a> ("search character not found\n");\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>search character found:  DEFG</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/memchr
memcmp	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int memcmp( const void* lhs, const void* rhs, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Compares the first <code>count</code> characters of the objects pointed to by <code>lhs</code> and <code>rhs</code>. The comparison is done lexicographically.</p><p>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as <code>unsigned char</code>) that differ in the objects being compared.</p><p>The behavior is undefined if access occurs beyond the end of either object pointed to by <code>lhs</code> and <code>rhs</code>. The behavior is undefined if either <code>lhs</code> or <code>rhs</code> is a null pointer.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  pointers to the objects to compare</td></tr><tr><td>  count</td><td> -</td><td>  number of bytes to examine</td></tr></table><span class="prog__sub"> Return value</span><p>Negative value if <code>lhs</code>  appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal, or if count is zero.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p></section>	http://en.cppreference.com/w/c/string/byte/memcmp
memcpy, memcpy_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>void* memcpy( void *dest, const void *src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>void* memcpy( void *restrict dest, const void *restrict src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t memcpy_s( void *restrict dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const void *restrict src, rsize_t count );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies <code>count</code> characters from the object pointed to by <code>src</code> to the object pointed to by <code>dest</code>. Both objects are interpreted as arrays of <code>unsigned char</code>.</div><div> The behavior is undefined if access occurs beyond the end of the dest array. If the objects overlap (which is a violation of the <a href="http://en.cppreference.com/w/c/language/restrict" title="c/language/restrict"><tt>restrict</tt></a> contract) (since C99), the behavior is undefined. The behavior is undefined if either <code>dest</code> or <code>src</code> is a null pointer.</div><div>2) Same as (1), except that the following errors are detected at runtime and cause the entire destination range <code>[dest, dest+destsz)</code> to be zeroed out (if both <code>dest</code> and <code>destsz</code> are valid), as well as call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>dest</code> or <code>src</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than RSIZE_MAX</li><li> <code>count</code> is greater than <code>destsz</code> (buffer overflow would occur)</li><li> the source and the destination objects overlap</li></ul></dd></dl></div><div> The behavior is undefined if the size of the character array pointed to by <code>dest</code> &lt; <code>count</code> &lt;= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>memcpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the object to copy to</td></tr><tr><td>  destsz</td><td> -</td><td>  max number of bytes to modify in the destination (typically the size of the destination object)</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the object to copy from</td></tr><tr><td>  count</td><td> -</td><td>  number of bytes to copy</td></tr></table><span class="prog__sub"> Return value</span><div>1) Returns a copy of <code>dest</code></div><div>2) Returns zero on success and non-zero value on error. Also on error, if <code>dest</code> is not a null pointer and <code>destsz</code> is valid, writes <code>destsz</code> zero bytes in to the destination array.</div></section>	http://en.cppreference.com/w/c/string/byte/memcpy
memmove, memmove_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void* memmove( void* dest, const void* src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t memmove_s(void *dest, rsize_t destsz, const void *src, rsize_t count);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies <code>count</code> characters from the object pointed to by <code>src</code> to the object pointed to by <code>dest</code>. Both objects are interpreted as arrays of <code>unsigned char</code>. The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to <code>dest</code>.</div><div> The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if either <code>dest</code> or <code>src</code> is a null pointer.</div><div>2) Same as (1), except when detecting the following errors at runtime, it zeroes out the entire destination range <code>[dest, dest+destsz)</code> (if both <code>dest</code> and <code>destsz</code> are valid) and calls the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>dest</code> or <code>src</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than RSIZE_MAX</li><li> <code>count</code> is greater than <code>destsz</code> (buffer overflow would occur)</li></ul></dd></dl></div><div> The behavior is undefined if the size of the character array pointed to by <code>dest</code> &lt; <code>count</code> &lt;= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>memmove_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the object to copy to</td></tr><tr><td>  destsz</td><td> -</td><td>  max number of bytes to modify in the destination (typically the size of the destination object)</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the object to copy from</td></tr><tr><td>  count</td><td> -</td><td>  number of bytes to copy</td></tr></table><span class="prog__sub"> Return value</span><div>1) Returns a copy of <code>dest</code></div><div>2) Returns zero on success and non-zero value on error. Also on error, if <code>dest</code> is not a null pointer and <code>destsz</code> is valid, writes <code>destsz</code> zero bytes in to the destination array.</div></section>	http://en.cppreference.com/w/c/string/byte/memmove
memset, memset_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void *memset( void *dest, int ch, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t memset_s( void *dest, rsize_t destsz, int ch, rsize_t count )</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies the value <code>ch</code> (after conversion to <code>unsigned char</code> as if by <code>(unsigned char)ch</code>) into each of the first <code>count</code> characters of the object pointed to by <code>dest</code>.</div><div> The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if <code>dest</code> is a null pointer.</div><div>2) Same as (1), except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function after storing <code>ch</code> in every location of the destination range <code>[dest, dest+destsz)</code> if <code>dest</code> and <code>destsz</code> are themselves valid:<dl><dd><ul><li> <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than RSIZE_MAX</li><li> <code>count</code> is greater than <code>destsz</code> (buffer overflow would occur)</li></ul></dd></dl></div><div> The behavior is undefined if the size of the character array pointed to by <code>dest</code> &lt; <code>count</code> &lt;= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>memset_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the object to fill</td></tr><tr><td>  ch</td><td> -</td><td>  fill byte</td></tr><tr><td>  count</td><td> -</td><td>  number of bytes to fill</td></tr><tr><td>  destsz</td><td> -</td><td>  size of the destination array</td></tr></table><span class="prog__sub"> Return value</span><div>1) A copy of <code>dest</code></div><div>2) zero on success, non-zero on error. Also on error, if <code>dest</code> is not a null pointer and <code>destsz</code> is valid, writes <code>destsz</code> fill bytes <code>ch</code> to the destination array.</div></section>	http://en.cppreference.com/w/c/string/byte/memset
strcat, strcat_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>char *strcat( char *dest, const char *src );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>char *strcat( char *restrict dest, const char *restrict src );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t strcat_s(char *restrict dest, rsize_t destsz, const char *restrict src);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Appends a copy of the null-terminated byte string pointed to by <code>src</code> to the end of the null-terminated byte string pointed to by <code>dest</code>. The character <code>src[0]</code> replaces the null terminator at the end of <code>dest</code>. The resulting byte string is null-terminated.</div><div> The behavior is undefined if the destination array is not large enough for the contents of both <code>src</code> and <code>dest</code> and the terminating null character. The behavior is undefined if the strings overlap. The behavior is undefined if either <code>dest</code> or <code>src</code> is not a pointer to a null-terminated byte string.</div><div>2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to <code>destsz</code>) with unspecified values and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> is zero or greater than RSIZE_MAX</li><li> there is no null terminator in the first <code>destsz</code> bytes of <code>dest</code></li><li> truncation would occur (the available space at the end of <code>dest</code> would not fit every character, including the null terminator, of <code>src</code>)</li><li> overlap would occur between the source and the destination strings</li></ul></dd></dl></div><div> The behavior is undefined if the size of the character array pointed to by <code>dest</code> &lt; <code><a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(dest)+<a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(src)+1</code> &lt;= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>strcat_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to append to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated byte string to copy from</td></tr><tr><td>  destsz</td><td> -</td><td>  maximum number of characters to write, typically the size of the destination buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than RMAX_SIZE).</div></section>	http://en.cppreference.com/w/c/string/byte/strcat
strchr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char *strchr( const char *str, int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of <code>ch</code> (after conversion to <code>char</code> as if by <code>(char)ch</code>) in the null-terminated byte string pointed to by <code>str</code> (each character interpreted as <code>unsigned char</code>). The terminating null character is considered to be a part of the string and can be found when searching for <code>'\x00'</code>.</p><p>The behavior is undefined if <code>str</code> is not a pointer to a null-terminated byte string.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr><td>  ch</td><td> -</td><td>  character to search for</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the found character in <code>str</code>, or null pointer if no such character is found.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;\xc2\xa0int main(void){  const char *str = "Try not. Do, or do not. There is no try.";  char target = 'T';  const char *result = str;\xc2\xa0  while((result = strchr(result, target)) != <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>) {    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Found '%c' starting at '%s'\n", target, result);    ++result; // Increment result, otherwise we'll find target at the same location  }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Found 'T' starting at 'Try not. Do, or do not. There is no try.'<br>Found 'T' starting at 'There is no try.'</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strchr
strcmp	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int strcmp( const char *lhs, const char *rhs );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Compares two null-terminated byte strings lexicographically.<br></p><p>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as <code>unsigned char</code>) that differ in the strings being compared.</p><p>The behavior is undefined if <code>lhs</code> or <code>rhs</code> are not pointers to null-terminated byte strings.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated byte strings to compare</td></tr></table><span class="prog__sub"> Return value</span><p>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p></section>	http://en.cppreference.com/w/c/string/byte/strcmp
strcoll	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int strcoll( const char *lhs, const char *rhs );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Compares two null-terminated byte strings according to the current locale as defined by the <a href="http://en.cppreference.com/w/c/locale/LC_categories" title="c/locale/LC categories">LC_COLLATE</a> category.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated byte strings to compare</td></tr></table><span class="prog__sub"> Return value</span><p>Negative value if <code>lhs</code> is <i>less than</i> (precedes) <code>rhs</code>.</p><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if <code>lhs</code> is <i>equal to</i> <code>rhs</code>.</p><p>Positive value if <code>lhs</code> is <i>greater than</i> (follows) <code>rhs</code>.</p></section>	http://en.cppreference.com/w/c/string/byte/strcoll
strcpy, strcpy_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>char *strcpy( char *dest, const char *src );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>char *strcpy( char *restrict dest, const char *restrict src );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t strcpy_s(char *restrict dest, rsize_t destsz, const char *restrict src);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies the null-terminated byte string pointed to by <code>src</code>, including the null terminator, to the character array whose first element is pointed to by <code>dest</code>.</div><div> The behavior is undefined if the <code>dest</code> array is not large enough. The behavior is undefined if the strings overlap. The behavior is undefined if either <code>dest</code> is not a pointer to a character array or <code>src</code> is not a pointer to a null-terminated byte string.</div><div>2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> is zero or greater than RSIZE_MAX</li><li> <code>destsz</code> is less or equal <code>strnlen_s(src, destsz)</code>; in other words, truncation would occur</li><li> overlap would occur between the source and the destination strings</li></ul></dd></dl></div><div> The behavior is undefined if the size of the character array pointed to by <code>dest</code> &lt;= <code>strnlen_s(src, destsz)</code> &lt; <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>strcpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the character array to write to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated byte string to copy from</td></tr><tr><td>  destsz</td><td> -</td><td>  maximum number of characters to write, typically the size of the destination buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than RSIZE_MAX).</div></section>	http://en.cppreference.com/w/c/string/byte/strcpy
strcspn	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strcspn( const char *dest, const char *src );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the length of the maximum initial segment of the null-terminated byte string pointed to by <code>dest</code>, that consists of only the characters <i>not</i> found in the null-terminated byte string pointed to by <code>src</code>.</p><p>The behavior is undefined if either <code>dest</code> or <code>src</code> is not a pointer to a null-terminated byte string.</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated byte string that contains the characters to search for</td></tr></table><span class="prog__sub"> Return value</span><p>The length of the maximum initial segment that contains only characters not found in the null-terminated byte string pointed to by <code>src</code></p></section>	http://en.cppreference.com/w/c/string/byte/strcspn
strerror, strerror_s, strerrorlen_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char* strerror( int errnum );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t strerror_s( char *buf, rsize_t bufsz, errno_t errnum );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strerrorlen_s( errno_t errnum );</code></div></td><td> (3) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Returns a pointer to the textual description of the system error code <code>errnum</code>, identical to the description that would be printed by <a href="http://en.cppreference.com/w/c/io/perror" title="c/io/perror">perror()</a>.</div><div> <code>errnum</code> is usually acquired from the <code>errno</code> variable, however the function accepts any value of type <code>int</code>. The contents of the string are locale-specific.</div><div> The returned string must not be modified by the program, but may be overwritten by a subsequent call to the <code>strerror</code> function. <code>strerror</code> is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</div><div>2) Same as (1), except that the message is copied into user-provided storage <code>buf</code>. No more than <code>bufsz-1</code> bytes are written, the buffer is always null-terminated. If the message had to be truncated to fit the buffer and <code>bufsz</code> is greater than 3, then only <code>bufsz-4</code> bytes are written, and the characters <code>"..."</code> are appended before the null terminator. In addition, the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>buf</code> is a null pointer</li><li> <code>bufsz</code> is zero or greater than RSIZE_MAX</li></ul></dd></dl></div><div> The behavior is undefined if writing to <code>buf</code> occurs past the end of the array, which can happen when the size of the buffer pointed to by <code>buf</code> is less than the number of characters in the error message which in turn is less than <code>bufsz</code>.</div><div>3) Computes the length of the untruncated locale-specific error message that <code>strerror_s</code> would write if it were called with <code>errnum</code>. The length does not include the null terminator.<dl><dd>As with all bounds-checked functions, <code>strerror_s</code> and <code>strerrorlen_s</code> are only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  errnum</td><td> -</td><td>  integral value referring to an error code</td></tr><tr><td>  buf</td><td> -</td><td>  pointer to a user-provided buffer</td></tr><tr><td>  bufsz</td><td> -</td><td>  size of the user-provided buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) Pointer to a null-terminated byte string corresponding to the <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> error code <code>errnum</code>.</div><div>2) Zero if the entire message was successfully stored in <code>buf</code>, non-zero otherwise.</div><div>3) Length (not including the null terminator) of the message that <code>strerror_s</code> would return</div></section>	http://en.cppreference.com/w/c/string/byte/strerror
strlen, strnlen_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strlen( const char *str );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strnlen_s( const char *str, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strsz );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Returns the length of the given null-terminated byte string, that is, the number of characters in a character array whose first element is pointed to by <code>str</code> up to and not including the first null character.</div><div> The behavior is undefined if <code>str</code> is not a pointer to a null-terminated byte string.</div><div>2) Same as (1), except that the function returns zero if <code>str</code> is a null pointer and returns <code>strsz</code> if the null character was not found in the first <code>strsz</code> bytes of <code>str</code>.</div><div> The behavior is undefined if both <code>str</code> points to a character array which lacks the null character and the size of that character array &lt; <code>strsz</code>; in other words, an erroneous value of <code>strsz</code> does not expose the impending buffer overflow.<dl><dd>As with all bounds-checked functions, <code>strnlen_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td> str</td><td> -</td><td>  pointer to the null-terminated byte string to be examined</td></tr><tr><td> strsz</td><td> -</td><td>  maximum number of characters to examine</td></tr></table><span class="prog__sub"> Return value</span><div>1) The length of the null-terminated byte string <code>str</code>.</div><div>2) The length of the null-terminated byte string <code>str</code> on success, zero if <code>str</code> is a null pointer, <code>strsz</code> if the null character was not found.</div></section>	http://en.cppreference.com/w/c/string/byte/strlen
strncat, strncat_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>char *strncat( char *dest, const char *src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>char *strncat( char *restrict dest, const char *restrict src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t strncat_s(char *restrict dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char *restrict src, rsize_t count);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Appends at most <code>count</code> characters from the character array pointed to by <code>src</code>, stopping if the null character is found, to the end of the null-terminated byte string pointed to by <code>dest</code>. The character <code>src[0]</code> replaces the null terminator at the end of <code>dest</code>. The terminating null character is always appended in the end (so the maximum number of bytes the function may write is <code>count+1</code>).</div><div> The behavior is undefined if the destination array does not have enough space for the contents of both <code>dest</code> and the first <code>count</code> characters of <code>src</code>, plus the terminating null character. The behavior is undefined if the source and destination objects overlap. The behavior is undefined if either <code>dest</code> is not a pointer to a null-terminated byte string or <code>src</code> is not a pointer to a character array,</div><div>2) Same as (1), except that this function may clobber the remainder of the destination array (from the last byte written to <code>destsz</code>) and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is zero or greater than RSIZE_MAX</li><li> there is no null character in the first <code>destsz</code> bytes of <code>dest</code></li><li> truncation would occur: <code>count</code> or the length of <code>src</code>, whichever is less, exceeds the space available between the null terminator of <code>dest</code> and <code>destsz</code>.</li><li> overlap would occur between the source and the destination strings</li></ul></dd></dl></div><div> The behavior is undefined if the size of the character array pointed to by <code>dest</code> &lt; <code>strnlen(dest,destsz)+strnlen(src,count)+1</code> &lt; <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by <code>src</code> &lt; <code>strnlen(src,count)</code> &lt; <code>destsz</code>; in other words, an erroneous value of <code>count</code> does not expose the impending buffer overflow.<dl><dd>As all bounds-checked functions, <code>strncat_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to append to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the character array to copy from</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of characters to copy</td></tr><tr><td>  destsz</td><td> -</td><td>  the size of the destination buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than RMAX_SIZE).</div></section>	http://en.cppreference.com/w/c/string/byte/strncat
strncmp	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int strncmp( const char *lhs, const char *rhs, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Compares at most <code>count</code> characters of two possibly null-terminated arrays. The comparison is done lexicographically.</p><p>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as <code>unsigned char</code>) that differ in the arrays being compared.</p><p>The behavior is undefined when access occurs past the end of either array <code>lhs</code> or <code>rhs</code>. The behavior is undefined when either <code>lhs</code> or <code>rhs</code> is the null pointer.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  pointers to the possibly null-terminated arrays to compare</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of characters to compare</td></tr></table><span class="prog__sub"> Return value</span><p>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal, or if count is zero.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p></section>	http://en.cppreference.com/w/c/string/byte/strncmp
strncpy, strncpy_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>char *strncpy( char *dest, const char *src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>char *strncpy( char *restrict dest, const char *restrict src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t strncpy_s(char *restrict dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const char *restrict src, rsize_t count);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies at most <code>count</code> characters of the character array pointed to by <code>src</code> (including the terminating null character, but not any of the characters that follow the null character) to character array pointed to by <code>dest</code>. </div><div> If <code>count</code> is reached before the entire array <code>src</code> was copied, the resulting character array is not null-terminated.</div><div> If, after copying the terminating null character from <code>src</code>, <code>count</code> is not reached, additional null characters are written to <code>dest</code> until the total of <code>count</code> characters have been written.</div><div> The behavior is undefined if the character arrays overlap, if either <code>dest</code> or <code>src</code> is not a pointer to a character array (including if <code>dest</code> or <code>src</code> is a null pointer), if the size of the array pointed to by <code>dest</code> is less than <code>count</code>, or if the size of the array pointed to by <code>src</code> is less than <code>count</code> and it does not contain a null character.</div><div>2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to <code>count</code>, it stops after writing the terminating null character (if there was no null in the source, it writes one at <code>dest[count]</code> and then stops). Also, the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is zero or greater than RSIZE_MAX</li><li> <code>count</code> is greater or equal <code>destsz</code>, but <code>destsz</code> is less or equal <code>strnlen_s(src, count)</code>, in other words, truncation would occur</li><li> overlap would occur between the source and the destination strings</li></ul></dd></dl></div><div> The behavior is undefined if the size of the character array pointed to by <code>dest</code> &lt; <code>strnlen_s(src, destsz)</code> &lt;= <code>destsz</code>; in other words, an erroneous value of <code>destsz</code> does not expose the impending buffer overflow. The behavior is undefined if the size of the character array pointed to by <code>src</code> &lt; <code>strnlen_s(src, count)</code> &lt; <code>destsz</code>; in other words, an erroneous value of <code>count</code> does not expose the impending buffer overflow.</div><dl><dd>As all bounds-checked functions, <code>strncpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the character array to copy to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the character array to copy from</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of characters to copy</td></tr><tr><td>  destsz</td><td> -</td><td>  the size of the destination buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, writes zero to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than RSIZE_MAX) and may clobber the rest of the destination array with unspecified values.</div></section>	http://en.cppreference.com/w/c/string/byte/strncpy
strpbrk	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char* strpbrk( const char* dest, const char* breakset );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Scans the null-terminated byte string pointed to by <code>dest</code> for any character from the null-terminated byte string pointed to by <code>breakset</code>, and returns a pointer to that character.</p><p>The behavior is undefined if either <code>dest</code> or <code>breakset</code> is not a pointer to a null-terminated byte string.</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr><td>  breakset</td><td> -</td><td>  pointer to the null-terminated byte string that contains the characters to search for</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the first character in <code>dest</code>, that is also in <code>breakset</code>, or null pointer if no such character exists.</p></section>	http://en.cppreference.com/w/c/string/byte/strpbrk
strrchr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char *strrchr( const char *str, int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Finds the last occurrence of <code>ch</code> (after conversion to <code>char</code> as if by <code>(char)ch</code>) in the null-terminated byte string pointed to by <code>str</code> (each character interpreted as <code>unsigned char</code>). The terminating null character is considered to be a part of the string and can be found if searching for <code>'\x00'</code>.</p><p>The behavior is undefined if <code>str</code> is not a pointer to a null-terminated byte string.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr><td>  ch</td><td> -</td><td>  character to search for</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the found character in <code>str</code>, or null pointer if no such character is found.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;string.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    char szSomeFileName[] = "foo/bar/foobar.txt";    char *pLastSlash = strrchr(szSomeFileName, '/');    char *pszBaseName = pLastSlash ? pLastSlash + 1 : szSomeFileName;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Base Name:\xc2\xa0%s", pszBaseName);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Base Name: foobar.txt</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strrchr
strspn	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strspn( const char *dest, const char *src );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the length of the maximum initial segment (span) of the null-terminated byte string pointed to by <code>dest</code>, that consists of only the characters found in the null-terminated byte string pointed to by <code>src</code>.</p><p>The behavior is undefined if either <code>dest</code> or <code>src</code> is not a pointer to a null-terminated byte string.</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated byte string to be analyzed</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated byte string that contains the characters to search for</td></tr></table><span class="prog__sub"> Return value</span><p>The length of the maximum initial segment that contains only characters from the null-terminated byte string pointed to by <code>src</code></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;string.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    const char *string = "abcde312$#@";    const char *low_alpha = "qwertyuiopasdfghjklzxcvbnm";\xc2\xa0    <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> spnsz = strspn(string, low_alpha);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("After skipping initial lowercase letters from '%s'\n"           "The remainder is '%s'\n", string, string+spnsz);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>After skipping initial lowercase letters from 'abcde312$#@'<br>The remainder is '312$#@'</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strspn
strstr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>char *strstr( const char* str, const char* substr );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of the null-terminated byte string pointed to by <code>substr</code> in the null-terminated byte string pointed to by <code>str</code>. The terminating null characters  are not compared.</p><p>The behavior is undefined if either <code>str</code> or <code>substr</code> is not a pointer to a null-terminated byte string.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to examine</td></tr><tr><td>  substr</td><td> -</td><td>  pointer to the null-terminated byte string to search for</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the first character of the found substring in <code>str</code>, or <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> if no such substring is found. If <code>substr</code> points to an empty string, <code>str</code> is returned.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;string.h&gt;#include &lt;stdio.h&gt;\xc2\xa0void find_str(char const* str, char const* substr) {    char* pos = strstr(str, substr);    if(pos) {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("found the string '%s' in '%s' at position:\xc2\xa0%ld\n", substr, str, pos - str);    } else {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("the string '%s' was not found in '%s'\n", substr, str);    }}\xc2\xa0int main(void) {    char* str = "one two three";    find_str(str, "two");    find_str(str, "");    find_str(str, "nine");    find_str(str, "n");\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>found the string 'two' in 'one two three' at position: 4<br>found the string '' in 'one two three' at position: 0<br>the string 'nine' was not found in 'one two three'<br>found the string 'n' in 'one two three' at position: 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strstr
strtof, strtod, strtold	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 strtof( const char *restrict str, char **restrict str_end );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0strtod( const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*str, char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0**str_end );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0strtod( const char *restrict str, char **restrict str_end );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>long double strtold( const char *restrict str, char **restrict str_end );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets a floating-point value in a byte string pointed to by <code>str</code>.</p><p>Function discards any whitespace characters (as determined by <code>std::<a href="http://en.cppreference.com/w/c/string/byte/isspace">isspace</a>()</code>) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</p><ul><li>decimal floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C locale) (defines significand)</li><li> (optional) <code>e</code> or <code>E</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li>binary floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>0x</code> or <code>0X</code></li><li> nonempty sequence of hexadecimal digits optionally containing a decimal-point character (as determined by the current C locale) (defines significand)</li><li> (optional) <code>p</code> or <code>P</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li> infinity expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>INF</code> or <code>INFINITY</code> ignoring case</li></ul></dd></dl><ul><li> not-a-number expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>NAN</code> or <code>NAN(</code><i>char_sequence</i><code>)</code> ignoring case of the <code>NAN</code> part. <i>char_sequence</i> can only contain alphanumeric characters. The result is a quiet NaN floating-point value.</li></ul></dd></dl><ul><li> any other expression that may be accepted by the currently installed C locale</li></ul><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the character past the last character interpreted. If <code>str_end</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, it is ignored.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr><tr><td>  str_end</td><td> -</td><td>  pointer to a pointer to character.</td></tr></table><span class="prog__sub"> Return value</span><p>Floating-point value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <a href="http://en.cppreference.com/w/c/numeric/math/HUGE_VAL" title="c/numeric/math/HUGE VAL">HUGE_VAL</a>, <a href="http://en.cppreference.com/w/c/numeric/math/HUGE_VAL" title="c/numeric/math/HUGE VAL">HUGE_VALF</a> or <a href="http://en.cppreference.com/w/c/numeric/math/HUGE_VAL" title="c/numeric/math/HUGE VAL">HUGE_VALL</a> is returned. If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    // parsing with error handling    const char *p = "111.11 -2.22 Nan nan(2) inF 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz";    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing '%s':\n", p);    char *end;    for (double f = strtod(p, &amp;end); p != end; f = strtod(p, &amp;end))    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("'%.*s' -&gt; ", (int)(end-p), p);        p = end;        if (errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>){            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("range error, got ");            errno = 0;        }        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f\n", f);    }\xc2\xa0    // parsing without error handling    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""  -0.0000000123junk"  --&gt; \xc2\xa0%g\n", strtod("  -0.0000000123junk", <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""junk"                 --&gt; \xc2\xa0%g\n", strtod("junk", <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>));}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>Parsing '111.11 -2.22 Nan inF 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz':<br>'111.11' -&gt; 111.110000<br>' -2.22' -&gt; -2.220000<br>' Nan' -&gt; nan<br>' nan(2)' -&gt; nan<br>' inF' -&gt; inf<br>' 0X1.BC70A3D70A3D7P+6' -&gt; 111.110000<br>'  1.18973e+4932' -&gt; range error, got inf<br>"  -0.0000000123junk"  --&gt;  -1.23e-08<br>"junk"                 --&gt;  0</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strtof
strtoimax, strtoumax	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;inttypes.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> strtoimax( const char *restrict nptr, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 char **restrict endptr, int base );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/integer">uintmax_t</a> strtoumax( const char *restrict nptr, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0char **restrict endptr, int base );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets an integer value in a byte string pointed to by <code>nptr</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base)  integer number representation and converts them to an  integer value. The valid   integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <a href="http://en.cppreference.com/w/c/locale/setlocale" title="c/locale/setlocale">locale</a>.</p><p>If the value of base is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Unary_arithmetic" title="c/language/operator arithmetic">unary minus</a> in the result type.</p><p>The functions sets the pointer pointed to by <code>endptr</code> to point to the character past the last character interpreted. If <code>endptr</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, it is ignored.</p><p>If the <code>nptr</code> is empty or does not have the expected form, no conversion is performed, and (if <code>enptr</code> is not <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>) the value of <code>nptr</code> is stored in the object pointed to by <code>endptr</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  nptr</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr><tr><td>  endptr</td><td> -</td><td>  pointer to a pointer to character.</td></tr><tr><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><span class="prog__sub"> Return value</span><ul><li> If successful, an integer value corresponding to the contents of <code>str</code> is returned.</li><li> If the converted value falls out of range of corresponding return type, a range error occurs (setting [[cpp/error/errno|<a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a>]] to <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">ERANGE</a>) and <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">INTMAX_MAX</a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">INTMAX_MIN</a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">UINTMAX_MAX</a> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned, as appropriate.</li><li> If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;\xc2\xa0int main(void){\xc2\xa0    char* endptr;\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", strtoimax(" -123junk",&amp;endptr,10)); /* base 10                    */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", strtoimax("11111111",&amp;endptr,2));   /* base 2                     */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", strtoimax("XyZ",&amp;endptr,36));       /* base 36                    */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", strtoimax("010",&amp;endptr,0));        /* octal auto-detection       */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", strtoimax("10",&amp;endptr,0));         /* decimal auto-detection     */    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", strtoimax("0x10",&amp;endptr,0));       /* hexadecimal auto-detection */\xc2\xa0    /* range error             */    /* LONG_MAX+1 --&gt; LONG_MAX */    errno = 0;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", strtoimax("9223372036854775808",&amp;endptr,10));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%s\n", <a href="http://en.cppreference.com/w/c/string/byte/strerror">strerror</a>(errno));\xc2\xa0    return 0;}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>-123<br>255<br>44027<br>8<br>10<br>16<br>9223372036854775807<br>Numerical result out of range</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strtoimax
strtok, strtok_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>char *strtok( char *str, const char *delim );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>char *strtok( char *restrict str, const char *restrict delim );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>char *strtok_s(char *restrict str, rsize_t *restrict strmax,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0const char *restrict delim, char **restrict ptr);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Finds the next token in a null-terminated byte string pointed to by <code>str</code>. The separator characters are identified by null-terminated byte string pointed to by <code>delim</code>.</div><div> This function is designed to be called multiples times to obtain successive tokens from the same string.</div><dl><dd><ul><li> If <code>str != <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a></code>, the call is treated as the first call to <code>strtok</code> for this particular string. The function searches for the first character which is <i>not</i> contained in <code>delim</code>.</li></ul><dl><dd><ul><li> If no such character was found, there are no tokens in <code>str</code> at all, and the function returns a null pointer. </li><li> If such character was found, it is the <i>beginning of the token</i>. The function then searches from that point on for the first character that <i>is</i> contained in <code>delim</code>. </li></ul><dl><dd><ul><li> If no such character was found, <code>str</code> has only one token, and future calls to <code>strtok</code> will return a null pointer</li><li> If such character was found, it is <i>replaced</i> by the null character <code>'\x00'</code> and the pointer to the following character is stored in a static location for subsequent invocations.</li></ul></dd></dl><ul><li> The function then returns the pointer to the beginning of the token</li></ul></dd></dl><ul><li> If <code>str == <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a></code>, the call is treated as a subsequent calls to <code>strtok</code>: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as <code>str</code>.</li></ul></dd></dl><div> The behavior is undefined if either <code>str</code> or <code>delim</code> is not a pointer to a null-terminated byte string.</div><div>2) Same as (1), except that on every step, writes the number of characters left to see in <code>str</code> into <code>*strmax</code> and writes the tokenizer's internal state to <code>*ptr</code>. Repeat calls (with null <code>str</code>) must pass <code>strmax</code> and <code>ptr</code> with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function, without storing anything in the object pointed to by <code>ptr</code><dl><dd><ul><li> <code>strmax</code>, <code>delim</code>, or <code>ptr</code> is a null pointer</li><li> on a non-initial call (with null <code>str</code>), <code>*ptr</code> is a null pointer</li><li> on the first call, <code>*strmax</code> is zero or greater than RSIZE_MAX</li><li> search for the end of a token reaches the end of the source string (as measured by the initial value of <code>*strmax</code>)) without encountering the null terminator</li></ul></dd></dl></div><div> The behavior is undefined if both <code>str</code> points to a character array which lacks the null character and <code>strmax</code> points to a value which is greater than the size of that character array.<dl><dd>As all bounds-checked functions, <code>strtok_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>string.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to tokenize</td></tr><tr><td>  delim</td><td> -</td><td>  pointer to the null-terminated byte string identifying delimiters</td></tr><tr><td>  strmax</td><td> -</td><td>  pointer to an object which initially holds the size of <code>str</code>: strtok_s stores the number of characters that remain to be examined</td></tr><tr><td>  ptr</td><td> -</td><td>  pointer to an object of type <code>char*</code>, which is used by strtok_s to store its internal state</td></tr></table><span class="prog__sub"> Return value</span><p>Returns pointer to the beginning of the next token or <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> if there are no more tokens.</p><span class="prog__sub"> Note</span><p>This function is destructive: it writes the <code>'\x00'</code> characters in the elements of the string <code>str</code>. In particular, a string literal cannot be used as the first argument of <code>strtok</code>.</p><p>Each call to <code>strtok</code> modifies a static variable: is not thread safe.</p><p>Unlike most other tokenizers, the delimiters in <code>strtok</code> can be different for each subsequent token, and can even depend on the contents of the previous tokens.</p><p>The <code>strtok_s</code> function differs from the POSIX <a class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html" rel="nofollow">strtok_r</a> function by guarding against storing outside of the string being tokenized, and by checking runtime constraints.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#define __STDC_WANT_LIB_EXT1__ 1#include &lt;string.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    char input[] = "A bird came down the walk";    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing the input string '%s'\n", input);    char *token = strtok(input, " ");    while(token) {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>(token);        token = strtok(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, " ");    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Contents of the input string now: '");    for(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n = 0; n &lt; sizeof input; ++n)        input[n] ? <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%c", input[n]) : <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\\0");    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("'");\xc2\xa0#ifdef __STDC_LIB_EXT1__    char str[] = "A bird came down the walk";    rsize_t strmax = sizeof str;    const char *delim = " ";    char *next_token;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing the input string '%s'\n", str);    token = strtok_s(str, &amp;strmax, delim, &amp;next_token);    while(token) {        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>(token);        token = strtok_s(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, &amp;strmax, delim, &amp;next_token);    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Contents of the input string now: '");    for(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n = 0; n &lt; sizeof str; ++n)        str[n] ? <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%c", str[n]) : <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\\0");    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("'");#endif}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>Parsing the input string 'A bird came down the walk'<br>A<br>bird<br>came<br>down<br>the<br>walk<br>Contents of the input string now: 'A\x00bird\x00came\x00down\x00the\x00walk\x00'<br>Parsing the input string 'A bird came down the walk'<br>A<br>bird<br>came<br>down<br>the<br>walk<br>Contents of the input string now: 'A\x00bird\x00came\x00down\x00the\x00walk\x00'</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strtok
strtol, strtoll	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>long \xc2\xa0 \xc2\xa0 \xc2\xa0strtol( const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*str, char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0**str_end, int base );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>long \xc2\xa0 \xc2\xa0 \xc2\xa0strtol( const char *restrict str, char **restrict str_end, int base );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>long long strtoll( const char *restrict str, char **restrict str_end, int base );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets an integer value in a byte string pointed to by <code>str</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base)  integer number representation and converts them to an  integer value. The valid   integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <a href="http://en.cppreference.com/w/c/locale/setlocale" title="c/locale/setlocale">locale</a>.</p><p>If the value of base is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Unary_arithmetic" title="c/language/operator arithmetic">unary minus</a> in the result type.</p><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the character past the last character interpreted. If <code>str_end</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, it is ignored.</p><p>If the <code>str</code> is empty or does not have the expected form, no conversion is performed, and (if <code>str_end</code> is not <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>) the value of <code>str</code> is stored in the object pointed to by <code>str_end</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr><tr><td>  str_end</td><td> -</td><td>  pointer to a pointer to character.</td></tr><tr><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><span class="prog__sub"> Return value</span><ul><li> If successful, an integer value corresponding to the contents of <code>str</code> is returned.</li><li> If the converted value falls out of range of corresponding return type, a range error occurs (setting <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> to <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">ERANGE</a>) and <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">LONG_MAX</a>, <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">LONG_MIN</a>, <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">LLONG_MAX</a> or <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">LLONG_MIN</a> is returned. </li><li> If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    // parsing with error handling    const char *p = "10 200000000000000000000000000000 30 -40 junk";    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing '%s':\n", p);    char *end;    for (long i = strtol(p, &amp;end, 10);         p != end;         i = strtol(p, &amp;end, 10))    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("'%.*s' -&gt; ", (int)(end-p), p);        p = end;        if (errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>){            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("range error, got ");            errno = 0;        }        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", i);    }\xc2\xa0    // parsing without error handling    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""1010" in binary  --&gt;\xc2\xa0%ld\n", strtol("1010",<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>,2));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""12" in octal     --&gt;\xc2\xa0%ld\n", strtol("12",<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>,8));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""A"  in hex       --&gt;\xc2\xa0%ld\n", strtol("A",<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>,16));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""junk" in base-36 --&gt;\xc2\xa0%ld\n", strtol("junk",<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>,36));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""012" in auto-detected base  --&gt;\xc2\xa0%ld\n", strtol("012",<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>,0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""0xA" in auto-detected base  --&gt;\xc2\xa0%ld\n", strtol("0xA",<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>,0));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>(""junk" in auto-detected base --&gt; \xc2\xa0%ld\n", strtol("junk",<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>,0));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Parsing '10 200000000000000000000000000000 30 -40 junk':<br>'10' -&gt; 10<br>' 200000000000000000000000000000' -&gt; range error, got 9223372036854775807<br>' 30' -&gt; 30<br>' -40' -&gt; -40<br>"1010" in binary  --&gt; 10<br>"12" in octal     --&gt; 10<br>"A"  in hex       --&gt; 10<br>"junk" in base-36 --&gt; 926192<br>"012" in auto-detected base  --&gt; 10<br>"0xA" in auto-detected base  --&gt; 10<br>"junk" in auto-detected base --&gt;  0</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strtol
strtoul, strtoull	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code>unsigned long \xc2\xa0 \xc2\xa0 \xc2\xa0strtoul( const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*str, char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0**str_end, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 int base );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>unsigned long \xc2\xa0 \xc2\xa0 \xc2\xa0strtoul( const char *restrict str, char **restrict str_end, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 int base );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>unsigned long long strtoull( const char *restrict str, char **restrict str_end,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0int base );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets an unsigned integer value in a byte string pointed to by <code>str</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base) unsigned integer number representation and converts them to an  integer value. The valid unsigned  integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <a href="http://en.cppreference.com/w/c/locale/setlocale" title="c/locale/setlocale">locale</a>.</p><p>If the value of base is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Unary_arithmetic" title="c/language/operator arithmetic">unary minus</a> in the result type, which applies unsigned integer wraparound rules.</p><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the character past the last character interpreted. If <code>str_end</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, it is ignored.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated byte string to be interpreted</td></tr><tr><td>  str_end</td><td> -</td><td>  pointer to a pointer to character.</td></tr><tr><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><span class="prog__sub"> Return value</span><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs (<a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> is set to <code>ERANGE</code>) and <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">ULONG_MAX</a> or <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">ULLONG_MAX</a> is returned. If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0int main(void){    const char *p = "10 200000000000000000000000000000 30 -40";    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing '%s':\n", p);    char *end;    for (unsigned long i = strtoul(p, &amp;end, 10);         p != end;         i = strtoul(p, &amp;end, 10))    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("'%.*s' -&gt; ", (int)(end-p), p);        p = end;        if (errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>){            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("range error, got ");            errno = 0;        }        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%lu\n", i);    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Parsing '10 200000000000000000000000000000 30 -40':<br>'10' -&gt; 10<br>' 200000000000000000000000000000' -&gt; range error, got 18446744073709551615<br>' 30' -&gt; 30<br>' -40' -&gt; 18446744073709551576</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/strtoul
strxfrm	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strxfrm( char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*dest, const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*src, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strxfrm( char *restrict dest, const char *restrict src, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Transforms the null-terminated byte string pointed to by <code>src</code> into the implementation-defined form such that comparing two transformed strings with <a href="http://en.cppreference.com/w/c/string/byte/strcmp" title="c/string/byte/strcmp">strcmp</a> gives the same result as comparing the original strings with <a href="http://en.cppreference.com/w/c/string/byte/strcoll" title="c/string/byte/strcoll">strcoll</a>, in the current C locale.</p><p>The first <code>count</code> characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.</p><p>The behavior is undefined if the <code>dest</code> array is not large enough. The behavior is undefined if <code>dest</code> and <code>src</code> overlap.</p><p>If <code>count</code> is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, then <code>dest</code> is allowed to be a null pointer.</p></section>	http://en.cppreference.com/w/c/string/byte/strxfrm
tolower	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int tolower( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.<br></p><p>In the default "C" locale, the following uppercase letters <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> are replaced with respective lowercase letters <code>abcdefghijklmnopqrstuvwxyz</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to be converted. If the value of <code>ch</code> is not representable as <code>unsigned char</code> and does not equal <code>EOF</code>, the behavior is undefined.</td></tr></table><span class="prog__sub"> Return value</span><p>Lowercase version of <code>ch</code> or unmodified <code>ch</code> if no lowercase version is listed in the current C locale.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;#include &lt;limits.h&gt;\xc2\xa0int main(void){    /* In the default locale: */    unsigned char l;    for (unsigned char u=0; u&lt;<a href="http://en.cppreference.com/w/c/types/limits">UCHAR_MAX</a>; u++) {        l = tolower(u);        if (l!=u) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%c%c ", u,l);    }    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n\n");\xc2\xa0    unsigned char c = '\xb4'; // the character \xc5\xbd in ISO-8859-15                              // but \xc2\xb4 (acute accent) in ISO-8859-1     unsigned char c2 = c;   // for printing    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in iso8859-1, tolower('0x%x') gives 0x%x\n", c2, tolower(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.iso885915");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in iso8859-15, tolower('0x%x') gives 0x%x\n", c2, tolower(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz<br>\xc2\xa0<br>in iso8859-1, tolower('0xb4') gives 0xb4<br>in iso8859-15, tolower('0xb4') gives 0xb8</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/tolower
toupper	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;ctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int toupper( int ch );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.<br></p><p>In the default "C" locale, the following lowercase letters <code>abcdefghijklmnopqrstuvwxyz</code> are replaced with respective uppercase letters <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  character to be converted. If the value of <code>ch</code> is not representable as <code>unsigned char</code> and does not equal <code>EOF</code>, the behavior is undefined.</td></tr></table><span class="prog__sub"> Return value</span><p>Uppercase version of <code>ch</code> or unmodified <code>ch</code> if no uppercase version is listed in the current C locale.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;locale.h&gt;#include &lt;limits.h&gt;\xc2\xa0int main(void){    /* In the default locale: */    unsigned char u;    for (unsigned char l=0; l&lt;<a href="http://en.cppreference.com/w/c/types/limits">UCHAR_MAX</a>; l++) {        u = toupper(l);        if (l!=u) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%c%c ", l,u);    }    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\n\n");\xc2\xa0    unsigned char c = '\xb8'; // the character \xc5\xbd in ISO-8859-15                              // but \xc2\xb4 (acute accent) in ISO-8859-1     unsigned char c2 = c;   // for printing    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.iso88591");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in iso8859-1, toupper('0x%x') gives 0x%x\n", c2, toupper(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.iso885915");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in iso8859-15, toupper('0x%x') gives 0x%x\n", c2, toupper(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>aA bB cC dD eE fF gG hH iI jJ kK lL mM nN oO pP qQ rR sS tT uU vV wW xX yY zZ <br>\xc2\xa0<br>in iso8859-1, toupper('0xb8') gives 0xb8<br>in iso8859-15, toupper('0xb8') gives 0xb4</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/byte/toupper
btowc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wint_t btowc( int c );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Widens a single-byte character <code>c</code> (reinterpreted as <code>unsigned char</code>) to its wide character equivalent. </p><p>Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to <code>wchar_t</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  c</td><td> -</td><td>  single-byte character to widen</td></tr></table><span class="prog__sub"> Return value</span><p><code>WEOF</code> if <code>c</code> is <a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a></p><p>wide character representation of <code>c</code> if <code>(unsigned char)c</code> is a valid single-byte character in the initial shift state, <code>WEOF</code> otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;locale.h&gt;#include &lt;assert.h&gt;\xc2\xa0void try_widen(unsigned char c){    wint_t w = btowc(c);    if(w != WEOF)        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The single-byte character\xc2\xa0%#x widens to\xc2\xa0%#x\n", c, w);    else        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The single-byte character\xc2\xa0%#x failed to widen\n", c);}\xc2\xa0int main(void){    char *loc = <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "lt_LT.iso88594");    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(loc);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In Lithuanian ISO-8859-4 locale:\n");    try_widen('A');    try_widen('\xdf'); // German letter \xc3\x9f (U+00df) in ISO-8859-4    try_widen('\xf9'); // Lithuanian letter \xc5\xb3 (U+0173) in ISO-8859-4\xc2\xa0    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "lt_LT.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("In Lithuanian UTF-8 locale:\n");    try_widen('A');    try_widen('\xdf');    try_widen('\xf9');}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>In Lithuanian ISO-8859-4 locale:<br>The single-byte character 0x41 widens to 0x41<br>The single-byte character 0xdf widens to 0xdf<br>The single-byte character 0xf9 widens to 0x173<br>In Lithuanian UTF-8 locale:<br>The single-byte character 0x41 widens to 0x41<br>The single-byte character 0xdf failed to widen<br>The single-byte character 0xf9 failed to widen</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/btowc
c16rtomb	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;uchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> c16rtomb( char* s, char16_t c16, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts a single code point from its variable-length 16-bit character representation (typically, UTF-16) to its narrow multibyte character representation.<br></p><p>If <code>s</code> is not a null pointer and <code>c16</code> is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences), and stores the multibyte character representation in the character array whose first element is pointed to by <code>s</code>. At most <code>MB_CUR_MAX</code> bytes can be written by this function.</p><p>If <code>s</code> is a null pointer, the call is equivalent to <code>c16rtomb(buf, u'\x00', ps)</code> for some internal buffer <code>buf</code>.</p><p>If <code>c16</code> is the null wide character <code>u'\x00'</code>, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter <code>*ps</code> is updated to represent the initial shift state.</p><p>If <code>c16</code> is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by <code>s</code>, only <code>*ps</code> is updated.</p><p>If the macro <code>__STDC_UTF_16__</code> is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  s</td><td> -</td><td>  pointer to narrow character array where the multibyte character will be stored</td></tr><tr><td>  c16</td><td> -</td><td>  the 16-bit character to convert</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by <code>s</code>. This value may be <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, e.g. when processing the first <code>char16_t</code> in a surrogate pair.</p><p>On failure (if <code>c16</code> is not a valid 16-bit code unit), returns <code>-1</code>, stores <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EILSEQ</a> in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a>, and leaves <code>*ps</code> in unspecified state.</p></section>	http://en.cppreference.com/w/c/string/multibyte/c16rtomb
c32rtomb	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;uchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> c32rtomb( char* s, char32_t c32, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation.<br></p><p>If <code>s</code> is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of <code>c32</code> (including any shift sequences), and stores the multibyte character representation in the character array whose first element is pointed to by <code>s</code>. At most <code>MB_CUR_MAX</code> bytes can be written by this function.</p><p>If <code>s</code> is a null pointer, the call is equivalent to <code>c32rtomb(buf, U'\x00', ps)</code> for some internal buffer <code>buf</code>.</p><p>If <code>c32</code> is the null wide character <code>U'\x00'</code>, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter <code>*ps</code> is updated to represent the initial shift state.</p><p>If the macro <code>__STDC_UTF_32__</code> is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  s</td><td> -</td><td>  pointer to narrow character array where the multibyte character will be stored</td></tr><tr><td>  c32</td><td> -</td><td>  the 32-bit character to convert</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr></table><span class="prog__sub"> Return value</span><p>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by <code>s</code>. This value may be <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, e.g. when processing the first <code>char32_t</code> in multi-<code>char32_t</code>-character sequence (does not occur in UTF-32).</p><p>On failure (if <code>c32</code> is not a valid 32-bit character), returns <code>-1</code>, stores <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EILSEQ</a> in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a>, and leaves <code>*ps</code> in unspecified state.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;uchar.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0<a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> state;int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    char32_t str[] = U"z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c"; // or z\xdf\u6c34\U0001f34c    <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> str_sz = sizeof str / sizeof *str;\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Processing\xc2\xa0%zu UTF-32 code units: [ ", str_sz);    for(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n = 0; n &lt; str_sz; ++n) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x ", str[n]); <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("]");\xc2\xa0    char out[MB_CUR_MAX];    for(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n = 0; n &lt; str_sz; ++n)    {        int rc = c32rtomb(out, str[n], &amp;state);        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x converted to [ ", str[n]);        for(int x = 0; x &lt; rc; ++x) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x ", (unsigned char)out[x]); <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("]");    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Processing 5 UTF-32 code units: [ 0x7a 0xdf 0x6c34 0x1f34c 0 ]<br>0x7a converted to [ 0x7a ]<br>0xdf converted to [ 0xc3 0x9f ]<br>0x6c34 converted to [ 0xe6 0xb0 0xb4 ]<br>0x1f34c converted to [ 0xf0 0x9f 0x8d 0x8c ]<br>0 converted to [ 0 ]</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/c32rtomb
mblen	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int mblen( const char* s, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines the size, in bytes, of the multibyte character whose first byte is pointed to by <code>s</code>. </p><p>If <code>s</code> is a null pointer, resets the global conversion state and determined whether shift sequences are used.</p><p>This function is equivalent to the call <code><a href="http://en.cppreference.com/w/c/string/multibyte/mbtowc">mbtowc</a>((wchar_t*)0, s, n)</code>, except that conversion state of <a href="http://en.cppreference.com/w/c/string/multibyte/mbtowc" title="c/string/multibyte/mbtowc">mbtowc</a> is unaffected.</p></section>	http://en.cppreference.com/w/c/string/multibyte/mblen
mbrlen	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> mbrlen( const char* s, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Determines the size, in bytes, of the remainder of the multibyte character whose first byte is pointed to by <code>s</code>, given the current conversion state <code>ps</code>.</p><p>This function is equivalent to the call <code><a href="http://en.cppreference.com/w/c/string/multibyte/mbrtowc">mbrtowc</a>(nullptr, s, n, ps?ps:&amp;internal)</code> for some hidden object <code>internal</code> of type <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t" title="c/string/multibyte/mbstate t">mbstate_t</a>, except that the expression <code>ps</code> is evaluated only once.</p><span class="prog__sub"> Parameters</span><table><tr><td>  s</td><td> -</td><td>  pointer to an element of a multibyte character string</td></tr><tr><td>  n</td><td> -</td><td>  limit on the number of bytes in s that can be examined</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the variable holding the conversion state</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if the next <code>n</code> or fewer bytes complete the null character.</p><p>The number of bytes (between <code>1</code> and <code>n</code>) that complete a valid multibyte character</p><p><code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-1</code> if encoding error occurs</p><p><code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-2</code> if the next <code>n</code> bytes are part of a possibly valid multibyte character, which is still incomplete after examining all <code>n</code> bytes</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;locale.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;\xc2\xa0int main(void){       // allow mbrlen() to work with UTF-8 multibyte encoding    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    // UTF-8 narrow multibyte encoding    const char* str = u8"\xe6\xb0\xb4";    <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> sz = <a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(str);\xc2\xa0    <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> mb;    <a href="http://en.cppreference.com/w/c/string/byte/memset">memset</a>(&amp;mb, 0, sizeof mb);    int len1 = mbrlen(str, 1, &amp;mb);    if(len1 == -2)         <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The first 1 byte of\xc2\xa0%s is an incomplete multibyte char"               " (mbrlen returns -2)\n", str);\xc2\xa0    int len2 = mbrlen(str+1, sz-1, &amp;mb);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The remaining\xc2\xa0%zu  bytes of\xc2\xa0%s hold\xc2\xa0%d bytes of the multibyte"           " character\n", sz-1, str, len2);\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Attempting to call mbrlen() in the middle of\xc2\xa0%s while in initial"           " shift state returns\xc2\xa0%zd\n", str, mbrlen(str+1, sz-1, &amp;mb));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>The first 1 byte of \xe6\xb0\xb4 is an incomplete multibyte char (mbrlen returns -2)<br>The remaining 2  bytes of \xe6\xb0\xb4 hold 2 bytes of the multibyte character<br>Attempting to call mbrlen() in the middle of \xe6\xb0\xb4 while in initial shift state returns -1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/mbrlen
mbrtoc16	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;uchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> mbrtoc16( char16_t* pc16, const char* s, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts a single code point from its narrow multibyte character representation to its variable-length 16-bit character representation (typically, UTF-16). <br></p><p>If <code>s</code> is not a null pointer, inspects at most <code>n</code> bytes of the multibyte character string, beginning with the byte pointed to by <code>s</code> to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in <code>s</code> is complete and valid, converts it to the corresponding 16-bit character and stores it in <code>*pc16</code> (if <code>pc16</code> is not null).</p><p>If the multibyte character in <code>*s</code> corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, <code>*ps</code> is updated in such a way that the next call to <code>mbrtoc16</code> will write out the additional char16_t, without considering <code>*s</code>.</p><p>If <code>s</code> is a null pointer, the values of <code>n</code> and <code>pc16</code> are ignored and the call is equivalent to <code>mbrtoc16(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, "", 1, ps)</code>.</p><p>If the wide character produced is the null character, the conversion state <code>*ps</code> represents the initial shift state.</p><p>If the macro <code>__STDC_UTF_16__</code> is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  pc16</td><td> -</td><td>  pointer to the location where the resulting 16-bit character will be written</td></tr><tr><td>  s</td><td> -</td><td>  pointer to the multibyte character string used as input</td></tr><tr><td>  n</td><td> -</td><td>  limit on the number of bytes in s that can be examined</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr></table><span class="prog__sub"> Return value</span><p>The first of the following that applies:<br></p><ul><li> <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if the character converted from <code>s</code> (and stored in <code>*pc16</code> if non-null) was the null character</li><li> the number of bytes <code>[1...n]</code> of the multibyte character successfully converted from <code>s</code></li><li> <code>-3</code> if the next <code>char16_t</code> from a multi-<code>char16_t</code> character (e.g. a surrogate pair) has now been written to <code>*pc16</code>. No bytes are processed from the input in this case.</li><li> <code>-2</code> if the next <code>n</code> bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to <code>*pc16</code>.</li><li> <code>-1</code> if encoding error occurs. Nothing is written to <code>*pc16</code>, the value <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EILSEQ</a> is stored in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> and the value if <code>*ps</code> is unspecified.</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;string.h&gt;#include &lt;uchar.h&gt;\xc2\xa0<a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> state;int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    char *str = u8"z\xdf\u6c34\U0001f34c"; // or u8"z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c"\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Processing\xc2\xa0%zu UTF-8 bytes: [ ", <a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(str));    for(char* p = str; *p; ++p) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x ", +(unsigned char)*p);    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("]");\xc2\xa0    char16_t c16;    char *ptr = str, *end = str + <a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(str)+1;    int rc;    while(rc = mbrtoc16(&amp;c16, ptr, end - ptr, &amp;state))    {           <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Next UTF-16 char:\xc2\xa0%#x obtained from ", c16);        if(rc == -3)            <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("earlier surrogate pair");        else if(rc &gt; 0) {            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d bytes [ ", rc);            for(int n = 0; n &lt; rc; ++n) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x ", +(unsigned char)ptr[n]);            <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("]");            ptr += rc;        }    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Processing 10 UTF-8 bytes: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c ]<br>Next UTF-16 char: 0x7a obtained from 1 bytes [ 0x7a ]<br>Next UTF-16 char: 0xdf obtained from 2 bytes [ 0xc3 0x9f ]<br>Next UTF-16 char: 0x6c34 obtained from 3 bytes [ 0xe6 0xb0 0xb4 ]<br>Next UTF-16 char: 0xd83c obtained from 4 bytes [ 0xf0 0x9f 0x8d 0x8c ]<br>Next UTF-16 char: 0xdf4c obtained from earlier surrogate pair</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/mbrtoc16
mbrtoc32	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;uchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> mbrtoc32( char32_t* pc32, const char* s, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts a single code point from its narrow multibyte character representation to its variable-length 32-bit character representation (but typically, UTF-32).<br></p><p>If <code>s</code> is not a null pointer, inspects at most <code>n</code> bytes of the multibyte character string, beginning with the byte pointed to by <code>s</code> to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in <code>s</code> is complete and valid, converts it to the corresponding 32-bit character and stores it in <code>*pc32</code> (if <code>pc32</code> is not null).</p><p>If the multibyte character in <code>*s</code> corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, <code>*ps</code> is updated in such a way that the next calls to <code>mbrtoc32</code> will write out the additional char32_t, without considering <code>*s</code>.</p><p>If <code>s</code> is a null pointer, the values of <code>n</code> and <code>pc32</code> are ignored and the call is equivalent to <code>mbrtoc32(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, "", 1, ps)</code>.</p><p>If the wide character produced is the null character, the conversion state <code>*ps</code> represents the initial shift state.</p><p>If the macro <code>__STDC_UTF_32__</code> is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale. </p><span class="prog__sub"> Parameters</span><table><tr><td>  pc32</td><td> -</td><td>  pointer to the location where the resulting 32-bit character will be written</td></tr><tr><td>  s</td><td> -</td><td>  pointer to the multibyte character string used as input</td></tr><tr><td>  n</td><td> -</td><td>  limit on the number of bytes in s that can be examined</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr></table><span class="prog__sub"> Return value</span><p>The first of the following that applies:<br></p><ul><li> <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if the character converted from <code>s</code> (and stored in <code>*pc32</code> if non-null) was the null character</li><li> the number of bytes <code>[1...n]</code> of the multibyte character successfully converted from <code>s</code></li><li> <code>-3</code> if the next <code>char32_t</code> from a multi-<code>char32_t</code> character has now been written to <code>*pc32</code>. No bytes are processed from the input in this case.</li><li> <code>-2</code> if the next <code>n</code> bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to <code>*pc32</code>.</li><li> <code>-1</code> if encoding error occurs. Nothing is written to <code>*pc32</code>, the value <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EILSEQ</a> is stored in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> and the value if <code>*ps</code> is unspecified.</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;string.h&gt;#include &lt;uchar.h&gt;#include &lt;assert.h&gt;\xc2\xa0<a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> state;int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    char *str = u8"z\xdf\u6c34\U0001f34c"; // or u8"z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c"\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Processing\xc2\xa0%zu UTF-8 bytes: [ ", <a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(str));    for(char* p = str; *p; ++p) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x ", (unsigned char)*p);    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("]");\xc2\xa0    char32_t c32;    char *ptr = str, *end = str + <a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(str) + 1;    int rc;    while(rc = mbrtoc32(&amp;c32, ptr, end - ptr, &amp;state))    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Next UTF-32 char:\xc2\xa0%#x obtained from ", c32);        <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(rc != -3); // no surrogate pairs in UTF-32        if(rc &gt; 0) {            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d bytes [ ", rc);            for(int n = 0; n &lt; rc; ++n) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x ", (unsigned char)ptr[n]);            <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("]");            ptr += rc;        }    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Processing 10 UTF-8 bytes: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c ]<br>Next UTF-32 char: 0x7a obtained from 1 bytes [ 0x7a ]<br>Next UTF-32 char: 0xdf obtained from 2 bytes [ 0xc3 0x9f ]<br>Next UTF-32 char: 0x6c34 obtained from 3 bytes [ 0xe6 0xb0 0xb4 ]<br>Next UTF-32 char: 0x1f34c obtained from 4 bytes [ 0xf0 0x9f 0x8d 0x8c ]</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/mbrtoc32
mbrtowc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> mbrtowc( wchar_t* pwc, const char* s, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts a narrow multibyte character to a wide character.<br></p><p>If <code>s</code> is not a null pointer, inspects at most <code>n</code> bytes of the multibyte character string, beginning with the byte pointed to by <code>s</code> to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in <code>s</code> is complete and valid, converts it to the corresponding wide character and stores it in <code>*pwc</code> (if <code>pwc</code> is not null).</p><p>If <code>s</code> is a null pointer, the values of <code>n</code> and <code>pwc</code> are ignored and call is equivalent to <code>mbrtowc(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, "", 1, ps)</code>.</p><p>If the wide character produced is the null character, the conversion state stored in <code>*ps</code> is the initial shift state.</p><span class="prog__sub"> Parameters</span><table><tr><td>  pwc</td><td> -</td><td>  pointer to the location where the resulting wide character will be written</td></tr><tr><td>  s</td><td> -</td><td>  pointer to the multibyte character string used as input</td></tr><tr><td>  n</td><td> -</td><td>  limit on the number of bytes in s that can be examined</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the conversion state used when interpreting the multibyte string</td></tr></table><span class="prog__sub"> Return value</span><p>The first of the following that applies:<br></p><ul><li> <code>\xe2\x80\x8b0\xe2\x80\x8b</code> if the character converted from <code>s</code> (and stored in <code>pwc</code> if non-null) was the null character</li><li> the number of bytes <code>[1...n]</code> of the multibyte character successfully converted from <code>s</code></li><li> <code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-2</code> if the next <code>n</code> bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to <code>*pwc</code>.</li><li> <code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-1</code> if encoding error occurs. Nothing is written to <code>*pwc</code>, the value <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EILSEQ</a> is stored in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a> and the value of <code>*ps</code> is left unspecified.</li></ul><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;string.h&gt;#include &lt;wchar.h&gt;\xc2\xa0// print multibyte string to wide-oriented stdout// equivalent to wprintf(L"%s\n", ptr);void print_mb(const char* ptr){    <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> state;    <a href="http://en.cppreference.com/w/c/string/byte/memset">memset</a>(&amp;state, 0, sizeof state);    const char* end = ptr + <a href="http://en.cppreference.com/w/c/string/byte/strlen">strlen</a>(ptr);    int len;    wchar_t wc;    while((len = mbrtowc(&amp;wc, ptr, end-ptr, &amp;state)) &gt; 0) {        <a href="http://en.cppreference.com/w/c/io/fwprintf">wprintf</a>(L"Next\xc2\xa0%d bytes are the character\xc2\xa0%lc \n", len, wc);        ptr += len;    }}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    // UTF-8 narrow multibyte encoding    print_mb(u8"z\xdf\u6c34\U0001f34c"); // or u8"z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c"}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Next 1 bytes are the character z<br>Next 2 bytes are the character \xc3\x9f<br>Next 3 bytes are the character \xe6\xb0\xb4<br>Next 4 bytes are the character \xf0\x9f\x8d\x8c</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/mbrtowc
mbsinit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int mbsinit( const <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps);</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>If <code>ps</code> is not a null pointer, the <code>mbsinit</code> function determines whether the pointed-to <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t" title="c/string/multibyte/mbstate t">mbstate_t</a> object describes the initial conversion state. </p></section>	http://en.cppreference.com/w/c/string/multibyte/mbsinit
mbsrtowcs, mbsrtowcs_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> mbsrtowcs( wchar_t* dst, const char** src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> len, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps )</code></div></td><td> (1) </td><td> (since C95) </td></tr><tr><td> <div><code>errno_t mbsrtowcs_s( <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> *restrict retval, wchar_t *restrict dst, rsize_t dstsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const char **restrict src, rsize_t len, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> *restrict ps);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts a null-terminated multibyte character sequence, which begins in the conversion state described by <code>*ps</code>, from the array whose first element is pointed to by <code>*src</code> to its wide character representation. If <code>dst</code> is not null, converted characters are stored in the successive elements of the wchar_t array pointed to by <code>dst</code>. No more than <code>len</code> wide characters are written to the destination array. Each multibyte character is converted as if by a call to <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtowc" title="c/string/multibyte/mbrtowc">mbrtowc</a>. The conversion stops if:</div><div> * The multibyte null character was converted and stored. <code>*src</code> is set to <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> and <code>*ps</code> represents the initial shift state.</div><div> * An invalid multibyte character (according to the current C locale) was encountered. <code>*src</code> is set to point at the beginning  of the first unconverted multibyte character.</div><div> * the next wide character to be stored would exceed <code>len</code>. <code>*src</code> is set to point at the beginning of the first unconverted multibyte character. This condition is not checked if <code>dst==<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a></code>.</div><div>2) Same as (1), except that</div><div> * the function returns its result as an out-parameter <code>retval</code></div><div> * if no null character was written to <code>dst</code> after <code>len</code> wide characters were written, then <code>L'\x00'</code> is stored in <code>dst[len]</code>, which means len+1 total wide characters are written</div><div> * the function clobbers the destination array from the terminating null and until <code>dstsz</code></div><div> * If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</div><div> * the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>retval</code>, <code>ps</code>, <code>src</code>, or <code>*src</code> is a null pointer</li><li> <code>dstsz</code> or <code>len</code> is greater than RSIZE_MAX/sizeof(wchar_t) (unless <code>dst</code> is null)</li><li> <code>dstsz</code> is not zero (unless <code>dst</code> is null)</li><li> There is no null character in the first <code>dstsz</code> multibyte characters in the <code>*src</code> array and <code>len</code> is greater than <code>dstsz</code> (unless <code>dst</code> is null)</li></ul></dd><dd>As all bounds-checked functions, <code>mbsrtowcs_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dst</td><td> -</td><td>  pointer to wide character array where the results will be stored</td></tr><tr><td>  src</td><td> -</td><td>  pointer to pointer to the first element of a null-terminated multibyte string</td></tr><tr><td>  len</td><td> -</td><td>  number of wide characters available in the array pointed to by dst</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the conversion state object</td></tr><tr><td>  dstsz</td><td> -</td><td>  max number of wide characters that will be written (size of the <code>dst</code> array)</td></tr><tr><td>  retval</td><td> -</td><td>  pointer to a size_t object where the result will be stored</td></tr></table><span class="prog__sub"> Return value</span><div>1) On success, returns the number of wide characters, excluding the terminating <code>L'\x00'</code>, written to the character array. If <code>dst==<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a></code>, returns the number of wide characters that would have been written given unlimited length. On conversion error (if invalid multibyte character was encountered), returns <code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-1</code>, stores <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EILSEQ</a> in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a>, and leaves <code>*ps</code> in unspecified state.</div><div>2) zero on success (in which case the number of wide characters excluding terminating zero that were, or would be written to <code>dst</code>, is stored in <code>*retval</code>), non-sero on error. In case of a runtime constraint violation, stores <code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-1</code> in <code>*retval</code> (unless <code>retval</code> is null) and sets <code>dst[0]</code> to <code>L'\x00'</code> (unless <code>dst</code> is null or <code>dstmax</code> is zero or greater than RSIZE_MAX)</div><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;wchar.h&gt;#include &lt;string.h&gt;\xc2\xa0void print_as_wide(const char* mbstr){    <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> state;    <a href="http://en.cppreference.com/w/c/string/byte/memset">memset</a>(&amp;state, 0, sizeof state);    int len = 1 + mbsrtowcs(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, &amp;mbstr, 0, &amp;state);    wchar_t wstr[len];    mbsrtowcs(&amp;wstr[0], &amp;mbstr, len, &amp;state);    <a href="http://en.cppreference.com/w/c/io/fwprintf">wprintf</a>(L"Wide string:\xc2\xa0%ls \n", wstr);    <a href="http://en.cppreference.com/w/c/io/fwprintf">wprintf</a>(L"The length, including L'\\0':\xc2\xa0%d\n", len);}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    print_as_wide(u8"z\xdf\u6c34\U0001f34c"); // u8"z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c"}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Wide string: z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c<br>The length, including L'\x00': 5</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/mbsrtowcs
mbstate_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;uchar.h&gt;</code></div></td><td></td><td><div>(since C11)</div></td></tr><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>struct mbstate_t;</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The type <code>mbstate_t</code> is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of <code>mbstate_t</code> represents the initial conversion state, although other values of <code>mbstate_t</code> may exist that also represent the initial conversion state.</p><p>Possible implementation of <code>mbstate_t</code> is a struct type holding an array representing the incomplete multibyte character, an integer counter indicating the number of bytes in the array that have been processed, and a representation of the current shift state.</p><p>The following functions should not be called from multiple threads without synchronization with the <code>mbstate_t*</code> argument of <code>NULL</code> due to possible data races: <a href="http://en.cppreference.com/w/c/string/multibyte/mbrlen" title="c/string/multibyte/mbrlen">mbrlen</a>, <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtowc" title="c/string/multibyte/mbrtowc">mbrtowc</a>, <a href="http://en.cppreference.com/w/c/string/multibyte/mbsrtowcs" title="c/string/multibyte/mbsrtowcs">mbsrtowcs</a>, <a href="http://en.cppreference.com/w/c/string/multibyte/mbtowc" title="c/string/multibyte/mbtowc">mbtowc</a>, <a href="http://en.cppreference.com/w/c/string/multibyte/wcrtomb" title="c/string/multibyte/wcrtomb">wcrtomb</a>, <a href="http://en.cppreference.com/w/c/string/multibyte/wcsrtombs" title="c/string/multibyte/wcsrtombs">wcsrtombs</a>, <a href="http://en.cppreference.com/w/c/string/multibyte/wctomb" title="c/string/multibyte/wctomb">wctomb</a>.</p></section>	http://en.cppreference.com/w/c/string/multibyte/mbstate_t
mbstowcs, mbstowcs_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> mbstowcs( wchar_t \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*dst, const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> len)</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> mbstowcs( wchar_t *restrict dst, const char *restrict src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> len)</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t mbstowcs_s(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> *restrict retval, wchar_t *restrict dst,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 rsize_t dstsz, const char *restrict src, rsize_t len);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts a multibyte character string from the array whose first element is pointed to by <code>src</code> to its wide character representation. Converted characters are stored in the successive elements of the array pointed to by <code>dst</code>. No more than <code>len</code> wide characters are written to the destination array.</div><div> Each character is converted as if by a call to <a href="http://en.cppreference.com/w/c/string/multibyte/mbtowc" title="c/string/multibyte/mbtowc">mbtowc</a>, except that the mbtowc conversion state is unaffected. The conversion stops if:</div><div> * The multibyte null character was converted and stored.</div><div> * An invalid (in the current C locale) multibyte character was encountered.</div><div> * The next wide character to be stored would exceed <code>len</code>.</div><div> If <code>src</code> and <code>dst</code> overlap, the behavior is undefined</div><div>2) Same as (1), except that</div><div> * conversion is as-if by <a href="http://en.cppreference.com/w/c/string/multibyte/mbrtowc" title="c/string/multibyte/mbrtowc">mbrtowc</a>, not <a href="http://en.cppreference.com/w/c/string/multibyte/mbtowc" title="c/string/multibyte/mbtowc">mbtowc</a></div><div> * the function returns its result as an out-parameter <code>retval</code></div><div> * if no null character was written to <code>dst</code> after <code>len</code> wide characters were written, then <code>L'\x00'</code> is stored in <code>dst[len]</code>, which means len+1 total wide characters are written</div><div> * if <code>dst</code> is a null pointer, the number of wide characters that would be produced is stored in <code>*retval</code></div><div> * the function clobbers the destination array from the terminating null and until <code>dstsz</code></div><div> * If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</div><div> * the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>retval</code> or <code>src</code> is a null pointer</li><li> <code>dstsz</code> or <code>len</code> is greater than RSIZE_MAX/sizeof(wchar_t) (unless <code>dst</code> is null)</li><li> <code>dstsz</code> is not zero (unless <code>dst</code> is null)</li><li> There is no null character in the first <code>dstsz</code> multibyte characters in the <code>src</code> array and <code>len</code> is greater than <code>dstsz</code> (unless <code>dst</code> is null)</li></ul></dd><dd>As all bounds-checked functions, <code>mbstowcs_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></div></section>	http://en.cppreference.com/w/c/string/multibyte/mbstowcs
mbtowc	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int mbtowc( wchar_t \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*pwc, const char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*s, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n )</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code>int mbtowc( wchar_t *restrict pwc, const char *restrict s, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n )</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts a multibyte character whose first byte is pointed to by <code>s</code> to a wide character, written to <code>*pwc</code> if <code>pwc</code> is not null.</p><p>If <code>s</code> is a null pointer, resets the global conversion state and determines whether shift sequences are used.</p></section>	http://en.cppreference.com/w/c/string/multibyte/mbtowc
wcrtomb, wcrtomb_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcrtomb( char *s, wchar_t wc, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> *ps);</code></div></td><td> (1) </td><td> (since C95) </td></tr><tr><td> <div><code>errno_t wcrtomb_s(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> *restrict retval, char *restrict s, rsize_t ssz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 wchar_t wc, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> *restrict ps);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts a wide character to its narrow multibyte representation.<br></p><div>1) If <code>s</code> is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of <code>wc</code> (including any shift sequences), and stores the multibyte character representation in the character array whose first element is pointed to by <code>s</code>. At most <code>MB_CUR_MAX</code> bytes can be written by this function.</div><div> If <code>s</code> is a null pointer, the call is equivalent to <code>wcrtomb(buf, L'\x00', ps)</code> for some internal buffer <code>buf</code>.</div><div> If wc is the null wide character <code>L'\x00'</code>, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter <code>*ps</code> is updated to represent the initial shift state.</div><div>2) Same as (1), except that</div><div> if <code>s</code> is a null pointer, the call is equivalent to <code>wcrtomb_s(&amp;retval, buf, sizeof buf, L'\x00', ps)</code> with internal variables <code>retval</code> and <code>buf</code> (whose size is greater than MB_CUR_MAX)</div><div> the result is returned in the out-parameter <code>retval</code></div><div> the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>retval</code> or <code>ps</code> is a null pointer.</li><li> <code>ssz</code> is zero or greater than RSIZE_MAX (unless <code>s</code> is null)</li><li> <code>ssz</code> is less than the number of bytes that would be written (unless <code>s</code> is null)</li><li> <code>s</code> is a null pointer but <code>ssz</code> is not zero </li></ul></dd><dd>As all bounds-checked functions, <code>wcrtomb_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  s</td><td> -</td><td>  pointer to narrow character array where the multibyte character will be stored</td></tr><tr><td>  wc</td><td> -</td><td>  the wide character to convert</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the conversion state object used when interpreting the multibyte string</td></tr><tr><td>  ssz</td><td> -</td><td>  max number of bytes to write (the size of the buffer <code>s</code>)</td></tr><tr><td>  retval</td><td> -</td><td>  pointer to an out-parameter where the result (number of bytes in the multibyte string including any shift sequences) will be stored</td></tr></table><span class="prog__sub"> Return value</span><div>1) On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by <code>s</code>. </div><div> On failure (if <code>wc</code> is not a valid wide character), returns <code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-1</code>, stores <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EILSEQ</a> in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a>, and leaves <code>*ps</code> in unspecified state.</div><div>2) Returns zero on success and non-zero on failure, in which case, <code>s[0]</code> is set to <code>'\x00'</code> (unless <code>s</code> is null or <code>ssz</code> is zero or greater than RSIZE_MAX) and <code>*retval</code> is set to <code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-1</code> (unless <code>retval</code> is null)</div><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;string.h&gt;#include &lt;wchar.h&gt;#include &lt;stdlib.h&gt;\xc2\xa0void print_wide(const wchar_t* wstr){    <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> state;    <a href="http://en.cppreference.com/w/c/string/byte/memset">memset</a>(&amp;state, 0, sizeof state);    char mb[MB_CUR_MAX+1];    for(;*wstr; ++wstr) {        int ret = wcrtomb(mb, *wstr, &amp;state);        mb[ret] = '\x00';        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("multibyte char\xc2\xa0%s is\xc2\xa0%d bytes\n", mb, ret);    }}\xc2\xa0int main(){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    print_wide(L"z\xdf\u6c34\U0001f34c"); // or L"z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c"}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>multibyte char z is 1 bytes<br>multibyte char \xc3\x9f is 2 bytes<br>multibyte char \xe6\xb0\xb4 is 3 bytes<br>multibyte char \xf0\x9f\x8d\x8c is 4 bytes</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/wcrtomb
wcsrtombs, wcsrtombs_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcsrtombs( char *dst, const wchar_t **src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> len, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a>* ps )</code></div></td><td> (1) </td><td> (since C95) </td></tr><tr><td> <div><code>errno_t wcsrtombs_s( <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> *restrict retval, char *restrict dst, rsize_t dstsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t **restrict src, rsize_t len, <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> *restrict ps);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts a sequence of wide characters from the array whose first element is pointed to by <code>*src</code> to its narrow multibyte representation that begins in the conversion state described by <code>*ps</code>. If <code>dst</code> is not null, converted characters are stored in the successive elements of the char array pointed to by <code>dst</code>. No more than <code>len</code> bytes are written to the destination array.</div><div> Each character is converted as if by a call to <a href="http://en.cppreference.com/w/c/string/multibyte/wcrtomb" title="c/string/multibyte/wcrtomb">wcrtomb</a>. The conversion stops if:</div><div> * The null character <code>L'\x00'</code> was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by <code>'\x00'</code>, <code>*src</code> is set to <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> and <code>*ps</code> represents the initial shift state.</div><div> * A <code>wchar_t</code> was found that does not correspond to a valid character in the current C locale. <code>*src</code> is set to point at the first unconverted wide character.</div><div> * the next multibyte character to be stored would exceed <code>len</code>. <code>*src</code> is set to point at the first unconverted wide character. This condition is not checked if <code>dst==<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a></code>.</div><div>2) Same as (1), except that</div><div> * the function returns its result as an out-parameter <code>retval</code></div><div> * if the conversion stops without writing a null character, the function will store <code>'\x00'</code> in the next byte in <code>dst</code>, which may be <code>dst[len]</code> or <code>dst[dstsz]]</code>, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.</div><div> * the function clobbers the destination array from the terminating null and until <code>dstsz</code></div><div> * If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</div><div> * the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>retval</code>, <code>ps</code>, <code>src</code>, or <code>*src</code> is a null pointer</li><li> <code>dstsz</code> or <code>len</code> is greater than RSIZE_MAX (unless <code>dst</code> is null)</li><li> <code>dstsz</code> is not zero (unless <code>dst</code> is null)</li><li> <code>len</code> is greater than <code>dstsz</code> and the conversion does not encounter null or encoding error in the <code>src</code> array by the time <code>dstsz</code> is reached (unless <code>dst</code> is null)</li></ul></dd><dd>As with all bounds-checked functions, <code>wcsrtombs_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dst</td><td> -</td><td>  pointer to narrow character array where the multibyte characters will be stored</td></tr><tr><td>  src</td><td> -</td><td>  pointer to pointer to the first element of a null-terminated wide string</td></tr><tr><td>  len</td><td> -</td><td>  number of bytes available in the array pointed to by dst</td></tr><tr><td>  ps</td><td> -</td><td>  pointer to the conversion state object</td></tr><tr><td>  dstsz</td><td> -</td><td>  max number of bytes that will be written (size of the <code>dst</code> array)</td></tr><tr><td>  retval</td><td> -</td><td>  pointer to a size_t object where the result will be stored</td></tr></table><span class="prog__sub"> Return value</span><div>1) On success, returns the number of bytes (including any shift sequences, but excluding the terminating <code>'\x00'</code>) written to the character array whose first element is pointed to by <code>dst</code>. If <code>dst==<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a></code>, returns the number of bytes that would have been written. On conversion error (if invalid wide character was encountered), returns <code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-1</code>, stores <a href="http://en.cppreference.com/w/c/error/errno_macros" title="c/error/errno macros">EILSEQ</a> in <a href="http://en.cppreference.com/w/c/error/errno" title="c/error/errno">errno</a>, and leaves <code>*ps</code> in unspecified state.</div><div>2) Returns zero on success (in which case the number of bytes excluding terminating zero that were, or would be written to <code>dst</code>, is stored in <code>*retval</code>), non-zero on error. In case of a runtime constraint violation, stores <code>(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a>)-1</code> in <code>*retval</code> (unless <code>retval</code> is null) and sets <code>dst[0]</code> to <code>'\x00'</code> (unless <code>dst</code> is null or <code>dstmax</code> is zero or greater than RSIZE_MAX)</div><p><br/></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;locale.h&gt;#include &lt;string.h&gt;#include &lt;wchar.h&gt;\xc2\xa0void print_wide(const wchar_t* wstr){    <a href="http://en.cppreference.com/w/c/string/multibyte/mbstate_t">mbstate_t</a> state;    <a href="http://en.cppreference.com/w/c/string/byte/memset">memset</a>(&amp;state, 0, sizeof state);    int len = 1 + wcsrtombs(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, &amp;wstr, 0, &amp;state);    char mbstr[len];    wcsrtombs(mbstr, &amp;wstr, len, &amp;state);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Multibyte string:\xc2\xa0%s\n", mbstr);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Length, including '\\0':\xc2\xa0%d\n", len);}\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    print_wide(L"z\xdf\u6c34\U0001f34c"); // or L"z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c"}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Multibyte string: z\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c<br>Length, including '\x00': 11</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/wcsrtombs
wcstombs, wcstombs_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcstombs( char \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*dst, const wchar_t \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0*src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> len );</code></div></td><td> </td><td> (until C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcstombs( char *restrict dst, const wchar_t *restrict src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> len );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t wcstombs_s( <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> *restrict retval, char *restrict dst, rsize_t dstsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict src, rsize_t len );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts a sequence of wide characters from the array whose first element is pointed to by <code>src</code> to its narrow multibyte representation that begins in the initial shift state. Converted characters are stored in the successive elements of the char array pointed to by <code>dst</code>. No more than <code>len</code> bytes are written to the destination array.</div><div> Each character is converted as if by a call to <a href="http://en.cppreference.com/w/c/string/multibyte/wctomb" title="c/string/multibyte/wctomb">wctomb</a>, except that the wctomb's conversion state is unaffected. The conversion stops if:</div><div> * The null character <code>L'\x00'</code> was converted and stored. The bytes stored in this case are the unshift sequence (if necessary) followed by <code>'\x00'</code>,</div><div> * A <code>wchar_t</code> was found that does not correspond to a valid character in the current C locale.</div><div> * The next multibyte character to be stored would exceed <code>len</code>.</div><div> If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</div><div>2) Same as (1), except that</div><div> * conversion is as-if by <a href="http://en.cppreference.com/w/c/string/multibyte/wcrtomb" title="c/string/multibyte/wcrtomb">wcrtomb</a>, not <a href="http://en.cppreference.com/w/c/string/multibyte/wctomb" title="c/string/multibyte/wctomb">wctomb</a></div><div> * the function returns its result as an out-parameter <code>retval</code></div><div> * if the conversion stops without writing a null character, the function will store <code>'\x00'</code> in the next byte in <code>dst</code>, which may be <code>dst[len]</code> or <code>dst[dstsz]]</code>, whichever comes first (meaning up to len+1/dstsz+1 total bytes may be written). In this case, there may be no unshift sequence written before the terminating null.</div><div> * if <code>dst</code> is a null pointer, the number of wide characters that would be produced is stored in <code>*retval</code></div><div> * the function clobbers the destination array from the terminating null and until <code>dstsz</code></div><div> * If <code>src</code> and <code>dst</code> overlap, the behavior is unspecified.</div><div> * the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>retval</code> or <code>src</code> is a null pointer</li><li> <code>dstsz</code> or <code>len</code> is greater than RSIZE_MAX (unless <code>dst</code> is null)</li><li> <code>dstsz</code> is not zero (unless <code>dst</code> is null)</li><li> <code>len</code> is greater than <code>dstsz</code> and the conversion does not encounter null or encoding error in the <code>src</code> array by the time <code>dstsz</code> is reached (unless <code>dst</code> is null)</li></ul></dd><dd>As all bounds-checked functions, <code>wcstombs_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></div></section>	http://en.cppreference.com/w/c/string/multibyte/wcstombs
wctob	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int wctob( wint_t c );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Narrows a wide character <code>c</code> if its multibyte character equivalent in the initial shift state is a single byte.</p><p>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  c</td><td> -</td><td>  wide character to narrow</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/io" title="c/io">EOF</a> if <code>c</code> does not represent a multibyte character with length <code>1</code> in initial shift state.</p><p>otherwise, the single-byte representation of <code>c</code> as <code>unsigned char</code> converted to <code>int</code></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;locale.h&gt;#include &lt;wchar.h&gt;#include &lt;stdio.h&gt;#include &lt;assert.h&gt;\xc2\xa0void try_narrowing(wchar_t c){    int cn = wctob(c);    if(cn != <a href="http://en.cppreference.com/w/c/io">EOF</a>)        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x narrowed to\xc2\xa0%#x\n", c, cn);    else        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%#x could not be narrowed\n", c);}\xc2\xa0int main(void){    char* utf_locale_present = <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "th_TH.utf8");    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(utf_locale_present);    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("In Thai UTF-8 locale:");    try_narrowing(L'a');    try_narrowing(L'\xe0\xb9\x9b');\xc2\xa0    char* tis_locale_present = <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "th_TH.tis620");    <a href="http://en.cppreference.com/w/c/error/assert">assert</a>(tis_locale_present);    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("In Thai TIS-620 locale:");    try_narrowing(L'a');    try_narrowing(L'\xe0\xb9\x9b');}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>In Thai UTF-8 locale:<br>0x61 narrowed to 0x61<br>0xe5b could not be narrowed<br>In Thai TIS-620 locale:<br>0x61 narrowed to 0x61<br>0xe5b narrowed to 0xfb</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/multibyte/wctob
wctomb, wctomb_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int wctomb( char *s, wchar_t wc );</code></div></td><td> (1) </td><td> </td></tr><tr><td> <div><code>errno_t wctomb_s(int *restrict status, char *restrict s, rsize_t ssz, wchar_t wc);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Converts a wide character <code>wc</code> to multibyte encoding and stores it (including any shift sequences) in the char array whose first element is pointed to by <code>s</code>. No more than <code>MB_CUR_MAX</code> characters are stored.</div><div> If <code>wc</code> is the null character, the null byte is written to <code>s</code>, preceded by any shift sequences necessary to restore the initial shift state.</div><div> If <code>s</code> is a null pointer, this function resets the global conversion state and determines whether shift sequences are used.</div><div>2) Same as (1), except that the result is returned in the out-parameter <code>status</code> and the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>ssz</code> is less than the number of bytes that would be written (unless <code>s</code> is null)</li><li> <code>ssz</code> is greater than RSIZE_MAX (unless <code>s</code> is null)</li><li> <code>s</code> is a null pointer but <code>ssz</code> is not zero </li></ul></dd><dd>As all bounds-checked functions, <code>wctomb_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>stdlib.h</code>.</dd></dl></div></section>	http://en.cppreference.com/w/c/string/multibyte/wctomb
iswalnum	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswalnum( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is an alphanumeric character, i.e. either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>) or any alphanumeric character specific to the current locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is a alphanumeric character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u13ad'; // the Cherokee letter HA ('\xe1\x8e\xad')    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswalnum(%#x) =\xc2\xa0%d\n", c, !!iswalnum(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswalnum(%#x) =\xc2\xa0%d\n", c, !!iswalnum(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswalnum(0x13ad) = 0<br>in Unicode locale, iswalnum(0x13ad) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswalnum
iswalpha	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswalpha( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>) or any alphabetic character specific to the current locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is a alphabetic character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u0b83'; // Tamil sign Visarga ('\xe0\xae\x83')    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswalpha(%#x) =\xc2\xa0%d\n", c, !!iswalpha(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswalpha(%#x) =\xc2\xa0%d\n", c, !!iswalpha(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswalpha(0xb83) = 0<br>in Unicode locale, iswalpha(0xb83) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswalpha
iswblank	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswblank( wint_t ch );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (<code>0x20</code>) and horizontal tab (<code>0x09</code>) are blank characters.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is a blank character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u3000'; // Ideographic space ('\xe3\x80\x80')    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswblank(%#x) =\xc2\xa0%d\n", c, !!iswblank(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswblank(%#x) =\xc2\xa0%d\n", c, !!iswblank(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswblank(0x3000) = 0<br>in Unicode locale, iswblank(0x3000) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswblank
iswcntrl	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswcntrl( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is a control character, i.e. codes <code>0x00-0x1F</code> and <code>0x7F</code> and any control characters specific to the current locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is a control character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u2028'; // the Unicode character "line separator"    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswcntrl(%#x) =\xc2\xa0%d\n", c, !!iswcntrl(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswcntrl(%#x) =\xc2\xa0%d\n", c, !!iswcntrl(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswcntrl(0x2028) = 0<br>in Unicode locale, iswcntrl(0x2028) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswcntrl
iswctype	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswctype( wint_t wc, wctype_t desc );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Classifies the wide character <code>wc</code> using the current C locale's LC_CTYPE category identified by <code>desc</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  wc</td><td> -</td><td>  the wide character to classify</td></tr><tr><td>  desc</td><td> -</td><td>  the LC_CTYPE category, obtained from a call to <a href="http://en.cppreference.com/w/c/string/wide/wctype" title="c/string/wide/wctype">wctype</a></td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero if the character <code>wc</code> has the property identified by <code>desc</code> in LC_CTYPE facet of the current C locale, zero otherwise.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;locale.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;stdio.h&gt;const char* classify(wchar_t wc, const char* cat){    return iswctype(wc, <a href="http://en.cppreference.com/w/c/string/wide/wctype">wctype</a>(cat)) ? "true" : "false";}int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "ja_JP.UTF-8");    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("The character \u6c34 is...");    const char* cats[] = {"digit", "alpha", "space", "cntrl", "jkanji"};    for(int n = 0; n &lt; 5; ++n)        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%s?\xc2\xa0%s\n", cats[n], classify(L'\u6c34', cats[n]));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>The character \xe6\xb0\xb4 is...<br>digit? false<br>alpha? true<br>space? false<br>cntrl? false<br>jkanji? true</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswctype
iswdigit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswdigit( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is an numeric character, zero otherwise.<br></p></section>	http://en.cppreference.com/w/c/string/wide/iswdigit
iswgraph	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswgraph( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character has a graphical representation, i.e. it is either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>), a punctuation character(<code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</code>) or any graphical character specific to the current C locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character has a graphical representation character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u2602'; // the Unicode character Umbrella ('\xe2\x98\x82')    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswgraph(%#x) =\xc2\xa0%d\n", c, !!iswgraph(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswgraph(%#x) =\xc2\xa0%d\n", c, !!iswgraph(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswgraph(0x2602) = 0<br>in Unicode locale, iswgraph(0x2602) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswgraph
iswlower	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswlower( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is a lowercase letter, i.e. one of <code>abcdefghijklmnopqrstuvwxyz</code> or any lowercase letter specific to the current locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is an lowercase letter, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u0444'; // Cyrillic small letter ef ('\xd1\x84')    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswlower(%#x) =\xc2\xa0%d\n", c, !!iswlower(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswlower(%#x) =\xc2\xa0%d\n", c, !!iswlower(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswlower(0x444) = 0<br>in Unicode locale, iswlower(0x444) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswlower
iswprint	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswprint( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character can be printed, i.e. it is either a number (<code>0123456789</code>), an uppercase letter (<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>), a lowercase letter (<code>abcdefghijklmnopqrstuvwxyz</code>), a punctuation character(<code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</code>), space or any printable character specific to the current C locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character can be printed, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u2002'; // Unicode character 'EN SPACE'    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswprint(%#x) =\xc2\xa0%d\n", c, !!iswprint(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswprint(%#x) =\xc2\xa0%d\n", c, !!iswprint(c));    wchar_t c2 = L'\x82'; // break permitted    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswprint(%#x) =\xc2\xa0%d\n", c2, !!iswprint(c2));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswprint(0x2002) = 0<br>in Unicode locale, iswprint(0x2002) = 1<br>in Unicode locale, iswprint(0x82) = 0</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswprint
iswpunct	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswpunct( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is a punctuation character, i.e. it is one of <code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~</code> or any punctuation character specific to the current locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is a punctuation character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u2051'; // Two asterisks ('\xe2\x81\x91')    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswpunct(%#x) =\xc2\xa0%d\n", c, !!iswpunct(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswpunct(%#x) =\xc2\xa0%d\n", c, !!iswpunct(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswpunct(0x2051) = 0<br>in Unicode locale, iswpunct(0x2051) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswpunct
iswspace	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswspace( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is a whitespace character, i.e. either space (<code>0x20</code>), form feed (<code>0x0c</code>), line feed (<code>0x0a</code>), carriage return (<code>0x0d</code>), horizontal tab (<code>0x09</code>), vertical tab (<code>0x0b</code>) or any whitespace character specific to the current locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is a whitespace character, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u2003'; // Unicode character 'EM SPACE'    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswspace(%#x) =\xc2\xa0%d\n", c, !!iswspace(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswspace(%#x) =\xc2\xa0%d\n", c, !!iswspace(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswspace(0x2003) = 0<br>in Unicode locale, iswspace(0x2003) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswspace
iswupper	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswupper( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character is an uppercase letter, i.e. one of <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> or any uppercase letter specific to the current locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is an uppercase letter, zero otherwise.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;wctype.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t c = L'\u053d'; // Armenian capital letter xeh ('\xd4\xbd')    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in the default locale, iswupper(%#x) =\xc2\xa0%d\n", c, !!iswupper(c));    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("in Unicode locale, iswupper(%#x) =\xc2\xa0%d\n", c, !!iswupper(c));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>in the default locale, iswupper(0x53d) = 0<br>in Unicode locale, iswupper(0x53d) = 1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/iswupper
iswxdigit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int iswxdigit( wint_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of <code>0123456789abcdefABCDEF</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ch</td><td> -</td><td>  wide character</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if the wide character is a hexadecimal numeric character, zero otherwise.<br></p></section>	http://en.cppreference.com/w/c/string/wide/iswxdigit
towctrans	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wint_t towctrans( wint_t wc, wctrans_t desc );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Maps the wide character <code>wc</code> using the current C locale's LC_CTYPE mapping category identified by <code>desc</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  wc</td><td> -</td><td>  the wide character to map</td></tr><tr><td>  desc</td><td> -</td><td>  the LC_CTYPE mapping, obtained from a call to <a href="http://en.cppreference.com/w/c/string/wide/wctrans" title="c/string/wide/wctrans">wctrans</a></td></tr></table><span class="prog__sub"> Return value</span><p>The mapped value of <code>wc</code> using the mapping identified by <code>desc</code> in LC_CTYPE facet of the current C locale.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;locale.h&gt;#include &lt;wctype.h&gt;#include &lt;wchar.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "ja_JP.UTF-8");    wchar_t kana[] = L"\xe3\x83\x92\xe3\x83\xa9\xe3\x82\xac\xe3\x83\x8a";    <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> sz = sizeof kana / sizeof *kana;    wchar_t hira[sz];    for(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n = 0; n &lt; sz; ++n)        hira[n] = towctrans(kana[n], <a href="http://en.cppreference.com/w/c/string/wide/wctrans">wctrans</a>("tojhira"));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("katakana characters\xc2\xa0%ls are\xc2\xa0%ls in hiragana\n", kana, hira);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>katakana characters \xe3\x83\x92\xe3\x83\xa9\xe3\x82\xac\xe3\x83\x8a are \xe3\x81\xb2\xe3\x82\x89\xe3\x81\x8c\xe3\x81\xaa in hiragana</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/towctrans
towlower	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wint_t towlower( wint_t wc );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts the given wide character to lowercase, if possible.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  wc</td><td> -</td><td>  wide character to be converted</td></tr></table><span class="prog__sub"> Return value</span><p>Lowercase version of <code>wc</code> or unmodified <code>wc</code> if no lowercase version is listed in the current C locale.</p></section>	http://en.cppreference.com/w/c/string/wide/towlower
towupper	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wint_t towupper( wint_t wc );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Converts the given wide character to uppercase, if possible.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  wc</td><td> -</td><td>  wide character to be converted</td></tr></table><span class="prog__sub"> Return value</span><p>Uppercase version of <code>wc</code> or unmodified <code>wc</code> if no uppercase version is listed in the current C locale.</p></section>	http://en.cppreference.com/w/c/string/wide/towupper
wcscat, wcscat_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>wchar_t *wcscat( wchar_t *dest, const wchar_t *src );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>wchar_t *wcscat(wchar_t *restrict dest, const wchar_t *restrict src);</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t wcscat_s(wchar_t *restrict dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict src);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Appends a copy of the wide string pointed to by <code>src</code> to the end of the wide string pointed to by <code>dest</code>. The wide character <code>src[0]</code> replaces the null terminator at the end of <code>dest</code>. The resulting wide string is null-terminated. The behavior is undefined if the destination array is not large enough for the contents of both <code>str</code> and <code>dest</code> and the terminating null wide character. The behavior is undefined if the strings overlap. </div><div>2) Same as (1), except that it may clobber the rest of the destination array (from the last character written to <code>destsz</code>) with unspecified values and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> there is no null terminator in the first <code>destsz</code> bytes of <code>dest</code></li><li> truncation would occur (the available space at the end of <code>dest</code> would not fit every wide character, including the null terminator, of <code>src</code>)</li><li> overlap would occur between the source and the destination strings</li></ul></dd><dd>As all bounds-checked functions, <code>wcscat_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to append to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string to copy from</td></tr><tr><td>  destsz</td><td> -</td><td>  maximum number of characters to write, typically the size of the destination buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, writes <code>L'\x00'</code> to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RMAX_SIZE/sizeof(wchar_t)</code>).</div><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;wchar.h&gt; #include &lt;stdio.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void) {    wchar_t str[50] = L"\xd0\x97\xd0\xb5\xd0\xbc\xd0\xbb\xd1\x8f, \xd0\xbf\xd1\x80\xd0\xbe\xd1\x89\xd0\xb0\xd0\xb9.";    wcscat(str, L" ");    wcscat(str, L"\xd0\x92 \xd0\xb4\xd0\xbe\xd0\xb1\xd1\x80\xd1\x8b\xd0\xb9 \xd0\xbf\xd1\x83\xd1\x82\xd1\x8c.");    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ls", str);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>\xd0\x97\xd0\xb5\xd0\xbc\xd0\xbb\xd1\x8f, \xd0\xbf\xd1\x80\xd0\xbe\xd1\x89\xd0\xb0\xd0\xb9. \xd0\x92 \xd0\xb4\xd0\xbe\xd0\xb1\xd1\x80\xd1\x8b\xd0\xb9 \xd0\xbf\xd1\x83\xd1\x82\xd1\x8c.</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/wcscat
wcschr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wchar_t* wcschr( const wchar_t* str, wchar_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of the wide character <code>ch</code> in the wide string pointed to by <code>str</code>. </p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr><td>  ch</td><td> -</td><td>  wide character to search for</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the found character in <code>str</code>, or <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> if no such character is found.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;wchar.h&gt;#include &lt;stdio.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t arr[] = L"\xe6\x8b\x9b\xe3\x81\x8d\xe7\x8c\xab \xd0\xba\xd0\xbe\xd1\x88\xd0\xba\xd0\xb0";    wchar_t *cat = wcschr(arr, L'\xe7\x8c\xab');    wchar_t *dog = wcschr(arr, L'\xe7\x8a\xac');\xc2\xa0    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    if(cat)        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The character \xe7\x8c\xab found at position\xc2\xa0%td\n", cat-arr);    else        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("The character \xe7\x8c\xab not found");\xc2\xa0    if(dog)        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("The character \xe7\x8a\xac found at position\xc2\xa0%td\n", dog-arr);    else        <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("The character \xe7\x8a\xac not found");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>The character \xe7\x8c\xab found at position 2<br>The character \xe7\x8a\xac not found</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/wcschr
wcscmp	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int wcscmp( const wchar_t *lhs, const wchar_t *rhs );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Compares two null-terminated wide strings lexicographically.<br></p><p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.<br></p><p>The behavior is undefined if <code>lhs</code> or <code>rhs</code> are not pointers to null-terminated wide strings.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated wide strings to compare</td></tr></table><span class="prog__sub"> Return value</span><p>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p></section>	http://en.cppreference.com/w/c/string/wide/wcscmp
wcscoll	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int wcscoll( const wchar_t *lhs, const wchar_t *rhs );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Compares two null-terminated wide strings according to the collation order defined by the <a href="http://en.cppreference.com/w/c/locale/LC_categories" title="c/locale/LC categories">LC_COLLATE</a> category of the currently installed locale.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated wide strings to compare</td></tr></table><span class="prog__sub"> Return value</span><p>Negative value if <code>lhs</code> is <i>less than</i> (precedes) <code>rhs</code>.</p><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if <code>lhs</code> is <i>equal to</i> <code>rhs</code>.</p><p>Positive value if <code>lhs</code> is <i>greater than</i> (follows) <code>rhs</code>.</p></section>	http://en.cppreference.com/w/c/string/wide/wcscoll
wcscpy, wcscpy_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>wchar_t *wcscpy( wchar_t *dest, const wchar_t *src );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>wchar_t *wcscpy( wchar_t *restrict dest, const wchar_t *restrict src );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t wcscpy_s( wchar_t *restrict dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict src );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies the wide string pointed to by <code>src</code> (including the terminating null wide character) to wide character array pointed to by <code>dest</code>. The behavior is undefined if the <code>dest</code> array is not large enough. The behavior is undefined if the strings overlap.</div><div>2) Same as (1), except that it may clobber the rest of the destination array with unspecified values and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> is zero or greater than <code>RSIZE_MAX / sizeof(wchar_t)</code></li><li> <code>destsz</code> is less or equal <code>wcsnlen_s(src, destsz)</code>, in other words, truncation would occur</li><li> overlap would occur between the source and the destination strings</li></ul></dd><dd>As with all bounds-checked functions, <code>wcscpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the wide character array to copy to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string to copy from</td></tr><tr><td>  destsz</td><td> -</td><td>  maximum number of characters to write, typically the size of the destination buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, writes <code>L'\x00'</code> to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RMAX_SIZE / sizeof(wchar_t)</code>).</div><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;wchar.h&gt;#include &lt;stdio.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t *src = L"\xe7\x8a\xac means dog";//  src[0] = L'\xe7\x8b\x97'\xc2\xa0; // this would be undefined behavior    wchar_t dst[<a href="http://en.cppreference.com/w/c/string/wide/wcslen">wcslen</a>(src) + 1]; // +1 to accommodate for the null terminator    wcscpy(dst, src);    dst[0] = L'\xe7\x8b\x97'; // OK\xc2\xa0    <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("src =\xc2\xa0%ls\ndst =\xc2\xa0%ls\n", src, dst);}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>src = \xe7\x8a\xac means dog<br>dst = \xe7\x8b\x97 means dog</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/wcscpy
wcscspn	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcscspn( const wchar_t* dest, const wchar_t* src );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the length of the maximum initial segment of the wide string pointed to by <code>dest</code>, that consists of only the characters <i>not</i> found in wide string pointed to by <code>src</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string that contains the characters to search for</td></tr></table><span class="prog__sub"> Return value</span><p>The length of the maximum initial segment that contains only characters not found in the character string pointed to by <code>src</code></p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/string/wide/wcscspn
wcslen, wcsnlen_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcslen( const wchar_t *str );</code></div></td><td> (1) </td><td> (since C95) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcsnlen_s(const wchar_t *str, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> strsz);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.</div><div>2) Same as (1), except that the function returns zero if <code>str</code> is a null pointer and returns <code>strsz</code> if the null wide character was not found in the first <code>strsz</code> wide characters of <code>src</code><dl><dd>As all bounds-checked functions, <code>wcsnlen_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td> str</td><td> -</td><td>  pointer to the null-terminated wide string to be examined</td></tr><tr><td> strsz</td><td> -</td><td>  maximum number of wide characters to examine</td></tr></table><span class="prog__sub"> Return value</span><div>1) The length of the null-terminated wide string <code>str</code>.</div><div>2) The length of the null-terminated wide string <code>str</code> on success, zero if <code>str</code> is a null  pointer, <code>strsz</code> if the null wide character was not found.</div></section>	http://en.cppreference.com/w/c/string/wide/wcslen
wcsncat, wcsncat_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>wchar_t *wcsncat( wchar_t *dest, const wchar_t *src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>wchar_t *wcsncat( wchar_t *restrict dest,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *restrict src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t wcsncat_s( wchar_t *restrict dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict src, rsize_t count );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Appends at most <code>count</code> wide characters from the wide string pointed to by <code>src</code>, stopping if the null terminator is copied, to the end of the character string pointed to by <code>dest</code>. The wide character <code>src[0]</code> replaces the null terminator at the end of <code>dest</code>. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is <code>count+1</code>).</div><div> The behavior is undefined if the destination array is not large enough for the contents of both <code>str</code> and <code>dest</code> and the terminating null wide character.</div><div> The behavior is undefined if the strings overlap. </div><div>2) Same as (1), except that this function may clobber the remainder of the destination array (from the last byte written to <code>destsz</code>) and that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> there is no null wide character in the first <code>destsz</code> bytes of <code>dest</code></li><li> truncation would occur: <code>count</code> or the length of <code>src</code>, whichever is less, exceeds the space available between the null terminator of <code>dest</code> and <code>destsz</code>.</li><li> overlap would occur between the source and the destination strings</li></ul></dd><dd>As all bounds-checked functions, <code>wcsncat_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to append to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string to copy from</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of wide characters to copy</td></tr><tr><td>  destsz</td><td> -</td><td>  the size of the destination buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, writes <code>L'\x00'</code> to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RMAX_SIZE/sizeof(wchar_t)</code>).</div></section>	http://en.cppreference.com/w/c/string/wide/wcsncat
wcsncmp	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int wcsncmp( const wchar_t* lhs, const wchar_t* rhs, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Compares at most <code>count</code> wide characters of two null-terminated wide strings. The comparison is done lexicographically.</p><p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.<br></p><p>The behavior is undefined if <code>lhs</code> or <code>rhs</code> are not pointers to null-terminated strings.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  pointers to the null-terminated wide strings to compare</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of characters to compare</td></tr></table><span class="prog__sub"> Return value</span><p>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order.</p><p>Zero if <code>lhs</code> and <code>rhs</code> compare equal.</p><p>Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order.</p></section>	http://en.cppreference.com/w/c/string/wide/wcsncmp
wcsncpy, wcsncpy_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>wchar_t* wcsncpy( wchar_t* dest, const wchar_t* src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>wchar_t *wcsncpy(wchar_t *restrict dest, const wchar_t *restrict src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n);</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t wcsncpy_s( wchar_t *restrict dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict src, rsize_t n);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies at most <code>count</code> characters of the wide string pointed to by <code>src</code> (including the terminating null wide character) to wide character array pointed to by <code>dest</code>. </div><div> If <code>count</code> is reached before the entire string <code>src</code> was copied, the resulting wide character array is not null-terminated.</div><div> If, after copying the terminating null wide character from <code>src</code>, <code>count</code> is not reached, additional null wide characters are written to <code>dest</code> until the total of <code>count</code> characters have been written.</div><div> If the strings overlap, the behavior is undefined.</div><div>2) Same as (1), except that the function does not continue writing zeroes into the destination array to pad up to <code>count</code>, it stops after writing the terminating null character (if there was no null in the source, it writes one at <code>dest[count]</code> and then stops). Also, the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> <code>count</code> is greater or equal <code>destsz</code>, but <code>destsz</code> is less or equal <code>wcsnlen_s(src, count)</code>, in other words, truncation would occur</li><li> overlap would occur between the source and the destination strings</li></ul></dd><dd>As all bounds-checked functions, <code>wcsncpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the wide character array to copy to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the wide string to copy from</td></tr><tr><td>  count</td><td> -</td><td>  maximum number of wide characters to copy</td></tr><tr><td>  destsz</td><td> -</td><td>  the size of the destination buffer</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, writes <code>L'\x00'</code> to <code>dest[0]</code> (unless <code>dest</code> is a null pointer or <code>destsz</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>) and may clobber the rest of the destination array with unspecified values.</div></section>	http://en.cppreference.com/w/c/string/wide/wcsncpy
wcspbrk	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wchar_t* wcspbrk( const wchar_t* dest, const wchar_t* str );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Finds the first character in wide string pointed to by <code>dest</code>, that is also in wide string pointed to by <code>str</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string that contains the characters to search for</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the first character in <code>dest</code>, that is also in <code>str</code>, or <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> if no such character exists.</p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/string/wide/wcspbrk
wcsrchr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wchar_t* wcsrchr( const wchar_t* str, wchar_t ch );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Finds the last occurrence of the wide character <code>ch</code> in the wide string pointed to by <code>str</code>. </p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr><td>  ch</td><td> -</td><td>  wide character to search for</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the found character in <code>str</code>, or <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> if no such character is found.</p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/string/wide/wcsrchr
wcsspn	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcsspn( const wchar_t* dest, const wchar_t* src );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the length of the maximum initial segment of the wide string pointed to by <code>dest</code>, that consists of only the characters found in wide string pointed to by <code>src</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to be analyzed</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string that contains the characters to search for</td></tr></table><span class="prog__sub"> Return value</span><p>The length of the maximum initial segment that contains only characters from wide string pointed to by <code>src</code></p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/string/wide/wcsspn
wcsstr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wchar_t* wcsstr( const wchar_t* dest, const wchar_t* src );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Finds the first occurrence of the wide string <code>src</code> in the wide string pointed to by <code>dest</code>. The terminating null characters are not compared.</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the null-terminated wide string to examine</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the null-terminated wide string to search for</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the first character of the found substring in <code>dest</code>, or <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> if no such substring is found. If <code>src</code> points to an empty string, <code>dest</code> is returned.</p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: no example </td></tr></table></section>	http://en.cppreference.com/w/c/string/wide/wcsstr
wcstof, wcstod, wcstold	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>float \xc2\xa0 \xc2\xa0 \xc2\xa0 wcstof( const wchar_t* str, wchar_t** str_end );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code>double \xc2\xa0 \xc2\xa0 \xc2\xa0wcstod( const wchar_t* str, wchar_t** str_end );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td> <div><code>long double wcstold( const wchar_t* str, wchar_t** str_end );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets a floating point value in a wide string pointed to by <code>str</code>.</p><p>Function discards any whitespace characters (as determined by <code>std::<a href="http://en.cppreference.com/w/c/string/byte/isspace">isspace</a>()</code>) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</p><ul><li>decimal floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> nonempty sequence of decimal digits optionally containing decimal-point character (as determined by the current C locale) (defines significand)</li><li> (optional) <code>e</code> or <code>E</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li>binary floating-point expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>0x</code> or <code>0X</code></li><li> nonempty sequence of hexadecimal digits optionally containing a decimal-point character (as determined by the current C locale) (defines significand)</li><li> (optional) <code>p</code> or <code>P</code> followed with optional minus or plus sign and nonempty sequence of decimal digits (defines exponent)</li></ul></dd></dl><ul><li> infinity expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>INF</code> or <code>INFINITY</code> ignoring case</li></ul></dd></dl><ul><li> not-a-number expression. It consists of the following parts:</li></ul><dl><dd><ul><li> (optional) plus or minus sign</li><li> <code>NAN</code> or <code>NAN(</code><i>char_sequence</i><code>)</code> ignoring case of the <code>NAN</code> part. <i>char_sequence</i> can only contain alphanumeric characters. The result is a quiet NaN floating-point value.</li></ul></dd></dl><ul><li> any other expression that may be accepted by the currently installed C locale</li></ul><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the wide character past the last character interpreted. If <code>str_end</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, it is ignored.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be interpreted</td></tr><tr><td>  str_end</td><td> -</td><td>  pointer to a pointer to a wide character.</td></tr></table><span class="prog__sub"> Return value</span><p>Floating point value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <a href="http://en.cppreference.com/w/c/numeric/math/HUGE_VAL" title="c/numeric/math/HUGE VAL">HUGE_VAL</a>, <a href="http://en.cppreference.com/w/c/numeric/math/HUGE_VAL" title="c/numeric/math/HUGE VAL">HUGE_VALF</a> or <a href="http://en.cppreference.com/w/c/numeric/math/HUGE_VAL" title="c/numeric/math/HUGE VAL">HUGE_VALL</a> is returned. If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;wchar.h&gt;\xc2\xa0int main(void){    const wchar_t *p = L"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz";    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing L"%ls":\n", p);    wchar_t *end;    for (double f = wcstod(p, &amp;end); p != end; f = wcstod(p, &amp;end))    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("'%.*ls' -&gt; ", (int)(end-p), p);        p = end;        if (errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>){            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("range error, got ");            errno = 0;        }        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f\n", f);    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Parsing L"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz":<br>'111.11' -&gt; 111.110000<br>' -2.22' -&gt; -2.220000<br>' 0X1.BC70A3D70A3D7P+6' -&gt; 111.110000<br>'  1.18973e+4932' -&gt; range error, got inf</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/wcstof
wcstoimax, wcstoumax	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;inttypes.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/integer">intmax_t</a> wcstoimax( const wchar_t *restrict nptr, <br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 wchar_t **restrict endptr, int base );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/integer">uintmax_t</a> wcstoumax( const wchar_t *restrict nptr,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0wchar_t **restrict endptr, int base );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets an unsigned integer value in a wide string pointed to by <code>nptr</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base) unsigned integer number representation and converts them to an  integer value. The valid unsigned  integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <a href="http://en.cppreference.com/w/c/locale/setlocale" title="c/locale/setlocale">locale</a>.</p><p>If the value of base is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Unary_arithmetic" title="c/language/operator arithmetic">unary minus</a> in the result type, which applies unsigned integer wraparound rules.</p><p>The functions sets the pointer pointed to by <code>endptr</code> to point to the wide character past the last character interpreted. If <code>endptr</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, it is ignored.</p><span class="prog__sub"> Parameters</span><table><tr><td>  nptr</td><td> -</td><td>  pointer to the null-terminated wide string to be interpreted</td></tr><tr><td>  endptr</td><td> -</td><td>  pointer to a pointer to a wide character.</td></tr><tr><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><span class="prog__sub"> Return value</span><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">INTMAX_MAX</a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">INTMAX_MIN</a>, <a href="http://en.cppreference.com/w/c/types/integer" title="c/types/integer">UINTMAX_MAX</a>, or <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned, as appropriate. If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</p><span class="prog__sub"> Example</span><table><tr><td></td><td>This section is incomplete<br/>Reason: example </td></tr></table></section>	http://en.cppreference.com/w/c/string/wide/wcstoimax
wcstok, wcstok_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>wchar_t* wcstok( wchar_t* str, const wchar_t* delim, wchar_t **ptr );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>wchar_t *wcstok(wchar_t * restrict str, const wchar_t * restrict delim,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 wchar_t **restrict ptr);</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>wchar_t *wcstok_s( wchar_t *restrict str, rsize_t *restrict strmax,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict delim, wchar_t **restrict ptr);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Finds the next token in a null-terminated wide string pointed to by <code>str</code>. The separator characters are identified by null-terminated wide string pointed to by <code>delim</code>.</div><div> This function is designed to be called multiples times to obtain successive tokens from the same string.</div><dl><dd><ul><li> If <code>str != <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a></code>, the call is treated as the first call to <code>wcstok</code> for this particular wide string. The function searches for the first wide character which is <i>not</i> contained in <code>delim</code>.</li></ul><dl><dd><ul><li> If no such wide character was found, there are no tokens in <code>str</code> at all, and the function returns a null pointer. </li><li> If such wide character was found, it is the <i>beginning of the token</i>. The function then searches from that point on for the first wide character that <i>is</i> contained in <code>delim</code>. </li></ul><dl><dd><ul><li> If no such wide character was found, <code>str</code> has only one token, and future calls to <code>wcstok</code> will return a null pointer</li><li> If such wide character was found, it is <i>replaced</i> by the null wide character <code>L'\x00'</code> and the parser state (typically a pointer to the following wide character) is stored in the user-provided location <code>*ptr</code>.</li></ul></dd></dl><ul><li> The function then returns the pointer to the beginning of the token</li></ul></dd></dl><ul><li> If <code>str == <a href="http://en.cppreference.com/w/c/types/NULL">NULL</a></code>, the call is treated as a subsequent call to <code>wcstok</code>: the function continues from where it left in the previous invocation with the same <code>*ptr</code>. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as <code>str</code>.</li></ul></dd></dl><div>2) Same as (1), except that on every step, writes the number of characters left to see in <code>str</code> into <code>*strmax</code>. Repeat calls (with null <code>str</code>) must pass both <code>strmax</code> and <code>ptr</code> with the values stored by the previous call. Also, the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function, without storing anything in the object pointed to by <code>ptr</code><dl><dd><ul><li> <code>strmax</code>, <code>delim</code>, or <code>ptr</code> is a null pointer</li><li> on a non-initial call (with null <code>str</code>), <code>*ptr</code> is a null pointer</li><li> on the first call, <code>*strmax</code> is zero or greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> search for the end of a token reaches the end of the source string (as measured by the initial value of <code>*strmax</code>)) without encountering the null terminator</li></ul></dd><dd>As all bounds-checked functions, <code>wcstok_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to tokenize</td></tr><tr><td>  delim</td><td> -</td><td>  pointer to the null-terminated wide string identifying delimiters</td></tr><tr><td>  ptr</td><td> -</td><td>  pointer to an object of type <code>wchar_t*</code>, which is used by both <code>wcstok</code> and <code>wcstok_s</code> to store the internal state of the parser</td></tr><tr><td>  strmax</td><td> -</td><td>  pointer to an object which initially holds the size of <code>str</code>: wcstok_s stores the number of characters that remain to be examined</td></tr></table><span class="prog__sub"> Return value</span><p>Returns pointer to the beginning of the next token or null pointer if there are no more tokens.<br></p><span class="prog__sub"> Note</span><p>This function is destructive: it writes the <code>L'\x00'</code> characters in the elements of the string <code>str</code>. In particular, a wide string literal cannot be used as the first argument of <code>wcstok</code>.</p><p>Unlike <a href="http://en.cppreference.com/w/c/string/byte/strtok" title="c/string/byte/strtok">strtok</a>, <code>wcstok</code> does not update static storage: it stores the parser state in the user-provided location.</p><p>Unlike most other tokenizers, the delimiters in <code>wcstok</code> can be different for each subsequent token, and can even depend on the contents of the previous tokens.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;wchar.h&gt;#include &lt;stdio.h&gt;\xc2\xa0int main(void){    wchar_t input[] = L"A bird came down the walk";    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing the input string '%ls'\n", input);    wchar_t *buffer;    wchar_t *token = wcstok(input, L" ", &amp;buffer);    while(token) {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ls\n", token);        token = wcstok(<a href="http://en.cppreference.com/w/c/types/NULL">NULL</a>, L" ", &amp;buffer);    }\xc2\xa0    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Contents of the input string now: '");    for(<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> n = 0; n &lt; sizeof input / sizeof *input; ++n)        input[n] ? <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%lc", input[n]) : <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("\\0");    <a href="http://en.cppreference.com/w/c/io/puts">puts</a>("'");}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Parsing the input string 'A bird came down the walk'<br>A<br>bird<br>came<br>down<br>the<br>walk<br>Contents of the input string now: 'A\x00bird\x00came\x00down\x00the\x00walk\x00'</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/wcstok
wcstol, wcstoll	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;cwchar&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>long \xc2\xa0 \xc2\xa0 \xc2\xa0wcstol( const wchar_t* str, wchar_t** str_end, int base );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td> <div><code>long long wcstoll( const wchar_t* str, wchar_t** str_end, int base );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets an integer value in a wide string pointed to by <code>str</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base)  integer number representation and converts them to an  integer value. The valid   integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <a href="http://en.cppreference.com/w/c/locale/setlocale" title="c/locale/setlocale">locale</a>.</p><p>If the value of base is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Unary_arithmetic" title="c/language/operator arithmetic">unary minus</a> in the result type.</p><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the wide character past the last character interpreted. If <code>str_end</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, it is ignored.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be interpreted</td></tr><tr><td>  str_end</td><td> -</td><td>  pointer to a pointer to wide character</td></tr><tr><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><span class="prog__sub"> Return value</span><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">LONG_MAX</a>, <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">LONG_MIN</a>, <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">LLONG_MAX</a> or <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">LLONG_MIN</a> is returned. If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;wchar.h&gt;\xc2\xa0int main(void){    const wchar_t *p = L"10 200000000000000000000000000000 30 -40";    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing L'%ls':\n", p);    wchar_t *end;    for (long i = wcstol(p, &amp;end, 10);         p != end;         i = wcstol(p, &amp;end, 10))    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("'%.*ls' -&gt; ", (int)(end-p), p);        p = end;        if (errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>){            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("range error, got ");            errno = 0;        }        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%ld\n", i);    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Parsing L'10 200000000000000000000000000000 30 -40':<br>'10' -&gt; 10<br>' 200000000000000000000000000000' -&gt; range error, got 9223372036854775807<br>' 30' -&gt; 30<br>' -40' -&gt; -40</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/wcstol
wcstoul, wcstoull	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>unsigned long \xc2\xa0 \xc2\xa0 \xc2\xa0wcstoul( const wchar_t* str, wchar_t** str_end, int base );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td> <div><code>unsigned long long wcstoull( const wchar_t* str, wchar_t** str_end, int base );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Interprets an unsigned integer value in a wide string pointed to by <code>str</code>.</p><p>Discards any whitespace characters (as identified by calling <code>isspace()</code>) until the first non-whitespace character is found, then takes as many characters as possible to form a valid <i>base-n</i> (where n=base) unsigned integer number representation and converts them to an  integer value. The valid unsigned  integer value consists of the following parts:</p><ul><li> (optional) plus or minus sign</li><li> (optional) prefix (<code>0</code>) indicating octal base (applies only when the base is <code>8</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> (optional) prefix (<code>0x</code> or <code>0X</code>) indicating hexadecimal base (applies only when the base is <code>16</code> or <code>\xe2\x80\x8b0\xe2\x80\x8b</code>)</li><li> a sequence of digits</li></ul><p>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is <code>{0,1</code>}, for base-3 integers is <code>{0,1,2</code>}, and so on. For bases larger than <code>10</code>, valid digits include alphabetic characters, starting from <code>Aa</code> for base-11 integer, to <code>Zz</code> for base-36 integer. The case of the characters is ignored.</p><p>Additional numeric formats may be accepted by the currently installed C <a href="http://en.cppreference.com/w/c/locale/setlocale" title="c/locale/setlocale">locale</a>.</p><p>If the value of base is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, the numeric base is auto-detected: if the prefix is <code>0</code>, the base is octal, if the prefix is <code>0x</code> or <code>0X</code>, the base is hexadecimal, otherwise the base is decimal.</p><p>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Unary_arithmetic" title="c/language/operator arithmetic">unary minus</a> in the result type, which applies unsigned integer wraparound rules.</p><p>The functions sets the pointer pointed to by <code>str_end</code> to point to the wide character past the last character interpreted. If <code>str_end</code> is <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, it is ignored.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  pointer to the null-terminated wide string to be interpreted</td></tr><tr><td>  str_end</td><td> -</td><td>  pointer to a pointer to a wide character.</td></tr><tr><td>  base</td><td> -</td><td> <i>base</i> of the interpreted integer value</td></tr></table><span class="prog__sub"> Return value</span><p>Integer value corresponding to the contents of <code>str</code> on success. If the converted value falls out of range of corresponding return type, range error occurs and <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">ULONG_MAX</a> or <a href="http://en.cppreference.com/w/c/types/limits" title="c/types/limits">ULLONG_MAX</a> is returned. If no conversion can be performed, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> is returned.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;wchar.h&gt;\xc2\xa0int main(void){    const wchar_t *p = L"10 200000000000000000000000000000 30 40";    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Parsing L'%ls':\n", p);    wchar_t *end;    for (unsigned long i = wcstoul(p, &amp;end, 10);         p != end;         i = wcstoul(p, &amp;end, 10))    {        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("'%.*ls' -&gt; ", (int)(end-p), p);        p = end;        if (errno == <a href="http://en.cppreference.com/w/c/error/errno_macros">ERANGE</a>){            <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("range error, got ");            errno = 0;        }        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%lu\n", i);    }}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>Parsing '10 200000000000000000000000000000 30 40':<br>'10' -&gt; 10<br>' 200000000000000000000000000000' -&gt; range error, got 18446744073709551615<br>' 30' -&gt; 30<br>' 40' -&gt; 40</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/wcstoul
wcsxfrm	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev"><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcsxfrm( wchar_t* dest, const wchar_t* src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (until C99) <br/>(since C95) </td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> wcsxfrm( wchar_t* restrict dest, const wchar_t* restrict src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>Transforms the null-terminated wide string pointed to by <code>src</code> into the implementation-defined form such that comparing two transformed strings with <a href="http://en.cppreference.com/w/c/string/wide/wcscmp" title="c/string/wide/wcscmp">wcscmp</a> gives the same result as comparing the original strings with <a href="http://en.cppreference.com/w/c/string/wide/wcscoll" title="c/string/wide/wcscoll">wcscoll</a>, in the current C locale.</p><p>The first <code>count</code> characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.</p><p>If <code>count</code> is <code>\xe2\x80\x8b0\xe2\x80\x8b</code>, then <code>dest</code> is allowed to be a null pointer.</p></section>	http://en.cppreference.com/w/c/string/wide/wcsxfrm
wctrans	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wctrans_t wctrans( const char* str );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Constructs a value of type <code>wctrans_t</code> that describes a LC_CTYPE category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as <code>"tojhira"</code> or <code>"tojkana"</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  C string holding the name of the desired mapping.<p>The following values of <code>str</code> are supported in all C locales:</p><table><tr><td>  Value of <code>str</code></td><td>  Effect</td></tr><tr><td> <code>"toupper"</code></td><td>  identifies the mapping used by <a href="http://en.cppreference.com/w/c/string/wide/towupper" title="c/string/wide/towupper">towupper</a></td></tr><tr><td> <code>"tolower"</code></td><td>  identifies the mapping used by <a href="http://en.cppreference.com/w/c/string/wide/towlower" title="c/string/wide/towlower">towlower</a></td></tr></table><p><br/></p></td></tr></table><span class="prog__sub"> Return value</span><p><code>wctrans_t</code> object suitable for use with <a href="http://en.cppreference.com/w/c/string/wide/towctrans" title="c/string/wide/towctrans">towctrans</a> to map wide characters according to the named mapping of the current C locale or zero if <code>str</code> does not name a mapping supported by the current C locale.</p></section>	http://en.cppreference.com/w/c/string/wide/wctrans
wctype	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wctype.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wctype_t wctype( const char* str );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Constructs a value of type <code>wctype_t</code> that describes a LC_CTYPE category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as <code>"jkanji"</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  str</td><td> -</td><td>  C string holding the name of the desired category</td></tr></table><p>The following values of <code>str</code> are supported in all C locales:</p><table><tr><td>  value of <code>str</code></td><td>  effect</td></tr><tr><td> <code>"alnum"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswalnum" title="c/string/wide/iswalnum">iswalnum</a></td></tr><tr><td> <code>"alpha"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswalpha" title="c/string/wide/iswalpha">iswalpha</a></td></tr><tr><td> <code>"blank"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswblank" title="c/string/wide/iswblank">iswblank</a> (C99)</td></tr><tr><td> <code>"cntrl"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswcntrl" title="c/string/wide/iswcntrl">iswcntrl</a></td></tr><tr><td> <code>"digit"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswdigit" title="c/string/wide/iswdigit">iswdigit</a></td></tr><tr><td> <code>"graph"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswgraph" title="c/string/wide/iswgraph">iswgraph</a></td></tr><tr><td> <code>"lower"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswlower" title="c/string/wide/iswlower">iswlower</a></td></tr><tr><td> <code>"print"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswprint" title="c/string/wide/iswprint">iswprint</a></td></tr><tr><td> <code>"space"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswspace" title="c/string/wide/iswspace">iswspace</a></td></tr><tr><td> <code>"upper"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswupper" title="c/string/wide/iswupper">iswupper</a></td></tr><tr><td> <code>"xdigit"</code></td><td>  identifies the category used by <a href="http://en.cppreference.com/w/c/string/wide/iswxdigit" title="c/string/wide/iswxdigit">iswxdigit</a></td></tr></table><span class="prog__sub"> Return value</span><p><code>wctype_t</code> object suitable for use with <a href="http://en.cppreference.com/w/c/string/wide/iswctype" title="c/string/wide/iswctype">iswctype</a> to classify wide characters according to the named category of the current C locale or zero if <code>str</code> does not name a category supported by the current C locale.</p></section>	http://en.cppreference.com/w/c/string/wide/wctype
wmemchr	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wchar_t *wmemchr( const wchar_t *ptr, wchar_t ch, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Locates the first occurrence of wide character <code>ch</code> in the initial <code>count</code> wide characters of the wide character array or integer array of compatible type, pointed to by <code>ptr</code>. </p><p>If <code>count</code> is zero, the function returns a null pointer.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ptr</td><td> -</td><td>  pointer to the wide character array to be examined</td></tr><tr><td>  ch</td><td> -</td><td>  wide character to search for</td></tr><tr><td>  count</td><td> -</td><td>  number of wide characters to examine</td></tr></table><span class="prog__sub"> Return value</span><p>Pointer to the location of the wide character, or a null pointer if no such character is found.<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;wchar.h&gt;#include &lt;locale.h&gt;\xc2\xa0int main(void){    wchar_t str[] = L"\xe8\xaf\xba\xe4\xb8\x8d\xe8\xbd\xbb\xe4\xbf\xa1\xef\xbc\x8c\xe6\x95\x85\xe4\xba\xba\xe4\xb8\x8d\xe8\xb4\x9f\xe6\x88\x91\x00\xe8\xaf\xba\xe4\xb8\x8d\xe8\xbd\xbb\xe8\xae\xb8\xef\xbc\x8c\xe6\x95\x85\xe6\x88\x91\xe4\xb8\x8d\xe8\xb4\x9f\xe4\xba\xba\xe3\x80\x82";    <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> sz = sizeof str / sizeof *str;\xc2\xa0    wchar_t target = L'\xe8\xae\xb8';    wchar_t* result = wmemchr(str, target, sz);\xc2\xa0    if (result) {        <a href="http://en.cppreference.com/w/c/locale/setlocale">setlocale</a>(<a href="http://en.cppreference.com/w/c/locale/LC_categories">LC_ALL</a>, "en_US.utf8");        <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Found '%lc' at position\xc2\xa0%td\n",target, result - str);    }}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>Found '\xe8\xae\xb8' at position 14</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/string/wide/wmemchr
wmemcmp	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int wmemcmp( const wchar_t *lhs, const wchar_t *rhs, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Compares the first <code>count</code> wide characters of the wide character (or compatible integer type) arrays pointed to by <code>lhs</code> and <code>rhs</code>. The comparison is done lexicographically.</p><p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.<br></p><p>If <code>count</code> is zero, the function does nothing.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  pointers to the wide character arrays to compare</td></tr><tr><td>  count</td><td> -</td><td>  number of wide characters to examine</td></tr></table><span class="prog__sub"> Return value</span><p>Negative value if the value of the first differing wide character in <code>lhs</code> is less than the value of the corresponding wide character in <code>rhs</code>: <code>lhs</code> precedes <code>rhs</code> in lexicographical order.</p><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> if all <code>count</code> wide characters of <code>lhs</code> and <code>rhs</code> are equal.</p><p>Positive value if the value of the first differing wide character in <code>lhs</code> is greater than the value of the corresponding wide character in <code>rhs</code>: <code>rhs</code> precedes <code>lhs</code> in lexicographical order.</p></section>	http://en.cppreference.com/w/c/string/wide/wmemcmp
wmemcpy, wmemcpy_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr></tbody><tbody class="t-dcl-rev t-dcl-rev-num"><tr><td></td><td>(1)</td><td></td></tr><tr><td> <div><code>wchar_t* wmemcpy( wchar_t* dest, const wchar_t* src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C95) <br/>(until C99) </td></tr><tr><td> <div><code>wchar_t *wmemcpy(wchar_t *restrict dest, const wchar_t *restrict src,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0<a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C99) </td></tr></tbody><tbody><tr><td> <div><code>errno_t wmemcpy_s( wchar_t *restrict dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const wchar_t *restrict src, rsize_t count );</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies exactly <code>count</code> successive wide characters from the wide character array pointed to by <code>src</code> to the wide character array pointed to by <code>dest</code>. If the objects overlap, the behavior is undefined. If <code>count</code> is zero, the function does nothing.</div><div>2) Same as (1), except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> <code>count</code> is greater than <code>destsz</code> (overflow would occur)</li><li> overlap would occur between the source and the destination arrays</li></ul></dd><dd>As all bounds-checked functions, <code>wmemcpy_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the wide character array to copy to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the wide character array to copy from</td></tr><tr><td>  count</td><td> -</td><td>  number of wide characters to copy</td></tr><tr><td>  destsz</td><td> -</td><td>  max number of wide characters to write (the size of the destination buffer)</td></tr></table><span class="prog__sub"> Return value</span><div>1) returns a copy of <code>dest</code></div><div>2) returns zero on success, returns non-zero on error. Also, on error, fills the entire <code>dst</code> up to and not including <code>dst+dstsz</code> with null wide characters, <code>L'\x00'</code> (unless <code>dest</code> is null or <code>destsz</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>)</div></section>	http://en.cppreference.com/w/c/string/wide/wmemcpy
wmemmove, wmemmove_s	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wchar_t* wmemmove( wchar_t* dest, const wchar_t* src, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> (1) </td><td> (since C95) </td></tr><tr><td> <div><code>errno_t wmemmove_s( wchar_t *dest, rsize_t destsz,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 const wchar_t *src, rsize_t count);</code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Copies exactly <code>count</code> successive wide characters from the wide character array pointed to by <code>src</code> to the wide character array pointed to by <code>dest</code>. If <code>count</code> is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to <code>dest</code>.</div><div>2) Same as (1), except that the following errors are detected at runtime and call the currently installed <a href="http://en.cppreference.com/w/c/error/set_constraint_handler_s" title="c/error/set constraint handler s">constraint handler</a> function:<dl><dd><ul><li> <code>src</code> or <code>dest</code> is a null pointer</li><li> <code>destsz</code> or <code>count</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code></li><li> <code>count</code> is greater than <code>destsz</code> (overflow would occur)</li></ul></dd><dd>As all bounds-checked functions, <code>wmemmove_s</code> is only guaranteed to be available if <code>__STDC_LIB_EXT1__</code> is defined by the implementation and if the user defines <code>__STDC_WANT_LIB_EXT1__</code> to the integer constant <code>1</code> before including <code>wchar.h</code>.</dd></dl></div><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the wide character array to copy to</td></tr><tr><td>  src</td><td> -</td><td>  pointer to the wide character array to copy from</td></tr><tr><td>  destsz</td><td> -</td><td>  max number of wide characters to write (the size of the destination buffer)</td></tr><tr><td>  count</td><td> -</td><td>  number of wide characters to copy</td></tr></table><span class="prog__sub"> Return value</span><div>1) Returns a copy of <code>dest</code></div><div>2) Returns zero on success, returns non-zero on error. Also, on error, fills the entire <code>dst</code> up to and not including <code>dst+dstsz</code> with null wide characters, <code>L'\x00'</code> (unless <code>dest</code> is null or <code>destsz</code> is greater than <code>RSIZE_MAX/sizeof(wchar_t)</code>)</div></section>	http://en.cppreference.com/w/c/string/wide/wmemmove
wmemset	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>wchar_t *wmemset( wchar_t *dest, wchar_t ch, <a href="http://en.cppreference.com/w/c/types/size_t">size_t</a> count );</code></div></td><td> </td><td> (since C95) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Copies the wide character <code>ch</code> into each of the first <code>count</code> wide characters of the wide character array (or integer array of compatible type) pointed to by <code>dest</code>.</p><p>If overflow occurs, the behavior is undefined.<br></p><p>If <code>count</code> is zero, the function does nothing.</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  pointer to the wide character array to fill</td></tr><tr><td>  ch</td><td> -</td><td>  fill wide character</td></tr><tr><td>  count</td><td> -</td><td>  number of wide characters to fill</td></tr></table><span class="prog__sub"> Return value</span><p>Returns a copy of <code>dest</code></p></section>	http://en.cppreference.com/w/c/string/wide/wmemset
call_once, once_flag, ONCE_FLAG_INIT	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void call_once( <a href="http://en.cppreference.com/w/c/thread">once_flag</a>* flag, void (*func)(void) );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>typedef /* unspecified */ <a href="http://en.cppreference.com/w/c/thread">once_flag</a></code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td> <div><code>#define ONCE_FLAG_INIT /* unspecified */</code></div></td><td> (3) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Calls function <code>func</code> exactly once, even if invoked from several threads. The completion of the function <code>func</code> synchronizes with all previous or subsequent calls to <code>call_once</code> with the same <code>flag</code> variable.</div><div>2) Complete object type capable of holding a flag used by <code>call_once</code></div><div>3) Expands to a value that can be used to initialize an object of type <code>once_flag</code>.</div><span class="prog__sub"> Parameters</span><table><tr><td>  flag</td><td> -</td><td>  pointer to an object of type <code>call_once</code> that is used to ensure <code>func</code> is called only once</td></tr><tr><td>  func</td><td> -</td><td>  the function to execute only once</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/thread/call_once
cnd_broadcast	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int cnd_broadcast( <a href="http://en.cppreference.com/w/c/thread">cnd_t</a> *cond );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Unblocks all thread that currently wait on condition variable pointed to by <code>cond</code>. If no threads are blocked, does nothing and returns <code>thrd_success</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  cond</td><td> -</td><td>  pointer to a condition variable</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/cnd_broadcast
cnd_destroy	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void cnd_destroy( <a href="http://en.cppreference.com/w/c/thread">cnd_t</a>* cond );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Destroys the condition variable pointed to by <code>cond</code>.</p><p>If there are threads waiting on <code>cond</code>, the behavior is undefined.</p><span class="prog__sub"> Parameters</span><table><tr><td>  cond</td><td> -</td><td>  pointer to the condition variable to destroy</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/thread/cnd_destroy
cnd_init	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int cnd_init( <a href="http://en.cppreference.com/w/c/thread">cnd_t</a>* cond );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Initializes new condition variable. The object pointed to by <code>cond</code> will be set to value that identifies the condition variable.</p><span class="prog__sub"> Parameters</span><table><tr><td>  cond</td><td> -</td><td>  pointer to a variable to store identifier of the condition variable to</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if the condition variable was successfully created. Otherwise returns <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_nomem</a> if there was insufficient amount of memory or <code>thrd_error</code> if another error occurred.</p></section>	http://en.cppreference.com/w/c/thread/cnd_init
cnd_signal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int cnd_signal( <a href="http://en.cppreference.com/w/c/thread">cnd_t</a> *cond );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Unblocks one thread that currently waits on condition variable pointed to by <code>cond</code>. If no threads are blocked, does nothing and returns <code>thrd_success</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  cond</td><td> -</td><td>  pointer to a condition variable</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/cnd_signal
cnd_timedwait	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int cnd_timedwait( <a href="http://en.cppreference.com/w/c/thread">cnd_t</a>* restrict cond, <a href="http://en.cppreference.com/w/c/thread">mtx_t</a>* restrict mutex,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const struct timespec* restrict time_point );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically unlocks the mutex pointed to by <code>mutex</code> and blocks on the condition variable pointed to by <code>cond</code> until the thread is signalled by <a href="http://en.cppreference.com/w/c/thread/cnd_signal" title="c/thread/cnd signal">cnd_signal</a> or <a href="http://en.cppreference.com/w/c/thread/cnd_broadcast" title="c/thread/cnd broadcast">cnd_broadcast</a>, or until the <code>TIME_UTC</code> based time point pointed to by <code>time_point</code> has been reached. The mutex is locked again before the function returns.</p><p>The behavior is undefined if the mutex is not already locked by the calling thread.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  cond</td><td> -</td><td>  pointer to the condition variable to block on</td></tr><tr><td>  mutex</td><td> -</td><td>  pointer to the mutex to unlock for the duration of the block</td></tr><tr><td>  duration</td><td> -</td><td>  pointer to a object specifying timeout time to wait until</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <code>thrd_timedout</code> if the timeout time has been reached before the mutex is locked, or  <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> if an error occurred.</p></section>	http://en.cppreference.com/w/c/thread/cnd_timedwait
cnd_wait	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int cnd_wait( <a href="http://en.cppreference.com/w/c/thread">cnd_t</a>* cond, <a href="http://en.cppreference.com/w/c/thread">mtx_t</a>* mutex );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Atomically unlocks the mutex pointed to by <code>mutex</code> and blocks on the condition variable pointed to by <code>cond</code> until the thread is signalled by <a href="http://en.cppreference.com/w/c/thread/cnd_signal" title="c/thread/cnd signal">cnd_signal</a> or <a href="http://en.cppreference.com/w/c/thread/cnd_broadcast" title="c/thread/cnd broadcast">cnd_broadcast</a>. The mutex is locked again before the function returns.</p><p>The behavior is undefined if the mutex is not already locked by the calling thread.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  cond</td><td> -</td><td>  pointer to the condition variable to block on</td></tr><tr><td>  mutex</td><td> -</td><td>  pointer to the mutex to unlock for the duration of the block</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/cnd_wait
mtx_destroy	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void mtx_destroy( <a href="http://en.cppreference.com/w/c/thread">mtx_t</a> *mutex );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Destroys the mutex pointed to by <code>mutex</code>.</p><p>If there are threads waiting on <code>mutex</code>, the behavior is undefined.</p><span class="prog__sub"> Parameters</span><table><tr><td>  mutex</td><td> -</td><td>  pointer to the mutex to destroy</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/thread/mtx_destroy
mtx_init	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int mtx_init( <a href="http://en.cppreference.com/w/c/thread">mtx_t</a>* mutex, int type );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Creates a new mutex object with <code>type</code>. The object pointed to by <code>mutex</code> is set to an identifier of the newly created mutex.</p><p><code>type</code> must have one of the following values:</p><ul><li><a href="http://en.cppreference.com/w/c/thread/mtx_types" title="c/thread/mtx types">mtx_plain</a> - a simple, non-recursive mutex is created.</li><li><a href="http://en.cppreference.com/w/c/thread/mtx_types" title="c/thread/mtx types">mtx_timed</a> - a non-recursive mutex, that supports timeout, is created.</li><li><code><a href="http://en.cppreference.com/w/c/thread/mtx_types">mtx_plain</a> | <a href="http://en.cppreference.com/w/c/thread/mtx_types">mtx_recursive</a></code> - a recursive mutex is created.</li><li><code><a href="http://en.cppreference.com/w/c/thread/mtx_types">mtx_timed</a> | <a href="http://en.cppreference.com/w/c/thread/mtx_types">mtx_recursive</a></code> - a recursive mutex, that supports timeout, is created.</li></ul><span class="prog__sub"> Parameters</span><table><tr><td>  mutex</td><td> -</td><td>  pointer to the mutex to initialize</td></tr><tr><td>  type</td><td> -</td><td>  the type of the mutex</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/mtx_init
mtx_lock	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int mtx_lock( <a href="http://en.cppreference.com/w/c/thread">mtx_t</a>* mutex );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Blocks the current thread until the mutex pointed to by <code>mutex</code> is locked.</p><p>The behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.<br></p><p>Prior calls to <a href="http://en.cppreference.com/w/c/thread/mtx_unlock" title="c/thread/mtx unlock">mtx_unlock</a> on the same mutex <i>synchronize-with</i> this operation, and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)</p><span class="prog__sub"> Parameters</span><table><tr><td>  mutex</td><td> -</td><td>  pointer to the mutex to lock</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/mtx_lock
mtx_timedlock	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int mtx_timedlock( <a href="http://en.cppreference.com/w/c/thread">mtx_t</a> *restrict mutex,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0const struct timespec *restrict time_point );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Blocks the current thread until the mutex pointed to by <code>mutex</code> is locked or until the <code>TIME_UTC</code> based time point pointed to by <code>time_point</code> has been reached.</p><p>The behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.<br></p><p>The behavior is undefined if the mutex does not support timeout.<br></p><p>Prior calls to <a href="http://en.cppreference.com/w/c/thread/mtx_unlock" title="c/thread/mtx unlock">mtx_unlock</a> on the same mutex <i>synchronize-with</i> this operation (if this operation succeeds), and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)</p><span class="prog__sub"> Parameters</span><table><tr><td>  mutex</td><td> -</td><td>  pointer to the mutex to lock</td></tr><tr><td>  time_point</td><td> -</td><td>  pointer to the timeout time to wait until</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <code>thrd_timedout</code> if the timeout time has been reached before the mutex is locked, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> if an error occurs.</p></section>	http://en.cppreference.com/w/c/thread/mtx_timedlock
mtx_trylock	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int mtx_trylock( <a href="http://en.cppreference.com/w/c/thread">mtx_t</a> *mutex );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Tries to lock the mutex pointed to by <code>mutex</code> without blocking. Returns immediately if the mutex is already locked.</p><p>Prior calls to <a href="http://en.cppreference.com/w/c/thread/mtx_unlock" title="c/thread/mtx unlock">mtx_unlock</a> on the same mutex <i>synchronize-with</i> this operation (if this operation succeeds), and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic)</p><span class="prog__sub"> Parameters</span><table><tr><td>  mutex</td><td> -</td><td>  pointer to the mutex to lock</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_busy</a> if the mutex has already been locked, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> if an error occurs.</p></section>	http://en.cppreference.com/w/c/thread/mtx_trylock
mtx_plain, mtx_recursive, mtx_timed	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>enum {<br/><p>\xc2\xa0 \xc2\xa0 mtx_plain = /* unspecified */,<br/>\xc2\xa0 \xc2\xa0 mtx_recursive = /* unspecified */,<br/>\xc2\xa0 \xc2\xa0 mtx_timed = /* unspecified */<br/></p>};</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>When passed to <a href="http://en.cppreference.com/w/c/thread/mtx_init" title="c/thread/mtx init">mtx_init</a>, identifies the type of a mutex to create.</p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>mtx_plain</code></td><td>  plain mutex</td></tr><tr><td> <code>mtx_recursive</code></td><td>  recursive mutex</td></tr><tr><td> <code>mtx_timed</code></td><td>  timed mutex</td></tr></table></section>	http://en.cppreference.com/w/c/thread/mtx_types
mtx_unlock	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int mtx_unlock( <a href="http://en.cppreference.com/w/c/thread">mtx_t</a> *mutex );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Unlocks the mutex pointed to by <code>mutex</code>. </p><p>The behavior is undefined if the mutex is not locked by the calling thread.<br></p><p>This function <i>synchronizes-with</i> subsequent <a href="http://en.cppreference.com/w/c/thread/mtx_lock" title="c/thread/mtx lock">mtx_lock</a>, <a href="http://en.cppreference.com/w/c/thread/mtx_trylock" title="c/thread/mtx trylock">mtx_trylock</a>, or <a href="http://en.cppreference.com/w/c/thread/mtx_timedlock" title="c/thread/mtx timedlock">mtx_timedlock</a> on the same mutex. All lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic).</p><span class="prog__sub"> Parameters</span><table><tr><td>  mutex</td><td> -</td><td>  pointer to the mutex to unlock</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/mtx_unlock
call_once, once_flag, ONCE_FLAG_INIT	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void call_once( <a href="http://en.cppreference.com/w/c/thread">once_flag</a>* flag, void (*func)(void) );</code></div></td><td> (1) </td><td> (since C11) </td></tr><tr><td> <div><code>typedef /* unspecified */ <a href="http://en.cppreference.com/w/c/thread">once_flag</a></code></div></td><td> (2) </td><td> (since C11) </td></tr><tr><td> <div><code>#define ONCE_FLAG_INIT /* unspecified */</code></div></td><td> (3) </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><div>1) Calls function <code>func</code> exactly once, even if invoked from several threads. The completion of the function <code>func</code> synchronizes with all previous or subsequent calls to <code>call_once</code> with the same <code>flag</code> variable.</div><div>2) Complete object type capable of holding a flag used by <code>call_once</code></div><div>3) Expands to a value that can be used to initialize an object of type <code>once_flag</code>.</div><span class="prog__sub"> Parameters</span><table><tr><td>  flag</td><td> -</td><td>  pointer to an object of type <code>call_once</code> that is used to ensure <code>func</code> is called only once</td></tr><tr><td>  func</td><td> -</td><td>  the function to execute only once</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/thread/ONCE_FLAG_INIT
thrd_create	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int thrd_create( <a href="http://en.cppreference.com/w/c/thread">thrd_t</a> *thr, <a href="http://en.cppreference.com/w/c/thread">thrd_start_t</a> func, void *arg );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Creates a new thread executing the function <code>func</code>. The function is invoked as <code>func(arg)</code>.</p><p>If successful, the object pointed to by <code>thr</code> is set to the identifier of the new thread.</p><p>The completion of this function <i>synchronizes-with</i> the beginning of the thread.</p><span class="prog__sub"> Parameters</span><table><tr><td>  thr</td><td> -</td><td>  pointer to memory location to put the identifier of the new thread</td></tr><tr><td>  func</td><td> -</td><td>  function to execute</td></tr><tr><td>  arg</td><td> -</td><td>  argument to pass to the function</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if the creation of the new thread was successful. Otherwise returns <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_nomem</a> if there was insufficient amount of memory or <code>thrd_error</code> if another error occurred.</p></section>	http://en.cppreference.com/w/c/thread/thrd_create
thrd_current	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code><a href="http://en.cppreference.com/w/c/thread">thrd_t</a> thrd_current(void);</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the identifier of the calling thread.<br></p><span class="prog__sub"> Parameters</span><p>(none)<br></p><span class="prog__sub"> Return value</span><p>The identifier of the calling thread.<br></p></section>	http://en.cppreference.com/w/c/thread/thrd_current
thrd_detach	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int thrd_detach( <a href="http://en.cppreference.com/w/c/thread">thrd_t</a> thr );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Detaches the thread identified by <code>thr</code> from the current environment. The resources held by the thread will be freed automatically once the thread exits.</p><span class="prog__sub"> Parameters</span><table><tr><td>  thr</td><td> -</td><td>  identifier of the thread to detach</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/thrd_detach
thrd_equal	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int thrd_equal( <a href="http://en.cppreference.com/w/c/thread">thrd_t</a> lhs, <a href="http://en.cppreference.com/w/c/thread">thrd_t</a> rhs );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Checks whether <code>lhs</code> and <code>rhs</code> refer to the same thread.</p><span class="prog__sub"> Parameters</span><table><tr><td>  lhs, rhs</td><td> -</td><td>  threads to compare</td></tr></table><span class="prog__sub"> Return value</span><p>Non-zero value if <code>lhs</code> and <code>rhs</code> refer to the same value, <code>\xe2\x80\x8b0\xe2\x80\x8b</code> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/thrd_equal
thrd_success, thrd_timedout, thrd_busy, thrd_nomem, thrd_error	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>enum {<br/><p>\xc2\xa0 \xc2\xa0 thrd_success = /* unspecified */,<br/>\xc2\xa0 \xc2\xa0 thrd_nomem = /* unspecified */,<br/>\xc2\xa0 \xc2\xa0 thrd_timedout = /* unspecified */,<br/>\xc2\xa0 \xc2\xa0 thrd_busy = /* unspecified */,<br/>\xc2\xa0 \xc2\xa0 thrd_error = /* unspecified */<br/></p>};</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Identifiers a thread error state.<br></p><table><tr><td>  Constant</td><td>  Explanation</td></tr><tr><td> <code>thrd_success</code></td><td>  indicates successful return value</td></tr><tr><td> <code>thrd_timedout</code></td><td>  indicates timed out return value</td></tr><tr><td> <code>thrd_busy</code></td><td>  indicates unsuccessful return value due to resource temporary unavailable</td></tr><tr><td> <code>thrd_nomem</code></td><td>  indicates unsuccessful return value due to out of memory condition</td></tr><tr><td> <code>thrd_error</code></td><td>  indicates unsuccessful return value</td></tr></table></section>	http://en.cppreference.com/w/c/thread/thrd_errors
thrd_exit	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>_Noreturn void thrd_exit( int res );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>First, for every thread-specific storage key which was created with a non-null destructor and for which the associated value is non-null (see <a href="http://en.cppreference.com/w/c/thread/tss_create" title="c/thread/tss create">tss_create</a>), <code>thrd_exit</code> sets the value associated with the key to <code>NULL</code> and then invokes the destructor with the previous value of the key. The order in which the destructors are invoked is unspecified.</p><p>If, after this, there remain keys with both non-null destructors and values (e.g. if a destructor executed <a href="http://en.cppreference.com/w/c/thread/tss_set" title="c/thread/tss set">tss_set</a>), the process is repeated up to <a href="http://en.cppreference.com/w/c/thread/TSS_DTOR_ITERATIONS" title="c/thread/TSS DTOR ITERATIONS">TSS_DTOR_ITERATIONS</a> times.</p><p>FInally, the <code>thrd_exit</code> function terminates execution of the calling thread and sets its result code to <code>res</code>.</p><p>If the last thread in the program is terminated with <code>thrd_exit</code>, the entire program terminates as if by calling <a href="http://en.cppreference.com/w/c/program/exit" title="c/program/exit">exit</a> with <a href="http://en.cppreference.com/w/c/program/EXIT_status" title="c/program/EXIT status">EXIT_SUCCESS</a> as the argument (so the functions registered by <a href="http://en.cppreference.com/w/c/program/atexit" title="c/program/atexit">atexit</a> are executed in the context of that last thread)</p><span class="prog__sub"> Parameters</span><table><tr><td>  res</td><td> -</td><td>  the result value to return</td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/thread/thrd_exit
thrd_join	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int thrd_join( <a href="http://en.cppreference.com/w/c/thread">thrd_t</a> thr, int *res );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Blocks the current thread until the thread identified by <code>thr</code> finishes execution.</p><p>If <code>res</code> is not a null pointer, the result code of the thread is put to the location pointed to by <code>res</code>.</p><p>The termination of the thread <i>synchronizes-with</i> the completion of this function.</p><p>The behavior is undefined if the thread was previously detached or joined by another thread.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  thr</td><td> -</td><td>  identifier of the thread to join</td></tr><tr><td>  res</td><td> -</td><td>  location to put the result code to</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/thrd_join
thrd_sleep	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int thrd_sleep( const struct timespec* time_point,<br/>\xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 \xc2\xa0 struct timespec* remaining );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Blocks the execution of the current thread for <i>at least</i> until the TIME_UTC based time point pointed to by <code>time_point</code> has been reached.</p><p>The sleep may resume earlier if a <a href="http://en.cppreference.com/w/c/program/signal" title="c/program/signal">signal</a> that is not ignored is received. In such case, if <code>remaining</code> is not <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, the remaining time duration is stored into the object pointed to by <code>remaining</code>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  time_point</td><td> -</td><td>  pointer to the time point to sleep until</td></tr><tr><td>  remaining</td><td> -</td><td>  pointer to the object to put the remaining time on interruption. May be <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>, in which case it is ignored</td></tr></table><span class="prog__sub"> Return value</span><p><code>\xe2\x80\x8b0\xe2\x80\x8b</code> on successful sleep, <code>-1</code> if a signal occurred, other negative value if an error occurred.</p></section>	http://en.cppreference.com/w/c/thread/thrd_sleep
thrd_yield	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void thrd_yield();</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Provides a hint to the implementation to reschedule the execution of threads, allowing other threads to run. <br></p><span class="prog__sub"> Parameters</span><p>(none)<br></p><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/thread/thrd_yield
thread_local	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define thread_local _Thread_local</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Convenience macro which can be used to specify that an object has <a href="http://en.cppreference.com/w/c/language/storage_duration" title="c/language/storage duration">thread-local storage duration</a>.</p></section>	http://en.cppreference.com/w/c/thread/thread_local
tss_create	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int tss_create( <a href="http://en.cppreference.com/w/c/thread">tss_t</a>* tss_key, <a href="http://en.cppreference.com/w/c/thread">tss_dtor_t</a> destructor );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Creates new thread-specific storage key and stores it in the object pointed to by <code>tss_key</code>. Although the same key value may be used by different threads, the values bound to the key by <a href="http://en.cppreference.com/w/c/thread/tss_set" title="c/thread/tss set">tss_set</a> are maintained on a per-thread basis and persist for the life of the calling thread.</p><p>The value <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> is associated with the newly created key in all existing threads, and upon thread creation, the values associated with all TSS keys is initialized to <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a>.</p><p>If <code>destructor</code> is not a null pointer, then also associates the destructor which is called when the storage is released by <a href="http://en.cppreference.com/w/c/thread/thrd_exit" title="c/thread/thrd exit">thrd_exit</a> (but not by <a href="http://en.cppreference.com/w/c/thread/tss_delete" title="c/thread/tss delete">tss_delete</a> and not at program termination by <a href="http://en.cppreference.com/w/c/program/exit" title="c/program/exit">exit</a>).</p><p>A call to <code>tss_create</code> from within a thread-specific storage destructor results in undefined behavior.</p><span class="prog__sub"> Parameters</span><table><tr><td>  tss_key</td><td> -</td><td>  pointer to memory location to store the new thread-specific storage key</td></tr><tr><td>  destructor</td><td> -</td><td>  pointer to a function to call at thread exit</td></tr></table></section>	http://en.cppreference.com/w/c/thread/tss_create
tss_delete	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void tss_delete( <a href="http://en.cppreference.com/w/c/thread">tss_t</a> tss_id );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Destroys the thread-specific storage identified by <code>tss_id</code>. </p><p>The destructor, if one was registered by <a href="http://en.cppreference.com/w/c/thread/tss_create" title="c/thread/tss create">tss_create</a>, is not called (they are only called at thread exit, either by <a href="http://en.cppreference.com/w/c/thread/thrd_exit" title="c/thread/thrd exit">thrd_exit</a> or by returning from the thread function), it is the responsibility of the programmer to ensure that every thread that is aware of <code>tss_id</code> performed all necessary cleanup, before the call to <code>tss_delete</code> is made.</p><p>If <code>tss_delete</code> is called while another thread is executing destructors for <code>tss_id</code>, it's unspecified whether this changes the number of invocations to the associated destructor.</p><p>If <code>tss_delete</code> is called while the calling thread is executing destructors, then the destructor associated with <code>tss_id</code> will not be executed again on this thread.</p><span class="prog__sub"> Parameters</span><table><tr><td>  tss_id</td><td> -</td><td>  thread-specific storage key previously returned by <a href="http://en.cppreference.com/w/c/thread/tss_create" title="c/thread/tss create">tss_create</a> and not yet deleted by <strong class="selflink">tss_delete</strong></td></tr></table><span class="prog__sub"> Return value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/thread/tss_delete
TSS_DTOR_ITERATIONS	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define TSS_DTOR_ITERATIONS /* unspecified */</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Expands to a positive integral <a href="http://en.cppreference.com/w/c/language/constant_expression" title="c/language/constant expression">constant expression</a> defining the maximum number of times a destructor for thread-local storage pointer will be called by  <a href="http://en.cppreference.com/w/c/thread/thrd_exit" title="c/thread/thrd exit">thrd_exit</a>.</p><p>This constant is equivalent to the POSIX <code>PTHREAD_DESTRUCTOR_ITERATIONS</code></p></section>	http://en.cppreference.com/w/c/thread/TSS_DTOR_ITERATIONS
tss_get	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void *tss_get( <a href="http://en.cppreference.com/w/c/thread">tss_t</a> tss_key );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the value held in thread-specific storage for the current thread identified by <code>tss_key</code>. Different threads may get different values identified by the same key.</p><p>On thread startup (see <a href="http://en.cppreference.com/w/c/thread/thrd_create" title="c/thread/thrd create">thrd_create</a>), the values associated with all TSS keys are NULL. Different value may be placed in the thread-specific storage with <a href="http://en.cppreference.com/w/c/thread/tss_set" title="c/thread/tss set">tss_set</a>.</p><span class="prog__sub"> Parameters</span><table><tr><td>  tss_key</td><td> -</td><td>  thread-specific storage key, obtained from <a href="http://en.cppreference.com/w/c/thread/tss_create" title="c/thread/tss create">tss_create</a> and not deleted by <a href="http://en.cppreference.com/w/c/thread/tss_delete" title="c/thread/tss delete">tss_delete</a></td></tr></table><span class="prog__sub"> Return value</span><p>The value on success, <a href="http://en.cppreference.com/w/c/types/NULL" title="c/types/NULL">NULL</a> on failure.</p></section>	http://en.cppreference.com/w/c/thread/tss_get
tss_set	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;threads.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>int tss_set( <a href="http://en.cppreference.com/w/c/thread">tss_t</a> tss_id, void *val );</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Sets the value of the thread-specific storage identified by <code>tss_id</code> for the current thread to <code>val</code>. Different threads may set different values to the same key.</p><p>The destructor, if available, is not invoked.<br></p><span class="prog__sub"> Parameters</span><table><tr><td>  tss_id</td><td> -</td><td>  thread-specific storage key, obtained from <a href="http://en.cppreference.com/w/c/thread/tss_create" title="c/thread/tss create">tss_create</a> and not deleted by <a href="http://en.cppreference.com/w/c/thread/tss_delete" title="c/thread/tss delete">tss_delete</a></td></tr><tr><td>  val</td><td> -</td><td>  value to set thread-specific storage to</td></tr></table><span class="prog__sub"> Return value</span><p><a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_success</a> if successful, <a href="http://en.cppreference.com/w/c/thread/thrd_errors" title="c/thread/thrd errors">thrd_error</a> otherwise.</p></section>	http://en.cppreference.com/w/c/thread/tss_set
Boolean type support library	A										<section class="prog__container"><p>The C programming language, as of C99, supports Boolean arithmetic with the built-in type <code>_Bool</code> (see <a href="http://en.cppreference.com/w/c/keyword/_Bool" title="c/keyword/ Bool">_Bool</a>). When the header <code>&lt;stdbool.h&gt;</code> is included, the Boolean type is also accessible as <code>bool</code>.</p><p><a href="http://en.cppreference.com/w/c/language/operator_logical" title="c/language/operator logical">Standard logical operators</a> <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> can be used with the Boolean type in any combination. </p><p>A program may undefine and perhaps then redefine the macros <code>bool</code>, <code>true</code> and <code>false</code>.</p><span class="prog__sub"> Macros</span><table><tr><td>  Macro name</td><td>  Expands to</td></tr><tr><td> <code>bool</code></td><td> <code>_Bool</code></td></tr><tr><td> <code>true</code></td><td>  integer constant <code>1</code></td></tr><tr><td> <code>false</code></td><td>  integer constant <code>0</code></td></tr><tr><td> <code>__bool_true_false_are_defined</code></td><td>  integer constant <code>1</code></td></tr></table><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;\xc2\xa0int main(void){    bool a=true, b=false;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", a&amp;&amp;b);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", a||b);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", !b);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>0<br>1<br>1</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/types/boolean
Fixed width integer types (since C99)	A										<section class="prog__container"><span class="prog__sub"> Types</span><table><tr><td> <div>Defined in header <code>&lt;stdint.h&gt;</code> </div></td></tr><tr><td> <code>int8_t</code><br/><code>int16_t</code><br/><code>int32_t</code><br/><code>int64_t</code></td><td>  signed integer type with width of<br/> exactly 8, 16, 32 and 64 bits respectively<br/>with no padding bits and using 2's complement for negative values<br/>(provided only if the implementation directly supports the type)</td></tr><tr><td> <code>int_fast8_t</code><br/><code>int_fast16_t</code><br/><code>int_fast32_t</code><br/><code>int_fast64_t</code></td><td>  fastest signed integer type with width of<br/> at least 8, 16, 32 and 64 bits respectively</td></tr><tr><td> <code>int_least8_t</code><br/><code>int_least16_t</code><br/><code>int_least32_t</code><br/><code>int_least64_t</code></td><td>  smallest signed integer type with width of<br/> at least 8, 16, 32 and 64 bits respectively</td></tr><tr><td> <code>intmax_t</code></td><td>  maximum width integer type</td></tr><tr><td> <code>intptr_t</code></td><td>  integer type capable of holding a pointer</td></tr><tr><td> <code>uint8_t</code><br/><code>uint16_t</code><br/><code>uint32_t</code><br/><code>uint64_t</code></td><td>  unsigned integer type with width of<br/> exactly 8, 16, 32 and 64 bits respectively <br/>(provided only if the implementation directly supports the type)</td></tr><tr><td> <code>uint_fast8_t</code><br/><code>uint_fast16_t</code><br/><code>uint_fast32_t</code><br/><code>uint_fast64_t</code></td><td>  fastest unsigned integer type with width of<br/> at least 8, 16, 32 and 64 bits respectively</td></tr><tr><td> <code>uint_least8_t</code><br/><code>uint_least16_t</code><br/><code>uint_least32_t</code><br/><code>uint_least64_t</code></td><td>  smallest unsigned integer type with width of<br/> at least 8, 16, 32 and 64 bits respectively</td></tr><tr><td> <code>uintmax_t</code></td><td>  maximum width unsigned integer type</td></tr><tr><td> <code>uintptr_t</code></td><td>  unsigned integer type capable of holding a pointer</td></tr></table><span class="prog__sub"> Macro constants</span><table><tr><td> <div>Defined in header <code>&lt;stdint.h&gt;</code> </div></td></tr><tr><td> <h5>   Signed integers\xc2\xa0: minimum value </h5></td></tr><tr><td> <div><div>INT8_MININT16_MININT32_MININT64_MIN</div></div></td><td>    minimum value of an object of type <strong class="selflink">int8_t</strong>, <strong class="selflink">int16_t</strong>, <strong class="selflink">int32_t</strong>, <strong class="selflink">int64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</div></div></td><td>    minimum value of an object of type <strong class="selflink">int_fast8_t</strong>, <strong class="selflink">int_fast16_t</strong>, <strong class="selflink">int_fast32_t</strong>, <strong class="selflink">int_fast64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</div></div></td><td>    minimum value of an object of type <strong class="selflink">int_least8_t</strong>, <strong class="selflink">int_least16_t</strong>, <strong class="selflink">int_least32_t</strong>, <strong class="selflink">int_least64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>INTPTR_MIN</div></div></td><td>   minimum value of an object of type <strong class="selflink">intptr_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>INTMAX_MIN</div></div></td><td>   minimum value of an object of type <strong class="selflink">intmax_t</strong> <br/> (macro constant)</td></tr><tr><td> <h5>   Signed integers\xc2\xa0: maximum value </h5></td></tr><tr><td> <div><div>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</div></div></td><td>    maximum value of an object of type <strong class="selflink">int8_t</strong>, <strong class="selflink">int16_t</strong>, <strong class="selflink">int32_t</strong>, <strong class="selflink">int64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</div></div></td><td>    maximum value of an object of type <strong class="selflink">int_fast8_t</strong>, <strong class="selflink">int_fast16_t</strong>, <strong class="selflink">int_fast32_t</strong>, <strong class="selflink">int_fast64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</div></div></td><td>    maximum value of an object of type <strong class="selflink">int_least8_t</strong>, <strong class="selflink">int_least16_t</strong>, <strong class="selflink">int_least32_t</strong>, <strong class="selflink">int_least64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>INTPTR_MAX</div></div></td><td>   maximum value of an object of type <strong class="selflink">intptr_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>INTMAX_MAX</div></div></td><td>   maximum value of an object of type <strong class="selflink">intmax_t</strong> <br/> (macro constant)</td></tr><tr><td> <h5>   Unsigned integers\xc2\xa0: maximum value </h5></td></tr><tr><td> <div><div>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</div></div></td><td>    maximum value of an object of type <strong class="selflink">uint8_t</strong>, <strong class="selflink">uint16_t</strong>, <strong class="selflink">uint32_t</strong>, <strong class="selflink">uint64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</div></div></td><td>    maximum value of an object of type <strong class="selflink">uint_fast8_t</strong>, <strong class="selflink">uint_fast16_t</strong>, <strong class="selflink">uint_fast32_t</strong>, <strong class="selflink">uint_fast64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</div></div></td><td>    maximum value of an object of type <strong class="selflink">uint_least8_t</strong>, <strong class="selflink">uint_least16_t</strong>, <strong class="selflink">uint_least32_t</strong>, <strong class="selflink">uint_least64_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>UINTPTR_MAX</div></div></td><td>   maximum value of an object of type <strong class="selflink">uintptr_t</strong> <br/> (macro constant)</td></tr><tr><td> <div><div>UINTMAX_MAX</div></div></td><td>   maximum value of an object of type <strong class="selflink">uintmax_t</strong> <br/> (macro constant)</td></tr></table><span class="prog__sub"> Function macros for minimum-width integer constants</span><table><tr><td> <div><div>INT8_CINT16_CINT32_CINT64_C</div></div></td><td>   expands to an integer constant expression having the value specified by its argument and the type <code>int_least8_t</code>, <code>int_least16_t</code>, <code>int_least32_t</code>, <code>int_least64_t</code> respectively  <br/> (function macro)</td></tr><tr><td> <div><div>INTMAX_C</div></div></td><td>   expands to an integer constant expression having the value specified by its argument and the type <code>intmax_t</code> <br/> (function macro)</td></tr><tr><td> <div><div>UINT8_CUINT16_CUINT32_CUINT64_C</div></div></td><td>   expands to an integer constant expression having the value specified by its argument and the type <code>uint_least8_t</code>, <code>uint_least16_t</code>, <code>uint_least32_t</code>, <code>uint_least64_t</code> respectively  <br/> (function macro)</td></tr><tr><td> <div><div>UINTMAX_C</div></div></td><td>   expands to an integer constant expression having the value specified by its argument and the type <code>uintmax_t</code> <br/> (function macro)</td></tr></table><div><div><pre><code>#include &lt;stdint.h&gt;UINT64_C(0x123) // might expand to 0x123ULL or 0x123UL</code></pre></div></div><p><br/></p><span class="prog__sub"> Format macro constants</span><table><tr><td> <div>Defined in header <code>&lt;inttypes.h&gt;</code> </div></td></tr></table><h4> Format constants for the <a href="http://en.cppreference.com/w/c/io/fprintf" title="c/io/fprintf">fprintf</a> family of functions</h4><table><tr><th rowspan="3"> Equivalent<br/>for <code>int</code> or<br/><code>unsigned int</code></th><th rowspan="3"> Description</th><th colspan="5"> Macros for data types</th></tr><tr><td> <br/><br/><br/><br/><div><div><code>[u]int<b>x</b>_t</code></div></div><br/><br/><br/><br/></td><td> <div><div><code>[u]int_least<b>x</b>_t</code></div></div></td><td> <div><div><code>[u]int_fast<b>x</b>_t</code></div></div></td><td> <div><div><code>[u]intmax_t</code></div></div></td><td> <div><div><code>[u]intptr_t</code></div></div></td></tr><tr><td> <b>x</b> = 8, 16, 32 or 64</td></tr><tr><th> <code>d</code></th><td> output of a signed decimal integer value</td><td> PRId<b>x</b></td><td> PRIdLEAST<b>x</b></td><td> PRIdFAST<b>x</b></td><td> PRIdMAX</td><td> PRIdPTR</td></tr><tr><th> <code>i</code></th><td> PRIi<b>x</b></td><td> PRIiLEAST<b>x</b></td><td> PRIiFAST<b>x</b></td><td> PRIiMAX</td><td> PRIiPTR</td></tr><tr><th> <code>u</code></th><td> output of an unsigned decimal integer value</td><td> PRIu<b>x</b></td><td> PRIuLEAST<b>x</b></td><td> PRIuFAST<b>x</b></td><td> PRIuMAX</td><td> PRIuPTR</td></tr><tr><th> <code>o</code></th><td> output of an unsigned octal integer value</td><td> PRIo<b>x</b></td><td> PRIoLEAST<b>x</b></td><td> PRIoFAST<b>x</b></td><td> PRIoMAX</td><td> PRIoPTR</td></tr><tr><th> <code>x</code></th><td> output of an unsigned lowercase hexadecimal integer value</td><td> PRIx<b>x</b></td><td> PRIxLEAST<b>x</b></td><td> PRIxFAST<b>x</b></td><td> PRIxMAX</td><td> PRIxPTR</td></tr><tr><th> <code>X</code></th><td> output of an unsigned uppercase hexadecimal integer value</td><td> PRIX<b>x</b></td><td> PRIXLEAST<b>x</b></td><td> PRIXFAST<b>x</b></td><td> PRIXMAX</td><td> PRIXPTR</td></tr></table><h4> Format constants for the <a href="http://en.cppreference.com/w/c/io/fscanf" title="c/io/fscanf">fscanf</a> family of functions</h4><table><tr><th rowspan="3"> Equivalent<br/>for <code>int</code> or<br/><code>unsigned int</code></th><th rowspan="3"> Description</th><th colspan="5"> Macros for data types</th></tr><tr><td> <br/><br/><br/><br/><div><div><code>[u]int<b>x</b>_t</code></div></div><br/><br/><br/><br/></td><td> <div><div><code>[u]int_least<b>x</b>_t</code></div></div></td><td> <div><div><code>[u]int_fast<b>x</b>_t</code></div></div></td><td> <div><div><code>[u]intmax_t</code></div></div></td><td> <div><div><code>[u]intptr_t</code></div></div></td></tr><tr><td> <b>x</b> = 8, 16, 32 or 64</td></tr><tr><th> <code>d</code></th><td> input of a signed decimal integer value</td><td> SCNd<b>x</b></td><td> SCNdLEAST<b>x</b></td><td> SCNdFAST<b>x</b></td><td> SCNdMAX</td><td> SCNdPTR</td></tr><tr><th> <code>i</code></th><td> input of a signed integer value (base is determined by the first characters parsed)</td><td> SCNi<b>x</b></td><td> SCNiLEAST<b>x</b></td><td> SCNiFAST<b>x</b></td><td> SCNiMAX</td><td> SCNiPTR</td></tr><tr><th> <code>u</code></th><td> input of an unsigned decimal integer value</td><td> SCNu<b>x</b></td><td> SCNuLEAST<b>x</b></td><td> SCNuFAST<b>x</b></td><td> SCNuMAX</td><td> SCNuPTR</td></tr><tr><th> <code>o</code></th><td> input of an unsigned octal integer value</td><td> SCNo<b>x</b></td><td> SCNoLEAST<b>x</b></td><td> SCNoFAST<b>x</b></td><td> SCNoMAX</td><td> SCNoPTR</td></tr><tr><th> <code>x</code></th><td> input of an unsigned hexadecimal integer value</td><td> SCNx<b>x</b></td><td> SCNxLEAST<b>x</b></td><td> SCNxFAST<b>x</b></td><td> SCNxMAX</td><td> SCNxPTR</td></tr></table><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;inttypes.h&gt;\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%zu\n", sizeof(int64_t));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%s\n", PRId64);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%+"PRId64"\n", INT64_MIN);    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%+"PRId64"\n", INT64_MAX);\xc2\xa0    int64_t n = 7;    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%+"PRId64"\n", n);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>8<br>lld<br>-9223372036854775808<br>+9223372036854775807<br>+7</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/types/integer
max_align_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stddef.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>typedef /*implementation-defined*/ max_align_t;</code></div></td><td> </td><td> (since C11) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong class="selflink">max_align_t</strong> is a type whose alignment requirement is at least as strict (as large) as that of every scalar type.</p></section>	http://en.cppreference.com/w/c/types/max_align_t
NULL	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stddef.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;locale.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define NULL /*implementation-defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The macro <code>NULL</code> is an implementation-defined null pointer constant, which may be</p><ul><li> an integer <a href="http://en.cppreference.com/w/c/language/constant_expression#Integer_constant_expression" title="c/language/constant expression">constant expression</a> with the value <code>\xe2\x80\x8b0\xe2\x80\x8b</code></li><li> an integer constant expression with the value 0 <a href="http://en.cppreference.com/w/c/language/conversion#Pointer_conversions" title="c/language/conversion">cast to the type</a> <code>void*</code></li></ul><p>A null pointer constant may be <a href="http://en.cppreference.com/w/c/language/conversion#Pointer_conversions" title="c/language/conversion">converted</a> to any pointer type; such conversion results in the null pointer value of that type.</p><span class="prog__sub"> Possible implementation</span><table><tr><td><div><div><pre><code>// C++ compatible:#define NULL 0// C++ incompatible:#define NULL (10*2 - 20)#define NULL ((void*)0)</code></pre></div></div></td></tr></table><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(void){        // any kind of pointer can be set to NULL    int* p = NULL;    struct S *s = NULL;    void(*f)(int, double) = NULL;\xc2\xa0    // many pointer-returning functions use null pointers to indicate error    char *ptr = <a href="http://en.cppreference.com/w/c/memory/malloc">malloc</a>(10);    if (ptr == NULL) <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("Out of memory");    <a href="http://en.cppreference.com/w/c/memory/free">free</a>(ptr);}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>(none)</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/types/NULL
offsetof	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stddef.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define offsetof(type, member) /*implementation-defined*/</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The macro <strong class="selflink">offsetof</strong> expands to a constant of type <a href="http://en.cppreference.com/w/c/types/size_t" title="c/types/size t">size_t</a>, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;\xc2\xa0struct S {    char c;    double d;};\xc2\xa0int main(void){    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("the first element is at offset\xc2\xa0%zu\n", offsetof(struct S, c));    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("the double is at offset\xc2\xa0%zu\n", offsetof(struct S, d));}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>the first element is at offset 0<br>the double is at offset 8</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/types/offsetof
ptrdiff_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stddef.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>typedef /*implementation-defined*/ ptrdiff_t;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong class="selflink">ptrdiff_t</strong> is the signed integer type of the result of <a href="http://en.cppreference.com/w/c/language/operator_arithmetic#Pointer_arithmetic" title="c/language/operator arithmetic">subtracting two pointers</a>.</p></section>	http://en.cppreference.com/w/c/types/ptrdiff_t
size_t	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stddef.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;stdio.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;stdlib.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;string.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;time.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div>Defined in header <code>&lt;uchar.h&gt;</code></div></td><td></td><td><div>(since C11)</div></td></tr><tr><td> <div>Defined in header <code>&lt;wchar.h&gt;</code></div></td><td></td><td><div>(since C95)</div></td></tr><tr><td> <div><code>typedef /*implementation-defined*/ size_t;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong class="selflink">size_t</strong> is the unsigned integer type of the result of <a href="http://en.cppreference.com/w/c/language/sizeof" title="c/language/sizeof"><tt>sizeof</tt></a> , <a href="http://en.cppreference.com/w/c/language/_Alignof" title="c/language/ Alignof">alignof</a> (since C11) and <a href="http://en.cppreference.com/w/c/types/offsetof" title="c/types/offsetof">offsetof</a>. </p></section>	http://en.cppreference.com/w/c/types/size_t
FLT_EVAL_METHOD	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;float.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define FLT_EVAL_METHOD /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Specifies the precision in which all floating-point arithmetic operations other than assignment and cast are done. <br></p><table><tr><td>  Value</td><td>  Explanation</td></tr><tr><td>  negative values except <code>-1</code></td><td>  implementation-defined behavior</td></tr><tr><td> <code>-1</code></td><td>  the default precision is not known</td></tr><tr><td> <code>0</code></td><td>  all operations and constants evaluate in the range and precision of the type used. Additionally, <code>float_t</code> and <code>double_t</code> are equivalent to <code>float</code> and <code>double</code> respectively</td></tr><tr><td> <code>1</code></td><td>  all operations and constants evaluate in the range and precision of <code>double</code>. Additionally, both <code>float_t</code> and <code>double_t</code> are equivalent to <code>double</code></td></tr><tr><td> <code>2</code></td><td>  all operations and constants evaluate in the range and precision of <code>long double</code>. Additionally, both <code>float_t</code> and <code>double_t</code> are equivalent to <code>long double</code></td></tr></table></section>	http://en.cppreference.com/w/c/types/limits/FLT_EVAL_METHOD
FLT_ROUNDS	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;float.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>#define FLT_ROUNDS /* implementation defined */</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>Returns the current rounding direction of floating-point arithmetic operations.<br></p><table><tr><td>  Value</td><td>  Explanation</td></tr><tr><td> <code>-1</code></td><td>  the default rounding direction is not known</td></tr><tr><td> <code>0</code></td><td>  toward zero, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">FE_TOWARDZERO</a></td></tr><tr><td> <code>1</code></td><td>  to nearest, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">FE_TONEAREST</a></td></tr><tr><td> <code>2</code></td><td>  towards positive infinity, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">FE_UPWARD</a></td></tr><tr><td> <code>3</code></td><td>  towards negative infinity, <a href="http://en.cppreference.com/w/c/numeric/fenv/FE_round" title="c/numeric/fenv/FE round">FE_DOWNWARD</a></td></tr><tr><td>  other values</td><td>  implementation-defined behavior</td></tr></table></section>	http://en.cppreference.com/w/c/types/limits/FLT_ROUNDS
va_arg	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdarg.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>T va_arg( va_list ap, T );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>va_arg</code> macro expands to an expression of type <code>T</code> that corresponds to the next parameter from the va_list <code>ap</code>.</p><p>Prior to calling <code>va_arg</code>, <code>ap</code> must be initialized by a call to either va_start or va_copy, with no intervening call to va_end.  Each invocation of the <code>va_arg</code> macro modifies <code>ap</code> to point to the next variable argument.</p><p>If <code>va_arg</code> is called when there are no more arguments in <code>ap</code>, or if the type of the next argument in <code>ap</code> (after promotions) is not compatible with <code>T</code>, the behavior is undefined, unless:</p><ul><li> one type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in both types; or</li><li> one type is pointer to <code>void</code> and the other is a pointer to a character type.</li></ul><span class="prog__sub"> Parameters</span><table><tr><td>  ap</td><td> -</td><td>  an instance of the va_list type</td></tr><tr><td>  T</td><td> -</td><td>  the type of the next parameter in <code>ap</code></td></tr></table><span class="prog__sub"> Expanded value</span><p>the next variable parameter in <code>ap</code></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#include &lt;math.h&gt;\xc2\xa0double stddev(int count, ...) {    double sum = 0;    double sum_sq = 0;    va_list args;    va_start(args, count);    for (int i = 0; i &lt; count; ++i) {        double num = va_arg(args, double);        sum += num;        sum_sq += num*num;    }    va_end(args);    return <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(sum_sq/count - (sum/count)*(sum/count));}\xc2\xa0int main(void) {    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f\n", stddev(4, 25.0, 27.3, 26.9, 25.7));}</code></pre></div></div><p>Output:<br></p><div><div><pre><code>0.920258</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/variadic/va_arg
va_copy	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdarg.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void va_copy( va_list dest, va_list src );</code></div></td><td> </td><td> (since C99) </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>va_copy</code> macro copies <code>src</code> to <code>dest</code>.</p><p>va_end should be called on <code>dest</code> before the function returns or any subsequent re-initialization of <code>dest</code> (via calls to va_start or va_copy).</p><span class="prog__sub"> Parameters</span><table><tr><td>  dest</td><td> -</td><td>  an instance of the va_list type to initialize</td></tr><tr><td>  src</td><td> -</td><td>  the source va_list that will be used to initialize <code>dest</code></td></tr></table><span class="prog__sub"> Expanded value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#include &lt;math.h&gt;\xc2\xa0double sample_stddev(int count, ...) {    /* Compute the mean with args1. */    double sum = 0;    va_list args1;    va_start(args1, count);    va_list args2;    va_copy(args2, args1);   /* copy va_list object */    for (int i = 0; i &lt; count; ++i) {        double num = va_arg(args1, double);        sum += num;    }    va_end(args1);    double mean = sum / count;\xc2\xa0    /* Compute standard deviation with args2 and mean. */    double sum_sq_diff = 0;    for (int i = 0; i &lt; count; ++i) {        double num = va_arg(args2, double);        sum_sq_diff += (num-mean) * (num-mean);    }    va_end(args2);    return <a href="http://en.cppreference.com/w/c/numeric/math/sqrt">sqrt</a>(sum_sq_diff / count);}\xc2\xa0int main(void) {    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%f\n", sample_stddev(4, 25.0, 27.3, 26.9, 25.7));}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>0.920258</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/variadic/va_copy
va_end	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdarg.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void va_end( va_list ap );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>va_end</code> macro performs cleanup for an <code>ap</code> object initialized by a call to va_start or va_copy.  <code>va_end</code> may modify <code>ap</code> so that it is no longer usable.</p><p>If there is no corresponding call to va_start or va_copy, or if <code>va_end</code> is not called before a function that calls va_start or va_copy returns, the behavior is undefined.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ap</td><td> -</td><td>  an instance of the va_list type to clean up</td></tr></table><span class="prog__sub"> Expanded value</span><p>(none)<br></p></section>	http://en.cppreference.com/w/c/variadic/va_end
va_list	A										<section class="prog__container"><table><tbody><tr><td> <div><code>/* unspecified */ va_list;</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><code>va_list</code> is a complete object type suitable for holding the information needed by the macros va_start, va_copy, va_arg, and va_end.</p><p>If a <code>va_list</code> instance is created, passed to another function, and used via va_arg in that function, then any subsequent use in the calling function should be preceded by a call to va_end.</p><p>It is legal to pass a pointer to a <code>va_list</code> object to another function and then use that object after the function returns.</p></section>	http://en.cppreference.com/w/c/variadic/va_list
va_start	A										<section class="prog__container"><table><tbody><tr><td> <div>Defined in header <code>&lt;stdarg.h&gt;</code></div></td><td></td><td></td></tr><tr><td> <div><code>void va_start( va_list ap, parmN );</code></div></td><td> </td><td> </td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>The <code>va_start</code> macro enables access to the variable arguments following the named argument <code>parmN</code>.  </p><p><code>va_start</code> should be invoked with an instance to a valid va_list object <code>ap</code> before any calls to va_arg.</p><p>If <code>parmN</code> is declared with <code>register</code> storage class specifier, with an array type, with a function type, or with a type not compatible with the type that results from default argument promotions, the behavior is undefined.</p><span class="prog__sub"> Parameters</span><table><tr><td>  ap</td><td> -</td><td>  an instance of the va_list type</td></tr><tr><td>  parmN</td><td> -</td><td>  the named parameter preceding the first variable parameter</td></tr></table><span class="prog__sub"> Expanded value</span><p>(none)<br></p><span class="prog__sub"> Example</span><div><div><div>Run this code</div></div><div><div><pre><code>#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;\xc2\xa0int add_nums(int count, ...) {    int result = 0;    va_list args;    va_start(args, count);    for (int i = 0; i &lt; count; ++i) {        result += va_arg(args, int);    }    va_end(args);    return result;}\xc2\xa0int main(void) {    <a href="http://en.cppreference.com/w/c/io/fprintf">printf</a>("%d\n", add_nums(4, 25, 25, 50, 50));}</code></pre></div></div><p>Possible output:<br></p><div><div><pre><code>150</code></pre></div></div></div></section>	http://en.cppreference.com/w/c/variadic/va_start
